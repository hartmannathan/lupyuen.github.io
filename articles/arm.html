<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX RTOS now runs on 64-bit Arm Cortex-A53 with Multi-Core Symmetric Multi-Processing... Will it run on PinePhone? Let's find out!"
    data-rh="true">
<meta name="description" 
    content="Apache NuttX RTOS now runs on 64-bit Cortex-A53 with Multi-Core Symmetric Multi-Processing... Will it run on PinePhone? Let's find out!">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/arm-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone</h1>
    <nav id="TOC"><ul>
<li><a href="#download-nuttx">1 Download NuttX</a><ul></ul></li>
<li><a href="#download-toolchain">2 Download Toolchain</a><ul></ul></li>
<li><a href="#download-qemu">3 Download QEMU</a><ul></ul></li>
<li><a href="#build-nuttx-single-core">4 Build NuttX: Single Core</a><ul></ul></li>
<li><a href="#test-nuttx-single-core">5 Test NuttX: Single Core</a><ul></ul></li>
<li><a href="#build-nuttx-multi-core">6 Build NuttX: Multi Core</a><ul></ul></li>
<li><a href="#test-nuttx-multi-core">7 Test NuttX: Multi Core</a><ul></ul></li>
<li><a href="#inside-nuttx-for-arm64">8 Inside NuttX for Arm64</a><ul></ul></li>
<li><a href="#nuttx-image">9 NuttX Image</a><ul></ul></li>
<li><a href="#nuttx-ram">10 NuttX RAM</a><ul></ul></li>
<li><a href="#pinephone-image">11 PinePhone Image</a><ul></ul></li>
<li><a href="#will-nuttx-boot-on-pinephone">12 Will NuttX Boot On PinePhone?</a><ul></ul></li>
<li><a href="#uart-driver-for-nuttx">13 UART Driver for NuttX</a><ul></ul></li>
<li><a href="#pinephone-on-rtos">14 PinePhone on RTOS</a><ul></ul></li>
<li><a href="#pinephone-drivers-and-apps">15 PinePhone Drivers and Apps</a><ul></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">17 Notes</a><ul></ul></li>
<li><a href="#appendix-pinephone-uart-log">18 Appendix: PinePhone UART Log</a><ul></ul></li>
<li><a href="#appendix-analyse-nuttx-image-with-ghidra">19 Appendix: Analyse NuttX Image with Ghidra</a><ul></ul></li>
<li><a href="#appendix-analyse-pinephone-image-with-ghidra">20 Appendix: Analyse PinePhone Image with Ghidra</a><ul></ul></li></ul></nav><p>üìù <em>25 Aug 2022</em></p>
<p><img src="https://lupyuen.github.io/images/arm-title.png" alt="Ghidra with Apache NuttX RTOS for Arm Cortex-A53" /></p>
<p><em>Ghidra with Apache NuttX RTOS for Arm Cortex-A53</em></p>
<p><strong>UPDATE:</strong> PinePhone is now officially supported by Apache NuttX RTOS <a href="https://lupyuen.github.io/articles/what">(See this)</a></p>
<p><a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) runs on 64-bit <strong>Arm Cortex-A53</strong> with Multiple Cores‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/boards/arm64/qemu/qemu-armv8a"><strong>NuttX on Arm Cortex-A53</strong></a></li>
</ul>
<p><strong>Pine64 PinePhone</strong> is based on the <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> with 4 Cores of Arm Cortex-A53‚Ä¶</p>
<ul>
<li><a href="https://wiki.pine64.org/index.php/PinePhone"><strong>PinePhone Wiki</strong></a></li>
</ul>
<p>Will NuttX run on PinePhone? Let‚Äôs find out!</p>
<p><em>Why NuttX?</em></p>
<p>NuttX is a <strong>tiny operating system</strong>. It might be a fun way to teach more people about the internals of Phone Operating Systems. (Without digging deep into the Linux Stack)</p>
<p>Someday we might have a cheap, fast, responsive and tweakable phone running on NuttX!</p>
<p><em>But why an RTOS for PinePhone? What about drivers and apps?</em></p>
<p>Yep we have interesting challenges running NuttX on PinePhone, we‚Äôll talk more below.</p>
<p>First we experiment with NuttX on Arm Cortex-A53, <strong>emulated with QEMU</strong>. Then we discuss how it might work on PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p>Many thanks to <a href="https://github.com/qinwei2004"><strong>qinwei2004</strong></a> and the NuttX Team for implementing <a href="https://github.com/apache/nuttx/pull/6478"><strong>Cortex-A53 support</strong></a>!</p>
<h1 id="download-nuttx"><a href="#download-nuttx">1 Download NuttX</a></h1>
<p><strong>NuttX Mainline</strong> has the latest support for Arm Cortex-A53. We download the Source Code for our experiment‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Create NuttX Directory
mkdir nuttx
cd nuttx

## Download NuttX OS
git clone \
    --recursive \
    https://github.com/apache/nuttx \
    nuttx

## Download NuttX Apps
git clone \
    --recursive \
    https://github.com/apache/nuttx-apps \
    apps

## We&#39;ll build NuttX inside nuttx/nuttx
cd nuttx
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#download-nuttx">(Having problems? Try my <strong><code>arm64</code></strong> branch)</a></p>
<p>We‚Äôll build NuttX in a while. Install the <strong>Build Prerequisites</strong> below, but skip the RISC-V Toolchain‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs download the Arm64 Toolchain instead‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-toolchain.png" alt="Arm64 Toolchain" /></p>
<h1 id="download-toolchain"><a href="#download-toolchain">2 Download Toolchain</a></h1>
<p>We‚Äôll <strong>cross-compile Arm64 NuttX</strong> on our computer. Download the Arm Toolchain for <strong>AArch64 ELF Bare-Metal Target <code>aarch64-none-elf</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads"><strong>Arm GNU Toolchain Downloads</strong></a></li>
</ul>
<p>For Linux x64 and WSL:</p>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz">gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz</a></li>
</ul>
<p>For macOS:</p>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.3.rel1/binrel/arm-gnu-toolchain-11.3.rel1-darwin-x86_64-aarch64-none-elf.pkg">arm-gnu-toolchain-11.3.rel1-darwin-x86_64-aarch64-none-elf.pkg</a></li>
</ul>
<p>(I don‚Äôt recommend building NuttX on Plain Old Windows CMD, please use WSL instead)</p>
<p>Add the downloaded Arm Toolchain to the <strong><code>PATH</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux x64 and WSL:
export PATH=&quot;$PATH:$HOME/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin&quot;

## For macOS:
export PATH=&quot;$PATH:/Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin&quot;
</code></pre></div>
<p>Check the Arm Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ aarch64-none-elf-gcc -v
gcc version 11.3.1 20220712 (Arm GNU Toolchain 11.3.Rel1)
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/tree/master/boards/arm64/qemu/qemu-armv8a">(Based on the instructions here)</a></p>
<h1 id="download-qemu"><a href="#download-qemu">3 Download QEMU</a></h1>
<p>Our experiment today will run on any Linux / macOS / Windows computer, <strong>no PinePhone needed</strong>.</p>
<p>That‚Äôs because we‚Äôre emulating Arm Cortex-A53 with the awesome <a href="https://www.qemu.org/"><strong>QEMU Machine Emulator</strong></a>.</p>
<p>Download and install QEMU‚Ä¶</p>
<ul>
<li><a href="https://www.qemu.org/download/"><strong>Download QEMU</strong></a></li>
</ul>
<p>For macOS we may use <strong><code>brew</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>brew install qemu
</code></pre></div>
<p>QEMU runs surprisingly well for emulating 64-bit Arm Cortex-A53, especially for a light operating system like NuttX.</p>
<p><img src="https://lupyuen.github.io/images/arm-build.png" alt="Build NuttX" /></p>
<h1 id="build-nuttx-single-core"><a href="#build-nuttx-single-core">4 Build NuttX: Single Core</a></h1>
<p>We‚Äôll run two experiments with QEMU‚Ä¶</p>
<ul>
<li>
<p>NuttX on a <strong>Single Core</strong> of Arm Cortex-A53</p>
</li>
<li>
<p>NuttX on <strong>4 Cores</strong> of Arm Cortex-A53</p>
</li>
</ul>
<p>Which works like 4 Arm64 Processors running in parallel, similar to PinePhone.</p>
<p>First we build NuttX for a <strong>Single Core</strong> of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Configure NuttX for Single Core
./tools/configure.sh -l qemu-armv8a:nsh

## Build NuttX
make

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/2c5db82c3103f52ed7ca99804f9220c1">(See the Build Log)</a></p>
<p>(On an old MacBook Pro 2012, NuttX builds in 2 minutes)</p>
<p>The NuttX Output Files may be found here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v1.0.1"><strong>NuttX for Arm Cortex-A53 Single Core</strong></a></li>
</ul>
<p>The output file <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.1/nuttx"><strong><code>nuttx</code></strong></a> is the Arm64 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF Executable</strong></a> that we‚Äôll run in the next step.</p>
<h1 id="test-nuttx-single-core"><a href="#test-nuttx-single-core">5 Test NuttX: Single Core</a></h1>
<p>We‚Äôre ready to run NuttX! This is how we test <strong>NuttX on QEMU</strong> with a Single Core of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start QEMU (Single Core) with NuttX
qemu-system-aarch64 \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx
</code></pre></div>
<p><a href="https://www.qemu.org/docs/master/system/arm/virt.html">(More about QEMU ‚Äúvirt‚Äù Machine)</a></p>
<p>QEMU shows this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

nx_start: Entry
up_allocate_heap: heap_start=0x0x402c4000, heap_size=0x7d3c000
gic_validate_dist_version: GICv3 version detect
gic_validate_dist_version: GICD_TYPER = 0x37a0007
gic_validate_dist_version: 224 SPIs implemented
gic_validate_dist_version: 0 Extended SPIs implemented
gic_validate_dist_version: Distributor has no Range Selector support
gic_validate_redist_version: GICD_TYPER = 0x1000011
gic_validate_redist_version: 16 PPIs implemented
gic_validate_redist_version: no VLPI support, no direct LPI support
up_timer_initialize: up_timer_initialize: cp15 timer(s) running at 62.50MHz, cycle 62500
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_highpri: Starting high-priority kernel worker thread(s)
nx_start_application: Starting init thread
lib_cxx_initialize: _sinit: 0x402a7000 _einit: 0x402a7000 _stext: 0x40280000 _etext: 0x402a8000
nsh: sysinit: fopen failed: 2
nsh: mkfatfs: command not found

NuttShell (NSH) NuttX-10.4.0
nsh&gt; nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p>Welcome to NuttX Land!</p>
<p>Enter ‚Äú<strong><code>help</code></strong>‚Äù or ‚Äú<strong><code>?</code></strong>‚Äù to see the <strong>NuttX Commands</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]

  .         cd        dmesg     help      mount     rmdir     true      xd        
  [         cp        echo      hexdump   mv        set       truncate  
  ?         cmp       exec      kill      printf    sleep     uname     
  basename  dirname   exit      ls        ps        source    umount    
  break     dd        false     mkdir     pwd       test      unset     
  cat       df        free      mkrd      rm        time      usleep    

Builtin Apps:
  getprime  hello     nsh       ostest    sh        
</code></pre></div>
<p>To be really sure that we‚Äôre <strong>emulating Arm64</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC2 1e8f2a8 Aug 23 2022 07:04:54 arm64 qemu-armv8a
</code></pre></div>
<p><a href="https://github.com/apache/nuttx-apps/blob/master/examples/hello/hello_main.c"><strong>‚ÄúHello World‚Äù</strong></a> works as expected‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; hello
task_spawn: name=hello entry=0x4029b594 file_actions=0x402c9580 attr=0x402c9588 argv=0x402c96d0
spawn_execattrs: Setting policy=2 priority=100 for pid=3
Hello, World!!
</code></pre></div>
<p>NuttX is <a href="https://nuttx.apache.org/docs/latest/introduction/inviolables.html"><strong>POSIX Compliant</strong></a>, so the Developer Experience feels very much like Linux (but much smaller)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /
/:
 dev/
 etc/
 proc/
</code></pre></div>
<p>We started the Bare Minimum of <strong>NuttX Devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /dev
/dev:
 console
 null
 ram0
 ram2
 ttyS0
 zero
</code></pre></div>
<p>With a few <strong>Background Processes</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /proc
/proc:
 0/
 1/
 2/
 meminfo
 memdump
 fs/
 self/
 uptime
 version
</code></pre></div>
<p>And NuttX runs <strong>everything in RAM</strong>, no File System needed (for today)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /etc
/etc:
 init.d/

nsh&gt; ls /etc/init.d
/etc/init.d:
 rcS

nsh&gt; cat /etc/init.d/rcS
## Create a RAMDISK and mount it at /tmp
mkrd -m 2 -s 512 1024
mkfatfs /dev/ram2
mount -t vfat /dev/ram2 /tmp
</code></pre></div>
<p>Press <strong>Ctrl-C</strong> to quit QEMU.</p>
<h1 id="build-nuttx-multi-core"><a href="#build-nuttx-multi-core">6 Build NuttX: Multi Core</a></h1>
<p>From Single Core to Multi Core! Now we build NuttX for <strong>4 Cores</strong> of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Erase the NuttX Configuration
make distclean

## Configure NuttX for 4 Cores
./tools/configure.sh -l qemu-armv8a:nsh_smp

## Build NuttX
make

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p>The NuttX Output Files may be found here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v1.0.0"><strong>NuttX for Arm Cortex-A53 Multi-Core</strong></a></li>
</ul>
<h1 id="test-nuttx-multi-core"><a href="#test-nuttx-multi-core">7 Test NuttX: Multi Core</a></h1>
<p>And this is how we test NuttX on QEMU with <strong>4 Cores</strong> of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start QEMU (4 Cores) with NuttX
qemu-system-aarch64 \
  -smp 4 \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx
</code></pre></div>
<p>Note that <strong><code>smp</code></strong> is set to 4. <a href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Symmetric-multi-processing?lang=en">(Symmetric Multi-Processing)</a></p>
<p>QEMU shows this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
</code></pre></div>
<p>NuttX boots on the <strong>First Core</strong> of our emulated Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>[CPU0] psci_detect: Detected PSCI v1.1
[CPU0] nx_start: Entry
[CPU0] up_allocate_heap: heap_start=0x0x402db000, heap_size=0x7d25000
[CPU0] gic_validate_dist_version: GICv3 version detect
[CPU0] gic_validate_dist_version: GICD_TYPER = 0x37a0007
[CPU0] gic_validate_dist_version: 224 SPIs implemented
[CPU0] gic_validate_dist_version: 0 Extended SPIs implemented
[CPU0] gic_validate_dist_version: Distributor has no Range Selector support
[CPU0] gic_validate_redist_version: GICD_TYPER = 0x1000001
[CPU0] gic_validate_redist_version: 16 PPIs implemented
[CPU0] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU0] up_timer_initialize: up_timer_initialize: cp15 timer(s) running at 62.50MHz, cycle 62500
[CPU0] uart_register: Registering /dev/console
[CPU0] uart_register: Registering /dev/ttyS0
</code></pre></div>
<p>Here comes excitement: NuttX boots on the <strong>Second Core</strong> of our Arm Cortex-A53!</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

[CPU1] gic_validate_redist_version: GICD_TYPER = 0x101000101
[CPU1] gic_validate_redist_version: 16 PPIs implemented
[CPU1] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU1] nx_idle_trampoline: CPU1: Beginning Idle Loop
[CPU0] arm64_start_cpu: Secondary CPU core 1 (MPID:0x1) is up
</code></pre></div>
<p>Followed by the <strong>Third Core</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

[CPU2] gic_validate_redist_version: GICD_TYPER = 0x201000201
[CPU2] gic_validate_redist_version: 16 PPIs implemented
[CPU2] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU2] nx_idle_trampoline: CPU2: Beginning Idle Loop
[CPU0] arm64_start_cpu: Secondary CPU core 2 (MPID:0x2) is up
</code></pre></div>
<p>Finally all <strong>4 Cores</strong> are up!</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

[CPU3] gic_validate_redist_version: GICD_TYPER = 0x301000311
[CPU3] gic_validate_redist_version: 16 PPIs implemented
[CPU3] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU0] arm64_start_cpu: Secondary CPU core 3 (MPID:0x3) is up
[CPU0] work_start_highpri: Starting high-priority kernel worker thread(s)
[CPU0] nx_start_application: Starting init thread
[CPU3] nx_idle_trampoline: CPU3: Beginning Idle Loop
[CPU0] nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><strong>NuttX Shell</strong> appears‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh: sysinit: fopen failed: 2
nsh: mkfatfs: command not found
NuttShell (NSH) NuttX-10.4.0
nsh&gt;
</code></pre></div>
<p>Even though we have 4 Cores, everything works as expected‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC2 1e8f2a8 Aug 21 2022 15:57:35 arm64 qemu-armv8a

nsh&gt; hello
[CPU0] task_spawn: name=hello entry=0x4029cee4 file_actions=0x402e52b0 attr=0x402e52b8 argv=0x402e5400
[CPU0] spawn_execattrs: Setting policy=2 priority=100 for pid=6
Hello, World!
</code></pre></div>
<p><a href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Symmetric-multi-processing?lang=en"><strong>Symmetric Multi-Processing</strong></a> never looked so cool!</p>
<p>(Can we use QEMU to emulate parts of PinePhone? That would be extremely helpful for testing!)</p>
<p><img src="https://lupyuen.github.io/images/arm-source.png" alt="Arm64 Architecture-Specific Source Files" /></p>
<p><a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common"><em>Arm64 Architecture-Specific Source Files</em></a></p>
<h1 id="inside-nuttx-for-arm64"><a href="#inside-nuttx-for-arm64">8 Inside NuttX for Arm64</a></h1>
<p><em>What‚Äôs inside the NuttX code for Arm Cortex-A53?</em></p>
<p>Let‚Äôs browse the <strong>Source Files</strong> for the implementation of Cortex-A53 on NuttX.</p>
<p>NuttX treats QEMU as a <strong>Target Board</strong> (as though it was a dev board). Here are the Source Files and Build Configuration for the <strong>QEMU Board</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/boards/arm64/qemu/qemu-armv8a">boards/arm64/qemu/qemu-armv8a</a></li>
</ul>
<p>(We‚Äôll clone this to create a Target Board for PinePhone)</p>
<p>The <strong>Board-Specific Drivers</strong> for QEMU are started in <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/src/qemu_bringup.c">qemu_bringup.c</a></p>
<p>(We‚Äôll start the PinePhone Drivers here)</p>
<p>The QEMU Board calls the <strong>QEMU Architecture-Specific Drivers</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/qemu">arch/arm64/src/qemu</a></li>
</ul>
<p>The <strong>UART Driver</strong> is located at <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/qemu/qemu_serial.c">qemu_serial.c</a> and <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/qemu/qemu_lowputc.S">qemu_lowputc.S</a></p>
<p>(For PinePhone we‚Äôll create a UART Driver for Allwinner A64 SoC. I2C, SPI and other Low-Level A64 Drivers will be located here too)</p>
<p>The QEMU Functions (Board and Architecture) call the <strong>Arm64 Architecture Functions</strong> (pic above)‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common">arch/arm64/src/common</a></li>
</ul>
<p>Which implement all kinds of Arm64 Features: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_fpu.c"><strong>FPU</strong></a>, <a href="https://github.com/lupyuen/pinephone-nuttx#interrupt-controller"><strong>Interrupts</strong></a>, <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c"><strong>MMU</strong></a>, <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_task_sched.c"><strong>Tasks</strong></a>, <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_arch_timer.c"><strong>Timers</strong></a>‚Ä¶</p>
<p>(We‚Äôll reuse them for PinePhone)</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra1.png" alt="Ghidra with Apache NuttX RTOS for Arm Cortex-A53" /></p>
<h1 id="nuttx-image"><a href="#nuttx-image">9 NuttX Image</a></h1>
<p><em>NuttX can‚Äôt possibly boot on PinePhone right?</em></p>
<p>It might! Let‚Äôs compare our <strong>NuttX Image</strong> with a <strong>PinePhone Linux Image</strong>. And find out what needs to be patched.</p>
<p>Follow these steps to load our <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.0/nuttx"><strong>NuttX ELF Image <code>nuttx</code></strong></a> into <a href="https://ghidra-sre.org/"><strong>Ghidra</strong></a>, the popular open-source tool for Reverse Engineering‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/arm#appendix-analyse-nuttx-image-with-ghidra"><strong>‚ÄúAnalyse NuttX Image with Ghidra‚Äù</strong></a></li>
</ul>
<p>Ghidra says that our NuttX Image will be loaded at address <strong><code>0x4028</code> <code>0000</code></strong>. (Pic above)</p>
<p>The Arm64 Instructions at the top of our NuttX Image will jump to <strong><code>real_start</code></strong> (to skip the header)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>40280000 4d 5a 00 91     add        x13,x18,#0x16
40280004 0f 00 00 14     b          real_start
</code></pre></div>
<p>After the header, <strong><code>real_start</code></strong> is defined at <code>0x4028</code> <code>0040</code> with the Startup Code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-title.png" alt="Ghidra with Apache NuttX RTOS for Arm Cortex-A53" /></p>
<p>We see something interesting: The <strong>Magic Number <code>ARM\x64</code></strong> appears at address <code>0x4028</code> <code>0038</code>. (Offset <code>0x38</code>)</p>
<p>Searching the net for this Magic Number reveals that it‚Äôs actually an <strong>Arm64 Linux Kernel Header!</strong></p>
<p>When we refer to the <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.0/nuttx.S"><strong>NuttX Disassembly <code>nuttx.S</code></strong></a>, we find happiness: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L79-L117">arch/arm64/src/common/arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>  /* Kernel startup entry point.
   * ---------------------------
   *
   * The requirements are:
   *   MMU = off, D-cache = off, I-cache = on or off,
   *   x0 = physical address to the FDT blob.
   *       it will be used when NuttX support device tree in the future
   *
   * This must be the very first address in the loaded image.
   * It should be loaded at any 4K-aligned address.
   */
  .globl __start;
__start:

  /* DO NOT MODIFY. Image header expected by Linux boot-loaders.
   *
   * This add instruction has no meaningful effect except that
   * its opcode forms the magic &quot;MZ&quot; signature of a PE/COFF file
   * that is required for UEFI applications.
   *
   * Some bootloader (such imx8 uboot) checking the magic &quot;MZ&quot; to see
   * if the image is a valid Linux image. but modifying the bootLoader is
   * unnecessary unless we need to do a customize secure boot.
   * so just put the &#39;&#39;MZ&quot; in the header to make bootloader happiness
   */

  add     x13, x18, #0x16      /* the magic &quot;MZ&quot; signature */
  b       real_start           /* branch to kernel start */
</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">(‚ÄúMZ‚Äù refers to Mark Zbikowski)</a></p>
<p>Yep that‚Äôs the jump to <strong><code>real_start</code></strong> that we saw earlier.</p>
<p>Followed by this header‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  .quad   0x480000              /* Image load offset from start of RAM */
  .quad   _e_initstack - __start         /* Effective size of kernel image, little-endian */
  .quad   __HEAD_FLAGS         /* Informative flags, little-endian */
  .quad   0                    /* reserved */
  .quad   0                    /* reserved */
  .quad   0                    /* reserved */
  .ascii  &quot;ARM\x64&quot;            /* Magic number, &quot;ARM\x64&quot; */
  .long   0                    /* reserved */

real_start: ...
</code></pre></div>
<p>Our NuttX Image actually follows the <strong>Arm64 Linux Kernel Image Format</strong>! As defined here‚Ä¶</p>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/arm64/booting.html"><strong>‚ÄúBooting AArch64 Linux‚Äù</strong></a></li>
</ul>
<p>The doc says that a Linux Kernel Image (for Arm64) begins with this <strong>64-byte header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>u32 code0;                    /* Executable code */
u32 code1;                    /* Executable code */
u64 text_offset;              /* Image load offset, little endian */
u64 image_size;               /* Effective Image size, little endian */
u64 flags;                    /* kernel flags, little endian */
u64 res2      = 0;            /* reserved */
u64 res3      = 0;            /* reserved */
u64 res4      = 0;            /* reserved */
u32 magic     = 0x644d5241;   /* Magic number, little endian, &quot;ARM\x64&quot; */
u32 res5;                     /* reserved (used for PE COFF offset) */
</code></pre></div>
<p><a href="https://www.kernel.org/doc/html/latest/arm64/booting.html">(Source)</a></p>
<p><em>Is there a proper Linux Header in our NuttX Image?</em></p>
<p>Let‚Äôs do a quick check on our NuttX Header.</p>
<p>The <strong>Image Load Offset</strong> in our NuttX Header is <strong><code>0x48</code> <code>0000</code></strong> as we‚Äôve seen earlier‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>.quad   0x480000  /* Image load offset from start of RAM */
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L107">(Source)</a></p>
<p>Our RAM starts at <strong><code>0x4000</code> <code>0000</code></strong>. (We‚Äôll see later)</p>
<p>This means that our NuttX Image will be loaded at <strong><code>0x4048</code> <code>0000</code></strong>.</p>
<p>But Ghidra (and the Arm Disassembly) says that our NuttX Image is actually loaded at <strong><code>0x4028</code> <code>0000</code></strong>! (Instead of <code>0x4048</code> <code>0000</code>)</p>
<p>Maybe the Image Load Offset should have been <strong><code>0x28</code> <code>0000</code></strong>? (Instead of <code>0x48</code> <code>0000</code>)</p>
<p>Everything else in the NuttX Header looks like a <strong>proper Linux Kernel Header</strong>.</p>
<p>Yep our NuttX Image might actually boot on PinePhone with some patching!</p>
<p><img src="https://lupyuen.github.io/images/arm-ram.png" alt="NuttX RAM" /></p>
<h1 id="nuttx-ram"><a href="#nuttx-ram">10 NuttX RAM</a></h1>
<p><em>How do we know that RAM starts at <code>0x4000</code> <code>0000</code>?</em></p>
<p><strong>RAM Size and RAM Start</strong> are defined in the NuttX Configuration for Arm64 (pic above): <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/nsh/defconfig#L48-L49">nsh/defconfig</a> and <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/nsh_smp/defconfig#L47-L48">nsh_smp/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_SIZE=134217728
CONFIG_RAM_START=0x40000000
</code></pre></div>
<p>That‚Äôs 128 MB RAM. Which should fit inside PinePhone‚Äôs 2 GB RAM.</p>
<p><em>Why is our NuttX Image loaded at <code>0x4028</code> <code>0000</code>?</em></p>
<p>Our NuttX Image was built with this <strong>Linker Command</strong>, as observed with ‚Äú<code>make</code> <code>--trace</code>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>aarch64-none-elf-ld \
  --entry=__start \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx/nuttx.map \
  -Tnuttx/nuttx/boards/arm64/qemu/qemu-armv8a/scripts/dramboot.ld  \
  -L nuttx/nuttx/staging \
  -L nuttx/nuttx/arch/arm64/src/board  \
  -o nuttx/nuttx/nuttx arm64_head.o  \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard /Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin/../lib/gcc/aarch64-none-elf/11.3.1/libgcc.a /Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin/../lib/gcc/aarch64-none-elf/11.3.1/../../../../aarch64-none-elf/lib/libm.a \
  --end-group
</code></pre></div>
<p>In the Linker Command above, we see the <strong>NuttX Linker Script</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/scripts/dramboot.ld#L30-L33">boards/arm64/qemu/qemu-armv8a/scripts/dramboot.ld</a></li>
</ul>
<p>Which defines <strong><code>_start</code></strong> as <code>0x4028</code> <code>0000</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  . = 0x40280000;  /* uboot load address */
  _start = .;
</code></pre></div>
<p>That‚Äôs why our NuttX Image is loaded at <code>0x4028</code> <code>0000</code>!</p>
<p><em>Will this work with PinePhone?</em></p>
<p>We‚Äôll change <strong><code>_start</code></strong> to <strong><code>0x4000</code> <code>0000</code></strong> for PinePhone.</p>
<p>In a while we‚Äôll see that Start of RAM is <strong><code>0x4000</code> <code>0000</code></strong> and Image Load Offset is 0 for a PinePhone Linux Image.</p>
<p><a href="https://lupyuen.github.io/articles/arm#appendix-pinephone-uart-log">(<strong>UPDATE:</strong> Start of RAM should be <strong><code>0x4008</code> <code>0000</code></strong> instead)</a></p>
<p><a href="https://lupyuen.github.io/articles/uboot#porting-notes">(<strong>UPDATE:</strong> We don‚Äôt need to change the Image Load Offset)</a></p>
<p>(What‚Äôs the significance of <code>0x4028</code> <code>0000</code>? Something specific to NXP i.MX8?)</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra7.png" alt="For ‚ÄúLanguage‚Äù select AARCH64:LE:v8A:default" /></p>
<h1 id="pinephone-image"><a href="#pinephone-image">11 PinePhone Image</a></h1>
<p>We‚Äôve seen our NuttX Image (which actually looks like a Linux Kernel Image). Now we compare with a <strong>PinePhone Linux Kernel Image</strong> and find out what needs to be patched in NuttX.</p>
<p>We‚Äôll analyse the Linux Kernel in the <strong>PinePhone Jumpdrive Image</strong>, since it‚Äôs small‚Ä¶</p>
<ul>
<li><a href="https://github.com/dreemurrs-embedded/Jumpdrive"><strong>dreemurrs-embedded/Jumpdrive</strong></a></li>
</ul>
<p>Here are the steps‚Ä¶</p>
<ol>
<li>
<p>Download <a href="https://github.com/dreemurrs-embedded/Jumpdrive/releases/download/0.8/pine64-pinephone.img.xz"><strong><code>pine64-pinephone.img.xz</code></strong></a></p>
</li>
<li>
<p>Extract the files from the microSD Image with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a></p>
</li>
<li>
<p>Expand the extracted files‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gunzip Image.gz
gunzip initramfs.gz
tar xvf initramfs
</code></pre></div></li>
<li>
<p>Follow these steps to import the uncompressed <strong><code>Image</code></strong> (Linux Kernel) into Ghidra</p>
<p><a href="https://lupyuen.github.io/articles/arm#appendix-analyse-pinephone-image-with-ghidra"><strong>‚ÄúAnalyse PinePhone Image with Ghidra‚Äù</strong></a></p>
</li>
<li>
<p>Check that we‚Äôve set the ‚ÄúLanguage‚Äù as <strong>‚ÄúAARCH64:LE:v8A:default‚Äù</strong>. (Pic above)</p>
</li>
</ol>
<p>Here‚Äôs the Jumpdrive <strong><code>Image</code></strong> (Linux Kernel) in Ghidra‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra2.png" alt="Ghidra with PinePhone Linux Image" /></p>
<p><em>That‚Äôs the Linux Kernel Header?</em></p>
<p>Right! The <a href="https://www.kernel.org/doc/html/latest/arm64/booting.html"><strong>Linux Kernel Header</strong></a> shows‚Ä¶</p>
<ul>
<li>
<p><strong>Magic Number</strong> is <code>ARM\x64</code></p>
<p>(At offset <code>0x38</code>)</p>
</li>
<li>
<p><strong>Image Load Offset</strong> is <code>0</code></p>
<p>(At offset <code>0x08</code>, pic above)</p>
</li>
</ul>
<p>The <strong>First Instruction</strong> at <code>0x4000</code> <code>0000</code> jumps to <code>0x4081</code> <code>0000</code> (to skip the Linux Kernel Header)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>40000000 00 40 20 14  b FUN_40810000
</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">(Sorry Mr Zbikowski, PinePhone doesn‚Äôt need your Magic Signature)</a></p>
<p>The <strong>Linux Kernel Code</strong> actually begins at <code>0x4081</code> <code>0000</code>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra3.png" alt="Ghidra with PinePhone Linux Image" /></p>
<p>After comparing our NuttX Image with a PinePhone Linux Image, we conclude that they look quite similar!</p>
<p><img src="https://lupyuen.github.io/images/arm-jumpdrive.png" alt="PinePhone Jumpdrive on microSD" /></p>
<h1 id="will-nuttx-boot-on-pinephone"><a href="#will-nuttx-boot-on-pinephone">12 Will NuttX Boot On PinePhone?</a></h1>
<p><em>So will NuttX boot on PinePhone?</em></p>
<p>It‚Äôs highly plausible! We discovered (with happiness) that NuttX already generates an Arm64 <strong>Linux Kernel Header.</strong></p>
<p>Thus NuttX could be a <strong>drop-in replacement</strong> for the PinePhone Linux Kernel! We just need to‚Ä¶</p>
<ol>
<li>
<p>Write <a href="https://github.com/dreemurrs-embedded/Jumpdrive"><strong>PinePhone Jumpdrive</strong></a> to a microSD Card (pic above)</p>
</li>
<li>
<p>Overwrite <strong><code>Image.gz</code></strong> by the (gzipped) NuttX Binary Image <strong><code>nuttx.bin</code></strong></p>
</li>
<li>
<p>Insert microSD Card into PinePhone</p>
</li>
<li>
<p>Power on PinePhone</p>
</li>
</ol>
<p>And NuttX will (theoretically) <strong>boot on PinePhone!</strong></p>
<p><em>But NuttX needs some changes for PinePhone?</em></p>
<p>Yep 3 things we‚Äôll modify in NuttX, as mentioned earlier‚Ä¶</p>
<ul>
<li>
<p>Change <strong><code>_start</code></strong> to <strong><code>0x4000</code> <code>0000</code></strong> (from <code>0x4028</code> <code>0000</code>) in the NuttX Linker Script: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/scripts/dramboot.ld#L30-L33">dramboot.ld</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
/* TODO: Change to 0x40000000 for PinePhone */
. = 0x40280000;  /* uboot load address */
_start = .;
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/arm#appendix-pinephone-uart-log">(UPDATE: <code>_start</code> / Start of RAM should be <strong><code>0x4008</code> <code>0000</code></strong> instead)</a></p>
</li>
<li>
<p>Change <strong>Image Load Offset</strong> in our NuttX Header to <strong><code>0x0</code></strong> (from <code>0x48</code> <code>0000</code>): <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L107">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* TODO: Change to 0x0 for PinePhone */
.quad   0x480000  /* Image load offset from start of RAM */
</code></pre></div></li>
<li>
<p>Increase the <strong>RAM Size</strong> to <strong>2 GB</strong> (from 128 MB): <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/nsh/defconfig#L48-L49">nsh/defconfig</a> and <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/nsh_smp/defconfig#L47-L48">nsh_smp/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* TODO: Increase to 2 GB for PinePhone */
CONFIG_RAM_SIZE=134217728
CONFIG_RAM_START=0x40000000
</code></pre></div>
<p>(We‚Äôll increase the RAM Size later, since we don‚Äôt need much RAM now)</p>
</li>
</ul>
<p><em>Will we see anything when NuttX boots on PinePhone?</em></p>
<p>Not yet. We need to implement the UART Driver for NuttX‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>UPDATE:</strong> NuttX boots on PinePhone yay!</a></p>
<p><img src="https://lupyuen.github.io/images/uboot-title.png" alt="NuttX boots on PinePhone yay!" /></p>
<p><a href="https://lupyuen.github.io/articles/uboot"><em>NuttX boots on PinePhone yay!</em></a></p>
<h1 id="uart-driver-for-nuttx"><a href="#uart-driver-for-nuttx">13 UART Driver for NuttX</a></h1>
<p>We won‚Äôt see any output from NuttX until we implement the <strong>UART Driver for NuttX</strong>.</p>
<p><strong>For QEMU:</strong> These are the Source Files for the UART Driver (PL011)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/qemu/qemu_serial.c">arch/arm64/src/qemu/qemu_serial.c</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/qemu/qemu_lowputc.S">arch/arm64/src/qemu/qemu_lowputc.S</a></p>
<p><a href="https://krinkinmu.github.io/2020/11/29/PL011.html">(More about PL011 UART)</a></p>
</li>
</ul>
<p>We‚Äôll redo the code above for the <strong>PinePhone UART Driver</strong> (based on Allwinner A64 SoC)‚Ä¶</p>
<ul>
<li>
<p><a href="https://linux-sunxi.org/A64/Memory_map"><strong>UART0 Memory Map</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/UART"><strong>Allwinner A64 UART</strong></a></p>
</li>
<li>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 Info</strong></a></p>
</li>
</ul>
<p><strong>UPDATE:</strong> We now have a partial implementation of the <a href="https://lupyuen.github.io/articles/uboot"><strong>PinePhone UART Driver</strong></a></p>
<p><em>Where‚Äôs the UART Port on PinePhone?</em></p>
<p>To access the UART Port on PinePhone, we‚Äôll use this <strong>USB Serial Debug Cable</strong>‚Ä¶</p>
<ul>
<li><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><strong>PinePhone Serial Debug Cable</strong></a></li>
</ul>
<p>Which connects to PinePhone‚Äôs <strong>Headphone Port.</strong> Genius!</p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Privacy_switch_configuration">(Remember to flip the Headphone Switch to OFF)</a></p>
<p>PinePhone‚Äôs <strong>UART Log</strong> will look like this‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/arm#appendix-pinephone-uart-log"><strong>‚ÄúPinePhone UART Log‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/arm-uart.jpg" alt="PinePhone UART Port in disguise" /></p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><em>PinePhone UART Port in disguise</em></a></p>
<h1 id="pinephone-on-rtos"><a href="#pinephone-on-rtos">14 PinePhone on RTOS</a></h1>
<p><em>Will an RTOS work well on Phones?</em></p>
<p><a href="https://en.wikipedia.org/wiki/BlackBerry_10"><strong>BlackBerry 10</strong></a> phones ran on <a href="https://en.wikipedia.org/wiki/QNX"><strong>QNX</strong></a>, which is a Real-Time Operating System. (10 years ago!)</p>
<p><em>What‚Äôs an RTOS anyway?</em></p>
<p>On a <a href="https://en.wikipedia.org/wiki/Real-time_operating_system"><strong>Real-Time Operating System (RTOS)</strong></a>, the Task Scheduling Behaviour is predictable. Like: Task X will be scheduled to run <strong>within Y microseconds</strong>.</p>
<p>An RTOS is not designed for High Processing Throughput. But it will guarantee (somewhat) that a Task will respond within a fixed period of time.</p>
<p><em>What does it mean for PinePhone on RTOS?</em></p>
<p>With an RTOS, I‚Äôm guessing the PinePhone User Interface will feel <strong>more responsive</strong>? And Incoming Calls and Text Messages will hopefully pop up quicker.</p>
<p>That assumes we‚Äôll assign the correct <strong>Priority for each Task</strong>. It sounds like we‚Äôre micro-managing the resources on PinePhone, but I‚Äôm curious to see the actual outcome.</p>
<p>(And it will be super educational!)</p>
<p><em>But NuttX might be too tiny for PinePhone?</em></p>
<p>A tiny operating system (like NuttX), might be good for <strong>teaching the internals</strong> of a Phone Operating System.</p>
<p>We might not get all PinePhone features to work.  But at least we‚Äôll understand every single feature that we built!</p>
<p>Tiny OSes are also easier to tweak. Think of the super-tweakable <a href="https://wiki.pine64.org/index.php/PineTime"><strong>PineTime Smartwatch</strong></a>, which also runs on an RTOS. (FreeRTOS)</p>
<p>(Maybe someday PineTime, PinePhone and Pinebook Pro will run NuttX for Educational Purposes!)</p>
<p><img src="https://lupyuen.github.io/images/pinephone-title.jpg" alt="PinePhone on Linux with a Zig GTK App" /></p>
<p><a href="https://lupyuen.github.io/articles/pinephone"><em>PinePhone on Linux with a Zig GTK App</em></a></p>
<h1 id="pinephone-drivers-and-apps"><a href="#pinephone-drivers-and-apps">15 PinePhone Drivers and Apps</a></h1>
<p><em>Are there NuttX Drivers for PinePhone?</em></p>
<p>Here comes the hard part: We have to <strong>code the Nuttx Driver</strong> for each PinePhone component‚Ä¶</p>
<ul>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.11_LCM/CTP"><strong>LCD Display / Touch Panel</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lte"><strong>4G LTE Modem</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.14_WIFI+BT"><strong>WiFi / BLE</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.7_NAND/eMMC"><strong>eMMC</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.6_POWER"><strong>Power Management</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list"><strong>And more‚Ä¶</strong></a></p>
</li>
</ul>
<p>PinePhone‚Äôs <strong>Device Tree</strong> tells us what drivers we need‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#pinephone-device-tree"><strong>‚ÄúPinePhone Device Tree‚Äù</strong></a></li>
</ul>
<p>Some drivers might already exist in NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/drivers"><strong>NuttX Drivers</strong></a></li>
</ul>
<p>We‚Äôve previously created NuttX Drivers for another Touchscreen Device: <a href="https://lupyuen.github.io/articles/pinedio2"><strong>Pine64 PineDio Stack BL604</strong></a>. (Pic below)</p>
<p><em>Do we really need all these PinePhone Drivers?</em></p>
<p>For <strong>Educational Purposes</strong>, we might not need all PinePhone Drivers.</p>
<p>Just pick the PinePhone Drivers that we need, compile them into NuttX, copy to microSD and boot up PinePhone.</p>
<p>Might be a quick way to <strong>experiment with the internals</strong> of NuttX on PinePhone!</p>
<p><em>What about NuttX Apps for PinePhone?</em></p>
<p>NuttX is bundled with some <strong>Demos and Utilities</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx-apps"><strong>NuttX Apps</strong></a></li>
</ul>
<p>But we‚Äôll probably create our own <strong>GUI Apps</strong> for PinePhone, like with <strong>Zig and LVGL</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl"><strong>‚ÄúBuild an LVGL Touchscreen App with Zig‚Äù</strong></a></li>
</ul>
<p>(Can we build PinePhone Drivers the safer way with Zig? Might be interesting to explore!)</p>
<p><em>What about X11 Apps?</em></p>
<p>According to <a href="https://www.linkedin.com/in/acassis/"><strong>Alan Carvalho de Assis</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx-apps/tree/master/graphics/twm4nx"><strong>Tab Window Manager</strong></a> (Tom‚Äôs Window Manager) has been ported from X11 to NuttX</p>
</li>
<li>
<p>(Coming Soon) <a href="http://www.microwindows.org/"><strong>Nano-X Window System</strong></a> might make it easier to port X11 Apps to NuttX</p>
</li>
</ul>
<p>Stay tuned for updates!</p>
<p><a href="https://github.com/dreinharth/byway">(Need a Wayland Compositor? This Zig one looks portable)</a></p>
<p><img src="https://lupyuen.github.io/images/pinedio2-title.jpg" alt="NuttX on a Touchscreen Device: Pine64 PineDio Stack BL604" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><em>NuttX on a Touchscreen Device: Pine64 PineDio Stack BL604</em></a></p>
<h1 id="whats-next"><a href="#whats-next">16 What‚Äôs Next</a></h1>
<p>Please check out the other articles on NuttX for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></li>
</ul>
<p><strong>NuttX on PinePhone</strong> might take a while to become a <strong>Daily Driver</strong>‚Ä¶</p>
<p>But today NuttX is ready to turn PinePhone into a valuable <strong>Learning Resource</strong>!</p>
<p>There‚Äôs plenty to be done for NuttX on PinePhone, please lemme know if you would like to join me üôè</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/wwz1ep/apache_nuttx_rtos_on_arm_cortexa53_how_it_might/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/arm.md"><strong>lupyuen.github.io/src/arm.md</strong></a></p>
<h1 id="notes"><a href="#notes">17 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1561843749168173056"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>What happens when we power on PinePhone? How does it start the Kernel Image in the microSD Card?</p>
<p>Check out these docs for Allwinner A64‚Ä¶</p>
<p><a href="https://linux-sunxi.org/BROM#A64"><strong>A64 Boot ROM</strong></a></p>
<p><a href="https://linux-sunxi.org/U-Boot"><strong>A64 U-Boot</strong></a></p>
<p><a href="https://linux-sunxi.org/BROM#U-Boot_SPL_limitations"><strong>A64 U-Boot SPL</strong></a></p>
<p><a href="https://linux-sunxi.org/Bootable_SD_card#SD_Card_Layout"><strong>SD Card Layout</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/arm-uart2.jpg" alt="PinePhone connected to USB Serial Debug Cable" /></p>
<p><a href="https://lupyuen.github.io/articles/arm#uart-driver-for-nuttx"><em>PinePhone connected to USB Serial Debug Cable</em></a></p>
<h1 id="appendix-pinephone-uart-log"><a href="#appendix-pinephone-uart-log">18 Appendix: PinePhone UART Log</a></h1>
<p>Earlier we talked about connecting a <strong>USB Serial Debug Cable</strong> to PinePhone‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/arm#uart-driver-for-nuttx"><strong>‚ÄúUART Driver for NuttX‚Äù</strong></a></li>
</ul>
<p>With the USB Serial Debug Cable we captured the <strong>UART Log</strong> below from PinePhone running <a href="https://github.com/dreemurrs-embedded/Jumpdrive"><strong>Jumpdrive</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ screen /dev/ttyUSB0 115200

DRAM: 2048 MiB
Trying to boot from MMC1
NOTICE:  BL31: v2.2(release):v2.2-904-gf9ea3a629
NOTICE:  BL31: Built : 15:32:12, Apr  9 2020
NOTICE:  BL31: Detected Allwinner A64/H64/R18 SoC (1689)
NOTICE:  BL31: Found U-Boot DTB at 0x4064410, model: PinePhone
NOTICE:  PSCI: System suspend is unavailable

U-Boot 2020.07 (Nov 08 2020 - 00:15:12 +0100)

DRAM:  2 GiB
MMC:   Device &#39;mmc@1c11000&#39;: seq 1 is in use by &#39;mmc@1c10000&#39;
mmc@1c0f000: 0, mmc@1c10000: 2, mmc@1c11000: 1
Loading Environment from FAT... *** Warning - bad CRC, using default environment

starting USB...
No working controllers found
Hit any key to stop autoboot:  0 
switch to partitions #0, OK
mmc0 is current device
Scanning mmc 0:1...
Found U-Boot script /boot.scr
653 bytes read in 3 ms (211.9 KiB/s)
## Executing script at 4fc00000
gpio: pin 114 (gpio 114) value is 1
4275261 bytes read in 192 ms (21.2 MiB/s)
Uncompressed size: 10170376 = 0x9B3008
36162 bytes read in 4 ms (8.6 MiB/s)
1078500 bytes read in 50 ms (20.6 MiB/s)
## Flattened Device Tree blob at 4fa00000
   Booting using the fdt blob at 0x4fa00000
   Loading Ramdisk to 49ef8000, end 49fff4e4 ... OK
   Loading Device Tree to 0000000049eec000, end 0000000049ef7d41 ... OK

Starting kernel ...

/ # uname -a
Linux (none) 5.9.1jumpdrive #3 SMP Sun Nov 8 00:41:50 CET 2020 aarch64 GNU/Linux

/ # ls
bin                info.sh            root               telnet_connect.sh
config             init               sbin               usr
dev                init_functions.sh  splash.ppm
error.ppm.gz       linuxrc            splash.ppm.gz
etc                proc               sys
</code></pre></div>
<p>We hope to see a similar UART Log when NuttX boots successfully on PinePhone.</p>
<p><em>What‚Äôs <code>boot.scr</code>?</em></p>
<div class="example-wrap"><pre class="language-text"><code>Found U-Boot script /boot.scr
</code></pre></div>
<p>According to the log above, the U-Boot Bootloader runs the <strong>U-Boot Script <code>boot.scr</code></strong> to‚Ä¶</p>
<ul>
<li>
<p>Light up the PinePhone LED (I think?)</p>
</li>
<li>
<p>Load <code>Image.gz</code> into RAM</p>
<p>(At <code>0x4408</code> <code>0000</code>)</p>
</li>
<li>
<p>Unzip <code>Image.gz</code> in RAM</p>
<p>(At <code>0x4008</code> <code>0000</code>)</p>
</li>
<li>
<p>Load the Linux Device Tree‚Ä¶</p>
<p><code>sun50i-a64-pinephone-1.2.dtb</code></p>
<p>(At <code>0x4FA0</code> <code>0000</code>)</p>
</li>
<li>
<p>Load the RAM File System <code>initramfs.gz</code></p>
<p>(At <code>0x4FE0</code> <code>0000</code>)</p>
</li>
<li>
<p>Boot the Unzipped Linux Kernel in <code>Image</code></p>
<p>(At <code>0x4008</code> <code>0000</code>)</p>
</li>
</ul>
<p>Here‚Äôs the Source File: <a href="https://github.com/dreemurrs-embedded/Jumpdrive/blob/master/src/pine64-pinephone.txt">Jumpdrive/src/pine64-pinephone.txt</a></p>
<div class="example-wrap"><pre class="language-bash"><code>setenv kernel_addr_z 0x44080000

setenv bootargs loglevel=0 silent console=tty0 vt.global_cursor_default=0

gpio set 114

if load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_z} /Image.gz; then
  unzip ${kernel_addr_z} ${kernel_addr_r}
  if load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} /sun50i-a64-pinephone-1.2.dtb; then
    if load ${devtype} ${devnum}:${distro_bootpart} ${ramdisk_addr_r} /initramfs.gz; then
      booti ${kernel_addr_r} ${ramdisk_addr_r}:${filesize} ${fdt_addr_r};
    else
      booti ${kernel_addr_r} - ${fdt_addr_r};
    fi;
  fi;
fi
</code></pre></div>
<p>The above U-Boot Script <strong><code>pine64-pinephone.txt</code></strong> is compiled to <strong><code>boot.scr</code></strong> by this Makefile: <a href="https://github.com/dreemurrs-embedded/Jumpdrive/blob/master/Makefile#L207-L209">Jumpdrive/Makefile</a></p>
<div class="example-wrap"><pre class="language-text"><code>%.scr: src/%.txt
	@echo &quot;MKIMG $@&quot;
	@mkimage -A arm -O linux -T script -C none -n &quot;U-Boot boot script&quot; -d $&lt; $@
</code></pre></div>
<p><a href="https://manpages.ubuntu.com/manpages/bionic/man1/mkimage.1.html">(<strong><code>mkimage</code></strong> is documented here)</a></p>
<p><em>What are fdt_addr_r, kernel_addr_r and ramdisk_addr_r?</em></p>
<p>They are <strong>Environment Variables</strong> defined in U-Boot‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>=&gt; printenv
fdt_addr_r=0x4FA00000
kernel_addr_r=0x40080000
ramdisk_addr_r=0x4FE00000
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#pinephone-u-boot-log">(Source)</a></p>
<p>U-Boot says that the <strong>Start of RAM <code>kernel_addr_r</code></strong> is <strong><code>0x4008</code> <code>0000</code></strong>.</p>
<p><strong>For NuttX:</strong> We might need to modify the above U-Boot Script because‚Ä¶</p>
<ul>
<li>
<p>NuttX doesn‚Äôt need the <strong>Linux Device Tree</strong></p>
</li>
<li>
<p>NuttX doesn‚Äôt need the <strong>RAM File System</strong> either</p>
</li>
<li>
<p>Which frees up more RAM for NuttX</p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/articles/arm#notes">(More about U-Boot Bootloader)</a></p>
<h1 id="appendix-analyse-nuttx-image-with-ghidra"><a href="#appendix-analyse-nuttx-image-with-ghidra">19 Appendix: Analyse NuttX Image with Ghidra</a></h1>
<p>This is how we analyse our <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.0/nuttx"><strong>NuttX ELF Image <code>nuttx</code></strong></a> with <a href="https://ghidra-sre.org/"><strong>Ghidra</strong></a>‚Ä¶</p>
<p>(Works for any ELF file actually)</p>
<ol>
<li>
<p>Install <a href="https://adoptium.net/releases.html?variant=openjdk11&amp;jvmVariant=hotspot"><strong>Java Dev Kit (JDK) 11</strong></a> (64-bit)</p>
</li>
<li>
<p>Download a <a href="https://github.com/NationalSecurityAgency/ghidra/releases"><strong>Ghidra Release File</strong></a>.</p>
<p>Extract the Ghidra Release File.</p>
</li>
<li>
<p>Launch Ghidra‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux and macOS
./ghidraRun

## For Windows
ghidraRun.bat
</code></pre></div></li>
<li>
<p>The <strong>Ghidra Help Window</strong> appears, with plenty of useful info that‚Äôs not available elsewhere.</p>
<p>Minimise the Ghidra Help Window for now.</p>
<p>(But remember to browse it when we have the time!)</p>
</li>
<li>
<p>In the <strong>Ghidra Main Window</strong>, click <strong>File</strong> ‚Üí <strong>New Project</strong></p>
<p>For <strong>Project Type</strong>: Select <strong>Non-Shared Project</strong></p>
<p>For <strong>Project Name</strong>: Enter <strong>‚ÄúMy Project‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra4.png" alt="New Ghidra Project" /></p>
</li>
<li>
<p>Click <strong>File</strong> ‚Üí <strong>Import File</strong></p>
<p>Select our <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.0/nuttx"><strong>NuttX ELF Image <code>nuttx</code></strong></a> </p>
</li>
<li>
<p>Ghidra detects that our Executable is <strong>‚ÄúAARCH64:LE:v8A:default‚Äù</strong>.</p>
<p>Click <strong>OK</strong> and <strong>OK</strong> again.</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra5.png" alt="Import Ghidra File" /></p>
</li>
<li>
<p>Double-click our ELF File <strong><code>nuttx</code></strong></p>
<p>The <strong>CodeBrowser Window</strong> appears.</p>
<p>(With a dragon-like spectre)</p>
</li>
<li>
<p>When prompted to analyze, click <strong>Yes</strong> and <strong>Analyze</strong>.</p>
<p>Ignore the warnings.</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra6.png" alt="Ghidra Analysis Options" /></p>
</li>
</ol>
<p>And we‚Äôre done with the analysis! We should see this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra9.png" alt="NuttX Image analysed with Ghidra" /></p>
<p>In case of problems, check these docs‚Ä¶</p>
<ul>
<li>
<p><a href="https://htmlpreview.github.io/?https://github.com/NationalSecurityAgency/ghidra/blob/stable/GhidraDocs/InstallationGuide.html"><strong>‚ÄúGhidra Installation Guide‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://git.mst.edu/slbnmc/ici-wiki/-/wikis/Tool-Guides/An-Introduction-to-Ghidra"><strong>‚ÄúAn Introduction to Ghidra‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/NationalSecurityAgency/ghidra"><strong>Ghidra Repo</strong></a></p>
</li>
</ul>
<p>Also check the Ghidra Help Window that we have minimised.</p>
<h1 id="appendix-analyse-pinephone-image-with-ghidra"><a href="#appendix-analyse-pinephone-image-with-ghidra">20 Appendix: Analyse PinePhone Image with Ghidra</a></h1>
<p>This is how we analyse the <strong>PinePhone Linux Kernel Image</strong> with <a href="https://ghidra-sre.org/"><strong>Ghidra</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Assume that we‚Äôve extracted and uncompressed the PinePhone Kernel <strong><code>Image</code></strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/arm#pinephone-image"><strong>‚ÄúPinePhone Image‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we‚Äôve created a <strong>Ghidra Project</strong></p>
<p>(From the previous section)</p>
</li>
<li>
<p>Go back to the <strong>Ghidra Project Window</strong>: ‚ÄúMy Project‚Äù</p>
<p>Click <strong>File</strong> ‚Üí <strong>Import File</strong></p>
<p>Select our PinePhone Kernel <strong><code>Image</code></strong></p>
</li>
<li>
<p>At the right of <strong>Language</strong>, click the <strong>‚Äú<code>...</code>‚Äù Button</strong> </p>
</li>
<li>
<p>Enter <strong><code>aarch</code></strong> into the Filter Box. Select‚Ä¶</p>
<ul>
<li>Processor: <strong><code>AARCH64</code></strong></li>
<li>Variant: <strong><code>v8A</code></strong></li>
<li>Size: <strong><code>64</code></strong></li>
<li>Endian: <strong><code>little</code></strong></li>
<li>Compiler: <strong><code>default</code></strong></li>
</ul>
<p>Click <strong>OK</strong>. </p>
<p>Language should now show <strong>‚ÄúAARCH64:LE:v8A:default‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra7.png" alt="For ‚ÄúLanguage‚Äù select AARCH64:LE:v8A:default" /></p>
</li>
<li>
<p>Click <strong>OK</strong> and <strong>OK</strong> again.</p>
</li>
<li>
<p>Double-click our <strong><code>Image</code></strong> File</p>
<p>The <strong>CodeBrowser Window</strong> appears.</p>
<p>(With a dragon-like spectre)</p>
</li>
<li>
<p>When prompted to analyze, click <strong>Yes</strong> and <strong>Analyze</strong>.</p>
<p>Ignore the warnings.</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra6.png" alt="Ghidra Analysis Options" /></p>
</li>
<li>
<p><strong>Start of RAM</strong> is <code>0x4000</code> <code>0000</code> according to the PinePhone Memory Map‚Ä¶</p>
<p><a href="https://linux-sunxi.org/A64/Memory_map"><strong>Allwinner A64 Memory Map</strong></a></p>
<p><strong>Image Load Offset</strong> is <code>0</code> according to the Linux Kernel Header (offset <code>0x08</code>)</p>
<p><a href="https://lupyuen.github.io/articles/arm#appendix-pinephone-uart-log">(<strong>UPDATE:</strong> Start of RAM should be <strong><code>0x4008</code> <code>0000</code></strong> instead)</a></p>
<p><a href="https://lupyuen.github.io/articles/uboot#porting-notes">(<strong>UPDATE:</strong> We don‚Äôt need to change the Image Load Offset)</a></p>
</li>
<li>
<p>So we shift our PinePhone Image to start at <strong><code>0x4000</code> <code>0000</code></strong>‚Ä¶</p>
<p>Click <strong>Window</strong> ‚Üí <strong>Memory Map</strong></p>
<p>Click <strong>ram</strong></p>
<p>Click the icon at top right with the Four Arrows (pic below)</p>
<p>(The icon says ‚ÄúMove a block to another address‚Äù)</p>
<p>Set <strong>New Start Address</strong> to <strong><code>40000000</code></strong></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/arm-ghidra8.png" alt="Change Start Address to 40000000" /></p>
<p>And we‚Äôre done with the analysis! We should see this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra10.png" alt="PinePhone Image analysed with Ghidra" /></p>

    
</body>
</html>