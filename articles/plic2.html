<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Ox64 BL808 SBC: UART Interrupt and Platform-Level Interrupt Controller (PLIC)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Ox64 BL808 SBC: UART Interrupt and Platform-Level Interrupt Controller (PLIC)" 
    data-rh="true">
<meta property="og:description" 
    content="TODO"
    data-rh="true">
<meta name="description" 
    content="TODO">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/plic2-registers.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/plic2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Ox64 BL808 SBC: UART Interrupt and Platform-Level Interrupt Controller (PLIC)</h1>
    <nav id="TOC"><ul>
<li><a href="#platform-level-interrupt-controller">1 Platform-Level Interrupt Controller</a><ul></ul></li>
<li><a href="#uart-interrupt">2 UART Interrupt</a><ul></ul></li>
<li><a href="#initialise-the-interrupts">3 Initialise the Interrupts</a><ul>
<li><a href="#disable-all-interrupts">3.1 Disable all Interrupts</a><ul></ul></li>
<li><a href="#clear-the-interrupts">3.2 Clear the Interrupts</a><ul></ul></li>
<li><a href="#set-the-interrupt-priority">3.3 Set the Interrupt Priority</a><ul></ul></li>
<li><a href="#set-the-interrupt-threshold">3.4 Set the Interrupt Threshold</a><ul></ul></li></ul></li>
<li><a href="#enable-the-interrupt">4 Enable the Interrupt</a><ul></ul></li>
<li><a href="#hart-0-supervisor-mode">5 Hart 0, Supervisor Mode</a><ul></ul></li>
<li><a href="#handle-the-interrupt">6 Handle the Interrupt</a><ul>
<li><a href="#claim-the-interrupt">6.1 Claim the Interrupt</a><ul></ul></li>
<li><a href="#dispatch-the-interrupt">6.2 Dispatch the Interrupt</a><ul></ul></li>
<li><a href="#complete-the-interrupt">6.3 Complete the Interrupt</a><ul></ul></li>
<li><a href="#pending-interrupts">6.4 Pending Interrupts</a><ul></ul></li></ul></li>
<li><a href="#trouble-with-interrupt-priority">7 Trouble with Interrupt Priority</a><ul></ul></li>
<li><a href="#more-trouble-with-interrupt-claim">8 More Trouble with Interrupt Claim</a><ul></ul></li>
<li><a href="#backup-plan">9 Backup Plan</a><ul></ul></li>
<li><a href="#all-things-considered">10 All Things Considered</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-nuttx-uart-driver-for-ox64">12 Appendix: NuttX UART Driver for Ox64</a><ul></ul></li>
<li><a href="#appendix-uart-interrupt-for-ox64">13 Appendix: UART Interrupt for Ox64</a><ul></ul></li></ul></nav><p>üìù <em>7 Dec 2023</em></p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="Platform-Level Interrupt Controller for Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<blockquote>
<p><em>‚ÄúIt‚Äôs time for the little red chicken‚Äôs bedtime story - and a reminder from Papa to try not to interrupt. But the chicken can‚Äôt help herself!‚Äù</em></p>
</blockquote>
<blockquote>
<p>‚Äî <a href="https://share.libbyapp.com/title/4190211">‚ÄúInterrupting Chicken‚Äù</a></p>
</blockquote>
<p>Our Story today is all about <strong>RISC-V Interrupts</strong> on the tiny <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> 64-bit Single-Board Computer (pic below)‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs inside the <strong>Platform-Level Interrupt Controller</strong> (PLIC)</p>
</li>
<li>
<p><strong>Setting up the PLIC</strong> at startup</p>
</li>
<li>
<p><strong>Enabling the PLIC Interrupt</strong> for UART Input</p>
</li>
<li>
<p><strong>Handling PLIC Interrupts</strong> for UART</p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(Based on <strong>Bouffalo Lab BL808 SoC</strong>)</a></p>
</li>
</ul>
<p>We‚Äôll walk through the steps with a simple barebones operating system: <a href="https://lupyuen.github.io/articles/ox2"><strong>Apache NuttX RTOS</strong></a>. (Real-Time Operating System)</p>
<p>Though we‚Äôll hit a bumpy journey with our work-in-progress <strong>NuttX on Ox64</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Leaky Writes</strong> seem to be affecting adjacent PLIC Registers</p>
</li>
<li>
<p><strong>Interrupt Claim</strong> doesn‚Äôt seem to be working right</p>
</li>
</ul>
<p>We begin our story‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox64-sd.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="platform-level-interrupt-controller"><a href="#platform-level-interrupt-controller">1 Platform-Level Interrupt Controller</a></h1>
<p><em>What‚Äôs this PLIC?</em></p>
<p>TODO: PLIC doc</p>
<p>(<strong>IRQ</strong> means Interrupt Request Number)</p>
<p>NuttX IRQ Number = 25 + RISC-V IRQ Number</p>
<p>NuttX reserves a bunch of IRQ Numbers for Internal Use. Hence the Offset of 25.</p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808a.jpg" alt="BL808 Platform-Level Interrupt Controller" /></p>
<h1 id="uart-interrupt"><a href="#uart-interrupt">2 UART Interrupt</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/plic2-irq.jpg" alt="BL808 UART3 Interrupt" /></p>
<h1 id="initialise-the-interrupts"><a href="#initialise-the-interrupts">3 Initialise the Interrupts</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers3a.jpg" alt="Disable Interrupts" /></p>
<h2 id="disable-all-interrupts"><a href="#disable-all-interrupts">3.1 Disable all Interrupts</a></h2>
<p>We begin by <strong>disabling all Interrupts</strong> in PLIC.</p>
<p>Writing 0 to the <strong>Interrupt Enable</strong> Register (pic above) will disable all PLIC Interrupts: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L41-L61">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the Platform-Level Interrupt Controller
void up_irqinitialize(void) {

  // Disable Supervisor-Mode Interrupts (SIE Register)
  up_irq_save();

  // Disable all External Interrupts
  // PLIC_ENABLE1 is 0xE000_2080
  // PLIC_ENABLE2 is 0xE000_2084
  // putreg32(V, A) writes 32-bit value V to address A
  putreg32(0x0, PLIC_ENABLE1);  // RISC-V IRQ 1  to 31
  putreg32(0x0, PLIC_ENABLE2);  // RISC-V IRQ 32 to 63
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/include/irq.h#L674-L703">(<strong>up_irq_save</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_internal.h#L124-L132">(<strong>putreg32</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/hardware/jh7110_plic.h#L34-L49">(<strong>PLIC_ENABLE</strong> and other PLIC Offsets are defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow">(NuttX calls <strong>up_irqinitialize</strong> at startup)</a></p>
<p>Hence at startup, all PLIC Interrupts are disabled until we <strong>enable them later</strong> (in PLIC).</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5a.jpg" alt="Clear Interrupts" /></p>
<h2 id="clear-the-interrupts"><a href="#clear-the-interrupts">3.2 Clear the Interrupts</a></h2>
<p>Next we <strong>Claim and Complete</strong> the Outstanding Interrupts (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L61-L68">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Claim and Complete the Outstanding Interrupts
  // PLIC_CLAIM is 0xE020_1004
  // getreg32(A) reads a 32-bit value from address A
  uintptr_t val = getreg32(PLIC_CLAIM);
  putreg32(val, PLIC_CLAIM);
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_internal.h#L124-L132">(<strong>getreg32</strong> is defined here)</a></p>
<p>(More about <strong>Claim and Complete</strong> in a while)</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers1.jpg" alt="Set Interrupt Priority" /></p>
<h2 id="set-the-interrupt-priority"><a href="#set-the-interrupt-priority">3.3 Set the Interrupt Priority</a></h2>
<p>We initialise the <strong>Interrupt Priority</strong> of all Interrupts to 1 (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L75C1-L90">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Set Priority for all External Interrupts to 1 (Lowest)
  // NR_IRQS is 83 (TODO: BL808 only supports 82 Peripheral Interrupts)
  // PLIC_PRIORITY is 0xE000_0000
  for (int id = 1; id &lt;= NR_IRQS; id++) {
    putreg32(
      1,  // Value
      (uintptr_t)(PLIC_PRIORITY + 4 * id)  // Address
    );
  }
</code></pre></div>
<p><em>Why set Interrupt Priority to 1?</em></p>
<ul>
<li>
<p>1 is the <strong>Lowest Interrupt Priority</strong></p>
</li>
<li>
<p>Default Interrupt Priority is 0, but it‚Äôs <strong>not valid</strong></p>
</li>
<li>
<p>Interrupt won‚Äôt actually fire until we <strong>enable it later</strong> (in PLIC)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/plic2-registers2.jpg" alt="Set Interrupt Threshold" /></p>
<h2 id="set-the-interrupt-threshold"><a href="#set-the-interrupt-threshold">3.4 Set the Interrupt Threshold</a></h2>
<p>Finally we set the PLIC <strong>Interrupt Threshold</strong> to 0 (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L90-L114">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Set Interrupt Threshold to 0
  // (Permits all External Interrupts)
  // PLIC_THRESHOLD is 0xE020_1000
  putreg32(0, PLIC_THRESHOLD);

  // Attach the Common RISC-V Exception Handlers
  // TODO: Do this earlier
  riscv_exception_attach();

  // Enable Supervisor-Mode Interrupts (SIE Register)
  up_irq_enable();
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_exception.c#L89-L142">(<strong>riscv_exception_attach</strong> is here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L208-L223">(<strong>up_irq_enable</strong> is here)</a></p>
<p><em>Why set Interrupt Threshold to 0?</em></p>
<ul>
<li>
<p>Earlier we set the <strong>Interrupt Priority to 1</strong> for All Interrupts</p>
</li>
<li>
<p>Since <strong>Interrupt Priority &gt; Interrupt Threshold</strong> (0)‚Ä¶</p>
<p>All Interrupts will be <strong>allowed to fire</strong></p>
</li>
<li>
<p>Remember: Interrupts won‚Äôt actually fire until we <strong>enable them later</strong> (in PLIC)</p>
</li>
</ul>
<p>And we‚Äôre done initing the PLIC at startup!</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers3.jpg" alt="Enable Interrupt" /></p>
<h1 id="enable-the-interrupt"><a href="#enable-the-interrupt">4 Enable the Interrupt</a></h1>
<p><em>Our Platform-Level Interrupt Controller (PLIC) is all ready for action‚Ä¶</em></p>
<p><em>How will we enable Interrupts in PLIC?</em></p>
<p>Suppose we‚Äôre enabling <strong>RISC-V IRQ 20</strong> for UART3 Interrupts.</p>
<p>All we need to do is to flip <strong>Bit 20</strong> to 1 in the <strong>Interrupt Enable</strong> Register (pic above). Like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L158-L208">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable the NuttX IRQ specified by `irq`
// UART3 Interrupt is RISC-V IRQ 20
// Which is NuttX IRQ 45 (Offset by 25)
void up_enable_irq(int irq) {

  // Omitted: Enable Inter-CPU Interrupts (SIE Register)
  // Omitted: Enable Timer Interrupts (TIE Register)

  // If this is an External Interrupt...
  if (irq &gt; RISCV_IRQ_EXT) {

    // Subtract 25 from NuttX IRQ to get the RISC-V IRQ
    int extirq = irq - RISCV_IRQ_EXT;

    // Set the Interrupt Enable Bit for `extirq` in PLIC
    if (0 &lt;= extirq &amp;&amp; extirq &lt;= 63) {
      modifyreg32(
        PLIC_ENABLE1 + (4 * (extirq / 32)),  // Address
        0,  // Clear Bits
        1 &lt;&lt; (extirq % 32)  // Set Bits
      );
    }
    else { PANIC(); }  // IRQ not supported (for now)
  }
}
</code></pre></div>
<p>And PLIC will happily accept RISC-V IRQ 20 whenever we press a key! (On the Serial Console, pic above)</p>
<p><em>Who calls up_enable_irq?</em></p>
<p>At startup, NuttX calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L383-L442"><strong>bl602_attach</strong></a> to attach the UART Interrupt Handler‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Attach UART Interrupt Handler
static int bl602_attach(struct uart_dev_s *dev) {
  ...
  // Enable Interrupt for UART3.
  // `irq` is NuttX IRQ 45
  up_enable_irq(priv-&gt;irq);
</code></pre></div>
<p>Which will call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L158-L208"><strong>up_enable_irq</strong></a> to enable the UART3 Interrupt.</p>
<p>We‚Äôre halfway through our Grand Plan of <strong>PLIC Interrupts</strong>! (Steps 1, 2 and 3, pic below)</p>
<p>We pause a moment to talk about Harts‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="Registers for Platform-Level Interrupt Controller" /></p>
<h1 id="hart-0-supervisor-mode"><a href="#hart-0-supervisor-mode">5 Hart 0, Supervisor Mode</a></h1>
<p><em>The pic above: Why does it say ‚ÄúHart 0, Supervisor Mode‚Äù?</em></p>
<p><strong>‚ÄúHart‚Äù</strong> is a RISC-V CPU Core. (‚ÄúHardware Thread‚Äù)</p>
<p><strong>‚ÄúHart 0‚Äù</strong> refers to the (one and only) <strong>64-bit RISC-V Core</strong> inside the BL808 SoC‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808a.jpg" alt="Inside the BL808 SoC" /></p>
<p>That runs our NuttX RTOS.</p>
<p><em>Does the Hart Number matter?</em></p>
<p>Most certainly! Inside the <strong>StarFive JH7110 SoC</strong> (for Star64 SBC), there are <strong>5 Harts</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808b.jpg" alt="Inside the StarFive JH7110" /></p>
<p>NuttX boots on <strong>Hart 1</strong>. So the PLIC Settings will use Hart 1. (Not Hart 0)</p>
<p>And the <strong>PLIC Register Offsets</strong> are different for Hart 0 vs Hart 1. Thus the Hart Number really matters!</p>
<p><em>Why ‚ÄúSupervisor Mode‚Äù?</em></p>
<ol>
<li>
<p><strong>RISC-V Machine Mode</strong> is the most powerful mode in our RISC-V SBC.</p>
<p><a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI Supervisor Binary Interface</strong></a> runs in Machine Mode.</p>
<p>(It‚Äôs like BIOS for RISC-V)</p>
</li>
<li>
<p><strong>RISC-V Supervisor Mode</strong> is less powerful than Machine Mode.</p>
<p><strong>NuttX Kernel</strong> runs in Supervisor Mode.</p>
<p>(Linux too!)</p>
</li>
<li>
<p><strong>RISC-V User Mode</strong> is the least powerful mode.</p>
<p><strong>NuttX Apps</strong> run in User Mode.</p>
<p>(Same for Linux Apps)</p>
</li>
</ol>
<p>PLIC has a different set of registers for Machine Mode vs Supervisor Mode.</p>
<p>That‚Äôs why we specify <strong>Supervisor Mode</strong> for the PLIC Registers.</p>
<p>Now we head back to our (interrupted) story‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers4.jpg" alt="Handle Interrupt" /></p>
<h1 id="handle-the-interrupt"><a href="#handle-the-interrupt">6 Handle the Interrupt</a></h1>
<p><em>What happens when we press a key on the Serial Console? (Pic above)</em></p>
<p><em>How will PLIC handle the UART Interrupt?</em></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5.jpg" alt="Interrupt Claim Register" /></p>
<h2 id="claim-the-interrupt"><a href="#claim-the-interrupt">6.1 Claim the Interrupt</a></h2>
<p><em>How will we know which RISC-V Interrupt has been fired?</em></p>
<p>That‚Äôs why we have the <strong>Interrupt Claim</strong> Register! (Pic above)</p>
<p>We read the Interrupt Claim Register to get the <strong>RISC-V IRQ Number</strong> that has been fired: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Dispatch the RISC-V Interrupt
void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs) {

  // Compute the (Interim) NuttX IRQ Number
  // Based on the Interrupt Vector Number
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);

  // If this is an External Interrupt...
  if (RISCV_IRQ_EXT == irq) {

    // Read the RISC-V IRQ Number
    // From PLIC Claim Register
    // Which also Claims the Interrupt
    // PLIC_CLAIM is 0xE020_1004
    uintptr_t val = getreg32(PLIC_CLAIM);

    // Compute the Actual NuttX IRQ Number:
    // RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)
    irq += val;
  }
  // Up Next: Dispatch and Complete the Interrupt
</code></pre></div>
<p><em>What exactly are we ‚Äúclaiming‚Äù?</em></p>
<p>When we <a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#interrupt-claims"><strong>Claim an Interrupt</strong></a> (by reading the Interrupt Claim Register)‚Ä¶</p>
<p>We‚Äôre telling the PLIC: ‚ÄúYes we acknowledge the Interrupt, but we‚Äôre not done yet!‚Äù</p>
<p>In a while we shall Complete the Interrupt. (To tell PLIC we‚Äôre done)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_exception_common.S#L63-L177">(<strong>riscv_dispatch_irq</strong> is called by the RISC-V Common Exception Handler)</a></p>
<h2 id="dispatch-the-interrupt"><a href="#dispatch-the-interrupt">6.2 Dispatch the Interrupt</a></h2>
<p>We have Claimed the Interrupt. It‚Äôs time to do some work: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Omitted: Claim the Interrupt
  ...
  // Remember: `irq` is now the ACTUAL NuttX IRQ Number:
  // RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)

  // If the RISC-V IRQ Number is valid (non-zero)...
  if (RISCV_IRQ_EXT != irq) {

    // Call the Interrupt Handler
    regs = riscv_doirq(irq, regs);
  }
  // Up Next: Complete the Interrupt
</code></pre></div>
<p>For UART Interrupts: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_doirq.c#L58-L134"><strong>riscv_doirq</strong></a> will call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L285-L343"><strong>uart_interrupt</strong></a> to handle the keypress.</p>
<p>(That‚Äôs because at startup, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L383-L442"><strong>bl602_attach</strong></a> has registered <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L285-L343"><strong>uart_interrupt</strong></a> as the UART Interrupt Handler)</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5.jpg" alt="Interrupt Claim Register" /></p>
<h2 id="complete-the-interrupt"><a href="#complete-the-interrupt">6.3 Complete the Interrupt</a></h2>
<p>To tell PLIC we‚Äôre done, we write the RISC-V IRQ Number back to the <strong>Interrupt Claim</strong> Register.</p>
<p>(Yep the same one we read earlier! Pic above)</p>
<p>This will <strong>Complete the Interrupt</strong> (so PLIC can fire the next one): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Omitted: Claim and Dispatch the Interrupt
  ...
  // If this is an External Interrupt...
  if (RISCV_IRQ_EXT &lt;= irq) {

    // Compute the RISC-V IRQ Number
    // and Complete the Interrupt.
    // PLIC_CLAIM is 0xE020_1004
    putreg32(               // We write the...
      irq - RISCV_IRQ_EXT,  // RISC-V IRQ Number (RISCV_IRQ_EXT = 25)
      PLIC_CLAIM            // To PLIC Claim (Complete) Register
    );
  }

  // Return the Registers to the Caller
  return regs;
}
</code></pre></div>
<p>And that‚Äôs how we handle PLIC Interrupts!</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers6.jpg" alt="Interrupt Pending Register" /></p>
<h2 id="pending-interrupts"><a href="#pending-interrupts">6.4 Pending Interrupts</a></h2>
<p><em>What‚Äôs with the Pending Interrupts? (Pic above)</em></p>
<p>Normally the Interrupt Claim Register is perfectly adequate for handling Interrupts.</p>
<p>But if we‚Äôre really curious: PLIC has an <strong>Interrupt Pending</strong> Register (pic above) that will tell us which Interrupts are pending Claiming or Completion: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Check the Pending Interrupts...
// Read PLIC_IP0: Interrupt Pending for interrupts 1 to 31
uintptr_t ip0 = getreg32(0xe0001000);

// If Bit 20 is set...
if (ip0 &amp; (1 &lt;&lt; 20)) {
  // Then UART3 Interrupt was fired (RISC-V IRQ 20)
  val = 20;
}
</code></pre></div>
<p>To tell PLIC we‚Äôre done: We clear the Individual Bits in the Interrupt Pending Register‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Clear the Pending Interrupts...
// Set PLIC_IP0: Interrupt Pending for interrupts 1 to 31
putreg32(0, 0xe0001000);

// TODO: Clear the Individual Bits instead of wiping out the Entire Register
</code></pre></div>
<p>One again, we don‚Äôt need really need this. We‚Äôll stash this as our Backup Plan in case things go wrong.</p>
<p>(Oh yes, things will go wrong in a while)</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers1.jpg" alt="Set Interrupt Priority" /></p>
<h1 id="trouble-with-interrupt-priority"><a href="#trouble-with-interrupt-priority">7 Trouble with Interrupt Priority</a></h1>
<p><em>I sense a twist in our story‚Ä¶</em></p>
<p>Earlier we said that we initialise the <strong>Interrupt Priorities to 1</strong> at startup: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L75C1-L90">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the Platform-Level Interrupt Controller
void up_irqinitialize(void) {
  ...
  // Set Priority for all External Interrupts to 1 (Lowest)
  for (int id = 1; id &lt;= NR_IRQS; id++) {
    putreg32(
      1,  // Value
      (uintptr_t)(PLIC_PRIORITY + 4 * id)  // Address
    );
  }

  // Dump the Interrupt Priorities
  infodumpbuffer(&quot;PLIC Interrupt Priority: After&quot;, 0xe0000004, 0x50 * 4);
</code></pre></div>
<p>When we run this on Ox64, something strange happens‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>PLIC Interrupt Priority: After (0xe0000004):
0000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4e8ca1f0c0c2bd3b22a8b63f098abdd5#file-ox64-nuttx-int-clear-pending-log-L150-L170">(See the <strong>Complete Log</strong>)</a></p>
<p><em>Everything becomes zero! Why???</em></p>
<p>Yeah this is totally baffling! And no Interrupts get fired, because <strong>Interrupt Priority 0 is invalid</strong>.</p>
<p>Let‚Äôs set the Interrupt Priority specifically for <strong>RISC-V IRQ 20</strong> (UART3 Interrupt): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L444-L465">bl602_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Test the setting of PLIC Interrupt Priority
// For RISC-V IRQ 20 only
void test_interrupt_priority(void) {
  // Read the values before setting Interrupt Priority
  uint32_t before50 = *(volatile uint32_t *) 0xe0000050UL;  // RISC-V IRQ 20
  uint32_t before54 = *(volatile uint32_t *) 0xe0000054UL;  // RISC-V IRQ 21

  // Set the Interrupt Priority
  // for 0x50 but NOT 0x54
  *(volatile uint32_t *) 0xe0000050UL = 1;

  // Read the values after setting Interrupt Priority
  uint32_t after50 = *(volatile uint32_t *) 0xe0000050UL;  // RISC-V IRQ 20
  uint32_t after54 = *(volatile uint32_t *) 0xe0000054UL;  // RISC-V IRQ 21

  // Dump before and after values:
  _info(&quot;before50=%u, before54=%u, after50=%u, after54=%u\n&quot;,
    before50, before54, after50, after54);
}
</code></pre></div>
<p>Again we get odd results‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>before50=0, before54=0
after50=1,  after54=1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4e8ca1f0c0c2bd3b22a8b63f098abdd5#file-ox64-nuttx-int-clear-pending-log-L257">(See the <strong>Complete Log</strong>)</a></p>
<p>IRQ 20 is set correctly. But <strong>IRQ 21 is also set</strong>! (Pic below)</p>
<p><em>Hmmm‚Ä¶ Our writing seems to have leaked over to the next 32-bit word?</em></p>
<p>Yeah we see the <strong>Leaky Write</strong> again when we set the <strong>Interrupt Enable</strong> Register‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// Before setting Interrupt Enable: Everything is 0
PLIC Hart 0 S-Mode Interrupt Enable: Before (0xe0002080):
0000  00 00 00 00 00 00 00 00                          ........        

// Set Interrupt Enable for RISC-V IRQ 20 (Bit 20)
up_enable_irq: extirq=20, addr=0xe0002080, val=0x1048576

// After setting Interrupt Enable:
// Bit 20 is also set in the next word!
PLIC Hart 0 S-Mode Interrupt Enable: After (0xe0002080):
0000  00 00 10 00 00 00 10 00                          ........  
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4e8ca1f0c0c2bd3b22a8b63f098abdd5#file-ox64-nuttx-int-clear-pending-log-L194-L198">(See the <strong>Complete Log</strong>)</a></p>
<p>Interrupt Enable has leaked over from <strong><code>0xE000</code> <code>2080</code></strong> to <strong><code>0xE000</code> <code>2084</code></strong>!</p>
<p>Thus we have an unexplained problem of <strong>Leaky Writes</strong>, affecting the Interrupt Priority and Interrupt Enable Registers.</p>
<p>Up Next: More worries‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-title.jpg" alt="Leaky Write for PLIC Interrupt Priority" /></p>
<h1 id="more-trouble-with-interrupt-claim"><a href="#more-trouble-with-interrupt-claim">8 More Trouble with Interrupt Claim</a></h1>
<p>We talked earlier about <strong>Handling Interrupts</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5.jpg" alt="Claim Interrupt" /></p>
<p>And how we fetch the <strong>RISC-V IRQ Number</strong> from the <strong>Interrupt Claim</strong> Register: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Dispatch the RISC-V Interrupt
void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs) {

  // Compute the (Interim) NuttX IRQ Number
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);

  // If this is an External Interrupt...
  if (RISCV_IRQ_EXT == irq) {

    // Read the RISC-V IRQ Number
    // From PLIC Claim Register
    // Which also Claims the Interrupt
    // PLIC_CLAIM is 0xE020_1004
    uintptr_t val = getreg32(PLIC_CLAIM);
</code></pre></div>
<p><em>What happens when we run this?</em></p>
<p>On Ox64 we see NuttX booting normally to the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.0.3
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4e8ca1f0c0c2bd3b22a8b63f098abdd5#file-ox64-nuttx-int-clear-pending-log-L293-L308">(See the <strong>Complete Log</strong>)</a></p>
<p>When we <strong>press a key</strong> on the Serial Console (to trigger a UART Interrupt)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_dispatch_irq:
  claim=0
</code></pre></div>
<p>Our Interrupt Handler says that the <strong>Interrupt Claim Register is 0</strong>‚Ä¶</p>
<p>Which means we can‚Äôt read the <strong>RISC-V IRQ Number</strong>!</p>
<p>We activate our Backup Plan‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers6.jpg" alt="Pending Interrupts" /></p>
<h1 id="backup-plan"><a href="#backup-plan">9 Backup Plan</a></h1>
<p><em>We have a Backup Plan for Handling Interrupts?</em></p>
<p>Our Backup Plan is to figure out the RISC-V IRQ Number by reading the <strong>Interrupt Pending</strong> Register (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    // If Interrupt Claimed is 0...
    if (val == 0) {
      // Check the Pending Interrupts...
      // Read PLIC_IP0: Interrupt Pending for interrupts 1 to 31
      uintptr_t ip0 = getreg32(0xe0001000);

      // If Bit 20 is set...
      if (ip0 &amp; (1 &lt;&lt; 20)) {
        // Then UART3 Interrupt was fired (RISC-V IRQ 20)
        val = 20;
      }
    }

    // Compute the Actual NuttX IRQ Number:
    // RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)
    irq += val;
  }

  // Omitted: Call the Interrupt Handler
  // and Complete the Interrupt
</code></pre></div>
<p>Which tells us the correct <strong>RISC-V IRQ Number</strong> yay!</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_dispatch_irq:
  irq=45
</code></pre></div>
<p>(<strong>NuttX IRQ 45</strong> means <strong>RISC-V IRQ 20</strong>)</p>
<p>Don‚Äôt forget to <strong>clear the Pending Interrupts</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Clear the Pending Interrupts
  // TODO: Clear the Individual Bits instead of wiping out the Entire Register
  putreg32(0, 0xe0001000);  // PLIC_IP0: Interrupt Pending for interrupts 1 to 31
  putreg32(0, 0xe0001004);  // PLIC_IP1: Interrupt Pending for interrupts 32 to 63

  // Dump the Pending Interrupts
  infodumpbuffer(&quot;PLIC Interrupt Pending&quot;, 0xe0001000, 2 * 4);

  // Yep works great, Pending Interrupts have been cleared...
  // PLIC Interrupt Pending (0xe0001000):
  // 0000  00 00 00 00 00 00 00 00                          ........        
</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_receive: rxdata=-1
bl602_receive: rxdata=0x0
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4e8ca1f0c0c2bd3b22a8b63f098abdd5#file-ox64-nuttx-int-clear-pending-log-L293-L308">(See the <strong>Complete Log</strong>)</a></p>
<p>TODO: Screenshot</p>
<h1 id="all-things-considered"><a href="#all-things-considered">10 All Things Considered</a></h1>
<p><em>Feels like we‚Äôre wading into murky greyish territory‚Ä¶ Like Jaws meets Twilight Zone on the Beach?</em></p>
<p>Yeah we said this <a href="https://lupyuen.github.io/articles/ox2#begin-with-star64-nuttx"><strong>last time</strong></a> and it‚Äôs happening now‚Ä¶</p>
<blockquote>
<p>‚ÄúIf RISC-V ain‚Äôt RISC-V on SiFive vs T-Head: We‚Äôll find out!‚Äù</p>
</blockquote>
<p>The PLIC Code in this article was <strong>originally tested OK</strong> with‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/plic"><strong>StarFive JH7110 SoC</strong></a> in RISC-V Supervisor Mode</p>
<p>(Based on SiFive U74 Core)</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/c906/c906_irq.c"><strong>T-Head C906 Core</strong></a> in RISC-V Machine Mode</p>
<p>(Ox64 BL808 runs on the C906 Core)</p>
</li>
<li>
<p>But NOT <strong>T-Head C906</strong> in <strong>RISC-V Supervisor Mode</strong></p>
<p>(Which might explain our troubles)</p>
</li>
</ul>
<p>Today we‚Äôre hitting 2 strange issues in the <strong>BL808 (C906) PLIC</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Leaky Writes</strong> to PLIC Registers</p>
<p>(Writing to one register will affect the next)</p>
</li>
<li>
<p><strong>PLIC Claim Register</strong> always reads as 0</p>
<p>(Instead of the RISC-V External Interrupt Number)</p>
</li>
</ul>
<p>So many questions‚Ä¶</p>
<ol>
<li>
<p><em>Any clue what‚Äôs causing this?</em></p>
<p>The <strong>Leaky Writes</strong> don‚Äôt seem to happen <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L282-L298"><strong>before enabling the MMU</strong></a> (Memory Management Unit)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// Before enabling Memory Mgmt Unit...
jh7110_mm_init: Test Interrupt Priority

// No Leaky Writes!
test_interrupt_priority:
  before50=0, before54=0
  after50=1,  after54=0

// Leaky Writes after enabling Memory Mgmt Unit
jh7110_kernel_mppings: map I/O regions
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4e8ca1f0c0c2bd3b22a8b63f098abdd5#file-ox64-nuttx-int-clear-pending-log-L116-L118">(See the <strong>Complete Log</strong>)</a></p>
<p>So it might be a problem with our MMU Settings.</p>
<p><a href="https://lupyuen.github.io/articles/mmu">(More about <strong>Memory Management Unit</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#strangeness-in-ox64-bl808-plic">(<strong>U-Boot Bootloader</strong> doesn‚Äôt have Leaky Writes)</a></p>
</li>
<li>
<p><em>What if we configure the MMU differently?</em></p>
<p>We moved the PLIC from <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L249-L258"><strong>Level 2 Page Tables</strong></a> up to <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L240-L245"><strong>Level 1</strong></a>‚Ä¶</p>
<p>Same problem.</p>
</li>
<li>
<p><em>Something special about the C906 MMU?</em></p>
<p>According to the <a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf"><strong>C906 User Manual</strong></a>  (Page 53), the C906 MMU supports <strong>Extended Page Attributes</strong>. Which might affect us?</p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#strangeness-in-ox64-bl808-plic">(More about <strong>C906 Extended Page Attributes</strong>)</a></p>
</li>
<li>
<p><em>What about the C906 PLIC?</em></p>
<p>According to the <a href="https://lore.kernel.org/lkml/CAJF2gTS8Z+6Ewy0D5+0X_h2Jz4BqsJp7wEC5F0iNaDsSpiE2aw@mail.gmail.com/"><strong>Linux PLIC Driver</strong></a>‚Ä¶</p>
<blockquote>
<p>‚ÄúThe T-HEAD C9xx SoC implements a modified/custom T-HEAD PLIC
specification which will mask current IRQ upon read to CLAIM register
and will unmask the IRQ upon write to CLAIM register‚Äù</p>
</blockquote>
<p>Will this affect our Interrupt Claim?</p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#strangeness-in-ox64-bl808-plic">(More about <strong>C906 PLIC</strong>)</a></p>
</li>
<li>
<p><em>Maybe the GCC Compiler didn‚Äôt generate the right code?</em></p>
<p>We wrote <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L487-L531"><strong>RISC-V Assembly</strong></a> with <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L531-L608"><strong>DCACHE / ICACHE</strong></a> and <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e76886a665fb9b8fe4f52c25e2f80877a62f415c/arch/risc-v/src/jh7110/bl602_serial.c#L446-L489"><strong>SFENCE</strong></a>.</p>
<p>Still the same.</p>
</li>
<li>
<p><em>Perhaps our problem is Leaky Reads? Not Leaky Writes?</em></p>
<p>Hmmm‚Ä¶ Perhaps!</p>
</li>
</ol>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>We‚Äôll do much more for <strong>NuttX on Ox64 BL808</strong>, stay tuned for updates!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/plic2.md"><strong>lupyuen.github.io/src/plic2.md</strong></a></p>
<h1 id="appendix-nuttx-uart-driver-for-ox64"><a href="#appendix-nuttx-uart-driver-for-ox64">12 Appendix: NuttX UART Driver for Ox64</a></h1>
<p>TODO</p>
<p>BL808 UART is mostly identical to BL602 UART, so we ported the NuttX BL602 UART Driver to BL808.</p>
<p>Here‚Äôs the UART Driver ported to BL808: [bl602_serial.c] (https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/bl602_serial.c)</p>
<p>We hardcoded the UART3 Base Address: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/hardware/bl602_uart.h#L30-L41">bl602_uart.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BL602_UART0_BASE 0x30002000
#define BL602_UART_BASE(n) (BL602_UART0_BASE)
// Previously: #define BL602_UART_BASE(n)    (BL602_UART0_BASE + (n * (BL602_UART1_BASE - BL602_UART0_BASE)))
</code></pre></div>
<p>We fixed the NuttX Start Code to call our new UART Driver: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L175-L184">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void riscv_earlyserialinit(void) {
  bl602_earlyserialinit();
}

void riscv_serialinit(void) {
  bl602_serialinit();
}
</code></pre></div>
<p>We disabled UART Interrupts for now: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/bl602_serial.c#L377-L431">bl602_attach and bl602_detach</a></p>
<p>And the UART Driver works! <a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">(See the log)</a></p>
<p>TODO: /dev/ttyS0 is missing</p>
<p>TODO: Enable UART Interrupts</p>
<h1 id="appendix-uart-interrupt-for-ox64"><a href="#appendix-uart-interrupt-for-ox64">13 Appendix: UART Interrupt for Ox64</a></h1>
<p>TODO</p>
<p>Let‚Äôs fix the UART Interrupts for NuttX on Ox64 BL808!</p>
<p>We fix the PLIC Offsets according to <a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">C906 User Manual (Page 77)</a></p>
<p><em>What‚Äôs the UART3 IRQ?</em></p>
<p>From the Linux Device Tree‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>serial@30002000 {
  compatible = &quot;bflb,bl808-uart&quot;;
  reg = &lt;0x30002000 0x1000&gt;;
  interrupts = &lt;0x14 0x04&gt;;
  clocks = &lt;0x04&gt;;
  status = &quot;okay&quot;;
  phandle = &lt;0x0a&gt;;
};
</code></pre></div>
<p>Thus‚Ä¶</p>
<ul>
<li>
<p>RISC-V IRQ = 0x14 = 20</p>
</li>
<li>
<p>UART3 Int = (IRQ_NUM_BASE + 4)</p>
</li>
<li>
<p>IRQ_NUM_BASE = 16</p>
</li>
<li>
<p>NuttX IRQ = 45 (Offset by RISCV_IRQ_EXT)</p>
</li>
<li>
<p>RISCV_IRQ_EXT = 25</p>
</li>
</ul>

    
</body>
</html>