<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Ox64 BL808 SBC: UART Interrupt and Platform-Level Interrupt Controller (PLIC)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Ox64 BL808 SBC: UART Interrupt and Platform-Level Interrupt Controller (PLIC)" 
    data-rh="true">
<meta property="og:description" 
    content="We dive into the Platform-Level Interrupt Controller (PLIC) for the tiny adorable Pine64 Ox64 BL808 64-bit Single-Board Computer... Using Apache NuttX Real-Time Operating System to explain the inner workings of PLIC"
    data-rh="true">
<meta name="description" 
    content="We dive into the Platform-Level Interrupt Controller (PLIC) for the tiny adorable Pine64 Ox64 BL808 64-bit Single-Board Computer... Using Apache NuttX Real-Time Operating System to explain the inner workings of PLIC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/plic2-registers.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/plic2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Ox64 BL808 SBC: UART Interrupt and Platform-Level Interrupt Controller (PLIC)</h1>
    <nav id="TOC"><ul>
<li><a href="#platform-level-interrupt-controller">1 Platform-Level Interrupt Controller</a><ul></ul></li>
<li><a href="#uart-interrupt">2 UART Interrupt</a><ul></ul></li>
<li><a href="#initialise-the-interrupts">3 Initialise the Interrupts</a><ul>
<li><a href="#disable-all-interrupts">3.1 Disable all Interrupts</a><ul></ul></li>
<li><a href="#clear-the-interrupts">3.2 Clear the Interrupts</a><ul></ul></li>
<li><a href="#set-the-interrupt-priority">3.3 Set the Interrupt Priority</a><ul></ul></li>
<li><a href="#set-the-interrupt-threshold">3.4 Set the Interrupt Threshold</a><ul></ul></li></ul></li>
<li><a href="#enable-the-interrupt">4 Enable the Interrupt</a><ul></ul></li>
<li><a href="#hart-0-supervisor-mode">5 Hart 0, Supervisor Mode</a><ul></ul></li>
<li><a href="#handle-the-interrupt">6 Handle the Interrupt</a><ul>
<li><a href="#claim-the-interrupt">6.1 Claim the Interrupt</a><ul></ul></li>
<li><a href="#dispatch-the-interrupt">6.2 Dispatch the Interrupt</a><ul></ul></li>
<li><a href="#complete-the-interrupt">6.3 Complete the Interrupt</a><ul></ul></li>
<li><a href="#pending-interrupts">6.4 Pending Interrupts</a><ul></ul></li></ul></li>
<li><a href="#trouble-with-interrupt-priority">7 Trouble with Interrupt Priority</a><ul></ul></li>
<li><a href="#more-trouble-with-interrupt-claim">8 More Trouble with Interrupt Claim</a><ul></ul></li>
<li><a href="#backup-plan">9 Backup Plan</a><ul></ul></li>
<li><a href="#all-things-considered">10 All Things Considered</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-uart-driver-for-ox64">12 Appendix: UART Driver for Ox64</a><ul></ul></li>
<li><a href="#appendix-build-and-run-nuttx">13 Appendix: Build and Run NuttX</a><ul></ul></li></ul></nav><p>üìù <em>3 Dec 2023</em></p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="Platform-Level Interrupt Controller for Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<blockquote>
<p><em>‚ÄúIt‚Äôs time for the little red chicken‚Äôs bedtime story - and a reminder from Papa to try not to interrupt. But the chicken can‚Äôt help herself!‚Äù</em></p>
</blockquote>
<blockquote>
<p>‚Äî <a href="https://share.libbyapp.com/title/4190211">‚ÄúInterrupting Chicken‚Äù</a></p>
</blockquote>
<p>Our Story today is all about <strong>RISC-V Interrupts</strong> on the tiny adorable <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> 64-bit Single-Board Computer (pic below)‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs inside the <strong>Platform-Level Interrupt Controller</strong> (PLIC)</p>
</li>
<li>
<p><strong>Setting up the PLIC</strong> at startup</p>
</li>
<li>
<p><strong>Enabling the PLIC Interrupt</strong> for Serial Console</p>
</li>
<li>
<p><strong>Handling PLIC Interrupts</strong> for UART Input</p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(Based on <strong>Bouffalo Lab BL808 SoC</strong>)</a></p>
</li>
</ul>
<p>We‚Äôll walk through the steps with a simple barebones operating system: <a href="https://lupyuen.github.io/articles/ox2"><strong>Apache NuttX RTOS</strong></a>. (Real-Time Operating System)</p>
<p>Though we‚Äôll hit a bumpy journey with our work-in-progress <strong>NuttX on Ox64</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Leaky Writes</strong> seem to affect adjacent PLIC Registers</p>
</li>
<li>
<p><strong>Interrupt Claim</strong> doesn‚Äôt seem to work right</p>
<p><a href="https://youtu.be/VSTpsSJ_7L0">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
</ul>
<p>We begin our story‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox64-sd.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="platform-level-interrupt-controller"><a href="#platform-level-interrupt-controller">1 Platform-Level Interrupt Controller</a></h1>
<p><em>What‚Äôs this PLIC?</em></p>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#plic"><strong>Platform-Level Interrupt Controller</strong></a> (PLIC) is the hardware inside our BL808 SoC that controls the forwarding of <strong>Peripheral Interrupts</strong> to our 64-bit RISC-V CPU.</p>
<p>(Like the Interrupts for <strong>UART</strong>, <strong>I2C</strong>, <strong>SPI</strong>, ‚Ä¶)</p>
<p><em>Why should we bother with PLIC?</em></p>
<p>Suppose we‚Äôre using the <strong>Serial Console</strong> on Ox64 SBC (pic below)‚Ä¶</p>
<ul>
<li>
<p>Every single <strong>key that we press</strong>‚Ä¶</p>
</li>
<li>
<p>Will fire an <strong>Interrupt through the PLIC</strong> to the RISC-V CPU</p>
</li>
<li>
<p>Without the PLIC, it‚Äôs <strong>impossible to enter commands</strong> in the Serial Console!</p>
</li>
</ul>
<p>That‚Äôs why it‚Äôs good to understand how PLIC works with an Operating System. (Like Linux or NuttX)</p>
<p><em>PLIC handles all kinds of Interrupts?</em></p>
<p>Yep plenty! We identify each Interrupt by its <strong>RISC-V IRQ Number</strong>. (<strong>IRQ</strong> means Interrupt Request Number)</p>
<p>NuttX uses its own <strong>NuttX IRQ Number</strong>‚Ä¶</p>
<ul>
<li>NuttX IRQ = 25 + RISC-V IRQ</li>
</ul>
<p>That‚Äôs because NuttX reserves a bunch of IRQ Numbers for Internal Use. (Hence the Offset of 25)</p>
<p>Let‚Äôs figure out the IRQ Number for Serial Console‚Ä¶</p>
<p><a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">(PLIC is documented in <strong>C906 User Manual</strong>, Page 74)</a></p>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#plic">(See the <strong>Official PLIC Spec</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808a.jpg" alt="BL808 Platform-Level Interrupt Controller" /></p>
<h1 id="uart-interrupt"><a href="#uart-interrupt">2 UART Interrupt</a></h1>
<p><em>What‚Äôs the Interrupt Number for the Serial Console?</em></p>
<p>To enable Text Input in the <strong>Ox64 Serial Console</strong>, we need the Interrupt Number for the <strong>UART Controller</strong>‚Ä¶</p>
<ul>
<li>
<p>We‚Äôre running on the <strong>D0 Multimedia Core</strong> of the BL808 SoC</p>
<p>(Pic above)</p>
</li>
<li>
<p>Connected to the D0 Multimedia Core is the <strong>UART3 Controller</strong> for Serial Console</p>
<p>(Pic below)</p>
</li>
<li>
<p>According to the table below: RISC-V IRQ Number for UART3 is‚Ä¶</p>
<p><strong>IRQ_NUM_BASE + 4</strong></p>
</li>
<li>
<p>Also in the table‚Ä¶</p>
<p><strong>IRQ_NUM_BASE</strong> is <strong>16</strong></p>
</li>
</ul>
<p>Therefore the <strong>RISC-V IRQ Number</strong> for our Serial Console (UART3) is <strong>20</strong>.</p>
<p>Remember that NuttX uses its own <strong>NuttX IRQ Number</strong>‚Ä¶</p>
<ul>
<li>NuttX IRQ = 25 + RISC-V IRQ</li>
</ul>
<p>Later we‚Äôll handle <strong>NuttX IRQ Number 45</strong> in our code. And our Ox64 Serial Console will support Text Input!</p>
<p><em>How did we get the UART Driver for Ox64 BL808?</em></p>
<p>We copied the <strong>NuttX UART Driver</strong> from BL602 to BL808, since the UART Controllers are similar‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/plic2#appendix-uart-driver-for-ox64"><strong>‚ÄúUART Driver for Ox64‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/plic2-irq.jpg" alt="BL808 Reference Manual (Page 44)" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><em>BL808 Reference Manual (Page 44)</em></a></p>
<h1 id="initialise-the-interrupts"><a href="#initialise-the-interrupts">3 Initialise the Interrupts</a></h1>
<p><em>How shall we get started with PLIC?</em></p>
<p>We walk through the steps to <strong>prepare the Platform-Level Interrupt Controller</strong> (PLIC) at startup‚Ä¶</p>
<ol>
<li>
<p><strong>Disable all Interrupts</strong></p>
<p>(Because we‚Äôre about to configure them)</p>
</li>
<li>
<p>Clear the <strong>Outstanding Interrupts</strong></p>
<p>(So we won‚Äôt get stuck at startup)</p>
</li>
<li>
<p>Set the <strong>Interrupt Priority</strong></p>
<p>(To the Lowest Priority)</p>
</li>
<li>
<p>Set the <strong>Interrupt Threshold</strong></p>
<p>(Allowing Interrupts to be fired later)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/plic2-registers3a.jpg" alt="Disable Interrupts" /></p>
<h2 id="disable-all-interrupts"><a href="#disable-all-interrupts">3.1 Disable all Interrupts</a></h2>
<p>We begin by <strong>disabling all Interrupts</strong> in PLIC.</p>
<p>Writing 0 to the <strong>Interrupt Enable</strong> Register (pic above) will disable all PLIC Interrupts: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L41-L61">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the Platform-Level Interrupt Controller
void up_irqinitialize(void) {

  // Disable Supervisor-Mode Interrupts (SIE Register)
  up_irq_save();

  // Disable all External Interrupts
  // PLIC_ENABLE1 is 0xE000_2080
  // PLIC_ENABLE2 is 0xE000_2084
  // putreg32(V, A) writes 32-bit value V to address A
  putreg32(0x0, PLIC_ENABLE1);  // RISC-V IRQ 1  to 31
  putreg32(0x0, PLIC_ENABLE2);  // RISC-V IRQ 32 to 63
</code></pre></div>
<p>Hence at startup, all PLIC Interrupts are disabled until we <strong>enable them later</strong> (in PLIC).</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/include/irq.h#L674-L703">(<strong>up_irq_save</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_internal.h#L124-L132">(<strong>putreg32</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/hardware/jh7110_plic.h#L34-L49">(<strong>PLIC_ENABLE</strong> and other PLIC Offsets)</a></p>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow">(NuttX calls <strong>up_irqinitialize</strong> at startup)</a></p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5a.jpg" alt="Clear Interrupts" /></p>
<h2 id="clear-the-interrupts"><a href="#clear-the-interrupts">3.2 Clear the Interrupts</a></h2>
<p>Next we <strong>Claim and Complete</strong> the Outstanding Interrupts, so they won‚Äôt bother us at startup (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L61-L68">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Claim and Complete the Outstanding Interrupts
  // PLIC_CLAIM is 0xE020_1004
  // getreg32(A) reads a 32-bit value from address A
  uintptr_t val = getreg32(PLIC_CLAIM);
  putreg32(val, PLIC_CLAIM);
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_internal.h#L124-L132">(<strong>getreg32</strong> is defined here)</a></p>
<p>(More about <strong>Claim and Complete</strong> in a while)</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers1.jpg" alt="Set Interrupt Priority" /></p>
<h2 id="set-the-interrupt-priority"><a href="#set-the-interrupt-priority">3.3 Set the Interrupt Priority</a></h2>
<p>We initialise the <strong>Interrupt Priority</strong> of all Interrupts to 1 (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L75C1-L90">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Set Priority for all External Interrupts to 1 (Lowest)
  // NR_IRQS is 83 (TODO: BL808 only supports 82 Peripheral Interrupts)
  // PLIC_PRIORITY is 0xE000_0000
  for (int id = 1; id &lt;= NR_IRQS; id++) {
    putreg32(
      1,  // Value
      (uintptr_t)(PLIC_PRIORITY + 4 * id)  // Address
    );
  }
</code></pre></div>
<p><em>Why set Interrupt Priority to 1?</em></p>
<ul>
<li>
<p>1 is the <strong>Lowest Interrupt Priority</strong></p>
</li>
<li>
<p>Default Interrupt Priority is 0, but it‚Äôs <strong>not valid</strong></p>
</li>
<li>
<p>Interrupt won‚Äôt actually fire until we <strong>enable it later</strong> (in PLIC)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/plic2-registers2.jpg" alt="Set Interrupt Threshold" /></p>
<h2 id="set-the-interrupt-threshold"><a href="#set-the-interrupt-threshold">3.4 Set the Interrupt Threshold</a></h2>
<p>Finally we set the <strong>Interrupt Threshold</strong> to 0 (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L90-L114">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Set Interrupt Threshold to 0
  // (Permits all External Interrupts)
  // PLIC_THRESHOLD is 0xE020_1000
  putreg32(0, PLIC_THRESHOLD);

  // Attach the Common RISC-V Exception Handlers
  // TODO: Do this earlier
  riscv_exception_attach();

  // Enable Supervisor-Mode Interrupts (SIE Register)
  up_irq_enable();
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_exception.c#L89-L142">(<strong>riscv_exception_attach</strong> is here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L208-L223">(<strong>up_irq_enable</strong> is here)</a></p>
<p><em>Why set Interrupt Threshold to 0?</em></p>
<ul>
<li>
<p>Earlier we set the <strong>Interrupt Priority to 1</strong> for All Interrupts</p>
</li>
<li>
<p>Since <strong>Interrupt Priority &gt; Interrupt Threshold</strong> (0)‚Ä¶</p>
<p>All Interrupts will be <strong>allowed to fire</strong></p>
</li>
<li>
<p>Remember: Interrupts won‚Äôt actually fire until we <strong>enable them later</strong> (in PLIC)</p>
</li>
</ul>
<p>And we‚Äôre done initing the PLIC at startup!</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers3.jpg" alt="Enable Interrupt" /></p>
<h1 id="enable-the-interrupt"><a href="#enable-the-interrupt">4 Enable the Interrupt</a></h1>
<p><em>Our Platform-Level Interrupt Controller (PLIC) is all ready for action‚Ä¶</em></p>
<p><em>How will we enable Interrupts in PLIC?</em></p>
<p>Suppose we‚Äôre enabling <strong>RISC-V IRQ 20</strong> for UART3 Interrupt.</p>
<p>All we need to do is to flip <strong>Bit 20</strong> to 1 in the <strong>Interrupt Enable</strong> Register (pic above). Like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L158-L208">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable the NuttX IRQ specified by `irq`
// UART3 Interrupt is RISC-V IRQ 20
// Which is NuttX IRQ 45 (Offset by 25)
void up_enable_irq(int irq) {

  // Omitted: Enable Inter-CPU Interrupts (SIE Register)
  // Omitted: Enable Timer Interrupts (TIE Register)

  // If this is an External Interrupt...
  if (irq &gt; RISCV_IRQ_EXT) {

    // Subtract 25 from NuttX IRQ to get the RISC-V IRQ
    int extirq = irq - RISCV_IRQ_EXT;

    // Set the Interrupt Enable Bit for `extirq` in PLIC
    // PLIC_ENABLE1 is 0xE000_2080
    // PLIC_ENABLE2 is 0xE000_2084
    if (0 &lt;= extirq &amp;&amp; extirq &lt;= 63) {
      modifyreg32(
        PLIC_ENABLE1 + (4 * (extirq / 32)),  // Address
        0,  // Clear Bits
        1 &lt;&lt; (extirq % 32)  // Set Bits
      );
    }
    else { PANIC(); }  // IRQ not supported (for now)
  }
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_modifyreg32.c#L37-L57">(<strong>modifyreg32</strong> is here)</a></p>
<p>And PLIC will happily accept RISC-V IRQ 20 whenever we press a key!</p>
<p>(On the Serial Console, pic above)</p>
<p><em>Who calls up_enable_irq?</em></p>
<p>At startup, NuttX calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L383-L442"><strong>bl602_attach</strong></a> to attach the UART Interrupt Handler‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Attach UART Interrupt Handler
static int bl602_attach(struct uart_dev_s *dev) {
  ...
  // Enable Interrupt for UART3.
  // `irq` is NuttX IRQ 45
  up_enable_irq(priv-&gt;irq);
</code></pre></div>
<p>Which will call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L158-L208"><strong>up_enable_irq</strong></a> to enable the UART3 Interrupt.</p>
<p>We‚Äôre halfway through our Grand Plan of <strong>PLIC Interrupts</strong>! (Steps 1, 2 and 3, pic below)</p>
<p>We pause a moment to talk about Harts‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="Registers for Platform-Level Interrupt Controller" /></p>
<h1 id="hart-0-supervisor-mode"><a href="#hart-0-supervisor-mode">5 Hart 0, Supervisor Mode</a></h1>
<p><em>The pic above: Why does it say ‚ÄúHart 0, Supervisor Mode‚Äù?</em></p>
<p><strong>‚ÄúHart‚Äù</strong> is a RISC-V CPU Core.</p>
<p>(‚ÄúHardware Thread‚Äù)</p>
<p><strong>‚ÄúHart 0‚Äù</strong> refers to the (one and only) <strong>64-bit RISC-V Core</strong> inside the BL808 SoC‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808a.jpg" alt="Inside the BL808 SoC" /></p>
<p>That runs our NuttX RTOS.</p>
<p><em>Does the Hart Number matter?</em></p>
<p>Most certainly! Inside the <strong>StarFive JH7110 SoC</strong> (for Star64 SBC), there are <strong>5 Harts</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808b.jpg" alt="Inside the StarFive JH7110" /></p>
<p>NuttX boots on <strong>Hart 1</strong>. So the PLIC Settings will use Hart 1. (Not Hart 0)</p>
<p>And the <strong>PLIC Register Offsets</strong> are different for Hart 0 vs Hart 1. Thus the Hart Number really matters!</p>
<p><em>Why ‚ÄúSupervisor Mode‚Äù?</em></p>
<ol>
<li>
<p><strong>RISC-V Machine Mode</strong> is the most powerful mode in our RISC-V SBC.</p>
<p><a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI Supervisor Binary Interface</strong></a> runs in Machine Mode.</p>
<p>(It‚Äôs like BIOS for RISC-V)</p>
</li>
<li>
<p><strong>RISC-V Supervisor Mode</strong> is less powerful than Machine Mode.</p>
<p><a href="https://lupyuen.github.io/articles/ox2"><strong>NuttX Kernel</strong></a> runs in Supervisor Mode.</p>
<p>(Linux too!)</p>
</li>
<li>
<p><strong>RISC-V User Mode</strong> is the least powerful mode.</p>
<p><a href="https://lupyuen.github.io/articles/app"><strong>NuttX Apps</strong></a> run in User Mode.</p>
<p>(Same for Linux Apps)</p>
</li>
</ol>
<p>PLIC has a different set of registers for Machine Mode vs Supervisor Mode.</p>
<p>That‚Äôs why we specify <strong>Supervisor Mode</strong> for the PLIC Registers.</p>
<p><em>What about the registers WITHOUT ‚ÄúHart 0, Supervisor Mode‚Äù?</em></p>
<p>These are the <strong>Common PLIC Registers</strong>, shared across all Harts and RISC-V Modes.</p>
<p>Heading back to our (interrupted) story‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers4.jpg" alt="Handle Interrupt" /></p>
<h1 id="handle-the-interrupt"><a href="#handle-the-interrupt">6 Handle the Interrupt</a></h1>
<p><em>What happens when we press a key on the Serial Console? (Pic above)</em></p>
<p><em>How will PLIC handle the UART Interrupt?</em></p>
<p>This is how we <strong>handle an Interrupt</strong> with the Platform-Level Interrupt Controller (PLIC)‚Ä¶</p>
<ol>
<li>
<p><strong>Claim</strong> the Interrupt</p>
<p>(To acknowledge the Interrupt)</p>
</li>
<li>
<p><strong>Dispatch</strong> the Interrupt</p>
<p>(Call the Interrupt Handler)</p>
</li>
<li>
<p><strong>Complete</strong> the Interrupt</p>
<p>(Tell PLIC we‚Äôre done)</p>
</li>
<li>
<p>Optional: Inspect and reset the <strong>Pending Interrupts</strong></p>
<p>(In case we‚Äôre really curious)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/plic2-registers5.jpg" alt="Interrupt Claim Register" /></p>
<h2 id="claim-the-interrupt"><a href="#claim-the-interrupt">6.1 Claim the Interrupt</a></h2>
<p><em>How will we know which RISC-V Interrupt has been fired?</em></p>
<p>That‚Äôs why we have the <strong>Interrupt Claim</strong> Register! (Pic above)</p>
<p>We read the Interrupt Claim Register to get the <strong>RISC-V IRQ Number</strong> that has been fired (20 for UART3): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L76">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Dispatch the RISC-V Interrupt
void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs) {

  // Compute the (Interim) NuttX IRQ Number
  // Based on the Interrupt Vector Number
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);

  // If this is an External Interrupt...
  if (RISCV_IRQ_EXT == irq) {

    // Read the RISC-V IRQ Number
    // From PLIC Claim Register
    // Which also Claims the Interrupt
    // PLIC_CLAIM is 0xE020_1004
    uintptr_t val = getreg32(PLIC_CLAIM);

    // Compute the Actual NuttX IRQ Number:
    // RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)
    irq += val;
  }
  // For UART3: `val` is 20 and `irq` is 45
  // Up Next: Dispatch and Complete the Interrupt
</code></pre></div>
<p><em>What exactly are we ‚Äúclaiming‚Äù?</em></p>
<p>When we <a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#interrupt-claims"><strong>Claim an Interrupt</strong></a> (by reading the Interrupt Claim Register)‚Ä¶</p>
<p>We‚Äôre telling the PLIC: ‚ÄúYes we <strong>acknowledge the Interrupt</strong>, but we‚Äôre not done yet!‚Äù</p>
<p>In a while we shall Complete the Interrupt. (To tell PLIC we‚Äôre done)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_exception_common.S#L63-L177">(<strong>riscv_dispatch_irq</strong> is called by the RISC-V Common Exception Handler)</a></p>
<h2 id="dispatch-the-interrupt"><a href="#dispatch-the-interrupt">6.2 Dispatch the Interrupt</a></h2>
<p>We have Claimed the Interrupt. It‚Äôs time to do some work: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L76-L85">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Omitted: Claim the Interrupt
  ...
  // Remember: `irq` is now the ACTUAL NuttX IRQ Number:
  // RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)
  // For UART3: `irq` is 45

  // If the RISC-V IRQ Number is valid (non-zero)...
  if (RISCV_IRQ_EXT != irq) {

    // Call the Interrupt Handler
    regs = riscv_doirq(irq, regs);
  }
  // Up Next: Complete the Interrupt
</code></pre></div>
<p>For UART Interrupts: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_doirq.c#L58-L134"><strong>riscv_doirq</strong></a> will call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L285-L343"><strong>uart_interrupt</strong></a> to handle the keypress.</p>
<p>(That‚Äôs because at startup, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L383-L442"><strong>bl602_attach</strong></a> has registered <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L285-L343"><strong>uart_interrupt</strong></a> as the UART Interrupt Handler)</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5.jpg" alt="Interrupt Claim Register" /></p>
<h2 id="complete-the-interrupt"><a href="#complete-the-interrupt">6.3 Complete the Interrupt</a></h2>
<p>To tell PLIC we‚Äôre done, we write the RISC-V IRQ Number (20) back to the <strong>Interrupt Claim</strong> Register.</p>
<p>(Yep the same one we read earlier! Pic above)</p>
<p>This will <a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#interrupt-completion"><strong>Complete the Interrupt</strong></a>, so PLIC can fire the next one: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L85-L105">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Omitted: Claim and Dispatch the Interrupt
  ...
  // Remember: `irq` is now the ACTUAL NuttX IRQ Number:
  // RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)
  // For UART3: `irq` is 45

  // If this is an External Interrupt (RISCV_IRQ_EXT = 25)...
  if (RISCV_IRQ_EXT &lt;= irq) {

    // Compute the RISC-V IRQ Number (20 for UART3)
    // and Complete the Interrupt.
    // PLIC_CLAIM is 0xE020_1004
    putreg32(               // We write the...
      irq - RISCV_IRQ_EXT,  // RISC-V IRQ Number (RISCV_IRQ_EXT = 25)
      PLIC_CLAIM            // To PLIC Claim (Complete) Register
    );
  }

  // Return the Registers to the Caller
  return regs;
}
</code></pre></div>
<p>And that‚Äôs how we handle a PLIC Interrupt!</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers6.jpg" alt="Interrupt Pending Register" /></p>
<h2 id="pending-interrupts"><a href="#pending-interrupts">6.4 Pending Interrupts</a></h2>
<p><em>What‚Äôs with the Pending Interrupts?</em></p>
<p>Normally the Interrupt Claim Register is perfectly adequate for handling Interrupts.</p>
<p>But if we‚Äôre really curious: PLIC has an <strong>Interrupt Pending</strong> Register (pic above) that will tell us which Interrupts are awaiting Claiming or Completion: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L62-L71">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Check the Pending Interrupts...
// Read PLIC_IP0: Interrupt Pending for interrupts 1 to 31
uintptr_t ip0 = getreg32(0xe0001000);

// If Bit 20 is set...
if (ip0 &amp; (1 &lt;&lt; 20)) {
  // Then UART3 Interrupt was fired (RISC-V IRQ 20)
  val = 20;
}
</code></pre></div>
<p>To tell PLIC we‚Äôre done: We <strong>clear the Individual Bits</strong> in the Interrupt Pending Register: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L94-L101">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Clear the Pending Interrupts...
// Set PLIC_IP0: Interrupt Pending for interrupts 1 to 31
putreg32(0, 0xe0001000);

// TODO: Clear the Individual Bits instead of wiping out the Entire Register
</code></pre></div>
<p>Once again, we don‚Äôt need really need this. We‚Äôll stash this as our <strong>Backup Plan</strong> in case things go wrong.</p>
<p>(Oh yes, things will go wrong in a while)</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers1.jpg" alt="Set Interrupt Priority" /></p>
<h1 id="trouble-with-interrupt-priority"><a href="#trouble-with-interrupt-priority">7 Trouble with Interrupt Priority</a></h1>
<p><em>I sense a twist in our story‚Ä¶</em></p>
<p>Earlier we initialised the <a href="https://lupyuen.github.io/articles/plic2#set-the-interrupt-priority"><strong>Interrupt Priorities to 1</strong></a> at startup (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq.c#L75C1-L90">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the Platform-Level Interrupt Controller
void up_irqinitialize(void) {
  ...
  // Set Priority for all External Interrupts to 1 (Lowest)
  // NR_IRQS is 83 (TODO: BL808 only supports 82 Peripheral Interrupts)
  // PLIC_PRIORITY is 0xE000_0000
  for (int id = 1; id &lt;= NR_IRQS; id++) {
    putreg32(
      1,  // Value
      (uintptr_t)(PLIC_PRIORITY + 4 * id)  // Address
    );
  }

  // Dump the Interrupt Priorities
  infodumpbuffer(&quot;PLIC Interrupt Priority: After&quot;, 0xe0000004, 0x50 * 4);
</code></pre></div>
<p>When we <a href="https://lupyuen.github.io/articles/plic2#appendix-build-and-run-nuttx"><strong>boot NuttX on Ox64</strong></a>, something strange happens‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>PLIC Interrupt Priority: After (0xe0000004):
0000  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L152-L172">(See the <strong>Complete Log</strong>)</a></p>
<p><em>Everything becomes zero! Why???</em></p>
<p>Yeah this is totally baffling! And no Interrupts get fired, because <strong>Interrupt Priority 0 is NOT valid</strong>.</p>
<p>Let‚Äôs set the Interrupt Priority specifically for <strong>RISC-V IRQ 20</strong> (UART3 Interrupt): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L444-L465">bl602_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Test the setting of PLIC Interrupt Priority
// For RISC-V IRQ 20 only
void test_interrupt_priority(void) {
  // Read the values before setting Interrupt Priority
  uint32_t before50 = *(volatile uint32_t *) 0xe0000050UL;  // RISC-V IRQ 20
  uint32_t before54 = *(volatile uint32_t *) 0xe0000054UL;  // RISC-V IRQ 21

  // Set the Interrupt Priority
  // for 0x50 (IRQ 20) but NOT 0x54 (IRQ 21)
  *(volatile uint32_t *) 0xe0000050UL = 1;

  // Read the values after setting Interrupt Priority
  uint32_t after50 = *(volatile uint32_t *) 0xe0000050UL;  // RISC-V IRQ 20
  uint32_t after54 = *(volatile uint32_t *) 0xe0000054UL;  // RISC-V IRQ 21

  // Dump before and after values:
  _info(&quot;before50=%u, before54=%u, after50=%u, after54=%u\n&quot;,
    before50, before54, after50, after54);
}
</code></pre></div>
<p>Again we get odd results (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>before50=0, before54=0
after50=1,  after54=1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L258-L260">(See the <strong>Complete Log</strong>)</a></p>
<p>IRQ 20 is set correctly: <em>‚Äúafter50=1‚Äù</em></p>
<p>However <strong>IRQ 21 is also set</strong>! <em>‚Äúafter54=1‚Äù</em></p>
<p><em>Hmmm‚Ä¶ Our writing seems to have leaked over to the next 32-bit word?</em></p>
<p>Yeah we see the <strong>Leaky Write</strong> again when we set the <a href="https://lupyuen.github.io/articles/plic2#enable-the-interrupt"><strong>Interrupt Enable</strong></a> Register‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// Before setting Interrupt Enable: Everything is 0
PLIC Hart 0 S-Mode Interrupt Enable: Before (0xe0002080):
0000  00 00 00 00 00 00 00 00                          ........        

// Set Interrupt Enable for RISC-V IRQ 20 (Bit 20)
up_enable_irq: extirq=20, addr=0xe0002080, val=0x1048576

// After setting Interrupt Enable:
// Bit 20 is also set in the next word!
PLIC Hart 0 S-Mode Interrupt Enable: After (0xe0002080):
0000  00 00 10 00 00 00 10 00                          ........  
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L196-L200">(See the <strong>Complete Log</strong>)</a></p>
<p>Interrupt Enable has leaked over from <strong><code>0xE000</code> <code>2080</code></strong> to <strong><code>0xE000</code> <code>2084</code></strong>!</p>
<p>Thus we have an unexplained problem of <strong>Leaky Writes</strong>, affecting the Interrupt Priority and Interrupt Enable Registers.</p>
<p>Up Next: More worries‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-title.jpg" alt="Leaky Write for PLIC Interrupt Priority" /></p>
<h1 id="more-trouble-with-interrupt-claim"><a href="#more-trouble-with-interrupt-claim">8 More Trouble with Interrupt Claim</a></h1>
<p>We talked earlier about <a href="https://lupyuen.github.io/articles/plic2#handle-the-interrupt"><strong>Handling Interrupts</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers5.jpg" alt="Claim Interrupt" /></p>
<p>And how we fetch the <strong>RISC-V IRQ Number</strong> from the <a href="https://lupyuen.github.io/articles/plic2#claim-the-interrupt"><strong>Interrupt Claim</strong></a> Register: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L62">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Dispatch the RISC-V Interrupt
void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs) {

  // Compute the (Interim) NuttX IRQ Number
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);

  // If this is an External Interrupt...
  if (RISCV_IRQ_EXT == irq) {

    // Read the RISC-V IRQ Number
    // From PLIC Claim Register
    // Which also Claims the Interrupt
    // PLIC_CLAIM is 0xE020_1004
    uintptr_t val = getreg32(PLIC_CLAIM);
</code></pre></div>
<p><em>What happens when we run this?</em></p>
<p>On Ox64 we see NuttX booting normally to the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.0.3
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L294-L325">(See the <strong>Complete Log</strong>)</a></p>
<p>When we <strong>press a key</strong> on the Serial Console (to trigger a UART Interrupt)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_dispatch_irq:
  claim=0
</code></pre></div>
<p>Our Interrupt Handler says that the <strong>Interrupt Claim Register is 0</strong>‚Ä¶</p>
<p>Which means we can‚Äôt read the <strong>RISC-V IRQ Number</strong>!</p>
<p>We activate our Backup Plan‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers6.jpg" alt="Pending Interrupts" /></p>
<h1 id="backup-plan"><a href="#backup-plan">9 Backup Plan</a></h1>
<p><em>What‚Äôs our Backup Plan for Handling Interrupts?</em></p>
<p>We can get the RISC-V IRQ Number by reading the <a href="https://lupyuen.github.io/articles/plic2#pending-interrupts"><strong>Interrupt Pending</strong></a> Register (pic above): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L62-L76">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// If Interrupt Claimed is 0...
if (val == 0) {
  // Check the Pending Interrupts...
  // Read PLIC_IP0: Interrupt Pending for interrupts 1 to 31
  uintptr_t ip0 = getreg32(0xe0001000);

  // If Bit 20 is set...
  if (ip0 &amp; (1 &lt;&lt; 20)) {
    // Then UART3 Interrupt was fired (RISC-V IRQ 20)
    val = 20;
  }
}

// Compute the Actual NuttX IRQ Number:
// RISC-V IRQ Number + 25 (RISCV_IRQ_EXT)
irq += val;

// Omitted: Call the Interrupt Handler
// and Complete the Interrupt
</code></pre></div>
<p>Which tells us the correct <strong>RISC-V IRQ Number</strong> for UART3 yay!</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_dispatch_irq:
  irq=45
</code></pre></div>
<p>(<strong>NuttX IRQ 45</strong> means <strong>RISC-V IRQ 20</strong>)</p>
<p>Don‚Äôt forget to <strong>clear the Pending Interrupts</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L94-L101">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Clear the Pending Interrupts
// TODO: Clear the Individual Bits instead of wiping out the Entire Register
putreg32(0, 0xe0001000);  // PLIC_IP0: Interrupt Pending for interrupts 1 to 31
putreg32(0, 0xe0001004);  // PLIC_IP1: Interrupt Pending for interrupts 32 to 63

// Dump the Pending Interrupts
infodumpbuffer(&quot;PLIC Interrupt Pending&quot;, 0xe0001000, 2 * 4);

// Yep works great, Pending Interrupts have been cleared...
// PLIC Interrupt Pending (0xe0001000):
// 0000  00 00 00 00 00 00 00 00                          ........        
</code></pre></div>
<p><em>Does it work for UART Input?</em></p>
<p>Since we‚Äôve correctly identified the IRQ Number, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_irq_dispatch.c#L48-L105"><strong>riscv_dispatch_irq</strong></a> will (eventually) call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L859-L904"><strong>bl602_receive</strong></a> to read the UART Input (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_receive: rxdata=-1
bl602_receive: rxdata=0x0
</code></pre></div>
<p>But the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L892-L901"><strong>UART Input is empty</strong></a>! We need to troubleshoot our UART Driver some more.</p>
<p>Meanwhile we wrap up our story for today‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L294-L325">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://youtu.be/VSTpsSJ_7L0">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/ox64b-1">(See the <strong>Build Outputs</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic2-run.png" alt="NuttX boots OK on Ox64 BL808! But UART Input is null" /></p>
<h1 id="all-things-considered"><a href="#all-things-considered">10 All Things Considered</a></h1>
<p><em>Feels like we‚Äôre wading into murky greyish territory‚Ä¶ Like Jaws meets Twilight Zone on the Beach?</em></p>
<p>Yeah we said this <a href="https://lupyuen.github.io/articles/ox2#begin-with-star64-nuttx"><strong>last time</strong></a>, and it‚Äôs happening now‚Ä¶</p>
<blockquote>
<p><em>‚ÄúIf RISC-V ain‚Äôt RISC-V on SiFive vs T-Head: We‚Äôll find out!‚Äù</em></p>
</blockquote>
<p>The PLIC Code in this article was <strong>originally tested OK</strong> with‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/plic"><strong>StarFive JH7110 SoC</strong></a> in RISC-V Supervisor Mode</p>
<p>(Based on SiFive U74 Core)</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/c906/c906_irq.c"><strong>T-Head C906 Core</strong></a> in RISC-V Machine Mode</p>
<p>(Ox64 BL808 runs on the C906 Core)</p>
</li>
<li>
<p>But NOT <strong>T-Head C906</strong> in <strong>RISC-V Supervisor Mode</strong></p>
<p>(Which might explain our troubles)</p>
</li>
</ul>
<p>Today we‚Äôre hitting 2 Strange Issues in the <strong>BL808 (C906) PLIC</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#trouble-with-interrupt-priority"><strong>Leaky Writes</strong></a> to PLIC Registers</p>
<p>(Writing to one register will affect the next)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#more-trouble-with-interrupt-claim"><strong>PLIC Claim Register</strong></a> always reads as 0</p>
<p>(Instead of RISC-V External Interrupt Number)</p>
</li>
</ul>
<p>Which shouldn‚Äôt happen because PLIC is in the <a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#plic"><strong>Official RISC-V Spec</strong></a>! So many questions‚Ä¶</p>
<ol>
<li>
<p><em>Any clue what‚Äôs causing this?</em></p>
<p><strong>Leaky Writes</strong> don‚Äôt seem to happen <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L282-L298"><strong>before enabling the MMU</strong></a> (Memory Management Unit)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// Before enabling Memory Mgmt Unit...
jh7110_mm_init: Test Interrupt Priority

// No Leaky Writes!
test_interrupt_priority:
  before50=0, before54=0
  after50=1,  after54=0

// Leaky Writes after enabling Memory Mgmt Unit
jh7110_kernel_mppings: map I/O regions
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L118-L120">(See the <strong>Complete Log</strong>)</a></p>
<p>So it might be a problem with our MMU Settings.</p>
<p><a href="https://lupyuen.github.io/articles/mmu">(More about <strong>Memory Management Unit</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#strangeness-in-ox64-bl808-plic">(<strong>U-Boot Bootloader</strong> doesn‚Äôt have Leaky Writes)</a></p>
</li>
<li>
<p><em>What if we configure the MMU differently?</em></p>
<p>We moved the PLIC from <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L249-L258"><strong>Level 2 Page Tables</strong></a> up to <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L240-L245"><strong>Level 1</strong></a>‚Ä¶</p>
<p>Same problem.</p>
</li>
<li>
<p><em>Something special about the C906 MMU?</em></p>
<p>According to the <a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf"><strong>C906 User Manual</strong></a> (Page 53), the C906 MMU supports <strong>Extended Page Attributes</strong>.</p>
<p>Is the <strong>MMU Caching</strong> causing issues? What‚Äôs ‚Äú<strong>sysmap.h</strong>‚Äù?</p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#strangeness-in-ox64-bl808-plic">(More about <strong>C906 Extended Page Attributes</strong>)</a></p>
</li>
<li>
<p><em>What about the C906 PLIC?</em></p>
<p>According to the <a href="https://lore.kernel.org/lkml/CAJF2gTS8Z+6Ewy0D5+0X_h2Jz4BqsJp7wEC5F0iNaDsSpiE2aw@mail.gmail.com/"><strong>Linux PLIC Driver</strong></a>‚Ä¶</p>
<p>‚ÄúThe T-HEAD C9xx SoC implements a modified/custom T-HEAD PLIC
specification which will mask current IRQ upon read to CLAIM register
and will unmask the IRQ upon write to CLAIM register‚Äù</p>
<p>Will this affect our Interrupt Claim?</p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#uart-interrupt-for-ox64-bl808">(More about <strong>C906 PLIC</strong>)</a></p>
</li>
<li>
<p><em>Maybe the GCC Compiler didn‚Äôt generate the right code?</em></p>
<p>We wrote <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L487-L531"><strong>RISC-V Assembly</strong></a>, disabling <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L531-L608"><strong>DCACHE / ICACHE</strong></a> and with <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e76886a665fb9b8fe4f52c25e2f80877a62f415c/arch/risc-v/src/jh7110/bl602_serial.c#L446-L489"><strong>SFENCE</strong></a>.</p>
<p>Still the same.</p>
</li>
<li>
<p><em>Perhaps our problem is Leaky Reads? Not Leaky Writes?</em></p>
<p>Hmmm‚Ä¶ Perhaps!</p>
</li>
</ol>
<p>Can we rewrite our Sad Story with a Happier Conclusion? Please lemme know! üôè</p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)" /></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>Today we talked about <strong>Interrupting Chicken, Oxen</strong> and <strong>Ox64 BL808 RISC-V SBC</strong>‚Ä¶</p>
<ul>
<li>
<p>We looked inside the <strong>Platform-Level Interrupt Controller</strong> (PLIC)</p>
</li>
<li>
<p>And <strong>set up the PLIC</strong> at startup</p>
</li>
<li>
<p>We <strong>enabled the PLIC Interrupt</strong> for Serial Console</p>
</li>
<li>
<p>Also <strong>handled PLIC Interrupts</strong> for UART Input</p>
</li>
<li>
<p>But we hit some <strong>Leaky Writes</strong> that affects adjacent PLIC Registers</p>
</li>
<li>
<p>Sadly <strong>Interrupt Claim</strong> doesn‚Äôt work as expected</p>
</li>
<li>
<p>Thus we activated our Backup Plan with the <strong>Interrupt Pending</strong> Register</p>
</li>
</ul>
<p>Plenty to fix for <strong>NuttX on Ox64 BL808</strong>. Stay tuned for updates!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/plic2.md"><strong>lupyuen.github.io/src/plic2.md</strong></a></p>
<h1 id="appendix-uart-driver-for-ox64"><a href="#appendix-uart-driver-for-ox64">12 Appendix: UART Driver for Ox64</a></h1>
<p><em>How did we create the NuttX UART Driver for Ox64 BL808?</em></p>
<p>Today NuttX supports the 32-bit predecessor of BL808: <a href="https://github.com/apache/nuttx/tree/master/arch/risc-v/src/bl602"><strong>Bouffalo Lab BL602</strong></a>.</p>
<p>When we compare these UARTs‚Ä¶</p>
<ul>
<li>
<p><strong>BL808 UART Controller</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>BL808 Reference Manual</strong>, Page 402)</a></p>
</li>
<li>
<p><strong>BL602 UART Controller</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf">(<strong>BL602 Reference Manual</strong>, Page 126)</a></p>
</li>
</ul>
<p>We discover that BL808 UART works the <strong>same way as BL602</strong>!</p>
<p>Thus we‚Äôll simply copy the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c"><strong>NuttX Driver for BL602 UART</strong></a> to Ox64.</p>
<p>Here‚Äôs the UART Driver <strong>ported to BL808</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c">bl602_serial.c</a></p>
<p><em>What did we change?</em></p>
<p>We hardcoded the <strong>UART3 Base Address</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/hardware/bl602_uart.h#L30-L41">bl602_uart.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// UART3 Base Address
#define BL602_UART0_BASE   0x30002000
#define BL602_UART_BASE(n) (BL602_UART0_BASE)
</code></pre></div>
<p>Then we set the <strong>UART3 Interrupt Number</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/bl602_serial.c#L169-L175">bl602_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// From BL808 Manual: UART3 Interrupt = (IRQ_NUM_BASE + 4)
// Where IRQ_NUM_BASE = 16
// So RISC-V IRQ = 20
// And NuttX IRQ = 45 (Offset by 25)
#define BL602_IRQ_UART0 45
</code></pre></div>
<p>And we modified the <strong>NuttX Start Code</strong> to call our new UART Driver: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/jh7110/jh7110_start.c#L175-L184">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At Startup, init the new UART Driver
void riscv_earlyserialinit(void) {
  bl602_earlyserialinit();
}

// Same here
void riscv_serialinit(void) {
  bl602_serialinit();
}
</code></pre></div>
<p>After making these changes, the UART Driver works OK for printing output to the Ox64 Serial Console!</p>
<p>(But not yet for UART Input, pic below)</p>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L112-L325">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://youtu.be/VSTpsSJ_7L0">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic2-run.png" alt="NuttX boots OK on Ox64 BL808! But UART Input is null" /></p>
<h1 id="appendix-build-and-run-nuttx"><a href="#appendix-build-and-run-nuttx">13 Appendix: Build and Run NuttX</a></h1>
<p>In this article, we ran a Work-In-Progress Version of <strong>Apache NuttX RTOS for Ox64</strong>, with PLIC partially working.</p>
<p>(Console Input is not yet fixed)</p>
<p>This is how we download and build NuttX for Ox64 BL808 SBC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch ox64b \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch ox64b \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Build NuttX
cd nuttx
tools/configure.sh star64:nsh
make

## Export the NuttX Kernel
## to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu">(And enable <strong>Scheduler Info Output</strong>)</a></p>
<p>Then we build the <strong>Initial RAM Disk</strong> that contains NuttX Shell and NuttX Apps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build the Apps Filesystem
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd

## Generate the Initial RAM Disk `initrd`
## in ROMFS Filesystem Format
## from the Apps Filesystem `../apps/bin`
## and label it `NuttXBootVol`
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &quot;NuttXBootVol&quot;

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.zero

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.zero initrd \
  &gt;Image
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/ox64b-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/ox64b-1">(See the <strong>Build Outputs</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/app#pad-the-initial-ram-disk">(Why the <strong>64 KB Padding</strong>)</a></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot">(Remember to flash <strong>OpenSBI and U-Boot Bootloader</strong>)</a></p>
<p>Then we do the <a href="https://lupyuen.github.io/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Overwrite the microSD Linux Image by the <strong>NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Overwrite the Linux Image
## on Ox64 microSD
cp Image \
  &quot;/Volumes/NO NAME/Image&quot;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <a href="https://lupyuen.github.io/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
<p>Ox64 boots <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI</strong></a>, which starts <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>, which starts <strong>NuttX Kernel</strong> and the NuttX Shell (NSH).</p>
<p><em>What happens when we press a key?</em></p>
<p>NuttX will respond to our keypress. (Because we configured the PLIC)</p>
<p>But the UART Input reads as null right now. (Pic above)</p>
<p><a href="https://gist.github.com/lupyuen/cf32c834f4f5b8f66715ee4c606b7580#file-ox64-nuttx-int-clear-pending2-log-L112-L325">(See the <strong>NuttX Log</strong>)</a></p>
<p><a href="https://youtu.be/VSTpsSJ_7L0">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/ox64b-1">(See the <strong>Build Outputs</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic2-draw.jpg" alt="Drawing the Platform-Level Interrupt Controller for Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>

    
</body>
</html>