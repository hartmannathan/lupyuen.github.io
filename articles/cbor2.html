<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Encode Sensor Data with CBOR on Apache NuttX OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Encode Sensor Data with CBOR on Apache NuttX OS" 
    data-rh="true">
<meta property="og:description" 
    content="Compressing Sensor Data with CBOR on Apache NuttX OS... By calling TinyCBOR Library"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/cbor2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Encode Sensor Data with CBOR on Apache NuttX OS</h1>
    <nav id="TOC"><ul>
<li><a href="#encode-sensor-data-with-tinycbor">1 Encode Sensor Data with TinyCBOR</a><ul>
<li><a href="#output-buffer-and-cbor-encoder">1.1 Output Buffer and CBOR Encoder</a><ul></ul></li>
<li><a href="#create-map-encoder">1.2 Create Map Encoder</a><ul></ul></li>
<li><a href="#encode-key-and-value">1.3 Encode Key and Value</a><ul></ul></li>
<li><a href="#close-map-encoder">1.4 Close Map Encoder</a><ul></ul></li>
<li><a href="#get-encoded-output">1.5 Get Encoded Output</a><ul></ul></li>
<li><a href="#download-source-code">1.6 Download Source Code</a><ul></ul></li>
<li><a href="#build-the-firmware">1.7 Build The Firmware</a><ul></ul></li>
<li><a href="#magic-happens">1.8 Magic Happens</a><ul></ul></li></ul></li>
<li><a href="#add-another-field">2 Add Another Field</a><ul>
<li><a href="#modify-map-encoder">2.1 Modify Map Encoder</a><ul></ul></li>
<li><a href="#encode-first-key-and-value">2.2 Encode First Key and Value</a><ul></ul></li>
<li><a href="#encode-second-key-and-value">2.3 Encode Second Key and Value</a><ul></ul></li>
<li><a href="#watch-the-magic">2.4 Watch the Magic</a><ul></ul></li></ul></li>
<li><a href="#cbor-data-types">3 CBOR Data Types</a><ul>
<li><a href="#numbers">3.1 Numbers</a><ul></ul></li>
<li><a href="#strings">3.2 Strings</a><ul></ul></li>
<li><a href="#other-types">3.3 Other Types</a><ul></ul></li></ul></li>
<li><a href="#floating-point-numbers">4 Floating-Point Numbers</a><ul>
<li><a href="#encode-floats-as-integers">4.1 Encode Floats as Integers</a><ul></ul></li>
<li><a href="#accuracy-and-precision">4.2 Accuracy and Precision</a><ul></ul></li></ul></li>
<li><a href="#decode-cbor">5 Decode CBOR</a><ul></ul></li>
<li><a href="#whats-next">6 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">7 Notes</a><ul></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">8 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#build-nuttx">8.1 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx">8.2 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx">8.3 Run NuttX</a><ul></ul></li></ul></li>
<li><a href="#appendix-porting-tinycbor-to-nuttx">9 Appendix: Porting TinyCBOR to NuttX</a><ul></ul></li></ul></nav><p>üìù <em>10 Jan 2022</em></p>
<p>Suppose we‚Äôre creating an IoT Gadget with <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX OS</strong></a> that transmits <strong>Sensor Data</strong> from two sensors: <strong>Temperature Sensor and Light Sensor</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234, 
  &quot;l&quot;: 2345 
}
</code></pre></div>
<p>(Located in a Greenhouse perhaps)</p>
<p>And we‚Äôre transmitting over a <strong>low-power wireless network</strong> like LoRa, Zigbee or Bluetooth LE.</p>
<p>We could transmit <strong>19 bytes of JSON</strong>. But there‚Äôs a more compact way to do it‚Ä¶.</p>
<p><a href="https://en.wikipedia.org/wiki/CBOR"><strong>Concise Binary Object Representation (CBOR)</strong></a>, which works like a binary, compressed form of JSON.</p>
<p>And we need only <strong>11 bytes of CBOR</strong>!</p>
<p><img src="https://lupyuen.github.io/images/cbor2-title.jpg" alt="Encoding Sensor Data with CBOR" /></p>
<p>Today we‚Äôll learn to encode Sensor Data with the <strong>TinyCBOR Library</strong> that we have ported to Apache NuttX OS‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/tinycbor-nuttx"><strong>lupyuen2/tinycbor-nuttx</strong></a></li>
</ul>
<p>The library has been tested on <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a>, but it should work on <strong>any NuttX Platform</strong> (like ESP32)</p>
<p><a href="https://lupyuen.github.io/articles/cbor2#appendix-porting-tinycbor-to-nuttx">(<strong>tinycbor-nuttx</strong> is a fork of TinyCBOR with minimal changes)</a></p>
<p><em>Must we scrimp and save every single byte?</em></p>
<p>Yes, <strong>every single byte matters</strong> for low-power wireless networks!</p>
<ol>
<li>
<p>Low-power wireless networks operate on Radio Frequency Bands that are <strong>shared with many other gadgets</strong>.</p>
<p>They are prone to <strong>collisions and interference</strong>.</p>
<p>The <strong>smaller the data packet</strong>, the higher the chance that it will be <strong>transmitted successfully</strong>!</p>
</li>
<li>
<p>When we transmit LoRa packets to <strong>The Things Network</strong> (the free public global LoRa network), we‚Äôre limited by their <a href="https://lupyuen.github.io/articles/ttn#fair-use-of-the-things-network"><strong>Fair Use Policy</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ttn#fair-use-of-the-things-network">(Roughly <strong>12 bytes</strong> per message, assuming 10 messages per hour)</a></p>
<p>JSON is too big for this. But CBOR works well!</p>
<p>(In the next article we‚Äôll watch the TinyCBOR Library in action for encoding Sensor Data in The Things Network)</p>
</li>
</ol>
<h1 id="encode-sensor-data-with-tinycbor"><a class="doc-anchor" href="#encode-sensor-data-with-tinycbor">¬ß</a>1 Encode Sensor Data with TinyCBOR</h1>
<p>We begin by encoding one data field into CBOR‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234
}
</code></pre></div>
<p>We call this a <strong>CBOR Map</strong> that maps a <strong>Key</strong> (‚Äú<code>t</code>‚Äù) to a <strong>Value</strong> (<code>1234</code>)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-map.png" alt="CBOR Map with 1 Key-Value Pair" /></p>
</blockquote>
<p>Let‚Äôs look at the code from our NuttX App that encodes the above into CBOR‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/tinycbor_test"><strong>lupyuen/tinycbor_test</strong></a></li>
</ul>
<h2 id="output-buffer-and-cbor-encoder"><a class="doc-anchor" href="#output-buffer-and-cbor-encoder">¬ß</a>1.1 Output Buffer and CBOR Encoder</h2>
<p>First we create an <strong>Output Buffer</strong> that will hold the encoded CBOR data: <a href="https://github.com/lupyuen/tinycbor_test/blob/main/tinycbor_test_main.c#L22-L82">tinycbor_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &quot;../libs/libtinycbor/src/cbor.h&quot;  //  For TinyCBOR Library

/// Test CBOR Encoding for { &quot;t&quot;: 1234 }
static void test_cbor(void) {

  //  Max output size is 50 bytes (which fits in a LoRa packet)
  uint8_t output[50];
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/ttn#fair-use-of-the-things-network">(50 bytes is the max packet size for LoRaWAN AS923 Data Rate 2)</a></p>
<p><strong>Output Buffer Size</strong> is important: Calls to the <strong>TinyCBOR library will fail</strong> if we run out of buffer space!</p>
<p>Next we define the <strong>CBOR Encoder</strong> (from TinyCBOR) that will encode our data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Our CBOR Encoder and Map Encoder
  CborEncoder encoder, mapEncoder;
</code></pre></div>
<p>As well as the <strong>Map Encoder</strong> that will encode our CBOR Map.</p>
<p>We <strong>initialise the CBOR Encoder</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init our CBOR Encoder
  cbor_encoder_init(
    &amp;encoder,        //  CBOR Encoder
    output,          //  Output Buffer
    sizeof(output),  //  Output Buffer Size
    0                //  Options (always 0)
  );
</code></pre></div><h2 id="create-map-encoder"><a class="doc-anchor" href="#create-map-encoder">¬ß</a>1.2 Create Map Encoder</h2>
<p>Now we create the <strong>Map Encoder</strong> that will encode our CBOR Map‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Create a Map Encoder that maps keys to values
  CborError res = cbor_encoder_create_map(
    &amp;encoder,     //  CBOR Encoder
    &amp;mapEncoder,  //  Map Encoder
    1             //  Number of Key-Value Pairs
  );    
  assert(res == CborNoError);
</code></pre></div>
<p>The last parameter (<code>1</code>) is important: It must match the <strong>Number of Key-Value Pairs</strong> (like <code>"t": 1234</code>) that we shall encode.</p>
<h2 id="encode-key-and-value"><a class="doc-anchor" href="#encode-key-and-value">¬ß</a>1.3 Encode Key and Value</h2>
<p>We encode the <strong>Key</strong> (‚Äú<code>t</code>‚Äù) into the CBOR Map‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Key
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;t&quot;           //  Key
  );    
  assert(res == CborNoError);
</code></pre></div>
<p>Followed by the <strong>Value</strong> (<code>1234</code>)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    1234          //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p><strong>cbor_encode_int</strong> encodes <strong>64-bit Signed Integers</strong>.</p>
<p>(We‚Äôll look at other data types in a while)</p>
<h2 id="close-map-encoder"><a class="doc-anchor" href="#close-map-encoder">¬ß</a>1.4 Close Map Encoder</h2>
<p>We‚Äôre done with our CBOR Map, so we <strong>close the Map Encoder</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Close the Map Encoder
  res = cbor_encoder_close_container(
    &amp;encoder,    //  CBOR Encoder
    &amp;mapEncoder  //  Map Encoder
  );
  assert(res == CborNoError);
</code></pre></div>
<p>Our CBOR Encoding is complete!</p>
<h2 id="get-encoded-output"><a class="doc-anchor" href="#get-encoded-output">¬ß</a>1.5 Get Encoded Output</h2>
<p>To work with the Encoded CBOR Output, we need to know <strong>how many bytes</strong> have been encoded‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  How many bytes were encoded
  size_t output_len = cbor_encoder_get_buffer_size(
    &amp;encoder,  //  CBOR Encoder
    output     //  Output Buffer
  );
  printf(&quot;CBOR Output: %d bytes\n&quot;, output_len);
</code></pre></div>
<p>For the demo we <strong>dump the encoded CBOR data</strong> to the console‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Dump the encoded CBOR output (6 bytes):
  //  0xa1 0x61 0x74 0x19 0x04 0xd2
  for (int i = 0; i &lt; output_len; i++) {
    printf(&quot;  0x%02x\n&quot;, output[i]);
  }
}
</code></pre></div>
<p>And that‚Äôs how we call the TinyCBOR Library to work with CBOR data!</p>
<p>Let‚Äôs watch what happens when we run the firmware‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-code.png" alt="Calling the TinyCBOR Library" /></p>
</blockquote>
<h2 id="download-source-code"><a class="doc-anchor" href="#download-source-code">¬ß</a>1.6 Download Source Code</h2>
<p>To test CBOR Encoding on NuttX, download the modified source code for <strong>NuttX OS and NuttX Apps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive --branch cbor https://github.com/lupyuen/nuttx nuttx
git clone --recursive --branch cbor https://github.com/lupyuen/nuttx-apps apps
</code></pre></div>
<p>Or if we prefer to <strong>add TinyCBOR</strong> to our NuttX Project, follow these instructions‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/tinycbor-nuttx"><strong>‚ÄúInstall TinyCBOR Library‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tinycbor_test"><strong>‚ÄúInstall TinyCBOR Test App‚Äù</strong></a></p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features">(<strong>For PineDio Stack BL604:</strong> The TinyCBOR Library and Test App are already preinstalled)</a></p>
<h2 id="build-the-firmware"><a class="doc-anchor" href="#build-the-firmware">¬ß</a>1.7 Build The Firmware</h2>
<p>Let‚Äôs build the NuttX Firmware with TinyCBOR inside‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we have downloaded the <strong>NuttX Source Code</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/cbor2#download-source-code"><strong>‚ÄúDownload Source Code‚Äù</strong></a></p>
</li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Edit the Build Config
make menuconfig 
</code></pre></div></li>
<li>
<p>In menuconfig, check the box for‚Ä¶</p>
<p><strong>‚ÄúLibrary Routines‚Äù</strong> ‚Üí <strong>‚ÄúTinyCBOR Library‚Äù</strong></p>
</li>
<li>
<p>Check the box for‚Ä¶</p>
<p><strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong> ‚Üí <strong>‚ÄúTinyCBOR Test App‚Äù</strong></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/63393052eba1f347422ef24c589fb9f4">(See the .config for BL602 and BL604)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/cbor2#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
</ol>
<h2 id="magic-happens"><a class="doc-anchor" href="#magic-happens">¬ß</a>1.8 Magic Happens</h2>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>tinycbor_test
</code></pre></div>
<p>We‚Äôll see 6 bytes of <strong>Encoded CBOR Output</strong> for ‚Äútest_cbor‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>test_cbor: Encoding { &quot;t&quot;: 1234 }
CBOR Output: 6 bytes
  0xa1
  0x61
  0x74
  0x19
  0x04
  0xd2
</code></pre></div>
<p>We have just compressed <strong>10 bytes of JSON</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234
}
</code></pre></div>
<p>Into <strong>6 bytes of CBOR</strong>.</p>
<p>We have scrimped and saved <strong>4 bytes</strong>!</p>
<p><img src="https://lupyuen.github.io/images/cbor2-run3.png" alt="Encoded CBOR Output" /></p>
<h1 id="add-another-field"><a class="doc-anchor" href="#add-another-field">¬ß</a>2 Add Another Field</h1>
<p>Now we <strong>add another field</strong> to our CBOR Encoding‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234, 
  &quot;l&quot;: 2345 
}
</code></pre></div>
<p>And watch how our program changes to accommodate the second field.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-map2.png" alt="CBOR Map with 2 Key-Value Pairs" /></p>
</blockquote>
<h2 id="modify-map-encoder"><a class="doc-anchor" href="#modify-map-encoder">¬ß</a>2.1 Modify Map Encoder</h2>
<p>We begin the same way as before: <a href="https://github.com/lupyuen/tinycbor_test/blob/main/tinycbor_test_main.c#L84-L158">tinycbor_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Test CBOR Encoding for { &quot;t&quot;: 1234, &quot;l&quot;: 2345 }
static void test_cbor2(void) {

  //  Max output size is 50 bytes (which fits in a LoRa packet)
  uint8_t output[50];

  //  Our CBOR Encoder and Map Encoder
  CborEncoder encoder, mapEncoder;

  //  Init our CBOR Encoder
  cbor_encoder_init( ... );
</code></pre></div>
<p>Now we <strong>create the Map Encoder</strong> with a tiny modification‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Create a Map Encoder that maps keys to values
  CborError res = cbor_encoder_create_map(
    &amp;encoder,     //  CBOR Encoder
    &amp;mapEncoder,  //  Map Encoder
    2             //  Number of Key-Value Pairs
  );    
  assert(res == CborNoError);
</code></pre></div>
<p>We changed the <strong>Number of Key-Value Pairs</strong> to <code>2</code>.</p>
<p>(Previously it was <code>1</code>)</p>
<h2 id="encode-first-key-and-value"><a class="doc-anchor" href="#encode-first-key-and-value">¬ß</a>2.2 Encode First Key and Value</h2>
<p>We encode the <strong>First Key and Value</strong> the same way as before‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Key
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;t&quot;           //  Key
  );    
  assert(res == CborNoError);

  //  First Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    1234          //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p>(Yep no changes above)</p>
<h2 id="encode-second-key-and-value"><a class="doc-anchor" href="#encode-second-key-and-value">¬ß</a>2.3 Encode Second Key and Value</h2>
<p>This part is new: We encode the <strong>Second Key and Value</strong> (‚Äú<code>l</code>‚Äù and <code>2345</code>)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Second Key-Value Pair: Map the Key
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;l&quot;           //  Key
  );    
  assert(res == CborNoError);

  //  Second Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    2345          //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p>And the rest of the code is the same‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Close the Map Encoder
  res = cbor_encoder_close_container( ... );

  //  How many bytes were encoded
  size_t output_len = cbor_encoder_get_buffer_size( ... );

  //  Dump the encoded CBOR output (11 bytes):
  //  0xa2 0x61 0x74 0x19 0x04 0xd2 0x61 0x6c 0x19 0x09 0x29
  for (int i = 0; i &lt; output_len; i++) {
    printf(&quot;  0x%02x\n&quot;, output[i]);
  }
}
</code></pre></div>
<p>Recap: To add a data field to our CBOR Encoding, we‚Ä¶</p>
<ol>
<li>
<p>Modify the call to <strong>cbor_encoder_create_map</strong> and update the <strong>Number of Key-Value Pairs</strong> (<code>2</code>)</p>
</li>
<li>
<p>Add the new <strong>Key and Value</strong>  (‚Äú<code>l</code>‚Äù and <code>2345</code>) to the CBOR Map</p>
</li>
</ol>
<p>Everything else stays the same.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-code2.png" alt="Add a second field" /></p>
</blockquote>
<h2 id="watch-the-magic"><a class="doc-anchor" href="#watch-the-magic">¬ß</a>2.4 Watch the Magic</h2>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>tinycbor_test
</code></pre></div>
<p>We‚Äôll see 11 bytes of <strong>Encoded CBOR Output</strong> for ‚Äútest_cbor2‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>test_cbor2: Encoding { &quot;t&quot;: 1234, &quot;l&quot;: 2345 }
CBOR Output: 11 bytes
  0xa2
  0x61
  0x74
  0x19
  0x04
  0xd2
  0x61
  0x6c
  0x19
  0x09
  0x29
</code></pre></div>
<p>We have just compressed <strong>19 bytes of JSON</strong> into <strong>11 bytes of CBOR</strong>.</p>
<p><strong>8 bytes</strong> saved!</p>
<p><img src="https://lupyuen.github.io/images/cbor2-title.jpg" alt="Encoding Sensor Data with CBOR" /></p>
<h1 id="cbor-data-types"><a class="doc-anchor" href="#cbor-data-types">¬ß</a>3 CBOR Data Types</h1>
<p><em>We‚Äôve been encoding 64-bit Signed Integers. What other Data Types can we encode?</em></p>
<p>Below are the <strong>CBOR Data Types</strong> and their respective <strong>Encoder Functions</strong> from the TinyCBOR Library‚Ä¶</p>
<h2 id="numbers"><a class="doc-anchor" href="#numbers">¬ß</a>3.1 Numbers</h2>
<ul>
<li>
<p><strong>Signed Integer</strong> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#gabbf6e10fd963d673f5ad293dff4a67a9">cbor_encode_int</a></p>
<p>(We called this earlier. Works for positive and negative integers)</p>
</li>
<li>
<p><strong>Unsigned Integer</strong> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#ga2b898ce6f5821c5aba8b6f0020c4b5ba">cbor_encode_uint</a></p>
<p>(Positive integers only)</p>
</li>
<li>
<p><strong>Negative Integer</strong> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#ga0e84daa854e0480f4a3758bcb46b9b60">cbor_encode_negative_int</a></p>
<p>(Negative integers only)</p>
</li>
<li>
<p><strong>Floating-Point Number</strong> (16, 32 or 64 bits):</p>
<p>(See the next chapter)</p>
</li>
</ul>
<h2 id="strings"><a class="doc-anchor" href="#strings">¬ß</a>3.2 Strings</h2>
<ul>
<li>
<p><strong>Null-Terminated String</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga6df3eff486535322f66584dc5431f9e9">cbor_encode_text_stringz</a></p>
<p>(We called this earlier to encode our Keys)</p>
</li>
<li>
<p><strong>Text String</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga4fa673c63e85b1fd6f8067aca4ccdde4">cbor_encode_text_string</a></p>
<p>(For strings that are not null-terminated)</p>
</li>
<li>
<p><strong>Byte String</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga1260b72bb0f067fd3c68d49a6b5f58d0">cbor_encode_byte_string</a></p>
<p>(For strings containing binary data)</p>
</li>
</ul>
<h2 id="other-types"><a class="doc-anchor" href="#other-types">¬ß</a>3.3 Other Types</h2>
<ul>
<li>
<p><strong>Boolean</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga857154b97cad978f4afb3e2f809051bd">cbor_encode_boolean</a></p>
</li>
<li>
<p><strong>Null</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga30b769ff1da73ed8b4536f551347c5ed">cbor_encode_null</a></p>
</li>
<li>
<p><strong>Undefined</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga9d9f0668e2cf69352a45095006efab4f">cbor_encode_undefined</a></p>
</li>
</ul>
<p>For the complete list of CBOR Encoder Functions, refer to the TinyCBOR docs‚Ä¶</p>
<ul>
<li><a href="https://intel.github.io/tinycbor/current/a00046.html"><strong>TinyCBOR: Encoding To CBOR</strong></a></li>
</ul>
<p>CBOR Data Types are explained in the CBOR Specification‚Ä¶</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-cbor-data-models"><strong>CBOR Data Models</strong></a></li>
</ul>
<p>To experiment with CBOR Encoding and Decoding, try the <a href="http://cbor.me/"><strong>CBOR Playground</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/grafana-cbor5.png" alt="CBOR Playground" /></p>
<h1 id="floating-point-numbers"><a class="doc-anchor" href="#floating-point-numbers">¬ß</a>4 Floating-Point Numbers</h1>
<p>The CBOR spec says that there are <a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-floating-point-numbers-and-"><strong>3 ways to encode floats</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Half-precision_floating-point_format"><strong>Half-Precision Float</strong></a> (16 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#gad8e5a125cfaceb9a32528e620e003bc6">cbor_encode_half_float</a></p>
<p>(<strong>3.3</strong> significant decimal digits. <a href="https://en.m.wikipedia.org/wiki/Half-precision_floating-point_format#IEEE_754_half-precision_binary_floating-point_format:_binary16">See this</a>)</p>
</li>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Single-precision_floating-point_format"><strong>Single-Precision Float</strong></a> (32 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#gae981ee934ef22ce4c5b52f8069e1b15c">cbor_encode_float</a></p>
<p>(<strong>6 to 9</strong> significant decimal digits. <a href="https://en.m.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32">See this</a>)</p>
</li>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Double-precision_floating-point_format"><strong>Double-Precision Float</strong></a> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#ga211aa80dc5b793ee8dd74d24cb9e7ca6">cbor_encode_double</a></p>
<p>(<strong>15 to 17</strong> significant decimal digits. <a href="https://en.m.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64">See this</a>)</p>
</li>
</ul>
<p><em>How do we select the proper float encoding?</em></p>
<p>Suppose we‚Äôre encoding Temperature Data (like <code>12.34</code> ¬∫C) that could range from <strong><code>0.00</code> ¬∫C to <code>99.99</code> ¬∫C</strong>.</p>
<p>This means that we need <strong>4 significant decimal digits</strong>.</p>
<p>Which is too many for a Half-Precision Float (16 bits), but OK for a <strong>Single-Precision Float</strong> (32 bits).</p>
<p>Thus we need <strong>5 bytes</strong> to encode the Temperature Data. (Including the CBOR Initial Byte)</p>
<h2 id="encode-floats-as-integers"><a class="doc-anchor" href="#encode-floats-as-integers">¬ß</a>4.1 Encode Floats as Integers</h2>
<p><em>Huh? If we encode an integer like <code>1234</code>, we need only <strong>3 bytes</strong>!</em></p>
<p>That‚Äôs why in this article we <strong>scale up 100 times</strong> for the Temperature Data and <strong>encode as an integer</strong> instead.</p>
<p>(So <code>1234</code> actually means <code>12.34</code> ¬∫C)</p>
<p><strong>2 bytes</strong> saved!</p>
<p>(Our scaling of Sensor Data is similar to <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic#Fixed-point_representation">Fixed-Point Representation</a>)</p>
<h2 id="accuracy-and-precision"><a class="doc-anchor" href="#accuracy-and-precision">¬ß</a>4.2 Accuracy and Precision</h2>
<p><em>Is it meaningful to record temperatures that are accurate to 0.01 ¬∫C?</em></p>
<p><em>How much accuracy do we need for Sensor Data anyway?</em></p>
<p>The accuracy for our Sensor Data depends on‚Ä¶</p>
<ol>
<li>
<p>Our monitoring requirements, and</p>
</li>
<li>
<p>Accuracy of our sensors</p>
</li>
</ol>
<p>Learn more about Accuracy and Precision of Sensor Data‚Ä¶</p>
<ul>
<li><a href="https://kotahi.net/iots-lesser-known-power-good-enough-data-accuracy/">IoT‚Äôs Lesser Known Power: ‚ÄúGood Enough‚Äù Data Accuracy</a></li>
</ul>
<h1 id="decode-cbor"><a class="doc-anchor" href="#decode-cbor">¬ß</a>5 Decode CBOR</h1>
<p><em>For decoding CBOR packets, can we call the TinyCBOR Library?</em></p>
<p>Sure, we can call the <strong>Decoder Functions</strong> in the TinyCBOR Library‚Ä¶</p>
<ul>
<li>
<p><a href="https://intel.github.io/tinycbor/current/a00047.html"><strong>TinyCBOR: Parsing CBOR streams</strong></a></p>
</li>
<li>
<p><a href="https://intel.github.io/tinycbor/current/a00048.html"><strong>TinyCBOR: Converting CBOR to text</strong></a></p>
</li>
<li>
<p><a href="https://intel.github.io/tinycbor/current/a00049.html"><strong>TinyCBOR: Converting CBOR to JSON</strong></a></p>
</li>
</ul>
<p>If we‚Äôre transmitting CBOR packets to a server (or cloud), we can decode them with a <strong>CBOR Library for Node.js, Go, Rust,</strong> ‚Ä¶</p>
<ul>
<li><a href="https://cbor.io/impls.html"><strong>CBOR Implementations</strong></a></li>
</ul>
<p>We can decode CBOR Payloads in <strong>The Things Network</strong> with a CBOR Payload Formatter‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/payload"><strong>‚ÄúCBOR Payload Formatter for The Things Network‚Äù</strong></a></li>
</ul>
<p>For Grafana we used a <strong>Go Library for CBOR</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/grafana#decode-cbor-in-go"><strong>‚ÄúDecode CBOR in Go‚Äù</strong></a></li>
</ul>
<p>There‚Äôs even a CBOR Library for <strong>Roblox and Lua Scripting</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/roblox-the-things-network#decode-base64-and-cbor-in-roblox"><strong>‚ÄúDecode Base64 and CBOR in Roblox‚Äù</strong></a></li>
</ul>
<p>TinyCBOR is available on various <strong>Embedded Operating Systems</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/mynewt-core/tree/master/encoding/tinycbor"><strong>Apache Mynewt</strong></a></p>
</li>
<li>
<p><a href="https://doc.riot-os.org/group__pkg__tinycbor.html"><strong>RIOT</strong></a></p>
</li>
<li>
<p><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_TINYCBOR.html"><strong>Zephyr</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio1.jpg" alt="Inside PineDio Stack BL604" /></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>6 What‚Äôs Next</h1>
<p>In the next few articles we‚Äôll build a <strong>complete IoT Sensor Device</strong> with NuttX‚Ä¶</p>
<ol>
<li>
<p>We‚Äôll take the <strong>LoRaWAN Stack</strong> from the previous article‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p>Read BL602‚Äôs <a href="https://lupyuen.github.io/articles/tsen"><strong>Internal Temperature Sensor</strong></a> to get real Sensor Data‚Ä¶</p>
<p><a href="https://github.com/lupyuen/bl602_adc_test"><strong>‚ÄúADC and Internal Temperature Sensor Library‚Äù</strong></a></p>
</li>
<li>
<p>Compress the Sensor Data with CBOR</p>
<p>(As explained in this article)</p>
</li>
<li>
<p>Transmit the compressed Sensor Data to <a href="https://lupyuen.github.io/articles/ttn"><strong>The Things Network</strong></a> over LoRaWAN</p>
<p>(Pic below)</p>
</li>
</ol>
<p>But first we‚Äôll take a short detour to explore <a href="https://lupyuen.github.io/articles/nuttx#rust-on-nuttx"><strong>Rust on NuttX</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rust2"><strong>‚ÄúRust on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rusti2c"><strong>‚ÄúRust talks I2C on Apache NuttX RTOS‚Äù</strong></a></p>
</li>
</ul>
<p>Stay Tuned!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/embedded_oc/comments/s0507e/encode_sensor_data_with_cbor_on_apache_nuttx_os/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/cbor2.md"><code>lupyuen.github.io/src/cbor2.md</code></a></p>
<p><img src="https://lupyuen.github.io/images/lorawan3-ttn.png" alt="NuttX transmits a CBOR Payload to The Things Network Over LoRaWAN" /></p>
<p><em>NuttX transmits a CBOR Payload to The Things Network Over LoRaWAN</em></p>
<h1 id="notes"><a class="doc-anchor" href="#notes">¬ß</a>7 Notes</h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1478613072973418498?s=20">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-build-flash-and-run-nuttx"><a class="doc-anchor" href="#appendix-build-flash-and-run-nuttx">¬ß</a>8 Appendix: Build, Flash and Run NuttX</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="build-nuttx"><a class="doc-anchor" href="#build-nuttx">¬ß</a>8.1 Build NuttX</h2>
<p>Follow these steps to build NuttX for BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we have downloaded the <strong>NuttX Source Code</strong> and configured the build‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/cbor2#download-source-code"><strong>‚ÄúDownload Source Code‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/cbor2#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>To build NuttX, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make
</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746">(See the complete log for BL602)</a></p>
</li>
<li>
<p><strong>For WSL:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>c:\blflash</strong> directory in the Windows File System‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  /mnt/c/blflash refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash
</code></pre></div>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx"><a class="doc-anchor" href="#flash-nuttx">¬ß</a>8.2 Flash NuttX</h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux: Change &quot;/dev/ttyUSB0&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change &quot;/dev/tty.usbserial-1410&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change &quot;COM5&quot; to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx"><a class="doc-anchor" href="#run-nuttx">¬ß</a>8.3 Run NuttX</h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0
</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;
</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p><strong>macOS Tip:</strong> Here‚Äôs the script I use to build, flash and run NuttX on macOS, all in a single step: <a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">run.sh</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="Script to build, flash and run NuttX on macOS" /></p>
<p><a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">(Source)</a></p>
<h1 id="appendix-porting-tinycbor-to-nuttx"><a class="doc-anchor" href="#appendix-porting-tinycbor-to-nuttx">¬ß</a>9 Appendix: Porting TinyCBOR to NuttX</h1>
<p>Below are the fixes we made while porting the TinyCBOR library to NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/tinycbor-nuttx/commit/cc12fca92c69f36a2be9ea6df7677420dc7a84dd"><strong>‚ÄúFix open_memstream for NuttX‚Äù</strong></a></li>
</ul>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>