<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Porting Mynewt to PineCone BL602</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Porting Mynewt to PineCone BL602" 
    data-rh="true">
<meta property="og:description" 
    content="How we port Apache Mynewt embedded operating system to the PineCone BL602 RISC-V Board" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/mynewt-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Porting Mynewt to PineCone BL602</h1>
    <nav id="TOC"><ul>
<li><a href="#adapt-from-existing-risc-v-port">1 Adapt from Existing RISC-V Port</a><ul></ul></li>
<li><a href="#set-gcc-compiler-for-risc-v">2 Set GCC Compiler for RISC-V</a><ul>
<li><a href="#mynewt-project-and-firmware">2.1 Mynewt Project and Firmware</a><ul></ul></li></ul></li>
<li><a href="#add-microcontroller-definition">3 Add Microcontroller Definition</a><ul></ul></li>
<li><a href="#add-board-support-package">4 Add Board Support Package</a><ul></ul></li>
<li><a href="#define-linker-script">5 Define Linker Script</a><ul>
<li><a href="#bootloader-image-header">5.1 Bootloader Image Header</a><ul></ul></li></ul></li>
<li><a href="#define-flash-map">6 Define Flash Map</a><ul>
<li><a href="#future-flash-map">6.1 Future Flash Map</a><ul></ul></li></ul></li>
<li><a href="#set-firmware-target">7 Set Firmware Target</a><ul></ul></li>
<li><a href="#build-the-firmware">8 Build the Firmware</a><ul></ul></li>
<li><a href="#implement-hardware-abstraction-layer">9 Implement Hardware Abstraction Layer</a><ul></ul></li>
<li><a href="#implement-start-code">10 Implement Start Code</a><ul></ul></li>
<li><a href="#risc-v-rv32imfc-vs-rv32imac">11 RISC-V rv32imfc vs rv32imac</a><ul></ul></li>
<li><a href="#decouple-sifive-fe310-from-rv32imac">12 Decouple SiFive FE310 from rv32imac</a><ul></ul></li>
<li><a href="#inspect-the-firmware">13 Inspect the Firmware</a><ul></ul></li>
<li><a href="#debug-firmware-with-vscode">14 Debug Firmware with VSCode</a><ul>
<li><a href="#debugging-features">14.1 Debugging Features</a><ul></ul></li>
<li><a href="#terminating-openocd">14.2 Terminating OpenOCD</a><ul></ul></li></ul></li>
<li><a href="#how-to-test">15 How To Test</a><ul>
<li><a href="#testing-the-led">15.1 Testing the LED</a><ul></ul></li>
<li><a href="#testing-the-jumper">15.2 Testing the Jumper</a><ul></ul></li>
<li><a href="#testing-the-uart-port">15.3 Testing the UART Port</a><ul></ul></li></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-load-firmware-to-cache-memory-not-flash-memory">17 Appendix: Load Firmware to Cache Memory, not Flash Memory</a><ul></ul></li>
<li><a href="#appendix-install-newt">18 Appendix: Install newt</a><ul>
<li><a href="#linux-and-macos">18.1 Linux and macOS</a><ul></ul></li>
<li><a href="#windows">18.2 Windows</a><ul></ul></li></ul></li>
<li><a href="#appendix-create-the-mynewt-firmware">19 Appendix: Create the Mynewt Firmware</a><ul></ul></li>
<li><a href="#appendix-vscode-settings">20 Appendix: VSCode Settings</a><ul>
<li><a href="#debugger-settings">20.1 Debugger Settings</a><ul></ul></li>
<li><a href="#task-settings">20.2 Task Settings</a><ul></ul></li></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/mynewt-title.png" alt="Debugging Mynewt Firmware with VSCode" /></p>
<p><em>Debugging Mynewt Firmware with VSCode</em></p>
<p>üìù <em>21 Dec 2020</em></p>
<p>Our journey so far‚Ä¶ </p>
<ol>
<li>
<p>We took a quick peek at <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Evaluation Board</strong></a>‚Ä¶</p>
</li>
<li>
<p>Then we <a href="https://lupyuen.github.io/articles/openocd"><strong>connected PineCone to OpenOCD</strong></a> with a JTAG Debugger‚Ä¶</p>
</li>
<li>
<p>And we <a href="https://lupyuen.github.io/articles/debug"><strong>debugged Rust on PineCone</strong></a> with VSCode and GDB</p>
</li>
</ol>
<p>Today we‚Äôll learn about our port of <a href="https://mynewt.apache.org/"><strong>Apache Mynewt</strong></a> embedded operating system to PineCone.</p>
<p><a href="https://youtu.be/iDS8CBplSw8">Watch the Sneak Peek on YouTube</a></p>
<p><em>Why port Mynewt to BL602?</em></p>
<p>Since FreeRTOS is already supported on BL602 (for multitasking Bluetooth LE and WiFi in the background), let‚Äôs port a modern embedded operating system like Mynewt.</p>
<p>It‚Äôs a great way to learn the internals of BL602.  And this article will be a valuable resource for porting to BL602 other embedded operating systems, like Zephyr and RIOT.</p>
<p><a href="https://lupyuen.github.io/articles/nuttx"><strong>UPDATE: Check out Apache NuttX operating system for BL602</strong></a></p>
<p><a href="https://github.com/nandojve/zephyr/blob/bouffalo/boards/riscv/dt_bl10_devkit/doc/index.rst"><strong>UPDATE: Check out Zephyr for BL602</strong></a></p>
<p><a href="https://github.com/bouffalolab/bl_mcu_sdk/pull/18"><strong>UPDATE: Zephyr is being ported to BL602 MCU SDK</strong></a></p>
<h1 id="adapt-from-existing-risc-v-port"><a href="#adapt-from-existing-risc-v-port">1 Adapt from Existing RISC-V Port</a></h1>
<p><em>What‚Äôs the quickest way to port Mynewt to PineCone BL602?</em></p>
<p>There‚Äôs one (and only one) RISC-V Board supported today on Mynewt: <strong>SiFive‚Äôs HiFive1 Board</strong>, based on the <strong>SiFive FE310 Microcontroller</strong>.</p>
<p>We shall copy and adapt the necessary files from the HiFive1 FE310 port to our PineCone BL602 port.</p>
<p><em>How different is BL602 from SiFive FE310?</em></p>
<p>The Memory Maps for BL602 and SiFive FE310 look totally different‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/pinecone-compare.jpg" alt="BL602 Memory Map vs SiFive FE310: Totally different" /></p>
<p><em>BL602 Memory Map (left) vs SiFive FE310 (right): Totally different</em></p>
<p>But <strong>BL602‚Äôs RISC-V Core is highly similar to SiFive FE310</strong>. Compare these two files‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/pine64/bl_iot_sdk/blob/master/components/bl602/freertos_riscv/config/platform.h"><code>platform.h</code> from <strong>BL602 IoT SDK</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/sifive/src/ext/freedom-e-sdk_3235929/bsp/env/freedom-e300-hifive1/platform.h"><code>platform.h</code> from <strong>Mynewt‚Äôs FE310 Port</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/mynewt-platform.png" alt="platform.h: BL602 (left) vs SiFive FE310 (right)" /></p>
<p><em>platform.h: BL602 (left) vs SiFive FE310 (right)</em></p>
<p>Since BL602‚Äôs RISC-V Core is so similar to FE310, it makes porting simpler.</p>
<p><img src="https://lupyuen.github.io/images/mynewt-e21.png" alt="BL602 is based on SiFive E21 RISC-V Core" /></p>
<p><em>BL602 is based on which SiFive RISC-V Core?</em></p>
<p>From the screenshot above, the name ‚ÄúE21‚Äù appears (over a hundred times) in the BL602 IoT SDK. <a href="https://github.com/pine64/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/Device/Bouffalo/BL602/Peripherals/l1c_reg.h#L178-L194">(See this)</a></p>
<p>Thus we assume that BL602 is based on the <strong>SiFive E21 RISC-V Core</strong> (and not E24)‚Ä¶</p>
<ul>
<li><a href="https://sifive.cdn.prismic.io/sifive/39d336f7-7dba-43f2-a453-8d55227976cc_sifive_E21_rtl_full_20G1.03.00_manual.pdf">SiFive E21 Manual</a></li>
</ul>
<p>While doing the porting, we shall compare the above E21 doc with the FE310 doc so that we can identify the differences (e.g. FE310 supports PLIC, E21 doesn‚Äôt)</p>
<ul>
<li><a href="https://sifive.cdn.prismic.io/sifive/4d063bf8-3ae6-4db6-9843-ee9076ebadf7_fe310-g000.pdf">SiFive FE310 Manual</a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/mynewt-gcc.png" alt="Mynewt‚Äôs default GCC Compiler is riscv64-unknown-elf-gcc" /></p>
<p><em>Mynewt‚Äôs default GCC Compiler is <code>riscv64-unknown-elf-gcc</code></em></p>
<h1 id="set-gcc-compiler-for-risc-v"><a href="#set-gcc-compiler-for-risc-v">2 Set GCC Compiler for RISC-V</a></h1>
<p>When building RISC-V Firmware, Mynewt uses the RISC-V GCC Compiler <code>riscv64-unknown-elf-gcc</code> <a href="https://github.com/apache/mynewt-core/blob/master/compiler/riscv64/compiler.yml">(See this)</a></p>
<p>But that‚Äôs not the same as our compiler from xPack RISC-V GCC: <code>riscv-none-embed-gcc</code></p>
<p><em>(See <a href="https://lupyuen.github.io/articles/debug">‚ÄúDebug Rust on PineCone BL602 with VSCode and GDB‚Äù</a>, Section 1.3, <a href="https://lupyuen.github.io/articles/debug#install-gdb">‚ÄúInstall GDB‚Äù</a>)</em></p>
<p>Hence we copy and modify the GCC settings like so: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/compiler/riscv-none-embed/compiler.yml"><code>compiler/riscv-none-embed/compiler.yml</code></a></p>
<div class="example-wrap"><pre class="language-yaml"><code>compiler.path.cc:      &quot;riscv-none-embed-gcc&quot;
compiler.path.as:      &quot;riscv-none-embed-gcc&quot;
compiler.path.archive: &quot;riscv-none-embed-ar&quot;
compiler.path.objdump: &quot;riscv-none-embed-objdump&quot;
compiler.path.objsize: &quot;riscv-none-embed-size&quot;
compiler.path.objcopy: &quot;riscv-none-embed-objcopy&quot;</code></pre></div>
<p>Mynewt will now compile our firmware with <code>riscv-none-embed-gcc</code></p>
<h2 id="mynewt-project-and-firmware"><a href="#mynewt-project-and-firmware">2.1 Mynewt Project and Firmware</a></h2>
<p><em>In the screen above, how did we create the Mynewt Project <code>pinecone-rust-mynewt</code> and the Mynewt Firmware <code>pinecone_app</code>?</em></p>
<p>I created <code>pinecone-rust-mynewt</code> and <code>pinecone_app</code> using Mynewt‚Äôs <code>newt</code> tool.</p>
<p>We‚Äôll download them in a while, so you don‚Äôt need to create them.</p>
<p><em>(FYI: I created <code>pinecone-rust-mynewt</code> and <code>pinecone_app</code> using the steps explained in the sections ‚ÄúAppendix: Install newt‚Äù and ‚ÄúAppendix: Create the Mynewt Firmware‚Äù below)</em></p>
<p><img src="https://lupyuen.github.io/images/mynewt-mcu.png" alt="Mynewt Microcontroller Definition for BL602" /></p>
<p><em>Mynewt Microcontroller Definition for BL602</em></p>
<h1 id="add-microcontroller-definition"><a href="#add-microcontroller-definition">3 Add Microcontroller Definition</a></h1>
<p>We create a <strong>Microcontroller Definition</strong> to tell Mynewt all about BL602‚Ä¶</p>
<ul>
<li>
<p><strong>BL602 Microcontroller Definition</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/hw/mcu/bl/bl602"><code>hw/mcu/bl/bl602</code></a></p>
</li>
<li>
<p><strong>BL602 Package</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/mcu/bl/bl602/pkg.yml"><code>pkg.yml</code></a></p>
</li>
<li>
<p><strong>BL602 Configuration</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/mcu/bl/bl602/syscfg.yml"><code>syscfg.yml</code></a></p>
</li>
</ul>
<p>This contains the code for the <a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/hw/mcu/bl/bl602/src"><strong>Hardware Adaptaion Layer</strong></a> that‚Äôs specific to BL602 and its built-in Periperal Functions (like Flash Memory, GPIO, I2C, SPI, ‚Ä¶)</p>
<p>The code here was derived from SiFive FE310: <a href="https://github.com/apache/mynewt-core/tree/master/hw/mcu/sifive/fe310"><code>hw/mcu/sifive/fe310</code></a></p>
<h1 id="add-board-support-package"><a href="#add-board-support-package">4 Add Board Support Package</a></h1>
<p>BL602 is present on various boards, PineCone is one of them. The BL602 boards have different features: LEDs, buttons, JTAG debugger, ‚Ä¶</p>
<p>In Mynewt we handle the board differences by creating a <strong>Board Support Package</strong> for PineCone‚Ä¶</p>
<ul>
<li>
<p><strong>PineCone Board Support Package</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/hw/bsp/pinecone"><code>hw/bsp/pinecone</code></a></p>
</li>
<li>
<p><strong>PineCone Definition</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/bsp.yml"><code>bsp.yml</code></a></p>
</li>
<li>
<p><strong>PineCone Package</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/pkg.yml"><code>pkg.yml</code></a></p>
</li>
<li>
<p><strong>PineCone Configuration</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/syscfg.yml"><code>syscfg.yml</code></a></p>
</li>
</ul>
<p>The Board Support Package for PineCone contains code that‚Äôs specific to PineCone. <a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/hw/bsp/pinecone/src">More details</a></p>
<p>The code here was derived from SiFive HiFive1 Board: <a href="https://github.com/apache/mynewt-core/tree/master/hw/bsp/hifive1"><code>hw/bsp/hifive1</code></a></p>
<h1 id="define-linker-script"><a href="#define-linker-script">5 Define Linker Script</a></h1>
<p>The Linker Script tells GCC Compiler about the Memory Layout for executing our firmware‚Ä¶</p>
<ol>
<li>
<p><strong>Flash Memory Area</strong>: For firmware code and read-only data</p>
</li>
<li>
<p><strong>RAM Memory Area</strong>: For read/write data</p>
</li>
</ol>
<p>Here‚Äôs our Linker Script for PineCone‚Ä¶</p>
<ul>
<li><strong>PineCone Linker Script</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/bsp_app.ld"><code>hw/bsp/pinecone/bsp_app.ld</code></a></li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>MEMORY
{
  /* Use this memory layout when firmware is loaded into cache memory. 
     Based on https://github.com/lupyuen/pinecone-rust/blob/main/memory.x */
  flash (rxai!w) : ORIGIN = 0x22008000, LENGTH = 48K /* Instruction Cache Memory */
  ram   (wxa!ri) : ORIGIN = 0x22014000, LENGTH = 48K /* Data Cache Memory */
}</code></pre></div>
<p>Note that we‚Äôre loading the firmware code and read-only data into BL602‚Äôs Instruction Cache Memory (similar to RAM), not into Flash Memory. (We‚Äôll learn why in a while)</p>
<p>In future when we‚Äôre ready to load our firmware into Flash Memory, we‚Äôll use this memory layout instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  /* TODO: Use this memory layout when firmware is loaded into Flash Memory 
     Based on Based on https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602/evb/ld/flash_rom.ld */
  flash (rxai!w) : ORIGIN = 0x23000000, LENGTH = 4M   /* Flash Memory */
  ram   (wxa!ri) : ORIGIN = 0x4200c000, LENGTH = 216K /* RAM          */</code></pre></div>
<p>(This is commented out in <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/bsp_app.ld"><code>bsp_app.ld</code></a>)</p>
<h2 id="bootloader-image-header"><a href="#bootloader-image-header">5.1 Bootloader Image Header</a></h2>
<p>We‚Äôre presently not using a Bootloader on PineCone‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Bootloader not in use. */
_imghdr_size = 0x0;</code></pre></div>
<p>In future when we use the Mynewt Bootloader, we need to reserve some space for the Bootloader Image Header, which is located at the start of the firmware code‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* This linker script is used for images and thus contains an image header */
/* TODO: Uncomment the next line when Bootloader is in use */
_imghdr_size = 0x20;</code></pre></div><h1 id="define-flash-map"><a href="#define-flash-map">6 Define Flash Map</a></h1>
<p>Mynewt‚Äôs MCUBoot Bootloader will roll back the Active Firmware to the Standby Firmware in case the Active Firmware can‚Äôt be started.</p>
<p>We define the <strong>Flash Map</strong> to tell Mynewt where in Flash Memory the Bootloader, Active Firmware Image and Standby Firmware Image will be located‚Ä¶</p>
<ul>
<li><strong>PineCone Flash Map</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/bsp.yml"><code>hw/bsp/pinecone/bsp.yml</code></a></li>
</ul>
<div class="example-wrap"><pre class="language-yaml"><code># BL602 Instruction Cache Memory starts at 0x2200 8000, size 48 KB
# Based on https://github.com/lupyuen/pinecone-rust/blob/main/memory.x
bsp.flash_map:
    areas:
        # System areas.
        # (Not Used) Bootloader
        FLASH_AREA_BOOTLOADER:
            device:  0
            offset:  0x22013c00
            size:    1kB    # 0x400
        # Active Firmware Image
        FLASH_AREA_IMAGE_0:
            device:  0 
            offset:  0x22008000
            size:    43kB   # 0xac00
        # (Not Used) Standby Firmware Image, in case Active Firmware can&#39;t start
        FLASH_AREA_IMAGE_1:
            device:  0
            offset:  0x22012c00
            size:    1kB    # 0x400
        # (Not used) Scratch Area for swapping Active Firmware and Standby Firmware
        FLASH_AREA_IMAGE_SCRATCH:
            device:  0
            offset:  0x22013000
            size:    1kB    # 0x400</code></pre></div>
<p>Remember that we‚Äôre loading our firmware into Cache Memory (instead of Flash Memory) and we‚Äôre not using the Bootloader. </p>
<p>That‚Äôs why we allocate most of the Cache Memory to the Active Firmware Image (located at the start of Cache Memory).</p>
<div class="example-wrap"><pre class="language-yaml"><code>        # User areas.
        # (Not Used) Reboot Log
        FLASH_AREA_REBOOT_LOG:
            user_id: 0
            device:  0
            offset:  0x22013400
            size:    1kB    # 0x400
        # (Not Used) User File System, like LittleFS
        FLASH_AREA_NFFS:
            user_id: 1
            device:  0
            offset:  0x22013800
            size:    1kB    # 0x400</code></pre></div>
<p>Since we have very little Cache Memory, we‚Äôll cut down on the Reboot Log and User File Systems.</p>
<h2 id="future-flash-map"><a href="#future-flash-map">6.1 Future Flash Map</a></h2>
<p>The Flash Map looks more meaningful when we‚Äôre ready to load our firmware into Flash Memory and turn on the Bootloader.</p>
<p>Here is our Flash Map for the future‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code># TODO: Use this memory layout when firmware is loaded into Flash Memory
# BL602 Flash starts at 0x2300 0000, size 4 MB
# Based on https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602/evb/ld/flash_rom.ld
bsp.flash_map:
    areas:
        # System areas.
        # TODO: Bootloader not in use. When used, move Bootloader to 0x2300 0000 and shift the other areas accordingly
        FLASH_AREA_BOOTLOADER:
            device:  0
            offset:  0x2330d000
            size:    32kB      # 0x8000
        # Active Firmware Image
        FLASH_AREA_IMAGE_0:
            device:  0 
            offset:  0x23000000
            size:    1024kB    # 0x100 000
        # Standby Firmware Image, in case Active Firmware can&#39;t start
        FLASH_AREA_IMAGE_1:
            device:  0
            offset:  0x23100000
            size:    1024kB    # 0x100 000
        # Scratch Area for swapping Active Firmware and Standby Firmware
        FLASH_AREA_IMAGE_SCRATCH:
            device:  0
            offset:  0x23300000
            size:    4kB       # 0x1000</code></pre></div>
<p>(This is commented out in <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/bsp/pinecone/bsp.yml"><code>bsp.yml</code></a>)</p>
<p>In future we‚Äôll have a proper Reboot Log and a User File System for saving files and data that will be retained across reboots‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>        # User areas.
        # Reboot Log
        FLASH_AREA_REBOOT_LOG:
            user_id: 0
            device:  0
            offset:  0x23301000
            size:    48kB      #  0xc000
        # User File System, like LittleFS
        FLASH_AREA_NFFS:
            user_id: 1
            device:  0
            offset:  0x23200000
            size:    1024kB    # 0x100 000</code></pre></div><h1 id="set-firmware-target"><a href="#set-firmware-target">7 Set Firmware Target</a></h1>
<p>We select the Mynewt Firmware to be built by creating a Firmware Target‚Ä¶</p>
<ul>
<li><strong>PineCone Firmware Target</strong>: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/targets/pinecone_app/target.yml"><code>targets/pinecone_app/target.yml</code></a></li>
</ul>
<div class="example-wrap"><pre class="language-yaml"><code>target.app: apps/blinky
target.bsp: &quot;hw/bsp/pinecone&quot;
target.build_profile: debug</code></pre></div>
<p>Here we specify that our firmware code comes from the <a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/apps/blinky">Blinky Sample App</a>. And our firmware will be compiled for the PineCone BL602 Board.</p>
<p>Also check out the <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/targets/pinecone_app/pkg.yml"><strong>Target Package</strong></a> and the <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/targets/pinecone_app/syscfg.yml"><strong>Target Configuration</strong></a>.</p>
<h1 id="build-the-firmware"><a href="#build-the-firmware">8 Build the Firmware</a></h1>
<p>We have created a minimal port of Mynewt to PineCone. Here‚Äôs how we build the firmware on Linux, macOS and Windows (plain old CMD, without WSL and MSYS2)‚Ä¶</p>
<ol>
<li>
<p>Install Mynewt‚Äôs <code>newt</code> tool according to the instructions here‚Ä¶</p>
<ul>
<li><a href="https://mynewt.apache.org/latest/newt/install/index.html">Installing <code>newt</code></a></li>
</ul>
<p>To build <code>newt</code> from the source code, check the section ‚ÄúAppendix: Install newt‚Äù below</p>
</li>
<li>
<p>At the command prompt, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Download source files
git clone --recursive https://github.com/lupyuen/pinecone-rust-mynewt
cd pinecone-rust-mynewt</code></pre></div></li>
<li>
<p>Download GCC from the <a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/tag/v8.3.0-2.3">xPack GCC for RISC-V site</a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/download/v8.3.0-2.3/xpack-riscv-none-embed-gcc-8.3.0-2.3-linux-x64.tar.gz">xPack GCC RISC-V for Linux x64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/download/v8.3.0-2.3/xpack-riscv-none-embed-gcc-8.3.0-2.3-linux-arm64.tar.gz">xPack GCC RISC-V for Linux Arm64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/download/v8.3.0-2.3/xpack-riscv-none-embed-gcc-8.3.0-2.3-darwin-x64.tar.gz">xPack GCC RISC-V for macOS x64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/download/v8.3.0-2.3/xpack-riscv-none-embed-gcc-8.3.0-2.3-win32-x64.zip">xPack GCC RISC-V for Windows x64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/riscv-none-embed-gcc-xpack/releases/tag/v8.3.0-2.3">Other builds of xPack GCC RISC-V</a></p>
</li>
</ul>
<p>Extract the downloaded archive.</p>
</li>
<li>
<p>Copy the extracted xPack GCC RISC-V folder to the <code>pinecone-rust-mynewt</code> folder.</p>
<p>Rename the copied folder as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt/xpack-riscv-none-embed-gcc</code></pre></div>
<p><strong>For Windows:</strong> Add the full path of <code>xpack-riscv-none-embed-gcc/bin</code> to the PATH. For example‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>c:\pinecone-rust-mynewt\xpack-riscv-none-embed-gcc\bin</code></pre></div></li>
<li>
<p>Download OpenOCD from the <a href="https://github.com/xpack-dev-tools/openocd-xpack/releases/tag/v0.10.0-15/">xPack OpenOCD site</a>‚Ä¶ (Other variants of OpenOCD may not work with PineCone)</p>
<ul>
<li>
<p><a href="https://github.com/xpack-dev-tools/openocd-xpack/releases/download/v0.10.0-15/xpack-openocd-0.10.0-15-linux-x64.tar.gz">xPack OpenOCD for Linux x64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/openocd-xpack/releases/download/v0.10.0-15/xpack-openocd-0.10.0-15-linux-arm64.tar.gz">xPack OpenOCD for Linux Arm64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/openocd-xpack/releases/download/v0.10.0-15/xpack-openocd-0.10.0-15-darwin-x64.tar.gz">xPack OpenOCD for macOS x64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/openocd-xpack/releases/download/v0.10.0-15/xpack-openocd-0.10.0-15-win32-x64.zip">xPack OpenOCD for Windows x64</a></p>
</li>
<li>
<p><a href="https://github.com/xpack-dev-tools/openocd-xpack/releases/tag/v0.10.0-15/">Other builds of xPack OpenOCD</a></p>
</li>
</ul>
<p>Extract the downloaded archive.</p>
</li>
<li>
<p>Copy the extracted xPack OpenOCD folder to the <code>pinecone-rust-mynewt</code> folder.</p>
<p>Rename the copied folder as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt/xpack-openocd</code></pre></div>
<p><strong>For Windows:</strong> Add the full path of <code>xpack-openocd/bin</code> to the PATH. For example‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>c:\pinecone-rust-mynewt\pinecone-rust-mynewt\xpack-openocd\bin</code></pre></div></li>
<li>
<p><strong>For Linux and macOS:</strong> Enter at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Build the firmware
export PATH=&quot;$PWD/xpack-riscv-none-embed-gcc/bin:$PATH&quot;
newt build pinecone_app

#  Display the firmware size
newt size -v pinecone_app</code></pre></div>
<p><strong>For Windows:</strong> Enter at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-cmd"><code>::  Build the firmware
newt\newt.exe build pinecone_app

::  Display the firmware size
newt\newt.exe size -v pinecone_app</code></pre></div></li>
</ol>
<p>We should see this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Linking /Users/Luppy/pinecone/pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky/blinky.elf
Target successfully built: targets/pinecone_app</code></pre></div>
<p>Followed by the size of the firmware (8,488 bytes) and its library components‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>+ newt size -v pinecone_app
Size of Application Image: app
Mem flash: 0x22008000-0x22014000
Mem ram: 0x22014000-0x22020000
  flash     ram 
      6     525 *fill*
    172       0 @apache-mynewt-core_hw_hal.a
   4494    8213 @apache-mynewt-core_kernel_os.a
     80       0 @apache-mynewt-core_libc_baselibc.a
    702     128 @apache-mynewt-core_sys_flash_map.a
      2       0 @apache-mynewt-core_sys_log_modlog.a
    782      29 @apache-mynewt-core_sys_mfg.a
     30       5 @apache-mynewt-core_sys_sysinit.a
     72       0 @apache-mynewt-core_util_mem.a
     60       8 apps_blinky.a
     44      12 hw_bsp_pinecone.a
    580     228 hw_mcu_bl_bl602.a
     92       0 pinecone_app-sysinit-app.a
    292    1064 libg.a
Loading compiler pinecone-rust-mynewt/compiler/riscv-none-embed, buildProfile debug

objsize
   text    data     bss     dec     hex filename
   8488      28    9104   17620    44d4 pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky/blinky.elf</code></pre></div>
<p>The compiled ELF firmware is located at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky/blinky.elf</code></pre></div><h1 id="implement-hardware-abstraction-layer"><a href="#implement-hardware-abstraction-layer">9 Implement Hardware Abstraction Layer</a></h1>
<p>The above steps will build successfully a minimal port of Mynewt for PineCone.</p>
<p>That‚Äôs because I have fixed many missing functions in Mynewt‚Äôs Hardware Abstraction Layer (HAL), like these‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/mynewt-hal.png" alt="Missing Functions in Mynewt HAL" /></p>
<p><em>Missing Functions in Mynewt HAL</em></p>
<p>We can see that Mynewt‚Äôs HAL consists of low-level functions that control BL602‚Äôs hardware functions: Flash Memory, Interrupts, Watchdog, GPIO, ‚Ä¶</p>
<p>We‚Äôll be filling in these missing HAL functions someday‚Ä¶ But for now I have inserted Stub Functions.</p>
<p>Which means that the firmware will build OK‚Ä¶ Just that GPIO and other features won‚Äôt actually work when we run the firmware.</p>
<p><em>How shall we fill in the HAL Functions for PineCone?</em></p>
<p>The BL602 HAL functions (GPIO, I2C, SPI, ‚Ä¶) are already implemented here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components"><strong>BL602 IoT SDK Firmware Components</strong></a></li>
</ul>
<p>We shall copy the source files from above and embed them here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/hw/mcu/bl/bl602/ext"><strong>Mynewt External Source Files for BL602</strong></a></li>
</ul>
<p>The BL602 SDK Functions look different from the Mynewt HAL API. Thus we‚Äôll have to create some adapter code in C to make the BL602 Functions look like the Mynewt HAL.</p>
<p>The code that adapts the BL602 SDK to Mynewt HAL shall be placed here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinecone-rust-mynewt/tree/main/hw/mcu/bl/bl602/src"><strong>Mynewt HAL for BL602</strong></a></li>
</ul>
<p>As we can see from the GPIO pic below, our job now is to <strong>adapt the BL602 SDK</strong> (left) <strong>to the Mynewt HAL</strong> (right).</p>
<p>(For reference: Here‚Äôs how the <a href="https://github.com/apache/mynewt-core/tree/master/hw/mcu/sifive/fe310/src">Mynewt HAL for SiFive FE310</a> is adapted from the <a href="https://github.com/apache/mynewt-core/tree/master/hw/mcu/sifive/src/ext/freedom-e-sdk_3235929">FE310 SDK</a>)</p>
<p><img src="https://lupyuen.github.io/images/mynewt-hal2.png" alt="BL602 GPIO SDK (left) vs Mynewt GPIO HAL (right)" /></p>
<p><em>BL602 GPIO SDK (left) vs Mynewt GPIO HAL (right)</em></p>
<h1 id="implement-start-code"><a href="#implement-start-code">10 Implement Start Code</a></h1>
<p>Most firmware will have some Start Code (written in Assembly Code) that will be executed when the firmware starts.</p>
<p>For the BL602 IoT SDK, this is the Start Code (in RISC-V Assembly)‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602/evb/src/boot/gcc/start.S"><strong>Start Code from BL602 IoT SDK: <code>start.S</code></strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/mynewt-start.png" alt="Start Code from BL602 IoT SDK: start.S" /></p>
<p><em>Start Code from BL602 IoT SDK: start.S</em></p>
<p>For Mynewt we‚Äôre using this Start Code instead‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/mcu/bl/bl602/src/arch/rv32imac/start.s"><strong>Start Code for Mynewt BL602: <code>start.s</code></strong></a></li>
</ul>
<p>(Adapted from <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/sifive/fe310/src/arch/rv32imac/start.s">FE310 Start Code</a>)</p>
<p>Mynewt‚Äôs Start Code initialises the RAM before calling the <code>main</code> function.</p>
<p><em>Is Mynewt‚Äôs Start Code any different from the BL602 SDK?</em></p>
<p>When we compare Mynewt‚Äôs Start Code with the BL602 SDK, we see that the BL602 SDK Start Code uses the Boot Partition and Flash Configuration. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602/evb/src/boot/gcc/start.S#L27-L54">More details</a></p>
<p>This code will have to be inserted into Mynewt‚Äôs Start Code, when our firmware is ready to be loaded into Flash Memory.</p>
<h1 id="risc-v-rv32imfc-vs-rv32imac"><a href="#risc-v-rv32imfc-vs-rv32imac">11 RISC-V rv32imfc vs rv32imac</a></h1>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/make_scripts_riscv/project.mk#L223">According to the SDK</a>, BL602 uses a RISC-V Core (SiFive E21) that‚Äôs designated <strong><code>rv32imfc</code></strong> based on its capabilities‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Designation</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>rv32i</code></strong></td><td style="text-align: left">32-bit RISC-V with Base Integer Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>m</code></strong></td><td style="text-align: left">Integer Multiplication + Division</td></tr>
<tr><td style="text-align: center"><strong><code>f</code></strong></td><td style="text-align: left"><strong>Single-Precision Hardware Floating Point</strong></td></tr>
<tr><td style="text-align: center"><strong><code>c</code></strong></td><td style="text-align: left">Compressed Instructions</td></tr>
</tbody></table>
</div>
<p><a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions">(Here‚Äôs the whole list)</a></p>
<p><strong>UPDATE:</strong> BL602 actually supports <strong><code>rv32acfimx</code></strong> <a href="https://lupyuen.github.io/articles/uart#enter-the-commands">(See this)</a></p>
<p>However Mynewt today supports only <strong><code>rv32imac</code></strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Designation</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>rv32i</code></strong></td><td style="text-align: left">32-bit RISC-V with Base Integer Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>m</code></strong></td><td style="text-align: left">Integer Multiplication + Division</td></tr>
<tr><td style="text-align: center"><strong><code>a</code></strong></td><td style="text-align: left"><strong>Atomic Instructions</strong></td></tr>
<tr><td style="text-align: center"><strong><code>c</code></strong></td><td style="text-align: left">Compressed Instructions</td></tr>
</tbody></table>
</div>
<p><em>What‚Äôs the difference?</em></p>
<p>Mynewt doesn‚Äôt support RISC-V <strong>Hardware Floating Point</strong> yet‚Ä¶ But it supports <strong>Atomic Instructions</strong> (for data synchronisation).</p>
<p>Thus for now we‚Äôll compile our Mynewt Firmware for <code>rv32imac</code> (without Hardware Floating Point)‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/mynewt-core/tree/master/kernel/os/src/arch/rv32imac"><strong>Mynewt Support for <code>rv32imac</code></strong></a></li>
</ul>
<p>In future we‚Äôll have to implement <code>rv32imfc</code> (with Hardware Floating Point) in Mynewt.</p>
<p><img src="https://lupyuen.github.io/images/mynewt-fe310.png" alt="SiFive FE310 Reference in Mynewt rv32imac" /></p>
<p><em>SiFive FE310 Reference in Mynewt rv32imac</em></p>
<h1 id="decouple-sifive-fe310-from-rv32imac"><a href="#decouple-sifive-fe310-from-rv32imac">12 Decouple SiFive FE310 from rv32imac</a></h1>
<p>There‚Äôs a peculiar problem compiling RISC-V Firmware on Mynewt‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Error: In file included from ...
repos/apache-mynewt-core/kernel/os/include/os/arch/rv32imac/os/os_arch.h:24:10:
fatal error: mcu/fe310.h: No such file or directory
#include &quot;mcu/fe310.h&quot;</code></pre></div>
<p>This error shows that <code>rv32imac</code>, the RISC-V support in Mynewt, is dependent on SiFive FE310. Which looks really odd. </p>
<p>(Probably done that way because FE310 is the only RISC-V Microcontroller supported by Mynewt)</p>
<p>We work around this problem by creating Stub Files like these‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/mcu/bl/bl602/include/mcu/fe310.h"><code>mcu/fe310.h</code></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/mcu/bl/bl602/include/env/freedom-e300-hifive1/platform.h"><code>env/freedom-e300-hifive1/platform.h</code></a></p>
</li>
</ul>
<p>These Stub Files point to the correct Header Files for BL602, so that our BL602 Firmware can be compiled successfully.</p>
<h1 id="inspect-the-firmware"><a href="#inspect-the-firmware">13 Inspect the Firmware</a></h1>
<p>We‚Äôre almost ready to run Mynewt on PineCone! Let‚Äôs do one final check before running our firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Build the firmware
export PATH=&quot;$PWD/xpack-riscv-none-embed-gcc/bin:$PATH&quot;
newt build pinecone_app

#  Display the firmware size
newt size -v pinecone_app</code></pre></div>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Linking pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky/blinky.elf
Target successfully built: targets/pinecone_app
+ newt size -v pinecone_app
Size of Application Image: app
Mem flash: 0x22008000-0x22014000
Mem ram:   0x22014000-0x22020000</code></pre></div>
<p>Yep this matches our Instruction Cache Memory (<code>0x2200 8000</code>) and Data Cache Memory (<code>0x2201 4000</code>).</p>
<div class="example-wrap"><pre class="language-text"><code>  flash     ram 
      6     525 *fill*
    172       0 @apache-mynewt-core_hw_hal.a
   4494    8213 @apache-mynewt-core_kernel_os.a
     80       0 @apache-mynewt-core_libc_baselibc.a
    702     128 @apache-mynewt-core_sys_flash_map.a
      2       0 @apache-mynewt-core_sys_log_modlog.a
    782      29 @apache-mynewt-core_sys_mfg.a
     30       5 @apache-mynewt-core_sys_sysinit.a
     72       0 @apache-mynewt-core_util_mem.a
     60       8 apps_blinky.a
     44      12 hw_bsp_pinecone.a
    580     228 hw_mcu_bl_bl602.a
     92       0 pinecone_app-sysinit-app.a
    292    1064 libg.a</code></pre></div>
<p>Here are all the code modules linked into our Mynewt Firmware. Note that‚Ä¶</p>
<ul>
<li>
<p>Mynewt Kernel takes the most memory</p>
</li>
<li>
<p>Our BL602 HAL <code>hw_mcu_bl_bl602</code> is tiny because it‚Äôs mostly Stub Functions</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Loading compiler pinecone-rust-mynewt/compiler/riscv-none-embed, buildProfile debug
objsize
   text    data     bss     dec     hex filename
   8488      28    9104   17620    44d4 pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky/blinky.elf</code></pre></div>
<p>Our Mynewt Firmware contains 8,488 bytes of code and data. It runs with 9,104 bytes of RAM (BSS).</p>
<p>The firmware build produces the following files in‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky</code></pre></div>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf"><strong><code>blinky.elf</code></strong></a>: Our Mynewt Firmware in ELF Format (<a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf">See this</a>)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf.map"><strong><code>blinky.elf.map</code></strong></a>: Memory Map of our Mynewt Firmware (<a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf.map">See this</a>)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf.lst"><strong><code>blinky.elf.lst</code></strong></a>: RISC-V Disassembly of our Mynewt Firmware (<a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf.lst">See this</a>)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/mynewt-disassembly.png" alt="RISC-V Disassembly of Mynewt Firmware" /></p>
<p><em>RISC-V Disassembly of Mynewt Firmware</em></p>
<p>Inspect the RISC-V Disassembly: <a href="https://github.com/lupyuen/pinecone-rust-mynewt/releases/download/v1.0.0/blinky.elf.lst"><code>blinky.elf.lst</code></a></p>
<p>It should look similar to our <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/hw/mcu/bl/bl602/src/arch/rv32imac/start.s">Start Code</a>. And it should be located at the Start Address of our firmware: <code>0x2200 8000</code>.</p>
<p>We‚Äôre ready to run our Mynewt Firmware on PineCone!</p>
<h1 id="debug-firmware-with-vscode"><a href="#debug-firmware-with-vscode">14 Debug Firmware with VSCode</a></h1>
<p>Now we run and debug our Mynewt Firmware with <a href="https://code.visualstudio.com/"><strong>VSCode</strong></a> on Linux, macOS and Windows‚Ä¶</p>
<ol>
<li>
<p>Connect PineCone and the JTAG Debugger to our computer. See the article‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/openocd">‚ÄúConnect PineCone BL602 to OpenOCD‚Äù</a>, Section 4, <a href="https://lupyuen.github.io/articles/openocd#connect-jtag-debugger-to-pinecone">‚ÄúConnect JTAG Debugger to PineCone‚Äù</a></p>
</li>
<li>
<p>Launch VSCode</p>
</li>
<li>
<p>Click <strong><code>File ‚Üí Open</code></strong></p>
<p>Select the folder <strong><code>pinecone-rust-mynewt</code></strong></p>
</li>
<li>
<p>Click <strong><code>Terminal ‚Üí Run Build Task</code></strong></p>
<p>This builds the Mynewt Firmware. The RISC-V ELF Firmware image is generated here‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt/bin/targets/pinecone_app/app/apps/blinky/blinky.elf</code></pre></div>
<p>This step also terminates any OpenOCD processes that are running. (Linux and macOS only)</p>
</li>
<li>
<p>Click <strong><code>Run ‚Üí Start Debugging</code></strong></p>
<p>The debugger loads our Mynewt Firmware to PineCone‚Äôs Cache Memory and begins execution.</p>
<p>Click <strong><code>View ‚Üí Debug Console</code></strong> to view the Debug Console. GDB messages will be shown here.</p>
</li>
<li>
<p>The debugger pauses execution at the first line of the <code>main</code> function</p>
<p>We should see the screen below‚Ä¶</p>
<p><a href="https://youtu.be/iDS8CBplSw8">Watch on YouTube</a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/mynewt-debug.png" alt="Debug Firmware with VSCode" /></p>
<p><em>Debug Firmware with VSCode</em></p>
<h2 id="debugging-features"><a href="#debugging-features">14.1 Debugging Features</a></h2>
<p>We may use these features for debugging our Mynewt Firmware‚Ä¶</p>
<ol>
<li>
<p><strong>Variables</strong> (Left Top Pane): Inspect global and local variables</p>
</li>
<li>
<p><strong>Watch</strong> (Left Centre): Show the value of expressions</p>
</li>
<li>
<p><strong>Call Stack</strong> (Left Bottom): Navigate the stack trace and its variables</p>
</li>
<li>
<p><strong>Debug Console</strong> (Centre): Enter GDB commands here</p>
</li>
<li>
<p><strong>Debug Toolbar</strong> (Top Right): Continue / Pause, Step Over, Step Into, Step Out, Restart, Stop</p>
</li>
<li>
<p>To set a <strong>Breakpoint</strong>, click the Gutter Column at the left of the source code</p>
</li>
<li>
<p>When we‚Äôre done with debugging, click the Stop button in the Debug Toolbar at top right</p>
</li>
</ol>
<p><a href="https://youtu.be/iDS8CBplSw8">Watch on YouTube</a></p>
<p><a href="https://code.visualstudio.com/docs/editor/debugging">More about VSCode Debugger</a></p>
<h2 id="terminating-openocd"><a href="#terminating-openocd">14.2 Terminating OpenOCD</a></h2>
<p>Before we start a new debugging session with <strong><code>Run ‚Üí Start Debugging</code></strong>‚Ä¶</p>
<p><em>We must always click <strong><code>Terminal ‚Üí Run Build Task</code></strong> first!</em></p>
<p>That‚Äôs because stopping the debugger will leave OpenOCD running (and locking up the connection to PineCone). </p>
<p>Clicking <strong><code>Run Build Task</code></strong> will terminate the OpenOCD task, so that the next debugging session can restart OpenOCD successfully.</p>
<p>For Windows: Sorry we need to terminate the OpenOCD task manually with the Task Manager.</p>
<p>In case of OpenOCD problems, check the OpenOCD log file‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt/openocd.log</code></pre></div>
<p>For details on the VSCode settings, check the section ‚ÄúAppendix: VSCode Settings‚Äù below.</p>
<h1 id="how-to-test"><a href="#how-to-test">15 How To Test</a></h1>
<p><em>How shall we test Mynewt on PineCone? Or any other RTOS ported to PineCone?</em></p>
<p>We have an interesting problem here‚Ä¶ PineCone is a barebones board that doesn‚Äôt have any sensors or actuators connected on interfaces like I2C and SPI.</p>
<p>It will be challenging to test the various interfaces ported to Mynewt. (I might test with the <a href="http://dangerousprototypes.com/docs/Bus_Pirate"><strong>Bus Pirate Probe</strong></a>)</p>
<p>For now I‚Äôll do <strong>‚ÄúOpportunistic Porting and Testing‚Äù</strong>‚Ä¶ I‚Äôll port to Mynewt only those PineCone Interfaces that I can test.</p>
<p><strong>Do you have ideas for testing an RTOS on PineCone? Let us know!</strong></p>
<h2 id="testing-the-led"><a href="#testing-the-led">15.1 Testing the LED</a></h2>
<p>Testing PineCone‚Äôs onboard RGB LED over GPIO seems easy‚Ä¶ Except that the LED is connected to the JTAG Port. So the debugger will fail.</p>
<p>In the earlier articles we learnt about remapping the JTAG port. This could be a (complicated) solution to test and debug the GPIO Port.</p>
<p>Meanwhile I‚Äôll proceed to port the GPIO HAL from the BL602 IoT SDK to Mynewt, as discussed earlier.</p>
<h2 id="testing-the-jumper"><a href="#testing-the-jumper">15.2 Testing the Jumper</a></h2>
<p>We could test GPIO Input with PineCone‚Äôs onboard jumper.</p>
<p>This should be straightforward, right after we port over the GPIO HAL to Mynewt.</p>
<h2 id="testing-the-uart-port"><a href="#testing-the-uart-port">15.3 Testing the UART Port</a></h2>
<p>PineCone‚Äôs UART Port is wired to the USB Connector. We could test PineCone‚Äôs UART Port over USB.</p>
<p>We‚Äôll need to port the UART HAL from the BL602 IoT SDK to Mynewt.</p>
<p><img src="https://lupyuen.github.io/images/mynewt-furry.jpg" alt="Furry PineCone" /></p>
<h1 id="whats-next"><a href="#whats-next">16 What‚Äôs Next</a></h1>
<p>There‚Äôs more work to be done porting Mynewt to PineCone‚Ä¶</p>
<ol>
<li>
<p><strong>Port the Hardware Abstraction Layer</strong> from BL602 IoT SDK to Mynewt: GPIO, UART, PWM, I2C, SPI‚Ä¶</p>
</li>
<li>
<p><strong>Bluetooth LE</strong>: We shall reverse engineer the Bluetooth LE Stack on PineCone. Then replace it by the open source <a href="https://github.com/apache/mynewt-nimble"><strong>NimBLE Stack</strong></a>.</p>
</li>
<li>
<p><strong>WiFi</strong>: Also needs to be reverse engineered. We might be able to port this Mynewt WiFi Driver to PineCone‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/runtimeco/mynewt_arduino_zero/tree/master/libs/winc1500"><code>mynewt_arduino_zero/ libs/winc1500</code></a></p>
</li>
<li>
<p><a href="https://github.com/runtimeco/mynewt_arduino_zero/tree/master/apps/winc1500_wifi"><code>mynewt_arduino_zero/ apps/winc1500_wifi</code></a></p>
</li>
</ul>
</li>
<li>
<p><strong>Rust</strong> will be supported so that we may build complex firmware without falling into traps with C Pointers.</p>
</li>
</ol>
<p>Then we shall have a fully <strong>Open Source Operating System for PineCone!</strong></p>
<p><em>How confident are we of porting Mynewt to PineCone BL602?</em></p>
<p>One year ago I <a href="https://lupyuen.github.io/articles/hey-gd32-vf103-on-risc-v-i-surrender-for-now">failed to port Mynewt</a> to an earlier RISC-V Microcontroller (GD32 VF103)</p>
<p><em>But Second Time‚Äôs The Charm!</em></p>
<p>PineCone‚Äôs BL602 Microcontroller runs on a RISC-V Core that‚Äôs similar to SiFive FE310. And porting Mynewt from FE310 to BL602 seems quick and easy. <a href="https://twitter.com/MisterTechBlog/status/1338759961526951937?s=19">(As seen on Twitter)</a></p>
<p>The port of Mynewt to PineCone BL602 continues here‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/mynewt.md"><code>lupyuen.github.io/src/mynewt.md</code></a></p>
<h1 id="appendix-load-firmware-to-cache-memory-not-flash-memory"><a href="#appendix-load-firmware-to-cache-memory-not-flash-memory">17 Appendix: Load Firmware to Cache Memory, not Flash Memory</a></h1>
<p><a href="https://lupyuen.github.io/articles/rust"><strong>UPDATE:</strong> We have a new way to create Rust Firmware with BL602 IoT SDK and flash to BL602 Flash Memory over UART, check this out</a></p>
<p><a href="https://github.com/9names/bl602-rust-example"><strong>UPDATE:</strong> Check out this Rust Firmware that runs in Flash Memory instead of Cache Memory</a></p>
<p><em>Why did we load our Mynewt Firmware (and Rust Firmware) to Cache Memory instead of Flash Memory?</em></p>
<p>Because OpenOCD couldn‚Äôt load our Mynewt Firmware (and Rust Firmware) into Flash Memory. </p>
<p>(Probably because of Flash Protection. Or because writing to BL602 Flash Memory hasn‚Äôt been implemented in OpenOCD.)</p>
<p><a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_Openocd&amp;GDB/en">BL602 OpenOCD with JTAG doesn‚Äôt support loading firmware into Flash Memory. See the BL602 OpenOCD Docs</a></p>
<p><em>What happens when we use <code>blflash</code> to load our firmware to Flash Memory?</em></p>
<p>We‚Äôre not sure if the Mynewt (or Rust) Firmware will run‚Ä¶ But it‚Äôs worth trying!</p>
<p>Make sure that we update the Memory Map to load our code into the XIP Flash Memory at <code>0x2300 0000</code>.</p>
<p>Note that the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602/evb/src/boot/gcc/start.S">Start Code from BL602 IoT SDK <code>start.S</code></a> references the Boot2 Bootloader.</p>
<p>We‚Äôre not sure why. Our Start Code from Mynewt (and Rust) doesn‚Äôt use the Boot2 Bootloader.</p>
<p><img src="https://lupyuen.github.io/images/mynewt-flash.png" alt="Loading Mynewt Firmware to Flash Memory" /></p>
<p><em>What happens when we use OpenOCD + JTAG to load our firmware to Flash Memory?</em></p>
<p>The screen above shows the first version of the Mynewt Firmware, that loads into Flash Memory.</p>
<p>We used this GDB command to dump out the first 10 words of PineCone‚Äôs Flash Memory‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>x/10x _reset_handler</code></pre></div>
<p>(<code>_reset_handler</code> is the function name of Mynewt‚Äôs Start Code, located at the start of our firmware)</p>
<p>When we compare the dumped data with our Firmware Disassembly, we see that the bytes don‚Äôt match.</p>
<p>Hence we deduce that our Mynewt Firmware wasn‚Äôt loaded correctly into Flash Memory.</p>
<p><img src="https://lupyuen.github.io/images/mynewt-ram.png" alt="Loading Mynewt Firmware to Cache Memory" /></p>
<p><em>What happens when we use OpenOCD + JTAG to load our firmware to Cache Memory?</em></p>
<p>Here‚Äôs the second try, loading our Mynewt Firmware to Cache Memory. (The same way that we loaded Rust Firmware in our previous article)</p>
<p>Entering the same GDB Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>x/10x _reset_handler</code></pre></div>
<p>We see that the data is identical. Our Mynewt Firmware is loaded correctly to Cache Memory indeed!</p>
<p><em>But we can‚Äôt run Mynewt Firmware in Cache Memory forever right?</em></p>
<p>The solution is to load our firmware to PineCone over USB (UART). (And flipping the jumper)</p>
<p>We may integrate with VSCode the command-line scripts for loading our firmware to PineCone.</p>
<p>Check out the article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/flash">‚ÄúFlashing Firmware to PineCone BL602‚Äù</a></li>
</ul>
<h1 id="appendix-install-newt"><a href="#appendix-install-newt">18 Appendix: Install newt</a></h1>
<p>We may install Mynewt‚Äôs <code>newt</code> tool according to the instructions here‚Ä¶</p>
<ul>
<li><a href="https://mynewt.apache.org/latest/newt/install/index.html">Installing <code>newt</code></a></li>
</ul>
<p>Or we may build from the source code‚Ä¶</p>
<h2 id="linux-and-macos"><a href="#linux-and-macos">18.1 Linux and macOS</a></h2>
<ol>
<li>
<p>Install the <a href="https://golang.org/dl/">latest version of Go</a></p>
</li>
<li>
<p>At a command prompt, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd /tmp
export mynewt_version=mynewt_1_8_0_tag
git clone --branch $mynewt_version https://github.com/apache/mynewt-newt/
cd mynewt-newt
./build.sh
sudo mv newt/newt /usr/local/bin
newt version</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Apache Newt 1.8.0</code></pre></div></li>
</ol>
<h2 id="windows"><a href="#windows">18.2 Windows</a></h2>
<p>The Windows version of <code>newt</code> is already bundled at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt\newt\newt.exe</code></pre></div>
<p>The build script <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/scripts/build-app.cmd"><code>build-app.cmd</code></a> uses the above <code>newt</code> executable.</p>
<p>However, the <code>newt</code> executable triggers a Windows Defender warning (because it wasn‚Äôt built as a certified executable). We need to <strong>update the Windows Security settings</strong> to allow the <code>newt</code> executable to run.</p>
<p>To build <code>newt</code> from the source code, follow these steps‚Ä¶</p>
<ol>
<li>
<p>Install the <a href="https://golang.org/dl/">latest version of Go</a></p>
</li>
<li>
<p>At a command prompt, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-cmd"><code>git clone --branch mynewt_1_8_0_tag https://github.com/apache/mynewt-newt/
cd mynewt-newt\newt
go build
newt.exe version</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Apache Newt 1.8.0</code></pre></div></li>
<li>
<p>Copy the <code>newt</code> executable from‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>mynewt-newt\newt\newt.exe</code></pre></div>
<p>To‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>pinecone-rust-mynewt\newt\newt.exe</code></pre></div></li>
</ol>
<p><img src="https://lupyuen.github.io/images/mynewt-windows.png" alt="Mynewt BL602 built with Windows CMD" /></p>
<p><em>Mynewt BL602 built with Windows CMD</em></p>
<h1 id="appendix-create-the-mynewt-firmware"><a href="#appendix-create-the-mynewt-firmware">19 Appendix: Create the Mynewt Firmware</a></h1>
<p>Mynewt Project <code>pinecone-rust-mynewt</code> and Mynewt Firmware <code>pinecone_app</code> were originally created using these steps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>newt new pinecone-rust-mynewt
cd pinecone-rust-mynewt
newt upgrade
newt target create pinecone_app
newt target set pinecone_app app=apps/blinky
# This will be changed to pinecone later
newt target set pinecone_app bsp=@apache-mynewt-core/hw/bsp/hifive1
newt target set pinecone_app build_profile=debug</code></pre></div>
<p>We don‚Äôt need to create them again, just download from‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinecone-rust-mynewt"><code>github.com/lupyuen/pinecone-rust-mynewt</code></a></li>
</ul>
<p>The steps above were based on the <a href="https://mynewt.apache.org/latest/tutorials/blinky/blinky_stm32f4disc.html">Blinky Tutorial for STM32F4-Discovery</a>.</p>
<p>I added this Git Modules file so that the Mynewt source files will be downloaded together with the repo‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/.gitmodules"><code>.gitmodules</code></a></li>
</ul>
<h1 id="appendix-vscode-settings"><a href="#appendix-vscode-settings">20 Appendix: VSCode Settings</a></h1><h2 id="debugger-settings"><a href="#debugger-settings">20.1 Debugger Settings</a></h2>
<p>The VSCode Debugger Settings may be found in <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/.vscode/launch.json"><code>.vscode/launch.json</code></a></p>
<p>This file defines‚Ä¶ </p>
<ul>
<li>
<p>Firmware Path (<code>target</code>)</p>
</li>
<li>
<p>GDB Path (<code>gdbpath</code>)</p>
</li>
<li>
<p>OpenOCD Path (in <code>autorun</code>, after <code>target remote</code>)</p>
</li>
<li>
<p>GDB Commands to be executed upon starting the debugger (<code>autorun</code>)</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-json"><code>{
    //  VSCode Debugger Config for PineCone BL602
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;BL602&quot;,
            &quot;type&quot;: &quot;gdb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            //  Application Executable to be flashed before debugging
            &quot;target&quot;: &quot;${workspaceRoot}/bin/targets/pinecone_app/app/apps/blinky/blinky.elf&quot;,
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
            &quot;gdbpath&quot;: &quot;${workspaceRoot}/xpack-riscv-none-embed-gcc/bin/riscv-none-embed-gdb&quot;,
            &quot;valuesFormatting&quot;: &quot;parseText&quot;,
            &quot;autorun&quot;: [
                //  Before loading the Application, run these gdb commands.
                //  Set timeout for executing openocd commands.
                &quot;set remotetimeout 600&quot;,

                //  This indicates that an unrecognized breakpoint location should automatically result in a pending breakpoint being created.
                &quot;set breakpoint pending on&quot;,

                //  Set breakpoints
                &quot;break main&quot;,                             //  Break at main()
                &quot;break __assert_func&quot;,                    //  Break for any C assert failures
                //  &quot;break os_default_irq&quot;,                   //  Break for any Mynewt unhandled interrupts
                //  &quot;break core::panicking::panic&quot;,       //  Break for any Rust assert failures and panics
                //  &quot;break core::result::unwrap_failed&quot;,  //  Break for any Rust unwrap and expect failures

                //  Launch OpenOCD. Based on https://www.justinmklam.com/posts/2017/10/vscode-debugger-setup/
                &quot;target remote | xpack-openocd/bin/openocd -c \&quot;gdb_port pipe; log_output openocd.log\&quot; -f openocd.cfg &quot;,

                //  Load the program into board memory
                &quot;load&quot;,

                //  Execute one RISC-V instruction and stop
                //  &quot;stepi&quot;,

                //  Run the program until we hit the main() breakpoint
                //  &quot;continue&quot;,
            ]
        }
    ]
}</code></pre></div><h2 id="task-settings"><a href="#task-settings">20.2 Task Settings</a></h2>
<p>The VSCode Task Settings may be found in <a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/.vscode/tasks.json"><code>.vscode/tasks.json</code></a></p>
<p>This file defines the VSCode Task for building the Mynewt Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            //  Build firmware
            &quot;label&quot;: &quot;Build Firmware&quot;,
            &quot;type&quot;: &quot;shell&quot;,
            &quot;windows&quot;: {
                &quot;command&quot;: &quot;cmd&quot;,
                &quot;args&quot;: [
                    &quot;/c&quot;,
                    &quot; newt build pinecone_app &amp;&amp; newt size -v pinecone_app &amp;&amp; echo ‚úÖ ‚óæ Ô∏èDone! &quot;
                ]
            },
            &quot;osx&quot;: {
                &quot;command&quot;: &quot;bash&quot;,
                &quot;args&quot;: [
                    &quot;-c&quot;, &quot;-l&quot;,
                    &quot; scripts/build-app.sh &amp;&amp; echo ‚úÖ ‚óæ Ô∏èDone! &quot;
                ]
            },
            &quot;linux&quot;: {
                &quot;command&quot;: &quot;bash&quot;,
                &quot;args&quot;: [
                    &quot;-c&quot;, &quot;-l&quot;,
                    &quot; scripts/build-app.sh &amp;&amp; echo ‚úÖ ‚óæ Ô∏èDone! &quot;
                ]
            },
            &quot;group&quot;: {
                &quot;kind&quot;: &quot;build&quot;,
                &quot;isDefault&quot;: true
            },
            &quot;problemMatcher&quot;: [ 
                {
                    //  Problem matcher for GNU Linker, e.g. /Users/Luppy/mynewt/stm32bluepill-mynewt-sensor/apps/my_sensor_app/src/ATParser.h:82: undefined reference to `operator delete[](void*)&#39;
                    &quot;fileLocation&quot;: [ &quot;absolute&quot; ],
                    &quot;pattern&quot;: {
                        &quot;regexp&quot;: &quot;^(/.*):(\\d+):\\s+(.*)$&quot;,
                        &quot;file&quot;: 1,
                        &quot;line&quot;: 2,
                        &quot;message&quot;: 3,
                        // &quot;code&quot;: 3,
                        // &quot;severity&quot;: 4,
                    }                    
                }
            ],
            &quot;presentation&quot;: {
                &quot;clear&quot;: true
            }
        },
        ...</code></pre></div>
<p><a href="https://github.com/lupyuen/pinecone-rust-mynewt/blob/main/scripts/build-app.sh"><code>scripts/build-app.sh</code></a> does the following‚Ä¶</p>
<ol>
<li>
<p>Terminate the OpenOCD process</p>
</li>
<li>
<p>Build the Mynewt Firmware</p>
</li>
<li>
<p>Display the firmware size</p>
</li>
</ol>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/env bash
#  macOS and Linux Bash script to build Mynewt Firmware

set -e  #  Exit when any command fails
set -x  #  Echo commands

#  Terminate any OpenOCD processes from the debug session
set +e  #  Ignore errors
pkill openocd
set -e  #  Stop on errors

#  Add GCC to the PATH
set +x  #  Stop echo
export PATH=&quot;$PWD/xpack-riscv-none-embed-gcc/bin:$PATH&quot;
set -x  #  Echo commands

#  Build the Mynewt Firmware
newt build pinecone_app

#  Display the firmware size
newt size -v pinecone_app</code></pre></div>
    
</body>
</html>