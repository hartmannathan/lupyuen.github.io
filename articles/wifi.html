<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Reverse Engineering WiFi on RISC-V BL602</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Reverse Engineering WiFi on RISC-V BL602" 
    data-rh="true">
<meta property="og:description" 
    content="What happens inside the WiFi Driver on RISC-V BL602... And how we found the incomplete source code for the driver"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/wifi-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Reverse Engineering WiFi on RISC-V BL602</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-wifi-demo-firmware">1 BL602 WiFi Demo Firmware</a><ul>
<li><a href="#register-wifi-event-handler">1.1 Register WiFi Event Handler</a><ul></ul></li>
<li><a href="#start-wifi-firmware-task">1.2 Start WiFi Firmware Task</a><ul></ul></li>
<li><a href="#start-wifi-manager-task">1.3 Start WiFi Manager Task</a><ul></ul></li>
<li><a href="#connect-to-wifi-network">1.4 Connect to WiFi Network</a><ul></ul></li>
<li><a href="#send-http-request">1.5 Send HTTP Request</a><ul></ul></li></ul></li>
<li><a href="#connect-to-wifi-access-point">2 Connect to WiFi Access Point</a><ul>
<li><a href="#send-request-to-wifi-manager-task">2.1 Send request to WiFi Manager Task</a><ul></ul></li>
<li><a href="#wifi-manager-state-machine">2.2 WiFi Manager State Machine</a><ul></ul></li>
<li><a href="#send-request-to-lmac">2.3 Send request to LMAC</a><ul></ul></li>
<li><a href="#trigger-lmac-interrupt">2.4 Trigger LMAC Interrupt</a><ul></ul></li></ul></li>
<li><a href="#decompiled-wifi-demo-firmware">3 Decompiled WiFi Demo Firmware</a><ul>
<li><a href="#linking-to-decompiled-code">3.1 Linking to decompiled code</a><ul></ul></li></ul></li>
<li><a href="#wifi-firmware-task">4 WiFi Firmware Task</a><ul>
<li><a href="#start-firmware-task">4.1 Start Firmware Task</a><ul></ul></li>
<li><a href="#schedule-kernel-events">4.2 Schedule Kernel Events</a><ul></ul></li>
<li><a href="#handle-transmit-payload">4.3 Handle Transmit Payload</a><ul></ul></li>
<li><a href="#another-transmit-payload">4.4 Another Transmit Payload</a><ul></ul></li></ul></li>
<li><a href="#ceva-rivierawaves">5 CEVA RivieraWaves</a><ul>
<li><a href="#upper-medium-access-control">5.1 Upper Medium Access Control</a><ul></ul></li>
<li><a href="#lower-medium-access-control">5.2 Lower Medium Access Control</a><ul></ul></li></ul></li>
<li><a href="#wifi-supplicant">6 WiFi Supplicant</a><ul></ul></li>
<li><a href="#wifi-physical-layer">7 WiFi Physical Layer</a><ul></ul></li>
<li><a href="#quantitative-analysis">8 Quantitative Analysis</a><ul>
<li><a href="#extract-the-decompiled-functions">8.1 Extract the decompiled functions</a><ul></ul></li>
<li><a href="#load-functions-into-spreadsheet">8.2 Load functions into spreadsheet</a><ul></ul></li>
<li><a href="#classify-the-decompiled-functions">8.3 Classify the decompiled functions</a><ul></ul></li>
<li><a href="#match-the-decompiled-functions">8.4 Match the decompiled functions</a><ul></ul></li>
<li><a href="#count-the-lines-of-code">8.5 Count the lines of code</a><ul></ul></li></ul></li>
<li><a href="#other-modules">9 Other Modules</a><ul></ul></li>
<li><a href="#github-search-is-our-best-friend">10 GitHub Search Is Our Best Friend!</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li></ul></nav><p>üìù <em>7 Jul 2021</em></p>
<p>Today we shall <strong>Reverse Engineer the WiFi Driver</strong> on the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V + WiFi SoC</strong></a> and learn what happens inside‚Ä¶ Guided by the (incomplete) source code that we found for the driver.</p>
<p>Why Reverse Engineer the BL602 WiFi Driver?</p>
<ol>
<li>
<p><strong>Education</strong>: To learn how WiFi Packets are transmitted and received on BL602.</p>
</li>
<li>
<p><strong>Troubleshooting</strong>: If the WiFi Driver doesn‚Äôt work right, we should be able to track down the problem. (Maybe fix it too!)</p>
</li>
<li>
<p><strong>Auditing</strong>: To be sure that WiFi Packets are transmitted / received correctly and securely. <a href="https://twitter.com/Yu_Wei_Wu/status/1406940637773979655?s=19">(See this non-BL602 example)</a></p>
</li>
<li>
<p><strong>Replacement</strong>: Perhaps one day we might replace the Closed-Source WiFi Driver by an Open Source driver. <a href="https://github.com/open-sdr/openwifi">(Maybe Openwifi?)</a></p>
</li>
</ol>
<p>Read on and join me on the Reverse Engineering journey!</p>
<p><img src="https://lupyuen.github.io/images/wifi-title.jpg" alt="Quantitative Analysis of Decompiled BL602 WiFi Firmware" /></p>
<h1 id="bl602-wifi-demo-firmware"><a href="#bl602-wifi-demo-firmware">1 BL602 WiFi Demo Firmware</a></h1>
<p>Let‚Äôs study the source code of the <strong>BL602 WiFi Demo Firmware</strong> from the BL602 IoT SDK: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi"><strong><code>bl602_demo_wifi</code></strong></a></p>
<p>In the demo firmware we shall‚Ä¶</p>
<ol>
<li>
<p>Register the <strong>WiFi Event Handler</strong> that will handle WiFi Events</p>
</li>
<li>
<p>Start the <strong>WiFi Firmware Task</strong> that will control the BL602 WiFi Firmware</p>
</li>
<li>
<p>Start the <strong>WiFi Manager Task</strong> that will manage the WiFi Connection State</p>
</li>
<li>
<p>Connect to a <strong>WiFi Access Point</strong></p>
</li>
<li>
<p>Send a <strong>HTTP Request</strong></p>
</li>
</ol>
<h2 id="register-wifi-event-handler"><a href="#register-wifi-event-handler">1.1 Register WiFi Event Handler</a></h2>
<p>When the firmware starts, we register a <strong>Callback Function that will handle WiFi Events</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi/bl602_demo_wifi/main.c#L819-L866"><code>main.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Called at startup to init drivers and run event loop
static void aos_loop_proc(void *pvParameters) {
  //  Omitted: Init the drivers
  ...
  //  Register Callback Function for WiFi Events
  aos_register_event_filter(
    EV_WIFI,              //  Event Type
    event_cb_wifi_event,  //  Event Callback Function
    NULL);                //  Event Callback Argument

  //  Start WiFi Networking Stack
  cmd_stack_wifi(NULL, 0, 0, NULL);

  //  Run event loop
  aos_loop_run();
}</code></pre></div>
<p>(We‚Äôll see <code>event_cb_wifi_event</code> in a while)</p>
<p>This startup code calls <strong><code>cmd_stack_wifi</code></strong> to start the WiFi Networking Stack.</p>
<p>Let‚Äôs look inside‚Ä¶</p>
<h2 id="start-wifi-firmware-task"><a href="#start-wifi-firmware-task">1.2 Start WiFi Firmware Task</a></h2>
<p>In <strong><code>cmd_stack_wifi</code></strong> we start the <strong>WiFi Firmware Task</strong> like so: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi/bl602_demo_wifi/main.c#L729-L747"><code>main.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Start WiFi Networking Stack
static void cmd_stack_wifi(char *buf, int len, int argc, char **argv) {
  //  Check whether WiFi Networking is already started
  static uint8_t stack_wifi_init  = 0;
  if (1 == stack_wifi_init) { return; }  //  Already started
  stack_wifi_init = 1;

  //  Start WiFi Firmware Task (FreeRTOS)
  hal_wifi_start_firmware_task();

  //  Post a WiFi Event to start WiFi Manager Task
  aos_post_event(
    EV_WIFI,                 //  Event Type
    CODE_WIFI_ON_INIT_DONE,  //  Event Code
    0);                      //  Event Argument
}</code></pre></div>
<p>(We‚Äôll cover <code>hal_wifi_start_firmware_task</code> later in this article)</p>
<p>After starting the task, we post the WiFi Event <code>CODE_WIFI_ON_INIT_DONE</code> to <strong>start the WiFi Manager Task</strong>.</p>
<p>Let‚Äôs look inside the WiFi Event Handler‚Ä¶</p>
<h2 id="start-wifi-manager-task"><a href="#start-wifi-manager-task">1.3 Start WiFi Manager Task</a></h2>
<p>Here‚Äôs how we handle <strong>WiFi Events</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi/bl602_demo_wifi/main.c#L374-L512"><code>main.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Callback Function for WiFi Events
static void event_cb_wifi_event(input_event_t *event, void *private_data) {

  //  Handle the WiFi Event
  switch (event-&gt;code) {

    //  Posted by cmd_stack_wifi to start Wi-Fi Manager Task
    case CODE_WIFI_ON_INIT_DONE:

      //  Start the WiFi Manager Task (FreeRTOS)
      wifi_mgmr_start_background(&amp;conf);
      break;

    //  Omitted: Handle other WiFi Events</code></pre></div>
<p>When we receive the WiFi Event <code>CODE_WIFI_ON_INIT_DONE</code>, we start the <strong>WiFi Manager Task</strong> (in FreeRTOS) by calling <code>wifi_mgmr_start_background</code>.</p>
<p><code>wifi_mgmr_start_background</code> comes from the BL602 WiFi Driver. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr.c#L1406-L1415">(See the source code)</a></p>
<h2 id="connect-to-wifi-network"><a href="#connect-to-wifi-network">1.4 Connect to WiFi Network</a></h2>
<p>Now that we have started both WiFi Background Tasks (WiFi Firmware Task and WiFi Manager Task), let‚Äôs connect to a WiFi Network!</p>
<p>The demo firmware lets us enter this command to <strong>connect to a WiFi Access Point</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>wifi_sta_connect YOUR_WIFI_SSID YOUR_WIFI_PASSWORD</code></pre></div>
<p>Here‚Äôs how the <strong><code>wifi_sta_connect</code></strong> command is implemented: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi/bl602_demo_wifi/main.c#L366-L372"><code>main.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Connect to WiFi Access Point
static void wifi_sta_connect(char *ssid, char *password) {

  //  Enable WiFi Client
  wifi_interface_t wifi_interface
    = wifi_mgmr_sta_enable();

  //  Connect to WiFi Access Point
  wifi_mgmr_sta_connect(
    wifi_interface,  //  WiFi Interface
    ssid,            //  SSID
    password,        //  Password
    NULL,            //  PMK
    NULL,            //  MAC Address
    0,               //  Band
    0);              //  Frequency
}</code></pre></div>
<p>We call <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr_ext.c#L202-L217"><strong><code>wifi_mgmr_sta_enable</code></strong></a> from the BL602 WiFi Driver to <strong>enable the WiFi Client</strong>.</p>
<p>(‚ÄúSTA‚Äù refers to ‚ÄúWiFi Station‚Äù, which means WiFi Client)</p>
<p>Then we call <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr_ext.c#L302-L307"><strong><code>wifi_mgmr_sta_connect</code></strong></a> (also from the BL602 WiFi Driver) to <strong>connect to the WiFi Access Point</strong>.</p>
<p>(We‚Äôll study the internals of <code>wifi_mgmr_sta_connect</code> in the next chapter)</p>
<h2 id="send-http-request"><a href="#send-http-request">1.5 Send HTTP Request</a></h2>
<p>Now we enter this command to <strong>send a HTTP Request</strong> over WiFi‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>httpc</code></pre></div>
<p>Here‚Äôs the implementation of the <strong><code>httpc</code></strong> command: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi/bl602_demo_wifi/main.c#L704-L727"><code>main.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Send a HTTP GET Request with LWIP
static void cmd_httpc_test(char *buf, int len, int argc, char **argv) {
  //  Check whether a HTTP Request is already running
  static httpc_connection_t settings;
  static httpc_state_t *req;
  if (req) { return; }  //  Request already running

  //  Init the LWIP HTTP Settings
  memset(&amp;settings, 0, sizeof(settings));
  settings.use_proxy = 0;
  settings.result_fn = cb_httpc_result;
  settings.headers_done_fn = cb_httpc_headers_done_fn;

  //  Send a HTTP GET Request with LWIP
  httpc_get_file_dns(
    &quot;nf.cr.dandanman.com&quot;,  //  Host
    80,                     //  Port
    &quot;/ddm/ContentResource/music/204.mp3&quot;,  //  URI
    &amp;settings,              //  Settings
    cb_altcp_recv_fn,       //  Callback Function
    &amp;req,                   //  Callback Argument
    &amp;req);                  //  Request
}</code></pre></div>
<p>On BL602 we use <a href="https://www.nongnu.org/lwip/2_1_x/index.html"><strong>LWIP, the Lightweight IP Stack</strong></a> to do IP, UDP, TCP and HTTP Networking.</p>
<p><a href="https://www.nongnu.org/lwip/2_1_x/group__httpc.html#gabd4ef2259885a93090733235cc0fa8d6"><code>httpc_get_file_dns</code> is documented here</a></p>
<p>For more details on the BL602 WiFi Demo Firmware, check out the docs‚Ä¶</p>
<ul>
<li><a href="https://pine64.github.io/bl602-docs/Examples/demo_wifi/wifi.html"><strong>BL602 WiFi Demo Firmware Docs</strong></a></li>
</ul>
<p>Let‚Äôs reverse engineer the BL602 WiFi Demo Firmware‚Ä¶ And learn what happens inside!</p>
<p><img src="https://lupyuen.github.io/images/wifi-connect.png" alt="Connecting to WiFi Access Point" /></p>
<h1 id="connect-to-wifi-access-point"><a href="#connect-to-wifi-access-point">2 Connect to WiFi Access Point</a></h1>
<p><em>What really happens when BL602 connects to a WiFi Access Point?</em></p>
<p>To understand how BL602 connects to a WiFi Access Point, let‚Äôs read the <strong>Source Code from the BL602 WiFi Driver</strong>.</p>
<p>Watch what happens as we‚Ä¶</p>
<ol>
<li>
<p>Send the Connect Request to the <strong>WiFi Manager Task</strong></p>
</li>
<li>
<p>Process the Connect Request with <strong>WiFi Manager‚Äôs State Machine</strong></p>
</li>
<li>
<p>Forward the Connect Request to the <strong>WiFi Hardware (LMAC)</strong></p>
</li>
<li>
<p>Trigger an <strong>LMAC Interrupt</strong> to perform the request</p>
</li>
</ol>
<h2 id="send-request-to-wifi-manager-task"><a href="#send-request-to-wifi-manager-task">2.1 Send request to WiFi Manager Task</a></h2>
<p>Earlier we called <strong><code>wifi_mgmr_sta_connect</code></strong> to connect to the WiFi Access Point.</p>
<p>Here‚Äôs what happens inside: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr_ext.c#L302-L307"><code>wifi_mgmr_ext.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Connect to WiFi Access Point
int wifi_mgmr_sta_connect(wifi_interface_t *wifi_interface, char *ssid, char *psk, char *pmk, uint8_t *mac, uint8_t band, uint16_t freq) {
  //  Set WiFi SSID and PSK
  wifi_mgmr_sta_ssid_set(ssid);
  wifi_mgmr_sta_psk_set(psk);

  //  Connect to WiFi Access Point
  return wifi_mgmr_api_connect(ssid, psk, pmk, mac, band, freq);
}</code></pre></div>
<p>We set the WiFi SSID and PSK. Then we call <code>wifi_mgmr_api_connect</code> to connect to the access point.</p>
<p><strong><code>wifi_mgmr_api_connect</code></strong> does this: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr_api.c#L40-L84"><code>wifi_mgmr_api.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Connect to WiFi Access Point
int wifi_mgmr_api_connect(char *ssid, char *psk, char *pmk, uint8_t *mac, uint8_t band, uint16_t freq) {
  //  Omitted: Copy PSK, PMK, MAC Address, Band and Frequency
  ...
  //  Send Connect Request to WiFi Manager Task
  wifi_mgmr_event_notify(msg);
  return 0;
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-connect2.png" alt="wifi_mgmr_api_connect" /></p>
<p>Here we call <code>wifi_mgmr_event_notify</code> to <strong>send the Connect Request</strong> to the WiFi Manager Task.</p>
<p><strong><code>wifi_mgmr_event_notify</code></strong> is defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr.c#L1332-L1343"><code>wifi_mgmr.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Send request to WiFi Manager Task
int wifi_mgmr_event_notify(wifi_mgmr_msg_t *msg) {
  //  Omitted: Wait for WiFi Manager to start
  ...
  //  Send request to WiFi Manager via Message Queue
  if (os_mq_send(
    &amp;(wifiMgmr.mq),  //  Message Queue
    msg,             //  Request Message
    msg-&gt;len)) {     //  Message Length
    //  Failed to send request
    return -1;
  }
  return 0;
}</code></pre></div>
<p><em>How does <code>os_mq_send</code> send the request to the WiFi Manager Task?</em></p>
<p><strong><code>os_mq_send</code></strong> calls FreeRTOS to deliver the Request Message to <strong>WiFi Manager‚Äôs Message Queue</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/os_hal.h#L174"><code>os_hal.h</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>#define os_mq_send(mq, msg, len) \
    (xMessageBufferSend(mq, msg, len, portMAX_DELAY) &gt; 0 ? 0 : 1)</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-connect3.png" alt="wifi_mgmr_event_notify" /></p>
<h2 id="wifi-manager-state-machine"><a href="#wifi-manager-state-machine">2.2 WiFi Manager State Machine</a></h2>
<p>The WiFi Manager runs a <strong>State Machine</strong> in its Background Task (FreeRTOS) to manage the state of each WiFi Connection.</p>
<p><em>What happens when WiFi Manager receives our request to connect to a WiFi Access Point?</em></p>
<p>Let‚Äôs find out in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/wifi_mgmr.c#L702-L745"><code>wifi_mgmr.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Called when WiFi Manager receives Connect Request
static void stateIdleAction_connect( void *oldStateData, struct event *event, void *newStateData) {
  //  Set the WiFi Profile for the Connect Request
  wifi_mgmr_msg_t *msg = event-&gt;data;
  wifi_mgmr_profile_msg_t *profile_msg = (wifi_mgmr_profile_msg_t*) msg-&gt;data;
  profile_msg-&gt;ssid_tail[0] = &#39;\0&#39;;
  profile_msg-&gt;psk_tail[0]  = &#39;\0&#39;;

  //  Remember the WiFi Profile in the WiFi Manager
  wifi_mgmr_profile_add(&amp;wifiMgmr, profile_msg, -1);

  //  Connect to the WiFi Profile. TODO: Other security support
  bl_main_connect(
    (const uint8_t *) profile_msg-&gt;ssid, profile_msg-&gt;ssid_len,
    (const uint8_t *) profile_msg-&gt;psk, profile_msg-&gt;psk_len,
    (const uint8_t *) profile_msg-&gt;pmk, profile_msg-&gt;pmk_len,
    (const uint8_t *) profile_msg-&gt;mac, (const uint8_t) profile_msg-&gt;band, (const uint16_t) profile_msg-&gt;freq);
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-connect4.png" alt="stateIdleAction_connect" /></p>
<p>Here we set the <strong>WiFi Profile</strong> and call <code>bl_main_connect</code> to connect to the profile.</p>
<p>In <strong><code>bl_main_connect</code></strong> we set the <strong>Connection Parameters for the 802.11 WiFi Protocol</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/bl_main.c#L189-L216"><code>bl_main.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Connect to the WiFi Profile
int bl_main_connect(const uint8_t* ssid, int ssid_len, const uint8_t *psk, int psk_len, const uint8_t *pmk, int pmk_len, const uint8_t *mac, const uint8_t band, const uint16_t freq) {

  //  Connection Parameters for 802.11 WiFi Protocol
  struct cfg80211_connect_params sme;    

  //  Omitted: Set the 802.11 Connection Parameters
  ...
  //  Connect to WiFi Network with the 802.11 Connection Parameters
  bl_cfg80211_connect(&amp;wifi_hw, &amp;sme);
  return 0;
}</code></pre></div>
<p>The Connection Parameters are passed to <strong><code>bl_cfg80211_connect</code></strong>, defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/bl_main.c#L539-L571"><code>bl_main.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Connect to WiFi Network with the 802.11 Connection Parameters
int bl_cfg80211_connect(struct bl_hw *bl_hw, struct cfg80211_connect_params *sme) {

  //  Will be populated with the connection result
  struct sm_connect_cfm sm_connect_cfm;

  //  Forward the Connection Parameters to the LMAC
  int error = bl_send_sm_connect_req(bl_hw, sme, &amp;sm_connect_cfm);

  //  Omitted: Check connection result</code></pre></div>
<p>Which calls <strong><code>bl_send_sm_connect_req</code></strong> to send the Connection Parameters to the <strong>WiFi Hardware (LMAC)</strong>.</p>
<p>Let‚Äôs dig in and find out how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wifi-connect5.png" alt="bl_send_sm_connect_req" /></p>
<h2 id="send-request-to-lmac"><a href="#send-request-to-lmac">2.3 Send request to LMAC</a></h2>
<p><em>What is LMAC?</em></p>
<p><strong>Lower Medium Access Control (LMAC)</strong> is the firmware that runs <strong>inside the BL602 WiFi Radio Hardware</strong> and executes the WiFi Radio functions. </p>
<p>(Like sending and receiving WiFi Packets)</p>
<p>To connect to a WiFi Access Point, we <strong>pass the Connection Parameters to LMAC</strong> by calling <strong><code>bl_send_sm_connect_req</code></strong>, defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/bl_msg_tx.c#L722-L804"><code>bl_msg_tx.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Forward the Connection Parameters to the LMAC
int bl_send_sm_connect_req(struct bl_hw *bl_hw, struct cfg80211_connect_params *sme, struct sm_connect_cfm *cfm) {

  //  Build the SM_CONNECT_REQ message
  struct sm_connect_req *req = bl_msg_zalloc(SM_CONNECT_REQ, TASK_SM, DRV_TASK_ID, sizeof(struct sm_connect_req));

  //  Omitted: Set parameters for the SM_CONNECT_REQ message
  ...
  //  Send the SM_CONNECT_REQ message to LMAC Firmware
  return bl_send_msg(bl_hw, req, 1, SM_CONNECT_CFM, cfm);
}</code></pre></div>
<p>Here we compose an <strong><code>SM_CONNECT_REQ</code></strong> message that contains the Connection Parameters.</p>
<p>(‚Äú<code>SM</code>‚Äù refers to the LMAC State Machine by RivieraWaves)</p>
<p>Then we call <strong><code>bl_send_msg</code></strong> to <strong>send the message to LMAC</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/bl_msg_tx.c#L315-L371"><code>bl_msg_tx.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Send message to LMAC Firmware
static int bl_send_msg(struct bl_hw *bl_hw, const void *msg_params, int reqcfm, lmac_msg_id_t reqid, void *cfm) {
  //  Omitted: Allocate a buffer for the message
  ...
  //  Omitted: Copy the message to the buffer
  ...
  //  Add the message to the LMAC Message Queue
  int ret = bl_hw-&gt;cmd_mgr.queue(&amp;bl_hw-&gt;cmd_mgr, cmd);</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-connect6.png" alt="bl_send_msg" /></p>
<p>The code above calls <strong><code>ipc_host_msg_push</code></strong> to <strong>add the message to the LMAC Message Queue</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/ipc_host.c#L139-L171"><code>ipc_host.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Add the message to the LMAC Message Queue.
//  IPC = Interprocess Communication
int ipc_host_msg_push(struct ipc_host_env_tag *env, void *msg_buf, uint16_t len) {
    //  Get the address of the IPC message buffer in Shared RAM
    uint32_t *src = (uint32_t*) ((struct bl_cmd *) msg_buf)-&gt;a2e_msg;
    uint32_t *dst = (uint32_t*) &amp;(env-&gt;shared-&gt;msg_a2e_buf.msg);

    //  Copy the message to the IPC message buffer
    for (int i = 0; i &lt; len; i += 4) { *dst++ = *src++; }
    env-&gt;msga2e_hostid = msg_buf;

    //  Trigger an LMAC Interrupt to send the message to EMB
    //  IPC_IRQ_A2E_MSG is 2
    ipc_app2emb_trigger_set(IPC_IRQ_A2E_MSG);</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-connect9.png" alt="ipc_host_msg_push" /></p>
<p>After copying the message to the LMAC Message Queue (in Shared RAM), we call <code>ipc_app2emb_trigger_set</code> to <strong>trigger an LMAC Interrupt</strong>.</p>
<p>LMAC (and the BL602 Radio Hardware) will then transmit the proper WiFi Packets to <strong>establish a network connection</strong> with the WiFi Access Point.</p>
<p>And that‚Äôs how BL602 connects to a WiFi Access Point!</p>
<p><img src="https://lupyuen.github.io/images/wifi-connect8.png" alt="ipc_app2emb_trigger_set" /></p>
<h2 id="trigger-lmac-interrupt"><a href="#trigger-lmac-interrupt">2.4 Trigger LMAC Interrupt</a></h2>
<p><em>But how do we trigger an LMAC Interrupt?</em></p>
<div class="example-wrap"><pre class="language-c"><code>//  Trigger an LMAC Interrupt to send the message to EMB
//  IPC_IRQ_A2E_MSG is 2
ipc_app2emb_trigger_set(IPC_IRQ_A2E_MSG);</code></pre></div>
<p>Let‚Äôs look inside <strong><code>ipc_app2emb_trigger_set</code></strong> and learn how it triggers an <strong>LMAC Interrupt</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/reg_ipc_app.h#L41-L69"><code>reg_ipc_app.h</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  WiFi Hardware Register Base Address
#define REG_WIFI_REG_BASE          0x44000000

//  IPC Hardware Register Base Address
#define IPC_REG_BASE_ADDR          0x00800000

//  APP2EMB_TRIGGER Register Definition
//  Bits    Field Name           Reset Value
//  -----   ------------------   -----------
//  31:00   APP2EMB_TRIGGER      0x0
#define IPC_APP2EMB_TRIGGER_ADDR   0x12000000
#define IPC_APP2EMB_TRIGGER_OFFSET 0x00000000
#define IPC_APP2EMB_TRIGGER_INDEX  0x00000000
#define IPC_APP2EMB_TRIGGER_RESET  0x00000000

//  Write to IPC Register
#define REG_IPC_APP_WR(env, INDEX, value) \
  (*(volatile u32 *) ((u8 *) env + IPC_REG_BASE_ADDR + 4*(INDEX)) \
    = value)

//  Trigger LMAC Interrupt
static inline void ipc_app2emb_trigger_set(u32 value) {
  //  Write to WiFi IPC Register at address 0x4480 0000
  REG_IPC_APP_WR(
    REG_WIFI_REG_BASE, 
    IPC_APP2EMB_TRIGGER_INDEX, 
    value);
}</code></pre></div>
<p>This code triggers an LMAC Interrupt by writing to the <strong>WiFi Hardware Register</strong> (for Interprocess Communication) at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>REG_WIFI_REG_BASE + IPC_REG_BASE_ADDR + 4 * IPC_APP2EMB_TRIGGER_INDEX</code></pre></div>
<p>Which gives us address <strong><code>0x4480 0000</code></strong></p>
<p><em>Wait‚Ä¶ Is address <code>0x4480 0000</code> documented anywhere?</em></p>
<p>Nope it‚Äôs not documented in the <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>BL602 Reference Manual</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wifi-connect7.png" alt="Undocumented WiFi Hardware Registers" /></p>
<p>In fact the entire region of <strong>WiFi Hardware Registers at <code>0x4400 0000</code></strong> is undocumented.</p>
<p>We‚Äôve just uncovered a BL602 WiFi Secret! ü§´</p>
<h1 id="decompiled-wifi-demo-firmware"><a href="#decompiled-wifi-demo-firmware">3 Decompiled WiFi Demo Firmware</a></h1>
<p><em>Are we really Reverse Engineering the BL602 WiFi Driver?</em></p>
<p>Not quite. So far we‚Äôve been reading the <strong>published source code</strong> for the BL602 WiFi Driver.</p>
<p><em>Can we do some serious Reverse Engineering now?</em></p>
<p>Most certainly! A big chunk of the BL602 WiFi Driver <strong>doesn‚Äôt come with any source code.</strong></p>
<p>(Like the functions for WiFi WPA Authentication)</p>
<p>But <a href="https://github.com/BraveHeartFLOSSDev"><strong><code>BraveHeartFLOSSDev</code></strong></a> did an excellent job decompiling into C (with Ghidra) the BL602 WiFi Demo Firmware‚Ä¶</p>
<ul>
<li><a href="https://github.com/BraveHeartFLOSSDev/bl602nutcracker1"><strong>BraveHeartFLOSSDev/bl602nutcracker1</strong></a></li>
</ul>
<p><a href="https://github.com/lupyuen/bl602nutcracker1">(We‚Äôll use this fork)</a></p>
<p>We shall now study this Decompiled C Code‚Ä¶ And do some serious Reverse Engineering of the BL602 WiFi Driver!</p>
<p><a href="https://ghidra-sre.org/">More about Ghidra</a></p>
<p><a href="https://github.com/BraveHeartFLOSSDev/GhidWork">Ghidra configuration for BL602</a></p>
<h2 id="linking-to-decompiled-code"><a href="#linking-to-decompiled-code">3.1 Linking to decompiled code</a></h2>
<p>Sadly GitHub won‚Äôt show our huge Decompiled C Files in the web browser. So <strong>deep-linking to specific lines of code</strong> will be a problem.</p>
<p>Here‚Äôs the workaround for deep-linking‚Ä¶</p>
<ol>
<li>
<p>Download the repo of Decompiled C Files‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>git clone --recursive https://github.com/lupyuen/bl602nutcracker1</code></pre></div></li>
<li>
<p>When we see a link like this‚Ä¶</p>
<blockquote>
<p>This is the decompiled code: <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L38512-L38609"><code>bl602_demo_wifi.c</code></a></p>
</blockquote>
<p><strong>Right-click</strong> (or long press) the link.</p>
<p>Select <strong><code>Copy Link Address</code></strong></p>
</li>
<li>
<p><strong>Paste the address</strong> into a text editor.</p>
<p>We will see this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L38512-L38609</code></pre></div></li>
<li>
<p>Note that the address ends with‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_demo_wifi.c#L38512-L38609</code></pre></div></li>
<li>
<p>This means that we should‚Ä¶</p>
<p>Open the downloaded source file <strong><code>bl602_demo_wifi.c</code></strong> in our code editor (like VSCode)</p>
<p>And jump to line number <strong><code>38512</code></strong> (use Ctrl-G)</p>
</li>
<li>
<p>And we shall see the referenced Decompiled C Code‚Ä¶</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/wifi-assert.png" alt="Assertions" /></p>
<h1 id="wifi-firmware-task"><a href="#wifi-firmware-task">4 WiFi Firmware Task</a></h1>
<p>The BL602 WiFi Driver operates with two Background Tasks (FreeRTOS)‚Ä¶</p>
<ul>
<li>
<p><strong>WiFi Manager Task</strong>: Manages the WiFi Connection State</p>
</li>
<li>
<p><strong>WiFi Firmware Task</strong>: Controls the WiFi Firmware</p>
</li>
</ul>
<p>We‚Äôve covered the WiFi Manager Task. (Remember the State Machine?)</p>
<p>Now we dive into the WiFi Firmware Task. Watch what happens as we‚Ä¶</p>
<ol>
<li>
<p>Start the <strong>WiFi Firmware Task</strong></p>
</li>
<li>
<p><strong>Schedule Kernel Events</strong> to handle WiFi Packets</p>
</li>
<li>
<p>Handle the <strong>transmission of WiFi Packets</strong></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/wifi-task.png" alt="Starting the WiFi Firmware Task" /></p>
<h2 id="start-firmware-task"><a href="#start-firmware-task">4.1 Start Firmware Task</a></h2>
<p>Earlier we saw <code>cmd_stack_wifi</code> calling <code>hal_wifi_start_firmware_task</code> to start the Firmware Task.</p>
<p>Let‚Äôs look inside <strong><code>hal_wifi_start_firmware_task</code></strong> now: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_wifi.c#L41-L49"><code>hal_wifi.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Start WiFi Firmware Task (FreeRTOS)
int hal_wifi_start_firmware_task(void) {
  //  Stack space for the WiFi Firmware Task
  static StackType_t wifi_fw_stack[WIFI_STACK_SIZE];

  //  Task Handle for the WiFi Firmware Task
  static StaticTask_t wifi_fw_task;

  //  Create a FreeRTOS Background Task
  xTaskCreateStatic(
    wifi_main,         //  Task will run this function
    (char *) &quot;fw&quot;,     //  Task Name
    WIFI_STACK_SIZE,   //  Task Stack Size
    NULL,              //  Task Parameters
    TASK_PRIORITY_FW,  //  Task Priority
    wifi_fw_stack,     //  Task Stack
    &amp;wifi_fw_task);    //  Task Handle
  return 0;
}</code></pre></div>
<p>This creates a <strong>FreeRTOS Background Task</strong> that runs the function <strong><code>wifi_main</code></strong> forever.</p>
<p><em>What‚Äôs inside <code>wifi_main</code>?</em></p>
<p>We don‚Äôt have the source code for <code>wifi_main</code>. But thanks to <a href="https://github.com/BraveHeartFLOSSDev"><code>BraveHeartFLOSSDev</code></a> we have the C code decompiled from the BL602 WiFi Firmware!</p>
<p>Here‚Äôs <strong><code>wifi_main</code></strong> from the Decompiled C Code: <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L32959-L33006"><code>bl602_demo_wifi.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  WiFi Firmware Task runs this forever
void wifi_main(void *param) {
  ...
  //  Init the LMAC and UMAC
  rfc_init(40000000);
  mpif_clk_init();
  sysctrl_init();
  intc_init();
  ipc_emb_init();
  bl_init();
  ...
  //  Loop forever handling WiFi Kernel Events
  do {
    ...
    //  Wait for something (?)
    if (ke_env.evt_field == 0) { ipc_emb_wait(); }
    ...
    //  Schedule a WiFi Kernel Event and handle it
    ke_evt_schedule();

    //  Sleep for a while
    iVar1 = bl_sleep();

    //  (Whaaat?)
    coex_wifi_pta_forece_enable((uint) (iVar1 == 0));
  } while( true );
}</code></pre></div>
<p>The actual Decompiled C Code for <code>wifi_main</code> looks a lot noisier‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wifi-task2.png" alt="wifi_main" /></p>
<p>So we picked the highlights for our Reverse Engineering.</p>
<p>(And we added some annotations too)</p>
<p><strong><code>wifi_main</code></strong> loops forever handling <strong>WiFi Kernel Events</strong>, to transmit and receive WiFi Packets.</p>
<p>(‚Äú<code>ke</code>‚Äù refers to the WiFi Kernel, the heart of the WiFi Driver)</p>
<p><code>wifi_main</code> calls <strong><code>ke_evt_schedule</code></strong> to handle WiFi Kernel Events.</p>
<p>Let‚Äôs lookup <code>ke_evt_schedule</code> in our Decompiled C Code: <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L28721-L28737"><code>bl602_demo_wifi.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Schedule a WiFi Kernel Event and handle it
void ke_evt_schedule(void) {
  int iVar1;
  evt_ptr_t *peVar2;
  
  while (ke_env.evt_field != 0) {
    iVar1 = __clzsi2(ke_env.evt_field);
    peVar2 = ke_evt_hdlr[iVar1].func;
    if ((0x1a &lt; iVar1) || (peVar2 == (evt_ptr_t *)0x0)) {
      assert_err(&quot;(event &lt; KE_EVT_MAX) &amp;&amp; ke_evt_hdlr[event].func&quot;,&quot;module&quot;,0xdd);
    }
    (*peVar2)(ke_evt_hdlr[iVar1].param);
  }
  //  This line is probably incorrectly decompiled
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}</code></pre></div>
<p>This decompiled code does‚Ä¶ something something something.</p>
<p>Thankfully <a href="https://en.wikipedia.org/wiki/One_weird_trick_advertisements">This One Weird Trick</a> will help us understand this cryptic decompiled code‚Ä¶ <strong>GitHub Search!</strong></p>
<p><img src="https://lupyuen.github.io/images/wifi-schedule2.png" alt="Searching for ke_evt_schedule" /></p>
<h2 id="schedule-kernel-events"><a href="#schedule-kernel-events">4.2 Schedule Kernel Events</a></h2>
<p><em>Is it possible that <code>ke_evt_schedule</code> wasn‚Äôt invented for BL602?</em></p>
<p><em>Maybe <code>ke_evt_schedule</code> was created for something else?</em></p>
<p>Bingo! Let‚Äôs do a <strong>GitHub Search</strong> for <code>ke_evt_schedule</code>!</p>
<ul>
<li>
<p><a href="https://github.com/search?o=desc&amp;q=ke_evt_schedule&amp;s=indexed&amp;type=Code"><strong>GitHub Code Search for <code>ke_evt_schedule</code></strong></a></p>
<p>(Search results are sorted by recently indexed)</p>
</li>
</ul>
<p>We‚Äôll see this <strong><code>ke_evt_schedule</code></strong> code from <strong>AliOS Things</strong> (the embedded OS) and <strong>RivieraWaves</strong> (explained next chapter): <a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/ke/ke_event.c#L203-L231"><code>ke_event.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Event scheduler entry point. This primitive has to be 
//  called in the background loop in order to execute the 
//  event handlers for the event that are set.
void ke_evt_schedule(void) {
  uint32_t field, event;
  field = ke_env.evt_field;
  while (field) { // Compiler is assumed to optimize with loop inversion

    // Find highest priority event set
    event = co_clz(field);

    // Sanity check
    ASSERT_ERR((event &lt; KE_EVT_MAX) &amp;&amp; ke_evt_hdlr[event].func);

    // Execute corresponding handler
    (ke_evt_hdlr[event].func)(ke_evt_hdlr[event].param);

    // Update the volatile value
    field = ke_env.evt_field;
  }
}</code></pre></div>
<p>Compare this with our <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L28721-L28737"><strong>decompiled version of <code>ke_evt_schedule</code></strong></a>‚Ä¶ It‚Äôs a <strong>perfect match</strong>!</p>
<p>Right down to the <strong>Assertion Check</strong>!</p>
<div class="example-wrap"><pre class="language-text"><code>(event &lt; KE_EVT_MAX) &amp;&amp; ke_evt_hdlr[event].func</code></pre></div>
<p>Since the two versions of <code>ke_evt_schedule</code> are functionally identical, let‚Äôs read the <strong>AliOS / RivieraWaves version of <code>ke_evt_schedule</code></strong>.</p>
<p><img src="https://lupyuen.github.io/images/wifi-task3.png" alt="ke_evt_schedule from AliOS / RivieraWaves" /></p>
<p>We see that <strong><code>ke_evt_schedule</code></strong> handles WiFi Kernel Events by calling the <strong>Event Handlers in <code>ke_evt_hdlr</code></strong>.</p>
<p>Here are the <strong><code>ke_evt_hdlr</code></strong> Event Handlers from the AliOS / RivieraWaves code: <a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/ke/ke_event.c#L78-L138"><code>ke_event.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Event Handlers called by ke_evt_schedule
static const struct ke_evt_tag ke_evt_hdlr[32] = {
  {&amp;rwnxl_reset_evt,    0},      // [KE_EVT_RESET]	
  {&amp;ke_timer_schedule,  0},      // [KE_EVT_KE_TIMER]   
  {&amp;txl_payload_handle, AC_VO},  // [KE_EVT_IPC_EMB_TXDESC_AC3]

  //  This Event Handler looks interesting                                                      
  {&amp;txl_payload_handle, AC_VI},  // [KE_EVT_IPC_EMB_TXDESC_AC2]
  {&amp;txl_payload_handle, AC_BE},  // [KE_EVT_IPC_EMB_TXDESC_AC1]
  {&amp;txl_payload_handle, AC_BK},  // [KE_EVT_IPC_EMB_TXDESC_AC0]	

  {&amp;ke_task_schedule,   0},      // [KE_EVT_KE_MESSAGE]
  {&amp;mm_hw_idle_evt,     0},      // [KE_EVT_HW_IDLE]
  ...</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-task4.png" alt="txl_payload_handle Event Handler" /></p>
<p><strong><code>txl_payload_handle</code></strong> is the Event Handler that handles the <strong>transmission of WiFi Payloads</strong>.</p>
<p>Let‚Äôs look inside and learn how it transmits WiFi Packets.</p>
<p><img src="https://lupyuen.github.io/images/wifi-task5.png" alt="txl_payload_handle doesn‚Äôt do much" /></p>
<h2 id="handle-transmit-payload"><a href="#handle-transmit-payload">4.3 Handle Transmit Payload</a></h2>
<p><em>What is <code>txl_payload_handle</code>?</em></p>
<p>Thanks to the AliOS / RivieraWaves source code, we have a meaningful description of the <strong><code>txl_payload_handle</code></strong> function: <a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/tx/txl/txl_cntrl.h#L377-L386"><code>txl_cntrl.h</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Perform operations on payloads that have been 
//  transfered from host memory. This primitive is 
//  called by the interrupt controller ISR. It 
//  performs LLC translation and MIC computing if required.
//  LLC = Logical Link Control, MIC = Message Integrity Code
void txl_payload_handle(int access_category);</code></pre></div>
<p>This suggests that <code>txl_payload_handle</code> is called to <strong>transmit WiFi Packets</strong>‚Ä¶ After the packet payload has been copied from BL602 to the Radio Hardware. (Via the <strong>Shared RAM Buffer</strong>)</p>
<p>Searching our decompiled code for <strong><code>txl_payload_handle</code></strong> shows this: <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L20205-L20216"><code>bl602_demo_wifi.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Handle transmit payload
void txl_payload_handle(void) {
  while ((_DAT_44a00024 &amp; 0x1f) != 0) {
    int iVar1 = __clzsi2(_DAT_44a00024 &amp; 0x1f);

    //  Write to WiFi Register at 0x44A0 0020
    _DAT_44a00020 = 1 &lt;&lt; (0x1fU - iVar1 &amp; 0x1f);
  }
}</code></pre></div>
<p>It doesn‚Äôt seem to do much payload processing.  But it writes to the undocumented <strong>WiFi Register at <code>0x44A0 0020</code></strong>.</p>
<p>Which will trigger the <strong>LMAC Firmware to transmit</strong> the WiFi Packet perhaps?</p>
<p>But hold up! We have something that might explain what‚Äôs inside <code>txl_payload_handle</code>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wifi-task6.png" alt="txl_payload_handle_backup" /></p>
<h2 id="another-transmit-payload"><a href="#another-transmit-payload">4.4 Another Transmit Payload</a></h2>
<p>Right after <code>txl_payload_handle</code> in our decompiled code, there‚Äôs a function <strong><code>txl_payload_handle_backup</code></strong>.</p>
<p>Based on the name, <code>txl_payload_handle_backup</code> is probably another function that handles payload transmission.</p>
<p>Here are the highlights of the decompiled <code>txl_payload_handle_backup</code> function: <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L20222-L20398"><code>bl602_demo_wifi.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Another transmit payload handler.
//  Probably works the same way as txl_payload_handle,
//  but runs on BL602 instead of LMAC Firmware.
void txl_payload_handle_backup(void) {
  ...
  //  Iterate through a list of packet buffers (?)
  while (ptVar4 = ptVar10-&gt;list[0].first, ptVar4 == (txl_buffer_tag *)0x0) {
LAB_230059f6:
    uVar3 = uVar3 + 1;
    ptVar10 = (txl_buffer_env_tag *)&amp;ptVar10-&gt;buf_idx[0].free_size;
    ptVar11 = (txl_cntrl_env_tag *)(ptVar11-&gt;txlist + 1);
  }</code></pre></div>
<p><strong><code>txl_payload_handle_backup</code></strong> starts by iterating through a list of packet buffers to be transmitted. (Probably)</p>
<p>Then it calls some <strong>RXU, TXL and TXU functions from RivieraWaves</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Loop (until when?)
  do {
    //  Call some RXU, TXL and TXU functions
    rxu_cntrl_monitor_pm((mac_addr *)&amp;ptVar4[1].lenheader);
    ...
    txl_machdr_format((uint32_t)(ptVar4 + 1));
    ...
    txu_cntrl_tkip_mic_append(txdesc,(uint8_t)uVar2);</code></pre></div>
<p>(More about RivieraWaves in the next chapter)</p>
<p>Next we write to some undocumented <strong>WiFi Registers: <code>0x44B0 8180</code>, <code>0x44B0 8198</code>, <code>0x44B0 81A4</code> and <code>0x44B0 81A8</code></strong> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Write to WiFi Registers
    _DAT_44b08180 = 0x800;
    _DAT_44b081a4 = ptVar9;
    ...
    _DAT_44b08180 = 0x1000;
    _DAT_44b081a8 = ptVar9;
    ...
    _DAT_44b08180 = 0x100;
    _DAT_44b08198 = ptVar9;</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver/reg_access.h">(They don‚Äôt appear in this list either)</a></p>
<p>The function performs some <strong>Assertion Checks</strong>. </p>
<p>The Assertion Failure Messages may be helpful for deciphering the decompiled code‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Assertion Checks
    line = 0x23c;
    condition = &quot;blmac_tx_ac_2_state_getf() != 2&quot;;
    ...
    line = 0x236;
    condition = &quot;blmac_tx_ac_3_state_getf() != 2&quot;;
    ...
    line = 0x22f;
    condition = &quot;blmac_tx_bcn_state_getf() != 2&quot;;
    ...
    line = 0x242;
    condition = &quot;blmac_tx_ac_1_state_getf() != 2&quot;;
    ...
    line = 0x248;
    condition = &quot;blmac_tx_ac_0_state_getf() != 2&quot;;
    ...
    assert_rec(condition, &quot;module&quot;, line);</code></pre></div>
<p>The function ends by <strong>setting a timer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Set a timer
    blmac_abs_timer_set(uVar6, (uint32_t)(puVar8 + _DAT_44b00120));

    //  Continue looping
  } while( true );
}</code></pre></div>
<p><em>Is the original source code for <code>txl_payload_handle_backup</code> really so long?</em></p>
<p>Likely not. The C Compiler optimises the firmware code by inlining some functions.</p>
<p>When we decompile the firmware, the inlined code appears embedded inside the calling functions. </p>
<p>(That‚Äôs why we see so much repetition in the decompiled code)</p>
<p>Let‚Äôs talk about RivieraWaves‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wifi-schedule3.png" alt="RivieraWaves in AliOS" /></p>
<h1 id="ceva-rivierawaves"><a href="#ceva-rivierawaves">5 CEVA RivieraWaves</a></h1>
<p>When we searched GitHub for the <strong>WiFi Event Scheduler <code>ke_evt_schedule</code></strong>, we found this source code‚Ä¶</p>
<ul>
<li><a href="https://github.com/mclown/AliOS-Things/tree/master/platform/mcu/bk7231u/beken/ip"><strong>mclown/AliOS-Things</strong></a></li>
</ul>
<p><a href="https://github.com/lupyuen/AliOS-Things/tree/master/platform/mcu/bk7231u/beken/ip">(We‚Äôll use this fork)</a></p>
<p>This appears to be the source code for the <strong>AliOS Things embedded OS</strong>.</p>
<p><a href="http://www.bekencorp.com/en/goods/detail/cid/13.html">(Ported to the Beken BK7231U WiFi SoC)</a></p>
<p>But at the top of the <a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/ke/ke_event.c">source file</a> we see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Copyright (C) RivieraWaves 2011-2016</code></pre></div>
<p>This means that the WiFi source code originates from <strong>CEVA RivieraWaves, not AliOS</strong>!</p>
<p><img src="https://lupyuen.github.io/images/wifi-lmac3.jpg" alt="CEVA RivieraWaves" /></p>
<p><a href="https://www.ceva-dsp.com/product/rivierawaves-wi-fi-platforms/">(Source)</a></p>
<p><em>What is CEVA RivieraWaves?</em></p>
<p>RivieraWaves is the <strong>Software / Firmware that implements the 802.11 Wireless Protocol</strong> on WiFi SoCs (like BL602).</p>
<p>On BL602 there are two layers of RivieraWaves Firmware‚Ä¶</p>
<ol>
<li>
<p><strong>Upper Medium Access Control (UMAC)</strong></p>
<p>Runs on the <strong>BL602 RISC-V CPU.</strong></p>
<p>Some of the code we‚Äôve seen earlier comes from UMAC.</p>
<p>(Like the Kernel Event Scheduler)</p>
</li>
<li>
<p><strong>Lower Medium Access Control (LMAC)</strong></p>
<p>Runs inside the <strong>BL602 Radio Hardware.</strong></p>
<p>We don‚Äôt have any LMAC code to study since it‚Äôs hidden inside the Radio Hardware.</p>
<p>(But we can see the LMAC Interfaces exposed by the WiFi Registers)</p>
</li>
</ol>
<p><a href="https://www.controleng.com/articles/wi-fi-and-the-osi-model/">More about WiFi Medium Access Control</a></p>
<p><a href="https://www.ceva-dsp.com/product/rivierawaves-wi-fi-platforms/">More about RivieraWaves</a></p>
<p><em>Is RivieraWaves used elsewhere?</em></p>
<p>Yes, RivieraWaves is used in many popular WiFi SoCs.</p>
<p>This article hints at the WiFi SoCs that might be using RivieraWaves (or similar code by CEVA)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/wifi-ceva.png" alt="Customers of RivieraWaves" /></p>
</blockquote>
<p><a href="https://csimarket.com/stocks/markets_glance.php?code=CEVA#:~:text=Included%20among%20our%20licensees%20are,%2C%20RDA%2C%20Renesas%2C%20Rockchip%2C">(Source)</a></p>
<h2 id="upper-medium-access-control"><a href="#upper-medium-access-control">5.1 Upper Medium Access Control</a></h2>
<p>Recall that <strong>UMAC (Upper Medium Access Control)</strong> is the RivieraWaves code that runs on the <strong>BL602 RISC-V CPU</strong>.</p>
<p>When we match the decompiled BL602 WiFi Firmware with the AliOS / RivieraWaves code, we discover the Source Code for the <strong>UMAC Modules (and Common Modules) that are used in BL602</strong>‚Ä¶</p>
<ol>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/common">CO Module</a> (Common)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/ke">KE Module</a> (Kernel)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/umac/src/me">ME Module</a> (Message?)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/umac/src/rc">RC Module</a> (Rate Control)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/umac/src/rxu">RXU Module</a> (Receive UMAC)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/umac/src/scanu">SCANU Module</a> (Scan SSID UMAC)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/umac/src/sm">SM Module</a> (State Machine)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/umac/src/txu">TXU Module</a> (Transmit UMAC)</li>
</ol>
<p>These modules are <strong>mostly identical across BL602 and AliOS / RivieraWaves</strong>. (Except RXU, which looks different)</p>
<p>(More about UMAC Matching when we discuss Quantitative Analysis)</p>
<p><img src="https://lupyuen.github.io/images/wifi-rivierawaves.png" alt="Compare BL602 with RivieraWaves" /></p>
<h2 id="lower-medium-access-control"><a href="#lower-medium-access-control">5.2 Lower Medium Access Control</a></h2>
<p>Remember that <strong>LMAC (Lower Medium Access Control)</strong> is the RivieraWaves code that runs inside the <strong>BL602 Radio Hardware</strong>.</p>
<p>By matching the decompiled BL602 WiFi Firmware with the AliOS / RivieraWaves code, we discover the <strong>LMAC Interfaces that are exposed by the BL602 Radio Hardware</strong>‚Ä¶</p>
<ol>
<li>APM Interface (Missing from AliOS)</li>
<li>CFG Interface (Missing from AliOS)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/chan">CHAN Interface</a> (MAC Channel Mgmt)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/hal">HAL Interface</a> (Hardware Abstraction Layer)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/mm">MM Interface</a> (MAC Mgmt)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/rx/rxl">RXL Interface</a> (Receive LMAC)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/sta">STA Interface</a> (Station Mgmt)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/tx/txl">TXL Interface</a> (Transmit LMAC)</li>
</ol>
<p>The LMAC Interfaces linked above are for reference only‚Ä¶ The <strong>BL602 implementation of LMAC is very different</strong> from the Beken BK7231U implementation above.</p>
<p>These LMAC Modules seem to be <strong>mostly identical across BL602 and AliOS / RivieraWaves</strong>‚Ä¶</p>
<ol>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/ps">PS Module</a> (Power Save)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/scan">SCAN Module</a> (Scan SSID)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/td">TD Module</a> (Traffic Detection)</li>
<li><a href="https://github.com/lupyuen/AliOS-Things/blob/master/platform/mcu/bk7231u/beken/ip/lmac/src/vif">VIF Module</a> (Virtual Interface)</li>
</ol>
<p>(More about LMAC Matching when we discuss Quantitative Analysis)</p>
<p><img src="https://lupyuen.github.io/images/wifi-supplicant2.jpg" alt="WiFi Supplicant: Rockchip RK3399 vs BL602" /></p>
<h1 id="wifi-supplicant"><a href="#wifi-supplicant">6 WiFi Supplicant</a></h1>
<p><em>What‚Äôs the WiFi Supplicant?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Wireless_supplicant"><strong>WiFi Supplicant</strong></a> is the code that handles WiFi Authentication.</p>
<p><a href="https://en.wikipedia.org/wiki/Wpa_supplicant">(Like for WPA and WPA2)</a></p>
<p><em>So WiFi Supplicant comes from RivieraWaves right?</em></p>
<p>Nope. Based on the decompiled code, <strong>BL602 implements its own WiFi Supplicant</strong> with functions like <code>supplicantInit</code>, <code>allocSupplicantData</code> and <code>keyMgmtGetKeySize</code>. <a href="https://lupyuen.github.io/images/wifi-supplicant.png">(See this)</a></p>
<p><em>Maybe the WiFi Supplicant code came from another project?</em></p>
<p>When we <a href="https://github.com/search?o=desc&amp;q=supplicantInit+allocSupplicantData+keyMgmtGetKeySize&amp;s=indexed&amp;type=Code"><strong>search GitHub for the function names</strong></a>, we discover this matching source code‚Ä¶</p>
<ul>
<li><a href="https://github.com/karthirockz/rk3399-kernel/tree/main/drivers/net/wireless/rockchip_wlan/mvl88w8977/mlan/esa"><strong>karthirockz/rk3399-kernel</strong></a></li>
</ul>
<p><a href="https://github.com/lupyuen/rk3399-kernel/tree/main/drivers/net/wireless/rockchip_wlan/mvl88w8977/mlan/esa">(We‚Äôll use this fork)</a></p>
<p>That‚Äôs actually the <strong>WiFi Supplicant for Rockchip RK3399</strong>, based on Linux!</p>
<p><em>Are they really the same code?</em></p>
<p>We compared the decompiled BL602 WiFi Supplicant code with the Rockchip RK3399 source code‚Ä¶ They are <strong>nearly 100% identical</strong>! <a href="https://lupyuen.github.io/images/wifi-supplicant2.png">(See this)</a></p>
<p>This is awesome because we have just uncovered the secret origin of (roughly) <strong>2,500 Lines of Code</strong> from the decompiled BL602 firmware!</p>
<p>(This data comes from the <strong>Quantitative Analysis</strong>, which we‚Äôll discuss in a while)</p>
<p><img src="https://lupyuen.github.io/images/wifi-rockchip.jpg" alt="WiFi Supplicant: Lines of code" /></p>
<h1 id="wifi-physical-layer"><a href="#wifi-physical-layer">7 WiFi Physical Layer</a></h1>
<p><em>What‚Äôs the WiFi Physical Layer?</em></p>
<p><strong>WiFi Physical layer</strong> is the wireless protocol that controls the airwaves and dictates how WiFi Packets should be transmitted and received.</p>
<p>(It operates underneath the Medium Access Control Layer)</p>
<p><a href="https://www.controleng.com/articles/wi-fi-and-the-osi-model/">More about WiFi Physical Layer</a></p>
<p><em>Lemme guess‚Ä¶ BL602 doesn‚Äôt use RivieraWaves for the WiFi Physical Layer?</em></p>
<p>Nope we don‚Äôt think the BL602 Physical Layer comes from RivieraWaves.</p>
<p>The origin of <strong>BL602‚Äôs Physical Layer is a little murky</strong>‚Ä¶</p>
<p><em>How so?</em></p>
<p>Here‚Äôs a snippet of <strong>BL602 Physical Layer</strong> from the decompiled code: <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c#L33527-L33614"><code>bl602_demo_wifi.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  From BL602 Decompiled Code: Init Physical Layer
void phy_init(phy_cfg_tag *config) {
  mdm_reset();
  ...
  mdm_txcbwmax_setf((byte)(_DAT_44c00000 &gt;&gt; 0x18) &amp; 3);
  _Var2 = phy_vht_supported();
  agc_config();
  ...
  // Init transmitter rate power control
  trpc_init();

  // Init phy adaptive features
  pa_init();

  phy_tcal_reset();
  phy_tcal_start();
}</code></pre></div>
<p>When we <a href="https://github.com/search?q=phy_init+phy_hw_set_channel&amp;type=code"><strong>search GitHub for <code>phy_init</code> and <code>phy_hw_set_channel</code></strong></a> (another BL602 function), we get one meaningful result‚Ä¶</p>
<ul>
<li><a href="https://github.com/jixinintelligence/bl602-604"><strong>jixinintelligence/bl602-604</strong></a></li>
</ul>
<p><a href="https://github.com/lupyuen/bl602-604">(We‚Äôll use this fork)</a></p>
<p>Which implements <code>phy_init</code> like so: <a href="https://github.com/lupyuen/bl602-604/blob/master/components/bl602/bl602_wifi/plf/refip/src/driver/phy/bl602_phy_rf/phy_bl602.c#L474-L492"><code>phy_bl602.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  From GitHub Search: Init Physical Layer
void phy_init(const struct phy_cfg_tag *config) {
  const struct phy_bl602_cfg_tag *cfg = (const struct phy_bl602_cfg_tag *)&amp;config-&gt;parameters;
  phy_hw_init(cfg);
  phy_env-&gt;cfg               = *cfg;
  phy_env-&gt;band              = PHY_BAND_2G4;
  phy_env-&gt;chnl_type         = PHY_CHNL_BW_OTHER;
  phy_env-&gt;chnl_prim20_freq  = PHY_UNUSED;
  phy_env-&gt;chnl_center1_freq = PHY_UNUSED;
  phy_env-&gt;chnl_center2_freq = PHY_UNUSED;

  // Init transmitter rate power control
  trpc_init();

  // Init phy adaptive features
  pa_init();
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/wifi-phy.png" alt="BL602 Physical Layer" /></p>
<p>Comparing the BL602 decompiled code with the GitHub Search Result‚Ä¶ The <strong>BL602 code seems to be doing a lot more</strong>?</p>
<p>(Where are the calls to <code>mdm_reset</code>, <code>phy_tcal_reset</code> and <code>phy_tcal_start</code>?)</p>
<p>Thus <strong>we don‚Äôt have a 100% match</strong> for the BL602 Physical Layer. (Maybe 50%)</p>
<p>Nonetheless this is a helpful discovery for our Reverse Engineering!</p>
<p><img src="https://lupyuen.github.io/images/wifi-quantify.png" alt="Extracting the function names from the decompiled firmware" /></p>
<h1 id="quantitative-analysis"><a href="#quantitative-analysis">8 Quantitative Analysis</a></h1>
<p><em>How many Lines of Decompiled Code do we actually need to decipher?</em></p>
<p><em>How much of the BL602 WiFi Source Code is already available elsewhere?</em></p>
<p>To answer these questions, let‚Äôs do a <strong>Quantitative Analysis of the Decompiled BL602 Firmware Code</strong>.</p>
<p>(Yep that‚Äôs the fancy term for <strong>data crunching with a spreadsheet</strong>)</p>
<p>We shall‚Ä¶</p>
<ol>
<li>
<p><strong>Extract the function names</strong> from the decompiled BL602 WiFi Demo Firmware</p>
</li>
<li>
<p><strong>Load the decompiled function names</strong> into a spreadsheet for analysis</p>
</li>
<li>
<p><strong>Classify the decompiled function names</strong> by module</p>
</li>
<li>
<p><strong>Match the decompiled function code</strong> with the source code we‚Äôve discovered through GitHub Search</p>
</li>
<li>
<p><strong>Count the number of lines of decompiled code</strong> that don‚Äôt have any matching source code</p>
</li>
</ol>
<h2 id="extract-the-decompiled-functions"><a href="#extract-the-decompiled-functions">8.1 Extract the decompiled functions</a></h2>
<p>Our <strong>BL602 WiFi Demo Firmware <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_demo_wifi"><code>bl602_demo_wifi</code></a></strong> has been decompiled into one giant C file‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.c"><strong>Decompiled WiFi Demo Firmware <code>bl602_demo_wifi.c</code></strong></a></li>
</ul>
<p>We run this command to <strong>extract the Function Names</strong> and their Line Numbers (for counting the Lines of Code)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>grep --line-number \
    &quot;^[_a-zA-Z]&quot; \
    bl602_demo_wifi.c \
    | grep -v LAB_ \
    &gt;bl602_demo_wifi.txt</code></pre></div>
<p>This produces <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.txt"><strong><code>bl602_demo_wifi.txt</code></strong></a>, a long list of Decompiled Function Names and their Line Numbers. <a href="https://lupyuen.github.io/images/wifi-quantify.png">(Here‚Äôs a snippet)</a></p>
<p>(Plus Function Parameters and Type Definitions‚Ä¶ We‚Äôll scrub them away soon)</p>
<p><em>But this list includes EVERYTHING‚Ä¶ Including the non-WiFi functions no?</em></p>
<p>Yes. But it‚Äôs fun to comb through <strong>Every Single Function in the Decompiled Firmware</strong> (128,000 Lines of Code)‚Ä¶ Just to see what makes it tick.</p>
<p><em>Why not just decompile and analyse the BL602 WiFi Library: <a href="https://github.com/pine64/bl602-re/tree/master/blobs"><code>libbl602_wifi.a</code></a> ?</em></p>
<p>The <a href="https://github.com/pine64/bl602-re/tree/master/blobs"><strong>BL602 WiFi Library <code>libbl602_wifi.a</code></strong></a> might contain some extra WiFi Functions that won‚Äôt get linked into the WiFi Firmware.</p>
<p>Hence we‚Äôre decompiling and analysing the <strong>actual WiFi Functions called by the WiFi Firmware</strong>.</p>
<p>(BTW: Our counting of Lines of Code will include Blank Lines and Comment Lines)</p>
<p><img src="https://lupyuen.github.io/images/wifi-quantify2.png" alt="Loading decompiled function names into a spreadsheet" /></p>
<h2 id="load-functions-into-spreadsheet"><a href="#load-functions-into-spreadsheet">8.2 Load functions into spreadsheet</a></h2>
<p>We load <a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.txt"><strong><code>bl602_demo_wifi.txt</code></strong></a> (the list of Decompiled Function Names and Line Numbers) into a spreadsheet for analysis. (See pic above)</p>
<p>Here‚Äôs our <strong>spreadsheet for Quantitative Analysis</strong> in various formats‚Ä¶</p>
<ul>
<li>
<p><a href="https://docs.google.com/spreadsheets/d/1C_XmkH-ZSXz9-V2HsYBv7K1KRx3RF3-zsoJRLh1GwxI/edit?usp=sharing">Google Sheets</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.ods">LibreOffice / OpenOffice Format</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.xlsx">Excel Format</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602nutcracker1/blob/main/bl602_demo_wifi.csv">CSV Format (raw data only)</a></p>
</li>
</ul>
<p>We scrub the data to remove the Type Definitions, Function Return Types and the Function Parameters.</p>
<p>Based on the Line Numbers, we compute the <strong>Lines of Code</strong> for each function (including Blank Lines and Comment Lines).</p>
<p>And apply <strong>Conditional Formatting</strong> to highlight the Decompiled Functions with the most Lines of Code. (Which are also the <strong>Most Complex Functions</strong>)</p>
<p>These are the functions we should pay more attention during the analysis.</p>
<p><img src="https://lupyuen.github.io/images/wifi-quantify3.png" alt="Classify the decompiled functions" /></p>
<h2 id="classify-the-decompiled-functions"><a href="#classify-the-decompiled-functions">8.3 Classify the decompiled functions</a></h2>
<p>Next we <strong>classify each Decompiled Function by Module</strong>.</p>
<p>The pic above shows that we‚Äôve classified the ‚Äú<code>rxl_</code>‚Äù functions as ‚Äú<code>???RivieraWaves RXL</code>‚Äù. (RXL means Receive LMAC)</p>
<p>We use ‚Äú<code>???</code>‚Äù to mark the Modules that we couldn‚Äôt find any source code.</p>
<p><em>Doing this for all 3,000 Decompiled Functions sounds tedious‚Ä¶?</em></p>
<p>Fortunately the Decompiled Functions belonging to a Module are <strong>clustered together</strong>. So it‚Äôs easy to copy and fill the Module Name for a batch of functions.</p>
<p>Remember our red highlighting for Complex Functions? It‚Äôs OK to <strong>skip the classification of the Less Complex Functions</strong> (if we‚Äôre not sure how to classify them).</p>
<p>In our spreadsheet we‚Äôve <strong>classified over 97,000 Decompiled Lines of Code</strong>. That‚Äôs <strong>86%</strong> of all Decompiled Lines of Code. Good enough for our analysis!</p>
<p><img src="https://lupyuen.github.io/images/wifi-quantify5.png" alt="Matching the decompiled function code" /></p>
<h2 id="match-the-decompiled-functions"><a href="#match-the-decompiled-functions">8.4 Match the decompiled functions</a></h2>
<p>Remember the source code we‚Äôve discovered earlier through <strong>GitHub Search</strong>?</p>
<p>(For RivieraWaves, WiFi Supplicant and Physical Layer)</p>
<p>Now we dive into the Discovered Source Code and see <strong>how closely they match the Decompiled Functions</strong>.</p>
<p><em>How do we record our findings?</em></p>
<p>Inside our spreadsheet is a column that records the <strong>Source Code URL</strong> (from GitHub Search) that we‚Äôve matched with our Decompiled Functions. (See pic above)</p>
<p>We‚Äôve also added a comment that says <strong>how closely they match</strong>. (‚ÄúBL602 version is different‚Äù)</p>
<p>If the Discovered Source Code doesn‚Äôt match the Decompiled Function, we <strong>flag the Module Name</strong> with ‚Äú<code>???</code>‚Äù.</p>
<p><em>Do we need to match every Decompiled Function?</em></p>
<p>To simplify the matching, we picked one or two of the <strong>Most Complex Functions from each Module</strong>.</p>
<p>(Yep the red highlighting really helps!)</p>
<p>Thus our matching is not 100% thorough and accurate‚Ä¶ But it‚Äôs reasonably accurate.</p>
<p><img src="https://lupyuen.github.io/images/wifi-title.jpg" alt="Counting the decompiled lines of code in BL602 WiFi Firmware" /></p>
<h2 id="count-the-lines-of-code"><a href="#count-the-lines-of-code">8.5 Count the lines of code</a></h2>
<p>Finally we add a <strong>Pivot Table to count the Lines of Code</strong> that are matched (or unmatched) with GitHub Search.</p>
<p>In the second tab of our spreadsheet, we see the Pivot Table that summarises the <strong>results of our Quantitative Analysis</strong>‚Ä¶</p>
<ol>
<li>
<p>Lines of Code to be <strong>Reverse Engineered: 10,500</strong></p>
<p>Not found on GitHub Search: <strong>LMAC Interface</strong>, and some parts of WiFi Supplicant.</p>
<p><img src="https://lupyuen.github.io/images/wifi-loc1.png" alt="Decompiled lines of code to be reverse engineered" /></p>
</li>
<li>
<p>Lines of Code for <strong>Partial Reverse Engineering: 3,500</strong></p>
<p>We found partial matches for the <strong>Physical Layer</strong> on GitHub Search.</p>
<p><img src="https://lupyuen.github.io/images/wifi-loc2.png" alt="Decompiled lines of code for partial reverse enginnering" /></p>
<p>(We‚Äôll talk about BL602 HAL and Standard Driver in the next chapter)</p>
</li>
<li>
<p>Lines of Code <strong>Already Found Elsewhere: 11,300</strong> (Wow!)</p>
<p>Found on GitHub Search: <strong>UMAC and most of WiFi Supplicant</strong></p>
<p><img src="https://lupyuen.github.io/images/wifi-loc3.png" alt="Decompiled lines of code already found elsewhere" /></p>
</li>
<li>
<p>We also have <strong>7,500</strong> Lines of Code from parts of the <strong>BL602 WiFi Driver</strong> whose source code may be found in the <strong>BL602 IoT SDK</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/bl602/bl602_wifidrv/bl60x_wifi_driver">(See this)</a></p>
<p>Includes the <strong>WiFi Manager</strong> that we‚Äôve seen earlier.</p>
<p><img src="https://lupyuen.github.io/images/wifi-loc8.png" alt="Lines of code for BL602 WiFi Driver" /></p>
</li>
</ol>
<p>Conclusion: We have <strong>plenty of source code</strong> to guide us for the <strong>Reverse Engineering of BL602 WiFi</strong>!</p>
<h1 id="other-modules"><a href="#other-modules">9 Other Modules</a></h1>
<p>WiFi Functions make up <strong>29%</strong> of the total Lines of Code in our Decompiled WiFi Firmware.</p>
<p><em>What‚Äôs inside the other 71% of the Decompiled Code?</em></p>
<p>Let‚Äôs run through the <strong>Non-WiFi Functions in our Decompiled Firmware</strong>‚Ä¶</p>
<p>(Complex modules are highlighted in red)</p>
<p><img src="https://lupyuen.github.io/images/wifi-loc7.png" alt="Decompiled lines of code" /></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/fs"><strong>AliOS</strong></a>: Embedded framework for multitasking and device drivers</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/3rdparty/aws-iot"><strong>AWS IoT, AWS MQTT</strong></a>: Demo Firmware talks to AWS Cloud for IoT and MQTT (Message Queue) Services</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/hal_drv/bl602_hal"><strong>BL602 Hardware Abstraction Layer (HAL)</strong></a>: Functions for Bootloader, DMA, GPIO, Flash Memory, Interrupts, Real Time Clock, Security (Encryption), UART, ‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/bl602/bl602_std/bl602_std/StdDriver"><strong>BL602 Standard Driver</strong></a>: Called by the BL602 Hardware Abstraction Layer to access the BL602 Hardware Registers</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/toolchain/riscv/Linux/lib/gcc/riscv64-unknown-elf/8.3.0/rv32imf/ilp32f"><strong>C Standard Library</strong></a>: Because our firmware is compiled with the GCC Compiler</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/stage/easyflash4/inc/easyflash.h"><strong>EasyFlash</strong></a>: Embedded database</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/bl602/freertos_riscv"><strong>FreeRTOS</strong></a>: Embedded OS that runs underneath AliOS</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/network"><strong>Lightweight IP (LWIP)</strong></a>: For IP, UDP, TCP and HTTP Networking</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/components/security/mbedtls"><strong>Mbed TLS</strong></a>: Implements Transport Layer Security, needed by AWS IoT and MQTT</p>
</li>
</ul>
<p>Source code is available for most of the Non-WiFi Functions.</p>
<p>(Just click the links above)</p>
<p><img src="https://lupyuen.github.io/images/wifi-schedule.png" alt="GitHub Code Search" /></p>
<h1 id="github-search-is-our-best-friend"><a href="#github-search-is-our-best-friend">10 GitHub Search Is Our Best Friend!</a></h1>
<p>Today we‚Äôve learnt a valuable lesson‚Ä¶ <strong>GitHub Search is our Best Friend for Reverse Engineering</strong>!</p>
<p>Here‚Äôs what we have discovered through GitHub Search‚Ä¶</p>
<ol>
<li>
<p>Source Code for <strong>UMAC and LMAC</strong></p>
<p><a href="https://github.com/search?o=desc&amp;q=ke_evt_schedule&amp;s=indexed&amp;type=Code">GitHub Code Search for <code>ke_evt_schedule</code></a></p>
</li>
<li>
<p>Source Code for <strong>WiFi Supplicant</strong></p>
<p><a href="https://github.com/search?o=desc&amp;q=supplicantInit+allocSupplicantData+keyMgmtGetKeySize&amp;s=indexed&amp;type=Code">GitHub Code Search for <code>supplicantInit</code>, <code>allocSupplicantData</code> and <code>keyMgmtGetKeySize</code></a></p>
</li>
<li>
<p>Source Code for <strong>Physical Layer</strong></p>
<p><a href="https://github.com/search?q=phy_init+phy_hw_set_channel&amp;type=code">GitHub Code Search for <code>phy_init</code> and <code>phy_hw_set_channel</code></a></p>
</li>
</ol>
<p>Remember to check GitHub Search when doing any Reverse Engineering! üëç </p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>This has been a thrilling journey‚Ä¶ Many Thanks to the contributors of the <a href="https://github.com/pine64/bl602-re"><strong>Pine64 BL602 Reverse Engineering Project</strong></a> for inspiring this article!</p>
<p>Today we‚Äôve done some Reverse Engineering for the purpose of <strong>Education</strong>‚Ä¶ Just to understand how BL602 sends and receives WiFi Packets.</p>
<p>And we now understand how to sniff around the Decompiled WiFi Firmware to <strong>uncover every WiFi Hardware Register</strong>.</p>
<p>I hope someone will continue the Reverse Engineering work‚Ä¶ Maybe create an <strong>Open Source WiFi Driver for BL602</strong>!</p>
<p><a href="https://github.com/pine64/bl602-re">(Perhaps we should revive the <strong>Pine64 BL602 Nutcracker Project</strong>)</a></p>
<p>In the next article we shall check out the <strong>BL706 Audio Video Board</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bl706"><strong>‚ÄúRISC-V BL706 Audio Video Board‚Äù</strong></a></li>
</ul>
<p>Stay tuned for more articles on BL602, BL604 and BL706!</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/ofj34x/reverse_engineering_wifi_on_riscv_bl602/?utm_source=share&amp;utm_medium=web2x&amp;context=3">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/wifi.md"><code>lupyuen.github.io/src/wifi.md</code></a></p>
<p><img src="https://lupyuen.github.io/images/bl706.jpg" alt="BL706 Audio Video Board" /></p>
<p><em>BL706 Audio Video Board</em></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1407971263088193540">this Twitter Thread</a></p>
</li>
<li>
<p>According to <a href="https://twitter.com/madushan1000/status/1409392882612637696">madushan1000 on Twitter</a>, the <strong>BL602 WiFi RTL</strong> may be found here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/fengmaoqiao/my_logic_code">fengmaoqiao/my_logic_code</a></p>
</li>
<li>
<p><a href="https://github.com/fengmaoqiao/workplace">fengmaoqiao/workplace</a></p>
</li>
<li>
<p><a href="https://twitter.com/madushan1000/status/1412694106816585728?s=19">More tips on BL602 WiFi and Bluetooth LE</a></p>
</li>
</ul>
</li>
<li>
<p>More about <strong>BL602 RF IP and Hardware Registers</strong>:</p>
<ul>
<li>
<p><a href="https://github.com/pine64/bl602-docs/tree/main/hardware_notes#rf-ip">Hardware Notes: RF IP</a></p>
</li>
<li>
<p><a href="https://github.com/pine64/bl602-docs/blob/main/hardware_notes/registers/phy/mdm.md">Hardware Notes: MDM Registers</a></p>
</li>
<li>
<p><a href="https://github.com/pine64/bl602-docs/blob/main/hardware_notes/registers/phy/agc.md">Hardware Notes: AGC Registers</a></p>
</li>
</ul>
</li>
<li>
<p>There‚Äôs an interesting discussion about the <strong>licensing of the WiFi Supplicant</strong>, which looks identical to the Linux version on Rockchip RK3399‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wifi-licence.png" alt="Licensing of the WiFi Supplicant" /></p>
<p><a href="https://news.ycombinator.com/item?id=27763031">(Source)</a></p>
</li>
<li>
<p>ESP32 uses CEVA‚Äôs Bluetooth IP but not CEVA‚Äôs WiFi IP, according to <a href="https://twitter.com/SpritesMods/status/1412308410226286598?s=19">SpritesMods on Twitter</a></p>
</li>
</ol>

    
</body>
</html>