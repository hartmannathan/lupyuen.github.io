<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Ox64 BL808 SBC: NuttX Apps and Initial RAM Disk</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Ox64 BL808 SBC: NuttX Apps and Initial RAM Disk" 
    data-rh="true">
<meta property="og:description" 
    content="(1) What's inside an Application for Apache NuttX RTOS (2) How it calls the NuttX Kernel (3) How NuttX Apps are bundled into the Initial RAM Disk for Pine64 Ox64 BL808 RISC-V SBC"
    data-rh="true">
<meta name="description" 
    content="(1) What's inside an Application for Apache NuttX RTOS (2) How it calls the NuttX Kernel (3) How NuttX Apps are bundled into the Initial RAM Disk for Pine64 Ox64 BL808 RISC-V SBC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/app-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/app.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Ox64 BL808 SBC: NuttX Apps and Initial RAM Disk</h1>
    <nav id="TOC"><ul>
<li><a href="#start-nuttx-apps">1 Start NuttX Apps</a><ul></ul></li>
<li><a href="#inside-a-nuttx-app">2 Inside a NuttX App</a><ul></ul></li>
<li><a href="#nuttx-app-calls-nuttx-kernel">3 NuttX App calls NuttX Kernel</a><ul></ul></li>
<li><a href="#kernel-handles-app-call">4 Kernel Handles App Call</a><ul></ul></li>
<li><a href="#kernel-accesses-user-memory">5 Kernel Accesses User Memory</a><ul></ul></li>
<li><a href="#initial-ram-disk">6 Initial RAM Disk</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>30 Nov 2023</em></p>
<p><img src="https://lupyuen.github.io/images/app-title.png" alt="TODO" /></p>
<p>TODO</p>
<p><a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 64-bit RISC-V SBC</strong></a>. (Pic below)</p>
<p>(Powered by <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Bouffalo Lab BL808 SoC</strong></a>)</p>
<p><a href="https://lupyuen.github.io/articles/ox2"><strong>Apache NuttX RTOS</strong></a>. (Real-Time Operating System)</p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)" /></p>
<p><a href="https://wiki.pine64.org/wiki/Ox64"><em>Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)</em></a></p>
<h1 id="start-nuttx-apps"><a href="#start-nuttx-apps">1 Start NuttX Apps</a></h1>
<p>TODO</p>
<p>NuttX Kernel starts a NuttX App (in ELF Format) by calling‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L84-L94"><strong>ELF Loader: g_elfbinfmt</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L225-L355"><strong>elf_loadbinary</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/libelf/libelf_load.c#L297-L445"><strong>elf_load</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/libelf/libelf_addrenv.c#L56-L178"><strong>elf_addrenv_alloc</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_addrenv.c#L339-L490"><strong>up_addrenv_create</strong></a>, which calls‚Ä¶</p>
<p>(Also calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_mmu.h#L152-L176"><strong>mmu_satp_reg</strong></a> to set SATP Register)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_addrenv.c#L213-L310"><strong>create_region</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_mmu.c#L62-L109"><strong>mmu_ln_setentry</strong></a> to populate the Page Table Entries</p>
</li>
</ul>
<p><em>Who calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L84-L94">ELF Loader g_elfbinfmt</a> to start the NuttX App?</em></p>
<p>Earlier we stepped through the <strong>Boot Sequence</strong> for NuttX‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow"><strong>‚ÄúNuttX Boot Flow‚Äù</strong></a></li>
</ul>
<p>Right after that, <a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_bringup.c#L373-L458"><strong>nx_bringup</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_bringup.c#L330-L367"><strong>nx_create_initthread</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_bringup.c#L212C1-L302"><strong>nx_start_application</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_exec.c#L183-L223"><strong>exec_spawn</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_exec.c#L42-L179"><strong>exec_internal</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_loadmodule.c#L136-L225"><strong>load_module</strong></a> and‚Ä¶</p>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_execmodule.c#L190-L450"><strong>exec_module</strong></a></p>
</li>
</ul>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_loadmodule.c#L136-L225"><strong>load_module</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_loadmodule.c#L83-L132"><strong>load_absmodule</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/master/include/nuttx/binfmt/binfmt.h#L122-L148"><strong>binfmt_s.load</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L84-L94"><strong>ELF Loader: g_elfbinfmt</strong></a> to load the ELF File (explained above)</p>
</li>
</ul>
<h1 id="inside-a-nuttx-app"><a href="#inside-a-nuttx-app">2 Inside a NuttX App</a></h1>
<p>TODO</p>
<p><em>What‚Äôs inside the simplest app for NuttX?</em></p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/ox64b/examples/hello/hello_main.c#L36-L40">hello_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int main(int argc, FAR char *argv[]) {
  printf(&quot;Hello, World!!\n&quot;);
  return 0;
}
</code></pre></div>
<p>Here‚Äôs the RISC-V Disassembly: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/ox64a-1/hello.S">hello.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>000000000000003e &lt;main&gt;:
main():
apps/examples/hello/hello_main.c:37
/****************************************************************************
 * hello_main
 ****************************************************************************/

int main(int argc, FAR char *argv[])
{
  3e:	1141                	addi	sp,sp,-16
apps/examples/hello/hello_main.c:38
  printf(&quot;Hello, World!!\n&quot;);
  40:	00000517          	auipc	a0,0x0	40: R_RISCV_PCREL_HI20	.LC0
	40: R_RISCV_RELAX	*ABS*
  44:	00050513          	mv	a0,a0	44: R_RISCV_PCREL_LO12_I	.L0 
	44: R_RISCV_RELAX	*ABS*

0000000000000048 &lt;.LVL1&gt;:
apps/examples/hello/hello_main.c:37
{
  48:	e406                	sd	ra,8(sp)
apps/examples/hello/hello_main.c:38
  printf(&quot;Hello, World!!\n&quot;);
  4a:	00000097          	auipc	ra,0x0	4a: R_RISCV_CALL	puts
	4a: R_RISCV_RELAX	*ABS*
  4e:	000080e7          	jalr	ra # 4a &lt;.LVL1+0x2&gt;

0000000000000052 &lt;.LVL2&gt;:
apps/examples/hello/hello_main.c:40
  return 0;
}
  52:	60a2                	ld	ra,8(sp)
  54:	4501                	li	a0,0
  56:	0141                	addi	sp,sp,16
  58:	8082                	ret
</code></pre></div>
<p>We see that <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/ox64b/examples/hello/hello_main.c#L36-L40">main</a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_puts.c#L34-L96">puts</a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_libfwrite.c#L45-L200">lib_fwrite_unlocked</a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_libfwrite.c#L145">stream-&gt;fs_iofunc.write</a> OR‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_libfwrite.c#L149">write</a> (See below)</p>
</li>
</ul>
<p>TODO: Which one?</p>
<p>TODO: _start prepares sig_trampoline and calls main</p>
<p><em>This code doesn‚Äôt look right‚Ä¶</em></p>
<div class="example-wrap"><pre class="language-text"><code>apps/examples/hello/hello_main.c:38
  printf(&quot;Hello, World!!\n&quot;);
  4a:	00000097          	auipc	ra,0x0
  4e:	000080e7          	jalr	ra
</code></pre></div>
<p>That‚Äôs because this is <strong>Relocatable Code</strong>. The auipc offset will be fixed up by the NuttX ELF Loader when it loads this code into User Memory.</p>
<p>The Relocation Info shows that 0x0 will be replaced by the address of <code>puts</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  4a:	00000097          	auipc	ra,0x0
  4a: R_RISCV_CALL	puts
  4e:	000080e7          	jalr	ra
</code></pre></div>
<p><em>Why <code>puts</code> instead of <code>printf</code>?</em></p>
<p>The GCC Compiler has cleverly optimised away <code>printf</code> to become <code>puts</code>.</p>
<p>If we do this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  printf(&quot;Hello, World %s!!\n&quot;, &quot;Luppy&quot;);
</code></pre></div>
<p>Then <code>printf</code> will appear in our disassembly.</p>
<h1 id="nuttx-app-calls-nuttx-kernel"><a href="#nuttx-app-calls-nuttx-kernel">3 NuttX App calls NuttX Kernel</a></h1>
<p>TODO</p>
<p><a href="https://nuttx.apache.org/docs/latest/components/syscall.html">Syscall Layer</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/syscall/syscall.csv#L209-L210">syscall.csv</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/include/sys/syscall_lookup.h#L202">syscall_lookup.h</a></p>
<p>Our NuttX App calls <code>write</code>, which is a Proxy Version‚Ä¶</p>
<p>From nuttx/syscall/proxies/PROXY_write.c</p>
<div class="example-wrap"><pre class="language-c"><code>/* Auto-generated write proxy file -- do not edit */

#include &lt;nuttx/config.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syscall.h&gt;

ssize_t write(int parm1, FAR const void * parm2, size_t parm3)
{
  return (ssize_t)sys_call3((unsigned int)SYS_write, (uintptr_t)parm1, (uintptr_t)parm2, (uintptr_t)parm3);
}
</code></pre></div>
<p>Proxy for <code>write</code> calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/include/syscall.h">sys_call3</a>, which makes an <code>ecall</code> to NuttX Kernel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static inline uintptr_t sys_call3(unsigned int nbr, uintptr_t parm1,
                                  uintptr_t parm2, uintptr_t parm3)
{
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);

  asm volatile
    (
     &quot;ecall&quot;
     :: &quot;r&quot;(r0), &quot;r&quot;(r1), &quot;r&quot;(r2), &quot;r&quot;(r3)
     : &quot;memory&quot;
     );

  asm volatile(&quot;nop&quot; : &quot;=r&quot;(r0));

  return r0;
}
</code></pre></div>
<p>TODO: Why <code>nop</code>?</p>
<p>List of proxies‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>‚Üí grep PROXY hello.S
PROXY__assert.c
PROXY__exit.c
PROXY_clock_gettime.c
PROXY_gettid.c
PROXY_lseek.c
PROXY_nxsem_wait.c
PROXY_sem_clockwait.c
PROXY_sem_destroy.c
PROXY_sem_post.c
PROXY_sem_trywait.c
PROXY_task_setcancelstate.c
PROXY_write.c

‚Üí grep PROXY init.S
PROXY__assert.c
PROXY__exit.c
PROXY_clock_gettime.c
PROXY_gettid.c
PROXY_nxsem_wait.c
PROXY_sched_getparam.c
PROXY_sched_setparam.c
PROXY_sem_clockwait.c
PROXY_sem_destroy.c
PROXY_sem_post.c
PROXY_sem_trywait.c
PROXY_task_setcancelstate.c
PROXY_write.c
PROXY_boardctl.c
PROXY_clock_nanosleep.c
PROXY_close.c
PROXY_ftruncate.c
PROXY_get_environ_ptr.c
PROXY_getenv.c
PROXY_gethostname.c
PROXY_ioctl.c
PROXY_kill.c
PROXY_lseek.c
PROXY_lstat.c
PROXY_mkdir.c
PROXY_mount.c
PROXY_nx_pthread_create.c
PROXY_nx_pthread_exit.c
PROXY_nx_vsyslog.c
PROXY_open.c
PROXY_pgalloc.c
PROXY_posix_spawn.c
PROXY_pthread_detach.c
PROXY_read.c
PROXY_rename.c
PROXY_rmdir.c
PROXY_sched_getscheduler.c
PROXY_sched_lock.c
PROXY_sched_unlock.c
PROXY_setenv.c
PROXY_stat.c
PROXY_sysinfo.c
PROXY_umount2.c
PROXY_unlink.c
PROXY_unsetenv.c
PROXY_waitpid.c
</code></pre></div><h1 id="kernel-handles-app-call"><a href="#kernel-handles-app-call">4 Kernel Handles App Call</a></h1>
<p>TODO</p>
<p>nuttx/syscall/stubs/STUB_write.c</p>
<div class="example-wrap"><pre class="language-c"><code>/* Auto-generated write stub file -- do not edit */

#include &lt;nuttx/config.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;

uintptr_t STUB_write(int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3)
{
  return (uintptr_t)write((int)parm1, (FAR const void *)parm2, (size_t)parm3);
}
</code></pre></div>
<p>TODO: Handle IRQ 8 (RISCV_IRQ_ECALLU)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_exception.c#L114-L119">Attach RISCV_IRQ_ECALLU</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_swint.c#L105-L537">riscv_swint</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_swint.c#L54-L100">dispatch_syscall</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/supervisor/riscv_syscall.S#L49-L177">sys_call2</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/supervisor/riscv_perform_syscall.c#L36-L78">riscv_perform_syscall</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_swint.c#L105-L537">riscv_swint</a> with IRQ 0, which calls‚Ä¶</p>
<p>???</p>
<p>TODO: Enable CONFIG_DEBUG_SYSCALL_INFO: Build Setup &gt; Debug Options &gt; Syscall Debug Features &gt; Syscall Warning / Error / Info</p>
<h1 id="kernel-accesses-user-memory"><a href="#kernel-accesses-user-memory">5 Kernel Accesses User Memory</a></h1>
<p>TODO</p>
<h1 id="initial-ram-disk"><a href="#initial-ram-disk">6 Initial RAM Disk</a></h1>
<p>TODO</p>
<p>Two ways we can load the Initial RAM Disk‚Ä¶</p>
<ol>
<li>
<p>Load the Initial RAM Disk from a <strong>Separate File: initrd</strong> (similar to Star64)</p>
<p>This means we need to modify the <a href="https://github.com/openbouffalo/buildroot_bouffalo/blob/main/board/pine64/ox64/boot-pine64.cmd"><strong>U-Boot Script: boot-pine64.scr</strong></a></p>
<p>And make it <a href="https://lupyuen.github.io/articles/semihost#appendix-boot-nuttx-over-tftp-with-initial-ram-disk"><strong>load the initrd</strong></a> file into RAM.</p>
<p>(Which is good for separating the NuttX Kernel and NuttX Apps)</p>
<p>OR‚Ä¶</p>
</li>
<li>
<p>Append the Initial RAM Disk to the <strong>NuttX Kernel Image</strong></p>
<p>So the U-Boot Bootloader will load (one-shot into RAM) the NuttX Kernel + Initial RAM Disk.</p>
<p>And we reuse the existing <strong>U-Boot Config</strong> on the microSD Card: <a href="https://github.com/openbouffalo/buildroot_bouffalo/blob/main/board/pine64/ox64/rootfs-overlay/boot/extlinux/extlinux.conf"><strong>extlinux/extlinux.conf</strong></a></p>
<p>(Which might be more efficient for our Limited RAM)</p>
<p><a href="https://github.com/openbouffalo/buildroot_bouffalo/wiki/U-Boot-Bootflow">(See the <strong>U-Boot Boot Flow</strong>)</a></p>
<p><strong>TODO:</strong> Can we mount the File System directly from the <strong>NuttX Kernel Image in RAM</strong>? Without copying to the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L26"><strong>RAM Disk Memory Region</strong></a>?</p>
</li>
</ol>
<p>We‚Äôll do the Second Method, since we are low on RAM. Like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Export the Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Insert 64 KB of zeroes after Binary Image for Kernel Stack
head -c 65536 /dev/zero &gt;/tmp/nuttx.zero

## Append Initial RAM Disk to Binary Image
cat nuttx.bin /tmp/nuttx.zero initrd \
  &gt;Image

## Overwrite the Linux Image on Ox64 microSD
cp Image &quot;/Volumes/NO NAME/&quot;
</code></pre></div>
<p>This is how we copy the initrd in RAM to the Memory Region for the RAM Disk: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L190-L245">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void jh7110_copy_ramdisk(void) {
  // Based on ROM FS Format: https://docs.kernel.org/filesystems/romfs.html
  // After _edata, search for &quot;-rom1fs-&quot;. This is the RAM Disk Address.
  // Stop searching after 64 KB.
  extern uint8_t _edata[];
  extern uint8_t _sbss[];
  extern uint8_t _ebss[];
  const char *header = &quot;-rom1fs-&quot;;
  uint8_t *ramdisk_addr = NULL;
  for (uint8_t *addr = _edata; addr &lt; (uint8_t *)JH7110_IDLESTACK_TOP + (65 * 1024); addr++) {
    if (memcmp(addr, header, strlen(header)) == 0) {
      ramdisk_addr = addr;
      break;
    }
  }
  // Check for Missing RAM Disk
  if (ramdisk_addr == NULL) { _info(&quot;Missing RAM Disk&quot;); }
  DEBUGASSERT(ramdisk_addr != NULL); 

  // RAM Disk must be after Idle Stack
  if (ramdisk_addr &lt;= (uint8_t *)JH7110_IDLESTACK_TOP) { _info(&quot;RAM Disk must be after Idle Stack&quot;); }
  DEBUGASSERT(ramdisk_addr &gt; (uint8_t *)JH7110_IDLESTACK_TOP);

  // Read the Filesystem Size from the next 4 bytes, in Big Endian
  // Add 0x1F0 to Filesystem Size
  const uint32_t size =
    (ramdisk_addr[8] &lt;&lt; 24) + 
    (ramdisk_addr[9] &lt;&lt; 16) + 
    (ramdisk_addr[10] &lt;&lt; 8) + 
    ramdisk_addr[11] + 
    0x1F0;
  _info(&quot;size=%d\n&quot;, size);

  // Filesystem Size must be less than RAM Disk Memory Region
  DEBUGASSERT(size &lt;= (size_t)__ramdisk_size);

  // Before Copy: Verify the RAM Disk Image to be copied
  verify_image(ramdisk_addr);

  // Copy the Filesystem Size to RAM Disk Start
  // Warning: __ramdisk_start overlaps with ramdisk_addr + size
  // memmove is aliased to memcpy, so we implement memmove ourselves
  local_memmove((void *)__ramdisk_start, ramdisk_addr, size);

  // Before Copy: Verify the copied RAM Disk Image
  verify_image(__ramdisk_start);
}
</code></pre></div>
<p>We copy the initrd at the very top of our NuttX Start Code, before erasing the BSS (in case it corrupts our RAM Disk, but actually it shouldn‚Äôt): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L144-L156">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Start Code
void jh7110_start(int mhartid) {
  DEBUGASSERT(mhartid == 0); /* Only Hart 0 supported for now */
  if (0 == mhartid) {
    /* Copy the RAM Disk */
    jh7110_copy_ramdisk();

    /* Clear the BSS */
    jh7110_clear_bss();
</code></pre></div>
<p>NuttX mounts the RAM Disk from the Memory Region later during startup: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/boards/risc-v/jh7110/star64/src/jh7110_appinit.c#L51-L87">jh7110_appinit.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// After NuttX has booted...
void board_late_initialize(void) {
  // Mount the RAM Disk
  mount_ramdisk();
}

// Mount the RAM Disk
int mount_ramdisk(void) {
  desc.minor    = RAMDISK_DEVICE_MINOR;
  desc.nsectors = NSECTORS((ssize_t)__ramdisk_size);
  desc.sectsize = SECTORSIZE;
  desc.image    = __ramdisk_start;
  ret = boardctl(BOARDIOC_ROMDISK, (uintptr_t)&amp;desc);
</code></pre></div>
<p>And NuttX mounts our RAM Disk successfully!</p>
<div class="example-wrap"><pre class="language-text"><code>jh7110_copy_ramdisk: _edata=0x50400258, _sbss=0x50400290, _ebss=0x50407000, JH7110_IDLESTACK_TOP=0x50407c00
jh7110_copy_ramdisk: ramdisk_addr=0x50408288
jh7110_copy_ramdisk: size=8192016
jh7110_copy_ramdisk: Before Copy: ramdisk_addr=0x50408288
jh7110_copy_ramdisk: After Copy: __ramdisk_start=0x50a00000
...
elf_initialize: Registering ELF
uart_register: Registering /dev/console
work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
load_absmodule: Loading /system/bin/init
elf_loadbinary: Loading file: /system/bin/init
elf_init: filename: /system/bin/init loadinfo: 0x5040c618
elf_read: Read 64 bytes from offset 0
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">(Source)</a></p>
<p><em>Why did we insert 64 KB of zeroes after the NuttX Binary Image, before the initrd Initial RAM Disk?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>## Insert 64 KB of zeroes after Binary Image for Kernel Stack
head -c 65536 /dev/zero &gt;/tmp/nuttx.zero

## Append Initial RAM Disk to Binary Image
cat nuttx.bin /tmp/nuttx.zero initrd \
  &gt;Image
</code></pre></div>
<p>When we refer to the <a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">NuttX Log</a> and the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/boards/risc-v/jh7110/star64/scripts/ld.script">NuttX Linker Script</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// End of Data Section
_edata=0x50400258

// Start of BSS Section
_sbss=0x50400290

// End of BSS Section
_ebss=0x50407000

// Top of Idle Stack
JH7110_IDLESTACK_TOP=0x50407c00

// We located the initd after the Top of Idle Stack
ramdisk_addr=0x50408288, size=8192016

// And we copied initrd to the Memory Region for the RAM Disk
__ramdisk_start=0x50a00000
</code></pre></div>
<p>Which says‚Ä¶</p>
<ol>
<li>
<p>The NuttX Binary Image <code>nuttx.bin</code> terminates at <code>_edata</code>. (End of Data Section)</p>
</li>
<li>
<p>If we append <code>initrd</code> directly to the end of <code>nuttx.bin</code>, it will collide with the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L74-L92">BSS Section</a> and the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_head.S#L94-L101">Idle Stack</a>. And <code>initrd</code> will get overwritten by NuttX.</p>
</li>
<li>
<p>Best place to append <code>initrd</code> is after the Top of Idle Stack. Which is located 32 KB after <code>_edata</code>. (End of Data Section)</p>
</li>
<li>
<p>That‚Äôs why we inserted a padding of 64 KB between <code>nuttx.bin</code> and <code>initrd</code>. So it won‚Äôt collide with BSS and Idle Stack.</p>
</li>
<li>
<p>Our code locates <code>initrd</code> (searching by Magic Number ‚Äú-rom1fs-‚Äù). And copies <code>initrd</code> to <code>__ramdisk_start</code>. (Memory Region for the RAM Disk)</p>
</li>
<li>
<p>NuttX mounts the RAM Disk from <code>__ramdisk_start</code>. (Memory Region for the RAM Disk)</p>
</li>
</ol>
<p><em>But 64 KB sounds so arbitrary. What if the parameters change?</em></p>
<p>That‚Äôs why we have a Runtime Check: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L190-L245">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // RAM Disk must be after Idle Stack
  if (ramdisk_addr &lt;= (uint8_t *)JH7110_IDLESTACK_TOP) { _info(&quot;RAM Disk must be after Idle Stack&quot;); }
  DEBUGASSERT(ramdisk_addr &gt; (uint8_t *)JH7110_IDLESTACK_TOP);
</code></pre></div>
<p><em>Why did we call local_memmove to copy <code>initrd</code> to <code>__ramdisk_start</code>? Why not memcpy?</em></p>
<p>That‚Äôs because <code>initrd</code> overlaps with <code>__ramdisk_start</code>!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ramdisk_addr = <span class="number">0x50408288</span>, size = <span class="number">8192016
</span>ramdisk_addr + size = <span class="number">0x50bd8298
</span>Which is AFTER __ramdisk_start (<span class="number">0x50a00000</span>)</code></pre></div>
<p><code>memcpy</code> won‚Äôt work with Overlapping Memory Regions. So we wrote our own: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L246-L487">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// From libs/libc/string/lib_memmove.c
static FAR void *local_memmove(FAR void *dest, FAR const void *src, size_t count) {
  FAR char *d;
  FAR char *s;
  DEBUGASSERT(dest &gt; src);
  d = (FAR char *) dest + count;
  s = (FAR char *) src + count;

  while (count--) {
    d -= 1;
    s -= 1;
    // TODO: Very strange. This needs to be volatile or C Compiler will replace this by memcpy.
    volatile char c = *s;
    *d = c;
  }
  return dest;
}
</code></pre></div>
<p><em>We‚Äôre sure that it works?</em></p>
<p>That‚Äôs why we called <code>verify_image</code> to do a simple integrity check on <code>initrd</code>, before and after copying. And that‚Äôs how we discovered that <code>memcpy</code> doesn‚Äôt work. From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L246-L487">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Verify that image is correct
static void verify_image(uint8_t *addr) {
  // Verify that the Byte Positions below (offset by 1) contain 0x0A
  for (int i = 0; i &lt; sizeof(search_addr) / sizeof(search_addr[0]); i++) {
    const uint8_t *p = addr + search_addr[i] - 1;
    if (*p != 0x0A) { _info(&quot;No Match: %p\n&quot;, p); }
  }
}

// Byte Positions (offset by 1) of 0x0A in initrd. Extracted from:
// grep --binary-files=text -b -o A initrd
const uint32_t search_addr[] =
{
76654,
78005,
79250,
...
7988897,
7992714,
};
</code></pre></div>
<p>But NuttX fails to start our NuttX Shell (NSH) ELF Executable from ‚Äú/system/bin/init‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>elf_read: Read 3392 bytes from offset 3385080
elf_addrenv_select: ERROR: up_addrenv_text_enable_write failed: -22
elf_load: ERROR: elf_addrenv_select() failed: -22
...
elf_loadbinary: Failed to load ELF program binary: -22
exec_internal: ERROR: Failed to load program &#39;/system/bin/init&#39;: -22
_assert: Current Version: NuttX  12.0.3 8017bd9-dirty Nov 10 2023 22:50:07 risc-v
_assert: Assertion failed ret &gt; 0: at file: init/nx_bringup.c:302 task: AppBringUp process: Kernel 0x502014ea
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">(Source)</a></p>
<p>Maybe because NuttX is trying to map the User Address Space 0xC000 0000: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/boards/risc-v/jh7110/star64/configs/nsh/defconfig#L17-L26">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_ARCH_TEXT_VBASE=0xC0000000
CONFIG_ARCH_TEXT_NPAGES=128
CONFIG_ARCH_DATA_VBASE=0xC0100000
CONFIG_ARCH_DATA_NPAGES=128
CONFIG_ARCH_HEAP_VBASE=0xC0200000
CONFIG_ARCH_HEAP_NPAGES=128
</code></pre></div>
<p>But our Kernel Memory Space already extends to 0xF000 0000? (Because of the PLIC at 0xE000 0000)</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_mm_init.c#L43-L46">jh7110_mm_init.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>/* Map the whole I/O memory with vaddr = paddr mappings */
#define MMU_IO_BASE     (0x00000000)
#define MMU_IO_SIZE     (0xf0000000)
</code></pre></div>
<p><em>Let‚Äôs disable PLIC, and exclude PLIC from Memory Map. Will the NuttX Shell start?</em></p>
<p>Yep it does! <a href="https://gist.github.com/lupyuen/9fc9b2de9938b48666cc5e5fa3f8278e">(See the log)</a></p>
<h1 id="whats-next"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>We‚Äôll do much more for <strong>NuttX on Ox64 BL808</strong>, stay tuned for updates!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/app.md"><strong>lupyuen.github.io/src/app.md</strong></a></p>

    
</body>
</html>