<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Ox64 BL808 SBC: NuttX Apps and Initial RAM Disk</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Ox64 BL808 SBC: NuttX Apps and Initial RAM Disk" 
    data-rh="true">
<meta property="og:description" 
    content="(1) What's inside an Application for Apache NuttX RTOS (2) How it calls the NuttX Kernel (3) How NuttX Apps are bundled into the Initial RAM Disk for Pine64 Ox64 BL808 RISC-V SBC"
    data-rh="true">
<meta name="description" 
    content="(1) What's inside an Application for Apache NuttX RTOS (2) How it calls the NuttX Kernel (3) How NuttX Apps are bundled into the Initial RAM Disk for Pine64 Ox64 BL808 RISC-V SBC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/app-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/app.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Ox64 BL808 SBC: NuttX Apps and Initial RAM Disk</h1>
    <nav id="TOC"><ul>
<li><a href="#inside-a-nuttx-app">1 Inside a NuttX App</a><ul></ul></li>
<li><a href="#nuttx-app-calls-nuttx-kernel">2 NuttX App calls NuttX Kernel</a><ul></ul></li>
<li><a href="#nuttx-kernel-handles-system-call">3 NuttX Kernel handles System Call</a><ul></ul></li>
<li><a href="#kernel-accesses-user-memory">4 Kernel Accesses User Memory</a><ul></ul></li>
<li><a href="#start-nuttx-apps">5 Start NuttX Apps</a><ul></ul></li>
<li><a href="#initial-ram-disk">6 Initial RAM Disk</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>30 Nov 2023</em></p>
<p><img src="https://lupyuen.github.io/images/app-title.png" alt="TODO" /></p>
<p>TODO</p>
<p><a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 64-bit RISC-V SBC</strong></a>. (Pic below)</p>
<p>(Powered by <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Bouffalo Lab BL808 SoC</strong></a>)</p>
<p><a href="https://lupyuen.github.io/articles/ox2"><strong>Apache NuttX RTOS</strong></a>. (Real-Time Operating System)</p>
<p><img src="https://lupyuen.github.io/images/ox64-sbc.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="inside-a-nuttx-app"><a href="#inside-a-nuttx-app">1 Inside a NuttX App</a></h1>
<p><em>What happens inside the simplest NuttX App?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// From https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/ox64b/examples/hello/hello_main.c#L36-L40
int main(int argc, FAR char *argv[]) {
  printf(&quot;Hello, World!!\n&quot;);
  return 0;
}
</code></pre></div>
<p>Let‚Äôs find out! We build <a href="https://lupyuen.github.io/articles/mmu#appendix-build-and-run-nuttx"><strong>NuttX for Ox64 BL808 SBC</strong></a>.</p>
<p>Which produces this <strong>ELF Executable</strong> for our NuttX App‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## ELF Executable for `hello` looks big...
$ ls -l ../apps/bin/hello
-rwxr-xr-x  518,192  ../apps/bin/hello

## But not much inside, mostly Debug Info...
$ riscv64-unknown-elf-size ../apps/bin/hello
   text  data  bss   dec  hex  filename
   3814     8    4  3826  ef2  ../apps/bin/hello

## Dump the RISC-V Disassembly to `hello.S`
$ riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello \
  &gt;hello.S \
  2&gt;&amp;1
</code></pre></div>
<p>Here‚Äôs the <strong>RISC-V Disassembly</strong> of our NuttX App: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/ox64a-1/hello.S">hello.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>## Omitted: _start() prepares for signals (sig_trampoline) and calls main()

003e &lt;main&gt;:
int main(int argc, FAR char *argv[]) {
  3e: 1141      addi   sp,sp,-16  ## Subtract 16 from Stack Pointer

## Set Register A0 (Arg 0) to &quot;Hello, World!!\n&quot;
  40: 00000517  auipc  a0,0x0    40: R_RISCV_PCREL_HI20    .LC0
  44: 00050513  mv     a0,a0     44: R_RISCV_PCREL_LO12_I  .L0 

printf(&quot;Hello, World!!\n&quot;);
  48: e406      sd     ra,8(sp)  ## Save Return Address to Stack Pointer, Offset 8
  4a: 00000097  auipc  ra,0x0    4a: R_RISCV_CALL  puts
  4e: 000080e7  jalr   ra      # 4a &lt;.LVL1+0x2&gt;  ## Call puts()

return 0;
  52: 60a2      ld    ra,8(sp)  ## Load Return Address from Stack Pointer, Offset 8
  54: 4501      li    a0,0      ## Set Return Value to 0
  56: 0141      addi  sp,sp,16  ## Add 16 to Stack Pointer
  58: 8082      ret             ## Return to caller: _start()

## Followed by the code for puts(), lib_fwrite_unlocked(), write(), ...
</code></pre></div>
<p>In the RISC-V Disassembly, we see that <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/ox64b/examples/hello/hello_main.c#L36-L40"><strong>main</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_puts.c#L34-L96"><strong>puts</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_libfwrite.c#L45-L200"><strong>lib_fwrite_unlocked</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_libfwrite.c#L149"><strong>write</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><strong>NuttX Kernel</strong> to print ‚ÄúHello World‚Äù</p>
</li>
</ul>
<p>How will <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_libfwrite.c#L149"><strong>write</strong></a> call the NuttX Kernel? We‚Äôll see soon!</p>
<p><em>This code doesn‚Äôt look right‚Ä¶</em></p>
<div class="example-wrap"><pre class="language-text"><code>printf(&quot;Hello, World!!\n&quot;);

  ## Load Register RA with Program Counter + 0x0
  4a: 00000097  auipc  ra, 0x0

  ## Call the function in Register RA: puts()
  4e: 000080e7  jalr   ra
</code></pre></div>
<p>We break it down‚Ä¶</p>
<ul>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-register-immediate-instructions"><strong><code>auipc</code></strong></a> sets Register RA to‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>Program Counter + 0x0
</code></pre></div></li>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--unconditional-jumps"><strong><code>jalr</code></strong></a> jumps to the Function pointed by Register RA‚Ä¶</p>
<p>Which we expect to be <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_puts.c#L34-L96"><strong>puts</strong></a></p>
</li>
</ul>
<p><em>Shouldn‚Äôt <code>auipc</code> add the Offset of <code>puts</code>?</em></p>
<p>Ah that‚Äôs because we‚Äôre looking at <a href="https://en.wikipedia.org/wiki/Relocation_(computing)"><strong>Relocatable Code</strong></a>!</p>
<p>The <strong><code>auipc</code></strong> Offset will be fixed up by the <strong>NuttX ELF Loader</strong> when it loads our NuttX App for execution.</p>
<p>The <strong>Relocation Info</strong> shows that <strong><code>0x0</code></strong> will be replaced by the Offset of <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/libs/libc/stdio/lib_puts.c#L34-L96"><strong>puts</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>printf(&quot;Hello, World!!\n&quot;);

  ## Load Register RA with Program Counter + 0x0...
  ## But actually 0x0 will be changed to the Offset of puts()
  4a: 00000097  auipc  ra, 0x0  4a: R_RISCV_CALL  puts

  ## Call the function in Register RA: puts()
  ## Which will work when ELF Loader fixes the Offset of puts()
  4e: 000080e7  jalr   ra     # 4a &lt;.LVL1+0x2&gt;
</code></pre></div>
<p>So we‚Äôre all good!</p>
<p><em>Why <code>puts</code> instead of <code>printf</code>?</em></p>
<p>The GCC Compiler has cleverly optimised away <strong>printf</strong> to become <strong>puts</strong>.</p>
<p>If we do this (and foil the GCC Compiler)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Nope, GCC Compiler won&#39;t change printf() to puts()
printf(&quot;Hello, World %s!!\n&quot;, &quot;Luppy&quot;);
</code></pre></div>
<p>Then <strong>printf</strong> will appear in our RISC-V Disassembly.</p>
<p>Let‚Äôs circle back to <strong>write</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/app-run.png" alt="NuttX App calls NuttX Kernel" /></p>
<h1 id="nuttx-app-calls-nuttx-kernel"><a href="#nuttx-app-calls-nuttx-kernel">2 NuttX App calls NuttX Kernel</a></h1>
<p><em>Our app will print something to the Console Output‚Ä¶</em></p>
<p><em>But NuttX Apps can‚Äôt write directly to the Serial Device right?</em></p>
<p>Nope! NuttX Apps run in <strong>RISC-V User Mode</strong>. Which doesn‚Äôt have access to Serial Device and other resources controlled by NuttX Kernel. (Running in <strong>RISC-V Supervisor Mode</strong>)</p>
<p>That‚Äôs why ‚Äú<strong>write</strong>‚Äù will trigger a <strong>System Call</strong> to the NuttX Kernel, jumping from RISC-V <strong>User Mode to Supervisor Mode</strong>. And write to the Serial Device.</p>
<p><em>Will NuttX Apps need Special Coding to make System Calls?</em></p>
<p>Nope! The System Call is <strong>totally transparent</strong> to our app‚Ä¶</p>
<ul>
<li>
<p>Our <strong>NuttX App</strong> will call a normal function named ‚Äú<strong>write</strong>‚Äù‚Ä¶</p>
</li>
<li>
<p>That pretends to be the actual ‚Äú<strong>write</strong>‚Äù function in <strong>NuttX Kernel</strong>‚Ä¶</p>
</li>
<li>
<p>By forwarding the ‚Äú<strong>write</strong>‚Äù function call (and parameters)‚Ä¶</p>
</li>
<li>
<p>Through a <strong>RISC-V System Call</strong></p>
</li>
</ul>
<p><em>What‚Äôs this ‚Äúforwarding‚Äù to a System Call?</em></p>
<p>This forwarding happens inside a <strong>Proxy Function</strong> that‚Äôs auto-generated during NuttX Build‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// From nuttx/syscall/proxies/PROXY_write.c
// Auto-Generated Proxy for `write`
ssize_t write(int parm1, FAR const void * parm2, size_t parm3) {
  return (ssize_t) sys_call3(  // Make a System Call with 3 parameters...
    (unsigned int) SYS_write,  // Kernel Function Number for `write`
    (uintptr_t) parm1,         // File Descriptor (1 = Standard Output)
    (uintptr_t) parm2,         // Buffer to be written
    (uintptr_t) parm3          // Number of bytes to write
  );
}
</code></pre></div>
<p>Our NuttX App calls this <strong>Proxy Version</strong> of ‚Äú<strong>write</strong>‚Äù (that pretends to be the Kernel ‚Äú<strong>write</strong>‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Our App calls the Proxy Function...
int ret = write(
  1,  // File Descriptor (1 = Standard Output)
  &quot;Hello, World!!\n&quot;,  // Buffer to be written
  15  // Number of bytes to write
);
</code></pre></div>
<p>Which triggers a <strong>System Call</strong> to the Kernel.</p>
<p><em>What‚Äôs inside sys_call3?</em></p>
<p>It makes a <strong>System Call</strong> with <strong>3 Parameters</strong></p>
<p>TODO</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/include/syscall.h">sys_call3</a>, which makes an <code>ecall</code> to NuttX Kernel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Make a System Call with 3 parameters
uintptr_t sys_call3(
  unsigned int nbr,  // Kernel Function Number
  uintptr_t parm1,   // First Parameter
  uintptr_t parm2,   // Second Parameter
  uintptr_t parm3    // Third Parameter
) {
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);

  asm volatile
    (
     &quot;ecall&quot;
     :: &quot;r&quot;(r0), &quot;r&quot;(r1), &quot;r&quot;(r2), &quot;r&quot;(r3)
     : &quot;memory&quot;
     );

  asm volatile(&quot;nop&quot; : &quot;=r&quot;(r0));

  return r0;
}
</code></pre></div>
<p>TODO: Why <code>nop</code>?</p>
<p>TODO</p>
<p><a href="https://nuttx.apache.org/docs/latest/components/syscall.html">Syscall Layer</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/syscall/syscall.csv#L209-L210">syscall.csv</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/include/sys/syscall_lookup.h#L202">syscall_lookup.h</a></p>
<p>List of proxies‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>‚Üí grep PROXY hello.S
PROXY__assert.c
PROXY__exit.c
PROXY_clock_gettime.c
PROXY_gettid.c
PROXY_lseek.c
PROXY_nxsem_wait.c
PROXY_sem_clockwait.c
PROXY_sem_destroy.c
PROXY_sem_post.c
PROXY_sem_trywait.c
PROXY_task_setcancelstate.c
PROXY_write.c

‚Üí grep PROXY init.S
PROXY__assert.c
PROXY__exit.c
PROXY_clock_gettime.c
PROXY_gettid.c
PROXY_nxsem_wait.c
PROXY_sched_getparam.c
PROXY_sched_setparam.c
PROXY_sem_clockwait.c
PROXY_sem_destroy.c
PROXY_sem_post.c
PROXY_sem_trywait.c
PROXY_task_setcancelstate.c
PROXY_write.c
PROXY_boardctl.c
PROXY_clock_nanosleep.c
PROXY_close.c
PROXY_ftruncate.c
PROXY_get_environ_ptr.c
PROXY_getenv.c
PROXY_gethostname.c
PROXY_ioctl.c
PROXY_kill.c
PROXY_lseek.c
PROXY_lstat.c
PROXY_mkdir.c
PROXY_mount.c
PROXY_nx_pthread_create.c
PROXY_nx_pthread_exit.c
PROXY_nx_vsyslog.c
PROXY_open.c
PROXY_pgalloc.c
PROXY_posix_spawn.c
PROXY_pthread_detach.c
PROXY_read.c
PROXY_rename.c
PROXY_rmdir.c
PROXY_sched_getscheduler.c
PROXY_sched_lock.c
PROXY_sched_unlock.c
PROXY_setenv.c
PROXY_stat.c
PROXY_sysinfo.c
PROXY_umount2.c
PROXY_unlink.c
PROXY_unsetenv.c
PROXY_waitpid.c
</code></pre></div><h1 id="nuttx-kernel-handles-system-call"><a href="#nuttx-kernel-handles-system-call">3 NuttX Kernel handles System Call</a></h1>
<p>TODO</p>
<p>From nuttx/syscall/stubs/STUB_write.c</p>
<div class="example-wrap"><pre class="language-c"><code>/* Auto-generated write stub file -- do not edit */

#include &lt;nuttx/config.h&gt;
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;

uintptr_t STUB_write(int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3)
{
  return (uintptr_t)write((int)parm1, (FAR const void *)parm2, (size_t)parm3);
}
</code></pre></div>
<p>TODO: Handle IRQ 8 (RISCV_IRQ_ECALLU)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_exception.c#L114-L119">Attach RISCV_IRQ_ECALLU</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_swint.c#L105-L537">riscv_swint</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_swint.c#L54-L100">dispatch_syscall</a>, which calls Kernel Function Stub and‚Ä¶ </p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/supervisor/riscv_syscall.S#L49-L177">sys_call2</a> with A0=SYS_syscall_return (3), which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/supervisor/riscv_perform_syscall.c#L36-L78">riscv_perform_syscall</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_swint.c#L105-L537">riscv_swint</a> with IRQ 0, to return from Syscall</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/include/sys/syscall_lookup.h#L202">syscall_lookup.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>SYSCALL_LOOKUP(write, 3)
</code></pre></div>
<p>Which defines SYS_write in the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/include/sys/syscall.h#L55-L66">Syscall Enum</a></p>
<p>From hello.S:</p>
<div class="example-wrap"><pre class="language-text"><code>ssize_t write(int parm1, FAR const void * parm2, size_t parm3)
{
 dcc:  872a                  mv  a4,a0

0000000000000dce &lt;.LVL1&gt;:
 dce:  87ae                  mv  a5,a1

0000000000000dd0 &lt;.LVL2&gt;:
 dd0:  86b2                  mv  a3,a2

0000000000000dd2 &lt;.LBB4&gt;:
sys_call3():
/Users/Luppy/ox64/nuttx/include/arch/syscall.h:252
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);
 dd2:  03f00513            li  a0,63
</code></pre></div>
<p>Thus SYS_write = 63</p>
<p>Also from hello.S:</p>
<div class="example-wrap"><pre class="language-text"><code> &lt;2&gt;&lt;66e7&gt;: Abbrev Number: 6 (DW_TAG_enumerator)
    &lt;66e8&gt;   DW_AT_name        : (indirect string, offset: 0x4b98): SYS_write
    &lt;66ec&gt;   DW_AT_const_value : 63
</code></pre></div>
<p>TODO: Enable CONFIG_DEBUG_SYSCALL_INFO: Build Setup &gt; Debug Options &gt; Syscall Debug Features &gt; Syscall Warning / Error / Info</p>
<p>From <a href="https://gist.github.com/lupyuen/ce82b29c664b1d5898b6a59743310c17">ECALL Log</a></p>
<div class="example-wrap"><pre class="language-text"><code>riscv_dispatch_irq: irq=8
riscv_swint: Entry: regs: 0x5040bcb0 cmd: 63
up_dump_register: EPC: 00000000800019b2
up_dump_register: A0: 000000000000003f A1: 0000000000000001 A2: 000000008000ad00 A3: 000000000000001e
up_dump_register: A4: 0000000000000001 A5: 000000008000ad00 A6: 0000000000000000 A7: fffffffffffffff8
up_dump_register: T0: 0000000050212a20 T1: 0000000000000007 T2: 0000000000000000 T3: 0000000080200908
up_dump_register: T4: 0000000080200900 T5: 0000000000000000 T6: 0000000000000000
up_dump_register: S0: 00000000802005c0 S1: 0000000080202010 S2: 0000000080202010 S3: 0000000000000000
up_dump_register: S4: 0000000000000001 S5: 0000000000000000 S6: 0000000000000000 S7: 0000000000000000
up_dump_register: S8: 0000000000000000 S9: 0000000000000000 S10: 0000000000000000 S11: 0000000000000000
up_dump_register: SP: 0000000080202b70 FP: 00000000802005c0 TP: 0000000000000000 RA: 0000000080001a6a
riscv_swint: SWInt Return: 37
STUB_write: nbr=440, parm1=1, parm2=8000ad00, parm3=1e

NuttShell (NSH) NuttX-12.0.3
riscv_swint: Entry: regs: 0x5040baa0 cmd: 3
up_dump_register: EPC: 0000000080001a6a
up_dump_register: A0: 0000000000000003 A1: 000000005040bbec A2: 000000000000001e A3: 0000000000000000
up_dump_register: A4: 0000000000007fff A5: 0000000000000001 A6: 0000000000000009 A7: fffffffffffffff8
up_dump_register: T0: 000000000000002e T1: 000000000000006a T2: 00000000000001ff T3: 000000000000006c
up_dump_register: T4: 0000000000000068 T5: 0000000000000009 T6: 000000000000002a
up_dump_register: S0: 00000000802005c0 S1: 0000000080202010 S2: 0000000080202010 S3: 0000000000000000
up_dump_register: S4: 0000000000000001 S5: 0000000000000000 S6: 0000000000000000 S7: 0000000000000000
up_dump_register: S8: 0000000000000000 S9: 0000000000000000 S10: 0000000000000000 S11: 0000000000000000
up_dump_register: SP: 000000005040bcb0 FP: 00000000802005c0 TP: 0000000000000000 RA: 0000000080001a6a
riscv_swint: SWInt Return: 1e
</code></pre></div>
<p>Before Call:</p>
<p>A0=0x3f (SYS_write) </p>
<p>A1=1 (stdout)</p>
<p>A2=0x8000ad00 (g_nshgreeting)</p>
<p>A3=0x1e (length)</p>
<p>nbr=440 (Offset for the stub lookup table, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/syscall/syscall_stublookup.c#L80-L93">g_stublookup</a>)</p>
<p>After Call:</p>
<p>A0=3 <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/include/syscall.h#L80-L87">(SYS_syscall_return)</a></p>
<p>Returns 0x1E = 30 chars, including <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/ox64b/nshlib/nsh_parse.c#L292-L302">linefeeds before and after</a></p>
<p>Not strictly an SBI like Linux, because the Kernel Function Numbers may change!</p>
<p>But it‚Äôs a lot simpler to experiment with new Kernel Functions.</p>
<h1 id="kernel-accesses-user-memory"><a href="#kernel-accesses-user-memory">4 Kernel Accesses User Memory</a></h1>
<p>TODO</p>
<p>Supervisor Mode may access memory in User Mode only if <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:translation">SUM bit is set in sstatus</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/sched/init/nx_start.c#L298-L713">nx_start</a> calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_initialstate.c#L41-L140">up_initial_state</a>, which calls‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_getnewintctx.c#L74-L81">riscv_set_idleintctx</a> to set the SUM bit in sstatus</p>
<h1 id="start-nuttx-apps"><a href="#start-nuttx-apps">5 Start NuttX Apps</a></h1>
<p>TODO</p>
<p>NuttX Kernel starts a NuttX App (in ELF Format) by calling‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L84-L94"><strong>ELF Loader: g_elfbinfmt</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L225-L355"><strong>elf_loadbinary</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/libelf/libelf_load.c#L297-L445"><strong>elf_load</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/libelf/libelf_addrenv.c#L56-L178"><strong>elf_addrenv_alloc</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_addrenv.c#L339-L490"><strong>up_addrenv_create</strong></a>, which calls‚Ä¶</p>
<p>(Also calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_mmu.h#L152-L176"><strong>mmu_satp_reg</strong></a> to set SATP Register)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_addrenv.c#L213-L310"><strong>create_region</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/arch/risc-v/src/common/riscv_mmu.c#L62-L109"><strong>mmu_ln_setentry</strong></a> to populate the Page Table Entries</p>
</li>
</ul>
<p><em>Who calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L84-L94">ELF Loader g_elfbinfmt</a> to start the NuttX App?</em></p>
<p>Earlier we stepped through the <strong>Boot Sequence</strong> for NuttX‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow"><strong>‚ÄúNuttX Boot Flow‚Äù</strong></a></li>
</ul>
<p>Right after that, <a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_bringup.c#L373-L458"><strong>nx_bringup</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_bringup.c#L330-L367"><strong>nx_create_initthread</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_bringup.c#L212C1-L302"><strong>nx_start_application</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_exec.c#L183-L223"><strong>exec_spawn</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_exec.c#L42-L179"><strong>exec_internal</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_loadmodule.c#L136-L225"><strong>load_module</strong></a> and‚Ä¶</p>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_execmodule.c#L190-L450"><strong>exec_module</strong></a></p>
</li>
</ul>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_loadmodule.c#L136-L225"><strong>load_module</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/binfmt/binfmt_loadmodule.c#L83-L132"><strong>load_absmodule</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/master/include/nuttx/binfmt/binfmt.h#L122-L148"><strong>binfmt_s.load</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64b/binfmt/elf.c#L84-L94"><strong>ELF Loader: g_elfbinfmt</strong></a> to load the ELF File (explained above)</p>
</li>
</ul>
<h1 id="initial-ram-disk"><a href="#initial-ram-disk">6 Initial RAM Disk</a></h1>
<p>TODO</p>
<p>Two ways we can load the Initial RAM Disk‚Ä¶</p>
<ol>
<li>
<p>Load the Initial RAM Disk from a <strong>Separate File: initrd</strong> (similar to Star64)</p>
<p>This means we need to modify the <a href="https://github.com/openbouffalo/buildroot_bouffalo/blob/main/board/pine64/ox64/boot-pine64.cmd"><strong>U-Boot Script: boot-pine64.scr</strong></a></p>
<p>And make it <a href="https://lupyuen.github.io/articles/semihost#appendix-boot-nuttx-over-tftp-with-initial-ram-disk"><strong>load the initrd</strong></a> file into RAM.</p>
<p>(Which is good for separating the NuttX Kernel and NuttX Apps)</p>
<p>OR‚Ä¶</p>
</li>
<li>
<p>Append the Initial RAM Disk to the <strong>NuttX Kernel Image</strong></p>
<p>So the U-Boot Bootloader will load (one-shot into RAM) the NuttX Kernel + Initial RAM Disk.</p>
<p>And we reuse the existing <strong>U-Boot Config</strong> on the microSD Card: <a href="https://github.com/openbouffalo/buildroot_bouffalo/blob/main/board/pine64/ox64/rootfs-overlay/boot/extlinux/extlinux.conf"><strong>extlinux/extlinux.conf</strong></a></p>
<p>(Which might be more efficient for our Limited RAM)</p>
<p><a href="https://github.com/openbouffalo/buildroot_bouffalo/wiki/U-Boot-Bootflow">(See the <strong>U-Boot Boot Flow</strong>)</a></p>
<p><strong>TODO:</strong> Can we mount the File System directly from the <strong>NuttX Kernel Image in RAM</strong>? Without copying to the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L26"><strong>RAM Disk Memory Region</strong></a>?</p>
</li>
</ol>
<p>We‚Äôll do the Second Method, since we are low on RAM. Like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Export the Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Insert 64 KB of zeroes after Binary Image for Kernel Stack
head -c 65536 /dev/zero &gt;/tmp/nuttx.zero

## Append Initial RAM Disk to Binary Image
cat nuttx.bin /tmp/nuttx.zero initrd \
  &gt;Image

## Overwrite the Linux Image on Ox64 microSD
cp Image &quot;/Volumes/NO NAME/&quot;
</code></pre></div>
<p>This is how we copy the initrd in RAM to the Memory Region for the RAM Disk: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L190-L245">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void jh7110_copy_ramdisk(void) {
  // Based on ROM FS Format: https://docs.kernel.org/filesystems/romfs.html
  // After _edata, search for &quot;-rom1fs-&quot;. This is the RAM Disk Address.
  // Stop searching after 64 KB.
  extern uint8_t _edata[];
  extern uint8_t _sbss[];
  extern uint8_t _ebss[];
  const char *header = &quot;-rom1fs-&quot;;
  uint8_t *ramdisk_addr = NULL;
  for (uint8_t *addr = _edata; addr &lt; (uint8_t *)JH7110_IDLESTACK_TOP + (65 * 1024); addr++) {
    if (memcmp(addr, header, strlen(header)) == 0) {
      ramdisk_addr = addr;
      break;
    }
  }
  // Check for Missing RAM Disk
  if (ramdisk_addr == NULL) { _info(&quot;Missing RAM Disk&quot;); }
  DEBUGASSERT(ramdisk_addr != NULL); 

  // RAM Disk must be after Idle Stack
  if (ramdisk_addr &lt;= (uint8_t *)JH7110_IDLESTACK_TOP) { _info(&quot;RAM Disk must be after Idle Stack&quot;); }
  DEBUGASSERT(ramdisk_addr &gt; (uint8_t *)JH7110_IDLESTACK_TOP);

  // Read the Filesystem Size from the next 4 bytes, in Big Endian
  // Add 0x1F0 to Filesystem Size
  const uint32_t size =
    (ramdisk_addr[8] &lt;&lt; 24) + 
    (ramdisk_addr[9] &lt;&lt; 16) + 
    (ramdisk_addr[10] &lt;&lt; 8) + 
    ramdisk_addr[11] + 
    0x1F0;
  _info(&quot;size=%d\n&quot;, size);

  // Filesystem Size must be less than RAM Disk Memory Region
  DEBUGASSERT(size &lt;= (size_t)__ramdisk_size);

  // Before Copy: Verify the RAM Disk Image to be copied
  verify_image(ramdisk_addr);

  // Copy the Filesystem Size to RAM Disk Start
  // Warning: __ramdisk_start overlaps with ramdisk_addr + size
  // memmove is aliased to memcpy, so we implement memmove ourselves
  local_memmove((void *)__ramdisk_start, ramdisk_addr, size);

  // Before Copy: Verify the copied RAM Disk Image
  verify_image(__ramdisk_start);
}
</code></pre></div>
<p>We copy the initrd at the very top of our NuttX Start Code, before erasing the BSS (in case it corrupts our RAM Disk, but actually it shouldn‚Äôt): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L144-L156">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Start Code
void jh7110_start(int mhartid) {
  DEBUGASSERT(mhartid == 0); /* Only Hart 0 supported for now */
  if (0 == mhartid) {
    /* Copy the RAM Disk */
    jh7110_copy_ramdisk();

    /* Clear the BSS */
    jh7110_clear_bss();
</code></pre></div>
<p>NuttX mounts the RAM Disk from the Memory Region later during startup: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/boards/risc-v/jh7110/star64/src/jh7110_appinit.c#L51-L87">jh7110_appinit.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// After NuttX has booted...
void board_late_initialize(void) {
  // Mount the RAM Disk
  mount_ramdisk();
}

// Mount the RAM Disk
int mount_ramdisk(void) {
  desc.minor    = RAMDISK_DEVICE_MINOR;
  desc.nsectors = NSECTORS((ssize_t)__ramdisk_size);
  desc.sectsize = SECTORSIZE;
  desc.image    = __ramdisk_start;
  ret = boardctl(BOARDIOC_ROMDISK, (uintptr_t)&amp;desc);
</code></pre></div>
<p>And NuttX mounts our RAM Disk successfully!</p>
<div class="example-wrap"><pre class="language-text"><code>jh7110_copy_ramdisk: _edata=0x50400258, _sbss=0x50400290, _ebss=0x50407000, JH7110_IDLESTACK_TOP=0x50407c00
jh7110_copy_ramdisk: ramdisk_addr=0x50408288
jh7110_copy_ramdisk: size=8192016
jh7110_copy_ramdisk: Before Copy: ramdisk_addr=0x50408288
jh7110_copy_ramdisk: After Copy: __ramdisk_start=0x50a00000
...
elf_initialize: Registering ELF
uart_register: Registering /dev/console
work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
load_absmodule: Loading /system/bin/init
elf_loadbinary: Loading file: /system/bin/init
elf_init: filename: /system/bin/init loadinfo: 0x5040c618
elf_read: Read 64 bytes from offset 0
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">(Source)</a></p>
<p><em>Why did we insert 64 KB of zeroes after the NuttX Binary Image, before the initrd Initial RAM Disk?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>## Insert 64 KB of zeroes after Binary Image for Kernel Stack
head -c 65536 /dev/zero &gt;/tmp/nuttx.zero

## Append Initial RAM Disk to Binary Image
cat nuttx.bin /tmp/nuttx.zero initrd \
  &gt;Image
</code></pre></div>
<p>When we refer to the <a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">NuttX Log</a> and the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/boards/risc-v/jh7110/star64/scripts/ld.script">NuttX Linker Script</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// End of Data Section
_edata=0x50400258

// Start of BSS Section
_sbss=0x50400290

// End of BSS Section
_ebss=0x50407000

// Top of Idle Stack
JH7110_IDLESTACK_TOP=0x50407c00

// We located the initd after the Top of Idle Stack
ramdisk_addr=0x50408288, size=8192016

// And we copied initrd to the Memory Region for the RAM Disk
__ramdisk_start=0x50a00000
</code></pre></div>
<p>Which says‚Ä¶</p>
<ol>
<li>
<p>The NuttX Binary Image <code>nuttx.bin</code> terminates at <code>_edata</code>. (End of Data Section)</p>
</li>
<li>
<p>If we append <code>initrd</code> directly to the end of <code>nuttx.bin</code>, it will collide with the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L74-L92">BSS Section</a> and the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_head.S#L94-L101">Idle Stack</a>. And <code>initrd</code> will get overwritten by NuttX.</p>
</li>
<li>
<p>Best place to append <code>initrd</code> is after the Top of Idle Stack. Which is located 32 KB after <code>_edata</code>. (End of Data Section)</p>
</li>
<li>
<p>That‚Äôs why we inserted a padding of 64 KB between <code>nuttx.bin</code> and <code>initrd</code>. So it won‚Äôt collide with BSS and Idle Stack.</p>
</li>
<li>
<p>Our code locates <code>initrd</code> (searching by Magic Number ‚Äú-rom1fs-‚Äù). And copies <code>initrd</code> to <code>__ramdisk_start</code>. (Memory Region for the RAM Disk)</p>
</li>
<li>
<p>NuttX mounts the RAM Disk from <code>__ramdisk_start</code>. (Memory Region for the RAM Disk)</p>
</li>
</ol>
<p><em>But 64 KB sounds so arbitrary. What if the parameters change?</em></p>
<p>That‚Äôs why we have a Runtime Check: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L190-L245">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // RAM Disk must be after Idle Stack
  if (ramdisk_addr &lt;= (uint8_t *)JH7110_IDLESTACK_TOP) { _info(&quot;RAM Disk must be after Idle Stack&quot;); }
  DEBUGASSERT(ramdisk_addr &gt; (uint8_t *)JH7110_IDLESTACK_TOP);
</code></pre></div>
<p><em>Why did we call local_memmove to copy <code>initrd</code> to <code>__ramdisk_start</code>? Why not memcpy?</em></p>
<p>That‚Äôs because <code>initrd</code> overlaps with <code>__ramdisk_start</code>!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ramdisk_addr = <span class="number">0x50408288</span>, size = <span class="number">8192016
</span>ramdisk_addr + size = <span class="number">0x50bd8298
</span>Which is AFTER __ramdisk_start (<span class="number">0x50a00000</span>)</code></pre></div>
<p><code>memcpy</code> won‚Äôt work with Overlapping Memory Regions. So we wrote our own: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L246-L487">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// From libs/libc/string/lib_memmove.c
static FAR void *local_memmove(FAR void *dest, FAR const void *src, size_t count) {
  FAR char *d;
  FAR char *s;
  DEBUGASSERT(dest &gt; src);
  d = (FAR char *) dest + count;
  s = (FAR char *) src + count;

  while (count--) {
    d -= 1;
    s -= 1;
    // TODO: Very strange. This needs to be volatile or C Compiler will replace this by memcpy.
    volatile char c = *s;
    *d = c;
  }
  return dest;
}
</code></pre></div>
<p><em>We‚Äôre sure that it works?</em></p>
<p>That‚Äôs why we called <code>verify_image</code> to do a simple integrity check on <code>initrd</code>, before and after copying. And that‚Äôs how we discovered that <code>memcpy</code> doesn‚Äôt work. From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_start.c#L246-L487">jh7110_start.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Verify that image is correct
static void verify_image(uint8_t *addr) {
  // Verify that the Byte Positions below (offset by 1) contain 0x0A
  for (int i = 0; i &lt; sizeof(search_addr) / sizeof(search_addr[0]); i++) {
    const uint8_t *p = addr + search_addr[i] - 1;
    if (*p != 0x0A) { _info(&quot;No Match: %p\n&quot;, p); }
  }
}

// Byte Positions (offset by 1) of 0x0A in initrd. Extracted from:
// grep --binary-files=text -b -o A initrd
const uint32_t search_addr[] =
{
76654,
78005,
79250,
...
7988897,
7992714,
};
</code></pre></div>
<p>But NuttX fails to start our NuttX Shell (NSH) ELF Executable from ‚Äú/system/bin/init‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>elf_read: Read 3392 bytes from offset 3385080
elf_addrenv_select: ERROR: up_addrenv_text_enable_write failed: -22
elf_load: ERROR: elf_addrenv_select() failed: -22
...
elf_loadbinary: Failed to load ELF program binary: -22
exec_internal: ERROR: Failed to load program &#39;/system/bin/init&#39;: -22
_assert: Current Version: NuttX  12.0.3 8017bd9-dirty Nov 10 2023 22:50:07 risc-v
_assert: Assertion failed ret &gt; 0: at file: init/nx_bringup.c:302 task: AppBringUp process: Kernel 0x502014ea
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/74a44a3e432e159c62cc2df6a726cb89">(Source)</a></p>
<p>Maybe because NuttX is trying to map the User Address Space 0xC000 0000: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/boards/risc-v/jh7110/star64/configs/nsh/defconfig#L17-L26">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_ARCH_TEXT_VBASE=0xC0000000
CONFIG_ARCH_TEXT_NPAGES=128
CONFIG_ARCH_DATA_VBASE=0xC0100000
CONFIG_ARCH_DATA_NPAGES=128
CONFIG_ARCH_HEAP_VBASE=0xC0200000
CONFIG_ARCH_HEAP_NPAGES=128
</code></pre></div>
<p>But our Kernel Memory Space already extends to 0xF000 0000? (Because of the PLIC at 0xE000 0000)</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/jh7110_mm_init.c#L43-L46">jh7110_mm_init.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>/* Map the whole I/O memory with vaddr = paddr mappings */
#define MMU_IO_BASE     (0x00000000)
#define MMU_IO_SIZE     (0xf0000000)
</code></pre></div>
<p><em>Let‚Äôs disable PLIC, and exclude PLIC from Memory Map. Will the NuttX Shell start?</em></p>
<p>Yep it does! <a href="https://gist.github.com/lupyuen/9fc9b2de9938b48666cc5e5fa3f8278e">(See the log)</a></p>
<p><img src="https://lupyuen.github.io/images/mmu-boot1.png" alt="Ox64 boots to NuttX Shell" /></p>
<p><a href="https://gist.github.com/lupyuen/aa9b3e575ba4e0c233ab02c328221525"><em>Ox64 boots to NuttX Shell</em></a></p>
<h1 id="whats-next"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>We‚Äôll do much more for <strong>NuttX on Ox64 BL808</strong>, stay tuned for updates!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/app.md"><strong>lupyuen.github.io/src/app.md</strong></a></p>

    
</body>
</html>