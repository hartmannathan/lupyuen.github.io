<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>BL602 Bootloader</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="BL602 Bootloader" 
    data-rh="true">
<meta property="og:description" 
    content="All about the BL602 RISC-V Bootloader... And how it loads the Application Firmware into XIP Flash Memory"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/boot-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">BL602 Bootloader</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-boot2-bootloader">1 BL602 Boot2 Bootloader</a><ul></ul></li>
<li><a href="#inside-the-bootloader">2 Inside the Bootloader</a><ul></ul></li>
<li><a href="#install-application-firmware">3 Install Application Firmware</a><ul></ul></li>
<li><a href="#write-firmware-to-xip-flash">4 Write Firmware to XIP Flash</a><ul></ul></li>
<li><a href="#bl602-partition-table">5 BL602 Partition Table</a><ul></ul></li>
<li><a href="#bl602-rom-driver-api">6 BL602 ROM Driver API</a><ul></ul></li>
<li><a href="#locating-the-rom-driver-api">7 Locating the ROM Driver API</a><ul></ul></li>
<li><a href="#start-the-firmware">8 Start the Firmware</a><ul></ul></li>
<li><a href="#remap-xip-flash">9 Remap XIP Flash</a><ul></ul></li>
<li><a href="#efuse-security">10 EFuse Security</a><ul></ul></li>
<li><a href="#bl602-firmware-boot-code">11 BL602 Firmware Boot Code</a><ul></ul></li>
<li><a href="#other-bootloaders">12 Other Bootloaders</a><ul></ul></li>
<li><a href="#whats-next">13 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">14 Notes</a><ul></ul></li></ul></nav><p>üìù <em>9 Jun 2021</em></p>
<p><em>How is our firmware loaded into BL602‚Äôs flash memory?</em></p>
<p><em>How does BL602 prevent tampering of firmware?</em></p>
<p>All this and much, much more shall be explained as we learn about the <strong>Boot2 Bootloader</strong> for the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V + WiFi SoC</strong></a>.</p>
<h1 id="bl602-boot2-bootloader"><a href="#bl602-boot2-bootloader">1 BL602 Boot2 Bootloader</a></h1>
<p>Let‚Äôs ponder what happens when we flash to BL602 the firmware that we have built‚Ä¶</p>
<p>(We‚Äôll call it the <strong>Application Firmware</strong>)</p>
<p><em>Sounds easy! We transfer the Application Firmware from our computer to BL602 (over USB)‚Ä¶</em></p>
<p><em>Then BL602 writes the Application Firmware to flash memory. Right?</em></p>
<p>Not quite. We talked about flashing Application Firmware in the article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/flash"><strong>‚ÄúFlashing Firmware to PineCone BL602‚Äù</strong></a></li>
</ul>
<p>During flashing, we transfer a <strong>Flashing Image</strong> from our computer to BL602 over USB, helped by the EFlash Loader‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/loader"><strong>‚ÄúBL602 EFlash Loader: Reverse Engineered with Ghidra‚Äù</strong></a></li>
</ul>
<p>The Flashing Image contains‚Ä¶</p>
<ol>
<li>
<p><strong>Boot2 Bootloader <code>blsp_boot2.bin</code></strong></p>
<p>(Written to the Flashing Image as <code>boot2image.bin</code>)</p>
</li>
<li>
<p><strong>Application Firmware <code>bl602.bin</code></strong></p>
<p>(Written to the Flashing Image as <code>fwimage.bin</code>)</p>
</li>
<li>
<p><strong>Partition Table <code>partition.bin</code></strong> and <strong>Device Tree <code>ro_params.dtb</code></strong></p>
</li>
</ol>
<p>Here‚Äôs how the Flashing Image is constructed‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-title.jpg" alt="Flashing BL602 firmware" /></p>
<p><em>Why is the Boot2 Bootloader transferred to BL602 during flashing?</em></p>
<p>During flashing, our Application Firmware isn‚Äôt written directly to BL602‚Äôs <strong>XIP Flash Memory</strong>.</p>
<p>Instead, <strong>BL602 runs the Boot2 Bootloader</strong> which‚Ä¶</p>
<ol>
<li>
<p><strong>Extracts our Application Firmware</strong> from the transferred Flashing Image</p>
</li>
<li>
<p><strong>Writes our Application Firmware</strong> to XIP Flash Memory</p>
</li>
<li>
<p><strong>Starts our Application Firmware</strong> from XIP Flash Memory</p>
</li>
</ol>
<p>XIP means <a href="https://en.wikipedia.org/wiki/Execute_in_place"><strong>Execute In Place</strong></a>.</p>
<p>It refers to the <strong>External Flash Memory (SPI Flash)</strong> that will store our executable firmware code.</p>
<p><em>Isn‚Äôt External Flash Memory too slow for running firmware code?</em></p>
<p>XIP uses <strong>Cache Memory</strong> (RAM) to speed up access to External Flash Memory.</p>
<p>This Cache Memory makes it possible to run firmware code stored in Flash Memory.</p>
<p><em>Where is the Boot2 Bootloader located?</em></p>
<p>BL602 runs the Boot2 Bootloader from XIP Flash Memory at address <strong><code>0x2300 0000</code></strong>.</p>
<p>Yep it‚Äôs the <strong>same address as our Application Firmware</strong>!</p>
<p><em>So the Bootloader overwrites itself by our Application Firmware?</em></p>
<p>Not quite. We‚Äôll learn later how the <strong>Boot2 Bootloader remaps the XIP Flash Memory</strong> to start the Application Firmware.</p>
<p><em>Is Boot2 really a Bootloader?</em></p>
<p>On other microcontrollers, the Bootloader is the first thing that runs when powered on. (Before jumping to the Application Firmware)</p>
<p>On BL602, the Boot2 Bootloader also <strong>installs new Application Firmware</strong> into XIP Flash Memory.</p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">(Somewhat similar to the MCUBoot Bootloader for PineTime Smart Watch)</a></p>
<p><em>Why so complicated?</em></p>
<p>BL602‚Äôs Boot2 Bootloader allows Application Firmware to be <strong>flashed securely</strong> to XIP Flash Memory‚Ä¶</p>
<ol>
<li>
<p>Boot2 Bootloader supports <strong>flashing of AES-Encrypted Application Firmware</strong></p>
<p>(So it‚Äôs possible to push encrypted firmware updates over-the-air)</p>
</li>
<li>
<p>Boot2 Bootloader can use <strong>Digital Signatures</strong> to verify that the Application Firmware is authentic</p>
<p>(Prevents tampering of firmware updates)</p>
</li>
</ol>
<p>We‚Äôll learn more about BL602 firmware security in a while.</p>
<p><img src="https://lupyuen.github.io/images/boot-loader.png" alt="BL602 Boot2 Bootloader runs at address 0x2300 0000" /></p>
<p><em>BL602 Boot2 Bootloader runs at address <code>0x2300 0000</code></em></p>
<h1 id="inside-the-bootloader"><a href="#inside-the-bootloader">2 Inside the Bootloader</a></h1>
<p>To understand the BL602 Bootloader, let‚Äôs look at the code inside‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-main.png" alt="Bootloader Main Function" /></p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L389-L571"><code>bl602_boot2/blsp_boot2.c</code></a></p>
<ol>
<li>
<p>The Bootloader starts by fetching the <strong>Clock Configuration and SPI Flash Configuration</strong> from the Flashing Image <a href="https://lupyuen.github.io/articles/flash#appendix-bl602-efuse-configuration">(See this)</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  SPI Flash Configuration
SPI_Flash_Cfg_Type flashCfg;

//  EFuse Hardware Configuration
Boot_Efuse_HW_Config efuseCfg;

int main(void) {
    ...
  //  It&#39;s better not enable interrupt
  //  BLSP_Boot2_Init_Timer();

  //  Set RAM Max size
  BLSP_Boot2_Disable_Other_Cache();

  //  Flush cache to get parameter
  BLSP_Boot2_Flush_XIP_Cache();

  Boot_Clk_Config clkCfg;  //  Clock Configuration
  ret = BLSP_Boot2_Get_Clk_Cfg(&amp;clkCfg);

  ret |= SF_Cfg_Get_Flash_Cfg_Need_Lock(0, &amp;flashCfg);
  BLSP_Boot2_Flush_XIP_Cache();</code></pre></div></li>
<li>
<p>Next the Bootloader <strong>initialises the Hardware Platform</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  bflb_platform_print_set(BLSP_Boot2_Get_Log_Disable_Flag());

  bflb_platform_init(BLSP_Boot2_Get_Baudrate());

  bflb_platform_deinit_time();</code></pre></div></li>
<li>
<p>We fetch the <strong>EFuse Configuration</strong> (for decrypting the Application Firmware and for verifying the firmware signature)</p>
<div class="example-wrap"><pre class="language-c"><code>  MSG_DBG(&quot;Get efuse config\r\n&quot;);
  BLSP_Boot2_Get_Efuse_Cfg(&amp;efuseCfg);</code></pre></div>
<p>(We‚Äôll see <strong><code>BLSP_Boot2_Get_Efuse_Cfg</code></strong> in a while)</p>
</li>
<li>
<p>We <strong>reset the Security Engine</strong> (for AES Encryption operations)</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Reset Sec_Eng for using
  BLSP_Boot2_Reset_Sec_Eng();</code></pre></div></li>
<li>
<p>The Bootloader supports <strong>multicore CPUs</strong>.  (Each core will start the Application Firmware with different parameters)</p>
<p>BL602 is a single-core CPU, so the <strong>CPU Count</strong> will be set to 1‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if (BLSP_Boot2_Get_Feature_Flag() != BLSP_BOOT2_SP_FLAG) {
    //  Get CPU count info
    cpuCount = BLSP_Boot2_Get_CPU_Count();
  } else {
    cpuCount = 1;
  }</code></pre></div></li>
<li>
<p>We <strong>fetch the Application Firmware Name</strong> from the Flashing Image.</p>
<p>Our Application Firmware is always named <strong>‚Äú<code>FW</code>‚Äù</strong> <a href="https://lupyuen.github.io/articles/flash#appendix-bl602-partition-table">(See this)</a></p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get power save mode
  psMode = BLSP_Read_Power_Save_Mode();

  //  Get User specified firmware
  uint8_t userFwName[9] = {0};  //  Firmware Name
  ARCH_MemCpy_Fast(
    userFwName,
    BLSP_Get_User_Specified_Fw(),
    4);</code></pre></div></li>
<li>
<p>We register the functions that will be called to <strong>Erase, Write and Read the Partition Table</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if (BLSP_Boot2_8M_Support_Flag()) {
    //  Set flash operation function, read via sbus
    PtTable_Set_Flash_Operation(PtTable_Flash_Erase,
      PtTable_Flash_Write, PtTable_Flash_Read);
  } else {
    //  Set flash operation function, read via xip
    PtTable_Set_Flash_Operation(PtTable_Flash_Erase,
      PtTable_Flash_Write, PtTable_Flash_Read);
  }</code></pre></div>
<p>(Yes the parameters for both calls of <code>PtTable_Set_Flash_Operation</code> are identical)</p>
</li>
<li>
<p>The Bootloader enters two loops‚Ä¶</p>
<ul>
<li>
<p><strong>Outer Loop ‚Äú<code>while</code>‚Äù</strong>: Loops until the writing (or rollback) of Application Firmware is complete</p>
</li>
<li>
<p><strong>Inner Loop ‚Äú<code>do</code>‚Äù</strong>: Loops through the Partition Table Entries until the writing of Application Firmware to XIP Flash Memory is complete </p>
</li>
</ul>
<div class="example-wrap"><pre class="language-c"><code>  while (1) {
    tempMode = 0;
    do {</code></pre></div>
<p>Let‚Äôs probe the inner loop‚Ä¶</p>
</li>
<li>
<p>We fetch the next <strong>Partition Table Entry</strong> from the Flashing Image‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      activeID = PtTable_Get_Active_Partition_Need_Lock(ptTableStuff);
      if (PT_TABLE_ID_INVALID==activeID){ BLSP_Boot2_On_Error(&quot;No valid PT\r\n&quot;); }

      BLSP_Boot2_Get_MFG_StartReq(
        activeID,
        &amp;ptTableStuff[activeID], 
        &amp;ptEntry[0],
        userFwName);</code></pre></div></li>
<li>
<p>We skip these two conditions because our Application Firmware is named ‚Äú<code>FW</code>‚Äù and we‚Äôre running on a single-core CPU‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Get entry and boot
      if (userFwName[0] == &#39;0&#39;) {
        //  Skip this code because our Firmware Name is &quot;FW&quot;
        ...
      } else if (userFwName[0] == &#39;1&#39; &amp;&amp; cpuCount &gt; 1) {
        //  Skip this code because our CPU Count is 1 (single core)
        ...
      } </code></pre></div></li>
<li>
<p>Now comes the fun part!</p>
<p>The Bootloader <strong>extracts the Application Firmware</strong> (from the Flashing Image) and <strong>writes it to XIP Flash Memory</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      else {
        ptParsed = BLSP_Boot2_Deal_One_FW(
          activeID,
          &amp;ptTableStuff[activeID],
          &amp;ptEntry[0],
          NULL,
          PT_ENTRY_FW_CPU0);

        if (ptParsed == 0) { continue; }
        if (cpuCount &gt; 1) {
          //  Skip this code because our CPU Count is 1 (single core)
          ...
        }
      }</code></pre></div>
<p>We‚Äôll study <strong><code>BLSP_Boot2_Deal_One_FW</code></strong> in the next chapter.</p>
</li>
<li>
<p>The Inner Loop repeats until it has located and processed the Application Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      ptParsed = 1;
    } while (ptParsed == 0);</code></pre></div></li>
<li>
<p>Now that the Application Firmware has been written to XIP Flash Memory, let‚Äôs get ready to start the Application Firmware!</p>
<p>We stage the <strong>Partition Table Entry</strong> that will be passed to the firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Pass data to App
    BLSP_Boot2_Pass_Parameter(NULL, 0);

    //  Pass active partition table ID
    BLSP_Boot2_Pass_Parameter(&amp;activeID, 4);

    //  Pass active partition table content: table header + entries + crc32
    BLSP_Boot2_Pass_Parameter(
      &amp;ptTableStuff[activeID],
      sizeof(PtTable_Config) + 4
        + ptTableStuff[activeID].ptTable.entryCnt
          * sizeof(PtTable_Entry_Config));</code></pre></div></li>
<li>
<p>We pass the <strong>Flash Configuration</strong> too‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Pass flash config
    if (ptEntry[0].Address[ptEntry[0].activeIndex] != 0) {
      XIP_SFlash_Read_Via_Cache_Need_Lock(
        BLSP_BOOT2_XIP_BASE 
          + ptEntry[0].Address[ptEntry[0].activeIndex] 
          + 8,
        flashCfgBuf,
        sizeof(flashCfgBuf));

      //  Include magic and CRC32
      BLSP_Boot2_Pass_Parameter(
        flashCfgBuf,
        sizeof(flashCfgBuf));
    }</code></pre></div></li>
<li>
<p>We initialise the <strong>Boot Header</strong> for each core (in a multicore CPU)</p>
<div class="example-wrap"><pre class="language-c"><code>    MSG_DBG(&quot;Boot start\r\n&quot;);
    for (i = 0; i &lt; cpuCount; i++) {
      bootHeaderAddr[i] = ptEntry[i].Address[ptEntry[i].activeIndex];
    }</code></pre></div></li>
<li>
<p>Finally we <strong>jump to the Application Firmware</strong> that has been written to XIP Flash Memory‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef BLSP_BOOT2_ROLLBACK  //  This is true
    //  Test mode is not need roll back
    if (rollBacked == 0 &amp;&amp; tempMode == 0) {
      ret = BLSP_MediaBoot_Main(bootHeaderAddr, bootRollback, 1);
    } else {
      ret = BLSP_MediaBoot_Main(bootHeaderAddr, bootRollback, 0);
    }
#else  //  This is false
    ...
#endif
    //  Fail in temp mode, continue to boot normal image
    if (tempMode == 1) { continue; }</code></pre></div>
<p>(<strong><code>BLSP_BOOT2_ROLLBACK</code></strong> is defined because the Bootloader supports firmware rollback)</p>
<p>We‚Äôll cover <strong><code>BLSP_MediaBoot_Main</code></strong> in a while.</p>
</li>
<li>
<p>What happens if the Bootloader fails to update or start the new Application Firmware?</p>
<p>The Bootloader will <strong>rollback the Application Firmware</strong> and restore the previous version into XIP Flash Memory‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef BLSP_BOOT2_ROLLBACK  //  This is true
    //  If rollback is done, we still fail, break
    if (rollBacked) { break; }
    for (i = 0; i &lt; cpuCount; i++) {
      if (bootRollback[i] != 0) {
        if (BFLB_BOOT2_SUCCESS == BLSP_Boot2_Rollback_PtEntry(
          activeID, &amp;ptTableStuff[activeID], &amp;ptEntry[i])) {
          rollBacked = 1;
        }
      }
    }
    //  If need no rollback, boot fail due to other reseaon instead of imgae issue, break
    if (rollBacked == 0) { break; }
#else  //  This is false
    ...
#endif
  }</code></pre></div>
<p>(The Outer Loop ends here)</p>
</li>
<li>
<p>The Main Function of the Bootloader will never return, because the Bootloader <strong>always jumps to the Application Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  We should never get here unless boot fail
  MSG_ERR(&quot;Media boot return %d\r\n&quot;,ret);
  while (1) {
    MSG_ERR(&quot;BLSP boot2 fail\r\n&quot;);
    ARCH_Delay_MS(500);
  }
}</code></pre></div></li>
</ol>
<p>That‚Äôs how the Bootloader installs our Application Firmware and starts the firmware!</p>
<p><img src="https://lupyuen.github.io/images/boot-main2.png" alt="Bootloader Main Function" /></p>
<h1 id="install-application-firmware"><a href="#install-application-firmware">3 Install Application Firmware</a></h1>
<p>As we‚Äôve seen, the Bootloader calls <strong><code>BLSP_Boot2_Deal_One_FW</code></strong> to‚Ä¶</p>
<ol>
<li>
<p><strong>Extract the Application Firmware</strong> from the Flashing Image</p>
</li>
<li>
<p><strong>Write the Application Firmware</strong> to XIP Flash Memory</p>
</li>
</ol>
<p>Here‚Äôs how it works: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L271-L313"><code>blsp_boot2.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Boot2 deal with one firmware.
//  Return 0 for partition table changed, need re-parse.
//  Return 1 for partition table or entry parsed successfully.
static int BLSP_Boot2_Deal_One_FW(
  PtTable_ID_Type activeID,       //  Active partition table ID
  PtTable_Stuff_Config *ptStuff,  //  Pointer of partition table stuff
  PtTable_Entry_Config *ptEntry,  //  Pointer of active entry
  uint8_t *fwName,                //  Firmware name pointer
  PtTable_Entry_Type type) {      //  Firmware name ID
  uint32_t ret;

  if (fwName != NULL) {
    MSG_DBG(&quot;Get FW:%s\r\n&quot;, fwName);
    ret = PtTable_Get_Active_Entries_By_Name(ptStuff, fwName, ptEntry);
  } else {
    MSG_DBG(&quot;Get FW ID:%d\r\n&quot;, type);
    ret = PtTable_Get_Active_Entries_By_ID(ptStuff, type, ptEntry);
  }</code></pre></div>
<p><strong><code>BLSP_Boot2_Deal_One_FW</code></strong> starts by fetching the <strong>Partition Table Entry</strong> for our Application Firmware named ‚Äú<code>FW</code>‚Äù.</p>
<p>Then it <strong>extracts the Application Firmware</strong> from the Flashing Image‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if (PT_ERROR_SUCCESS != ret) {
    MSG_ERR(&quot;Entry not found\r\n&quot;);
  } else {
    BLSP_Dump_PtEntry(ptEntry);
    MSG_DBG(&quot;Check Img\r\n&quot;);
    if (BLSP_Boot2_Check_XZ_FW(activeID, ptStuff, ptEntry) == 1) {
      return 0;
    }</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L190-L224"><strong><code>BLSP_Boot2_Check_XZ_FW</code></strong></a> extracts and decompresses the Application Firmware. <a href="https://en.wikipedia.org/wiki/XZ_Utils">(XZ Compression)</a></p>
<p>Now that we have the decompressed Application Firmware, we <strong>write the firmware to XIP Flash Memory</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Check if this partition need copy
    if (ptEntry-&gt;activeIndex &gt;= 2) {
      if (BFLB_BOOT2_SUCCESS == BLSP_Boot2_Do_FW_Copy(
        activeID, 
        ptStuff, 
        ptEntry)) {
        return 0;
      }
    }
  }
  return 1;
}</code></pre></div>
<p>In the next chapter we study <strong><code>BLSP_Boot2_Do_FW_Copy</code></strong>.</p>
<p><img src="https://lupyuen.github.io/images/boot-install.png" alt="Bootloader installing Application Firmware" /></p>
<h1 id="write-firmware-to-xip-flash"><a href="#write-firmware-to-xip-flash">4 Write Firmware to XIP Flash</a></h1>
<p>Previously on ‚ÄúDays Of Our Lives‚Äù‚Ä¶ The Bootloader decompresses the Application Firmware and calls <strong><code>BLSP_Boot2_Do_FW_Copy</code></strong> to write the firmware to XIP Flash Memory.</p>
<p>Watch what happens next: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L226-L269"><code>blsp_boot2.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Buffer for writing to XIP Flash Memory
#define BFLB_BOOT2_READBUF_SIZE  4 * 1024
uint8_t boot2ReadBuf[BFLB_BOOT2_READBUF_SIZE] __attribute__((section(&quot;.system_ram&quot;)));

//  Boot2 copy firmware from OTA region to normal region
static int BLSP_Boot2_Do_FW_Copy(
  PtTable_ID_Type activeID,         //  Active partition table ID
  PtTable_Stuff_Config *ptStuff,    //  Pointer of partition table stuff
  PtTable_Entry_Config *ptEntry) {  //  Pointer of active entry

  uint8_t activeIndex = ptEntry-&gt;activeIndex;
  uint32_t srcAddress = ptEntry-&gt;Address[activeIndex&amp;0x01];
  uint32_t destAddress = ptEntry-&gt;Address[!(activeIndex&amp;0x01)];
  uint32_t destMaxSize = ptEntry-&gt;maxLen[!(activeIndex&amp;0x01)];
  uint32_t totalLen = ptEntry-&gt;len;
  uint32_t dealLen = 0;
  uint32_t curLen = 0;</code></pre></div>
<p><strong><code>BLSP_Boot2_Do_FW_Copy</code></strong> starts by fetching the <strong>Partition Table Entry</strong> for the Application Firmware, containing <strong>Source Address, Destination Address and Firmware Length</strong>.</p>
<p>(More about the Partition Table in the next chapter)</p>
<p>Then it <strong>erases the XIP Flash Memory</strong> at the Destination Address‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if (SUCCESS != XIP_SFlash_Erase_Need_Lock(
    &amp;flashCfg,
    destAddress,
    destAddress+destMaxSize - 1)) {
    MSG_ERR(&quot;Erase flash fail&quot;);
    return BFLB_BOOT2_FLASH_ERASE_ERROR;
  }</code></pre></div>
<p>Next we handle the decompressed Application Firmware, chunk by chunk (4 KB)</p>
<div class="example-wrap"><pre class="language-c"><code>  while (dealLen &lt; totalLen) {
    curLen = totalLen - dealLen;
    if (curLen &gt; sizeof(boot2ReadBuf)) {
      curLen = sizeof(boot2ReadBuf);
    }</code></pre></div>
<p>We <strong>read the decompressed Application Firmware</strong> (in 4 KB chunks)</p>
<div class="example-wrap"><pre class="language-c"><code>    if (BFLB_BOOT2_SUCCESS != BLSP_MediaBoot_Read(
      srcAddress,
      boot2ReadBuf,
      curLen)) {
      MSG_ERR(&quot;Read FW fail when copy\r\n&quot;);
      return BFLB_BOOT2_FLASH_READ_ERROR;
    }</code></pre></div>
<p>We <strong>write the firmware to XIP Flash Memory</strong> (in 4 KB chunks)</p>
<div class="example-wrap"><pre class="language-c"><code>    if (SUCCESS != XIP_SFlash_Write_Need_Lock(
      &amp;flashCfg,
      destAddress,
      boot2ReadBuf,
      curLen)) {
      MSG_ERR(&quot;Write flash fail&quot;);
      return BFLB_BOOT2_FLASH_WRITE_ERROR;
    }</code></pre></div>
<p>Finally we repeat the steps with the <strong>next 4 KB chunk</strong>, until the entire decompressed Application Firmware is written to XIP Flash Memory‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    srcAddress += curLen;
    destAddress += curLen;
    dealLen += curLen;
  }
  return BFLB_BOOT2_SUCCESS;
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/boot-write.png" alt="Bootloader writing firmware to XIP flash" /></p>
<h1 id="bl602-partition-table"><a href="#bl602-partition-table">5 BL602 Partition Table</a></h1>
<p><em>The Bootloader appears to be driven by the Partition Table (from the Flashing Image). What‚Äôs inside the Partition Table?</em></p>
<p>Each entry of the <strong>Partition Table</strong> describes a <strong>section of the Flashing Image</strong>.</p>
<p>Here‚Äôs the <strong>Partition Table Entry</strong> that describes our <strong>Application Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>[[pt_entry]]
type     = 0
name     = &quot;FW&quot;
device   = 0
address0 = 0x10000
size0    = 0xC8000
address1 = 0xD8000
size1    = 0x88000
len      = 0</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/flash#appendix-bl602-partition-table">(From this BL602 Partition Table)</a></p>
<p>This Partition Table Entry says that our Application Firmware (compressed) is located in the Flash Image at <strong>offset <code>0x10000</code> with size <code>0xC8000</code></strong> (compressed).</p>
<p>(But why are there two firmware sections <code>0x10000</code> and <code>0xD8000</code>?)</p>
<p>With this information, our Bootloader will be able to decompress the Application Firmware and write to XIP Flash Memory‚Ä¶ </p>
<div class="example-wrap"><pre class="language-c"><code>static int BLSP_Boot2_Do_FW_Copy( ... ) {
  //  Fetch the Partition Table Entry for the Application Firmware
  uint8_t activeIndex = ptEntry-&gt;activeIndex;
  uint32_t srcAddress = ptEntry-&gt;Address[activeIndex&amp;0x01];
  uint32_t destAddress = ptEntry-&gt;Address[!(activeIndex&amp;0x01)];
  uint32_t destMaxSize = ptEntry-&gt;maxLen[!(activeIndex&amp;0x01)];
  uint32_t totalLen = ptEntry-&gt;len;</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L226-L269">(We‚Äôve seen this earlier in <code>blsp_boot2.c</code>)</a></p>
<p><strong>Exercise for the Reader:</strong> Please take these two things‚Ä¶</p>
<ol>
<li>
<p><strong><code>pt_entry</code></strong> Partition Table Entry above</p>
</li>
<li>
<p><strong><code>BLSP_Boot2_Do_FW_Copy</code></strong> code above</p>
</li>
</ol>
<p>Match them and verify that the code makes sense!</p>
<p>(Maybe we‚Äôll figure out why there are two firmware sections <code>0x10000</code> and <code>0xD8000</code>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#partition-table">More about BL602 Partition Table</a></p>
<p><img src="https://lupyuen.github.io/images/boot-partition.png" alt="Matching the BL602 Partition Table" /></p>
<h1 id="bl602-rom-driver-api"><a href="#bl602-rom-driver-api">6 BL602 ROM Driver API</a></h1>
<p>Earlier we‚Äôve seen these functions called by the Bootloader to <strong>access XIP Flash Memory</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>XIP_SFlash_Erase_Need_Lock</strong>: Erase XIP Flash Memory</p>
</li>
<li>
<p><strong>XIP_SFlash_Read_Via_Cache_Need_Lock</strong>: Read XIP Flash Memory</p>
</li>
<li>
<p><strong>XIP_SFlash_Write_Need_Lock</strong>: Write XIP Flash Memory</p>
</li>
</ul>
<p><em>These XIP Flash Memory Functions are defined in the Bootloader right?</em></p>
<p>Not quite‚Ä¶ The XIP Flash Memory Functions are located in the <strong>BL602 Boot ROM</strong>!</p>
<p><em>Shiver me timbers and call me Shirley! What‚Äôs the BL602 Boot ROM?</em></p>
<p><strong>BL602 Boot ROM</strong> is the region of <strong>Read-Only Memory at <code>0x2100 0000</code></strong> that contains‚Ä¶</p>
<ol>
<li>
<p><strong>Boot Code</strong> that‚Äôs run whenever we power on (or reset) BL602</p>
<p>(The Boot Code runs just before the Bootloader)</p>
</li>
<li>
<p><strong>ROM Driver API</strong> called by the Bootloader</p>
<p>(Like the XIP Flash Memory Functions above)</p>
</li>
</ol>
<p><em>Why put the ROM Driver API in the Boot ROM?</em></p>
<ul>
<li>
<p>We <strong>reduce the Bootloader size</strong> by placing the low-level functions in Boot ROM</p>
</li>
<li>
<p>Some ROM Driver Functions need to run in a <strong>secure, tamper-proof ROM environment</strong></p>
<p>(Like the functions for decrypting and verifying Application Firmware)</p>
</li>
</ul>
<p><em>Wait this sounds familiar‚Ä¶?</em></p>
<p>Our computers have a similar Boot ROM‚Ä¶ It‚Äôs called the <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface"><strong>Unified Extensible Firmware Interface (UEFI)</strong></a></p>
<p>It contains secure boot code that‚Äôs run whenever we power on our computer.</p>
<p>In the next chapter we shall explore the <strong>Table of ROM Driver API Functions</strong> located in ROM API at <strong><code>0x2101 0800</code></strong></p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_romdriver.h"><code>bl602_romdriver.h</code></a> ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-driver5.png" alt="ROM Driver API in Boot ROM" /></p>
<h1 id="locating-the-rom-driver-api"><a href="#locating-the-rom-driver-api">7 Locating the ROM Driver API</a></h1>
<p><em>How did we find out that the ROM Driver API is located in Boot ROM?</em></p>
<p>Let‚Äôs look at the <strong>RISC-V Disassembly for the Bootloader</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/releases/download/v8.0.2/bl602_boot2.S"><code>bl602_boot2.S</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>__ALWAYS_INLINE BL_Err_Type ATTR_TCM_SECTION 
XIP_SFlash_Read_Via_Cache_Need_Lock(
  uint32_t addr,
  uint8_t *data, 
  uint32_t len) {
  return RomDriver_XIP_SFlash_Read_Via_Cache_Need_Lock(
    addr, 
    data, 
    len);
}</code></pre></div>
<p>That‚Äôs the C definition of the function <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_romapi.c#L833-L836"><strong>XIP_SFlash_Read_Via_Cache_Need_Lock</strong></a>.</p>
<p>(Which is called by the Bootloader to read XIP Flash Memory)</p>
<p><em>The function looks kinda empty?</em></p>
<p>Yes, because <strong>XIP_SFlash_Read_Via_Cache_Need_Lock</strong> is a <strong>Stub Function</strong>.</p>
<p>It forwards the Function Call to the _<em>Real Function: RomDriver_XIP_SFlash_Read_Via_Cache <em>Need_Lock</em></em>.</p>
<p><em>Where is the Real Function for reading XIP Flash Memory?</em></p>
<p>After the code above we see the RISC-V Assembly Code that the GCC Compiler has emitted for our Stub Function‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>2201050a &lt;XIP_SFlash_Read_Via_Cache_Need_Lock&gt;:
2201050a:	210117b7          	lui	a5,0x21011
2201050e:	aa47a303          	lw	t1,-1372(a5) # 21010aa4 &lt;StackSize+0x210106a4&gt;
22010512:	8302                jr	t1</code></pre></div>
<p><em>So the Real Function is located at <code>0x2101 0aa4</code>?</em></p>
<p>Right! _<em>RomDriver_XIP_SFlash_Read_Via_Cache <em>Need_Lock</em></em> is located in the Boot ROM at <code>0x2101 0aa4</code>.</p>
<p>(Remember that the Boot ROM lives at <code>0x2100 0000</code> to <code>0x2101 FFFF</code>)</p>
<p>Hence when the Bootloader reads XIP Flash Memory‚Ä¶</p>
<ol>
<li>
<p>Bootloader calls the <strong>Stub Function</strong> at <code>0x2201 050a</code></p>
<p>(Located in ITCM)</p>
</li>
<li>
<p>Stub Function calls the <strong>Real Function</strong> at <code>0x2101 0aa4</code></p>
<p>(Located in Boot ROM)</p>
</li>
</ol>
<p><em>What‚Äôs ITCM?</em></p>
<p>ITCM means <strong>Instruction Tightly Coupled Memory</strong>.</p>
<p>This is <strong>Cache Memory</strong> (RAM) that has been configured (via the Level 1 Cache Controller) for code execution.</p>
<p>(See ‚ÄúChapter 7: L1C (Level 1 Cache)‚Äù in the BL602 Reference Manual)</p>
<p><img src="https://lupyuen.github.io/images/boot-driver3.png" alt="BL602 Bootloader Linker Script defines functions in ITCM" /></p>
<p><em>What are the functions in the ROM Driver API?</em></p>
<p>The <strong>ROM Driver Functions</strong> are listed in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_romdriver.c#L80-L269"><code>bl602_romdriver.c</code></a> and <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_romdriver.h"><code>bl602_romdriver.h</code></a></p>
<p>The functions cover‚Ä¶</p>
<ul>
<li>
<p>Power On / Off, Power Management, Reset</p>
</li>
<li>
<p>Memory Access, Flash Memory</p>
</li>
<li>
<p>GPIO, EFuse and Delay</p>
</li>
</ul>
<p>The <strong>Bootloader Linker Map <a href="https://github.com/lupyuen/bl_iot_sdk/releases/download/v8.0.2/bl602_boot2.map"><code>bl602_boot2.map</code></a></strong> reveals the <strong>Table of ROM Driver Stub Functions</strong> at ITCM address <code>0x2201 0000</code>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-driver.png" alt="ROM Driver Functions" /></p>
<h1 id="start-the-firmware"><a href="#start-the-firmware">8 Start the Firmware</a></h1>
<p>Earlier we‚Äôve seen the Bootloader calling <strong><code>BLSP_MediaBoot_Main</code></strong> to start our Application Firmware.</p>
<p>Let‚Äôs look inside the function: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_media_boot.c#L337-L434"><code>blsp_media_boot.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code> //  Media boot main process
int32_t BLSP_MediaBoot_Main(
  uint32_t cpuBootheaderAddr[BFLB_BOOT2_CPU_MAX],  //  CPU bootheader address list
  uint8_t cpuRollBack[BFLB_BOOT2_CPU_MAX],         //  CPU need roll back flag hold list
  uint8_t rollBack) {  //  1 for rollback when imge error occurs, 0 for not rollback when imge error occurs
    
  //  Omitted: Reset some parameters
  ...    
  //  Omitted: Try to boot from flash
  ret = BLSP_MediaBoot_Parse_One_FW(
    &amp;bootImgCfg[i],
    bootHeaderAddr[i],
    bootHeaderAddr[i] + BFLB_FW_IMG_OFFSET_AFTER_HEADER);
  ...
  //  Omitted: Get MSP and PC value
  ...    
  //  Fix invalid PC and MSP
  BLSP_Fix_Invalid_MSP_PC();   
       
  //  Prepare jump to entry
  BLSP_MediaBoot_Pre_Jump();
    
  //  We should never get here unless something is wrong
  return BFLB_BOOT2_FAIL;
}</code></pre></div>
<p>This code calls <strong><code>BLSP_MediaBoot_Pre_Jump</code></strong> to start the firmware.</p>
<p>Let‚Äôs trace it: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_common.c#L113-L133"><code>blsp_common.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Media boot pre-jump
int32_t BLSP_MediaBoot_Pre_Jump(void) {
  //  Security Engine deinit
  BLSP_Boot2_Reset_Sec_Eng();
    
  //  Platform deinit
  bflb_platform_deinit(); 
    
  //  Jump to entry point
  BLSP_Boot2_Jump_Entry();    
  return BFLB_BOOT2_SUCCESS;
}</code></pre></div>
<p>Here we clean up the Security Engine and the Hardware Platform after use.</p>
<p>Then we call <strong><code>BLSP_Boot2_Jump_Entry</code></strong> to jump to the Application Firmware.</p>
<p>Let‚Äôs probe deeper: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_common.c#L165-L257"><code>blsp_common.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Boot2 jump to entryPoint
void ATTR_TCM_SECTION BLSP_Boot2_Jump_Entry(void) {
  ...    
  BLSP_Sboot_Finish();    
        
  //  Enable cache with flash offset.
  //  Note: After this, should be no flash direct read,
  //  If need to read, should take flash offset into consideration
  if (0 != efuseCfg.encrypted[0]) {
    //  For encrypted img, use non-continuous read
    ret = BLSP_Boot2_Set_Cache(
      0,
      &amp;flashCfg,
      &amp;bootImgCfg[0]);
  } else {
    //  For unencrypted img, use continuous read
    ret = BLSP_Boot2_Set_Cache(
      1,
      &amp;flashCfg,
      &amp;bootImgCfg[0]);
  }
  //  Omitted: Set decryption before reading MSP and PC
  if (0 != efuseCfg.encrypted[0]) {
    BLSP_Boot2_Set_Encrypt(0, &amp;bootImgCfg[0]);
    BLSP_Boot2_Set_Encrypt(1, &amp;bootImgCfg[1]);
    ...
  }
  //  Omitted: Handle Other CPU&#39;s entry point
  ...    
  //  Handle CPU0&#39;s entry point
  if (bootImgCfg[0].imgValid) {
    pentry = (pentry_t) bootImgCfg[0].entryPoint;
    if (bootImgCfg[0].mspVal != 0) {
      __set_MSP(bootImgCfg[0].mspVal);
    }
    ...
    //  Jump to the entry point
    if (pentry != NULL) { pentry(); }
  }   </code></pre></div>
<p>As expected, the function ends by <strong>jumping to the Entry Point</strong> of our Application Firmware: <code>pentry</code></p>
<p>But before that, it calls <strong><code>BLSP_Boot2_Set_Cache</code></strong> to fix up the XIP Flash Memory.</p>
<p>Let‚Äôs find out why.</p>
<h1 id="remap-xip-flash"><a href="#remap-xip-flash">9 Remap XIP Flash</a></h1>
<p>Remember that the <strong>Bootloader and Application Firmware</strong> are both programmed to run at the <strong>same XIP Flash Memory address <code>0x2300 0000</code></strong>.</p>
<p><em>Does the Bootloader overwrite itself with the Application Firmware?</em></p>
<p>Not quite! Here‚Äôs the answer, many thanks to <a href="https://twitter.com/__9names/status/1401152245693960193"><strong>9names on Twitter</strong></a>‚Ä¶</p>
<blockquote>
<p>‚ÄúIt doesn‚Äôt overwrite itself, that‚Äôs the trick.
What is at <code>0x23000000</code> depends on how the cache is configured, you can change it!‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúSee <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_common.c#L165-L257"><code>BLSP_Boot2_Jump_Entry</code> in <code>blsp_common.c</code></a> for an example. This is what makes it possible to boot multiple applications without patching the firmware‚Äù</p>
</blockquote>
<p>We‚Äôve seen <strong><code>BLSP_Boot2_Jump_Entry</code></strong> in the previous chapter: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_common.c#L165-L257"><code>blsp_common.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Boot2 jump to entryPoint
void ATTR_TCM_SECTION BLSP_Boot2_Jump_Entry(void) {
  ...    
  //  Enable cache with flash offset.
  //  Note: After this, should be no flash direct read,
  //  If need to read, should take flash offset into consideration
  //  For unencrypted img, use continuous read
  ret = BLSP_Boot2_Set_Cache(
    1,
    &amp;flashCfg,
    &amp;bootImgCfg[0]);</code></pre></div>
<p>This code calls <strong><code>BLSP_Boot2_Set_Cache</code> to fix up the cache</strong> for XIP Flash Memory: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_port.c#L423-L485"><code>blsp_port.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Media boot set cache according to image config
int32_t ATTR_TCM_SECTION BLSP_Boot2_Set_Cache(
  uint8_t contRead,
SPI_Flash_Cfg_Type *flashCfg,
    Boot_Image_Config *bootImgCfg) {
  ...
  //  If flash caching is enabled...
  if (bootImgCfg[0].cacheEnable) {

    //  And the Entry Point is in XIP Flash Memort 0x2300 0000...
    if ((bootImgCfg[0].entryPoint &amp; 0xFF000000) == BLSP_BOOT2_XIP_BASE) {

      //  Set the flash image offset
      SF_Ctrl_Set_Flash_Image_Offset(
        bootImgCfg[0].imgStart.flashOffset);

      //  Enable reading of flash cache
      SFlash_Cache_Read_Enable(
        flashCfg,
        SF_CTRL_QIO_MODE,
        contRead,
        bootImgCfg[0].
        cacheWayDisable);</code></pre></div>
<p>When we match this code with <a href="https://lupyuen.github.io/articles/flash#appendix-bl602-efuse-configuration">this Flashing Image Configuration</a>, we get‚Ä¶</p>
<ul>
<li>
<p><strong><code>cacheEnable</code></strong> is true</p>
</li>
<li>
<p><strong><code>entryPoint</code></strong> is <code>BLSP_BOOT2_XIP_BASE</code> (<code>0x2300 0000</code>)</p>
</li>
<li>
<p><strong><code>imgStart</code></strong> is <code>0x2000</code></p>
</li>
</ul>
<p>The calls to <strong>SF_Ctrl_Set_Flash_Image_Offset</strong> and <strong>SFlash_Cache_Read_Enable</strong> will <strong>remap the XIP Cache</strong>.</p>
<p>After remapping the XIP Cache, <strong><code>0x2300 0000</code> will point to our Application Firmware.</strong> (Instead of the Bootloader)</p>
<p>And that‚Äôs how we <strong>switch over from Bootloader to Application Firmware</strong> in XIP Flash Memory!</p>
<p>(Note that <strong>SF_Ctrl_Set_Flash_Image_Offset</strong> and <strong>SFlash_Cache_Read_Enable</strong> are defined in the Boot ROM and we can‚Äôt see the source code. So it‚Äôs possible that our interpretation is incorrect)</p>
<h1 id="efuse-security"><a href="#efuse-security">10 EFuse Security</a></h1>
<p><em>What‚Äôs an EFuse in BL602?</em></p>
<p>An <strong>EFuse</strong> stores one bit of data (<code>0</code> or <code>1</code>) in a special way‚Ä¶ Once an EFuse is set to <code>1</code>, it can never be reset to <code>0</code>.</p>
<p>BL602 has 1,024 EFuses (1,024 bits).</p>
<p><em>How are EFuses used in BL602?</em></p>
<p>Since the EFuses are one-time write-only bits, they are useful for storing AES Encryption Keys securely.</p>
<p>Once the AES Encryption Keys have been injected into BL602‚Äôs EFuses, they can never be changed.</p>
<p><em>Why would we need AES Encryption Keys in BL602?</em></p>
<ol>
<li>
<p>BL602 Bootloader supports <strong>flashing of AES-Encrypted Application Firmware</strong></p>
<p>(So it‚Äôs possible to push encrypted firmware updates over-the-air)</p>
</li>
<li>
<p>BL602 Bootloader can use <strong>Digital Signatures</strong> to verify that the Application Firmware is authentic</p>
<p>(Prevents tampering of firmware updates)</p>
</li>
</ol>
<p>We don‚Äôt encrypt and sign firmware images during development.</p>
<p>But let‚Äôs watch how the BL602 Bootloader handles encrypted and signed firmware images for commercial BL602 gadgets.</p>
<p><a href="https://lupyuen.github.io/articles/flash#efuse-configuration">More about BL602 EFuse</a></p>
<p><em>How does the Bootloader work with the EFuse Hardware?</em></p>
<p>Earlier we saw the Bootloader calling <strong><code>BLSP_Boot2_Get_Efuse_Cfg</code></strong> to read the EFuse Configuration.</p>
<p>Here‚Äôs what happens inside: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_port.c#L184-L209"><code>blsp_port.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Boot2 get efuse config security
void ATTR_TCM_SECTION BLSP_Boot2_Get_Efuse_Cfg(
  Boot_Efuse_HW_Config *efuseCfg) {
  uint32_t tmp;

  HBN_Set_ROOT_CLK_Sel(GLB_ROOT_CLK_XTAL);

  //  Get sign and AES type
  EF_Ctrl_Read_Secure_Boot(
    (EF_Ctrl_Sign_Type*) efuseCfg-&gt;sign, 
    (EF_Ctrl_SF_AES_Type*) efuseCfg-&gt;encrypted);

  //  Get hash: AES key slot 0 and slot 1
  EF_Ctrl_Read_AES_Key(
    0,
    (uint32_t *) efuseCfg-&gt;pkHashCpu0,
    8);
  EF_Ctrl_Read_Chip_ID(efuseCfg-&gt;chipID);

  //  Get HBN check sign config
  EF_Ctrl_Read_Sw_Usage(0, &amp;tmp);
  efuseCfg-&gt;hbnCheckSign = (tmp &gt;&gt; 22) &amp; 0x01;

  GLB_Set_System_CLK_Div(0, 1);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
}</code></pre></div>
<p>This code calls the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_ef_ctrl.c"><strong><code>EF_Ctrl</code> Functions</strong></a> from the BL602 Standard Driver to access the EFuse Hardware.</p>
<p><img src="https://lupyuen.github.io/images/boot-efuse.png" alt="EFuse Configuration" /></p>
<p>We <strong>decrypt the firmware</strong> with the EFuse Key here: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_port.c#L386-L421"><code>blsp_port.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Set encryption config
int32_t ATTR_TCM_SECTION BLSP_Boot2_Set_Encrypt(
  uint8_t index,                    //  Region index
  Boot_Image_Config *bootImgCfg) {  //  Boot image config pointer to hold parsed information
  ...
  //  Set AES Key
  SF_Ctrl_AES_Set_Key_BE(
      index, 
      NULL,
      (SF_Ctrl_AES_Key_Type) (bootImgCfg-&gt;encryptType - 1));

  //  Set AES Initialisation Vector
  SF_Ctrl_AES_Set_IV_BE(
      index, 
      bootImgCfg-&gt;aesiv,
      bootImgCfg-&gt;imgStart.flashOffset);

  //  Set AES Region
  SF_Ctrl_AES_Set_Region(
      index,
      1,  //  Enable this region
      1,  //  Hardware key
      bootImgCfg-&gt;imgStart.flashOffset,
      bootImgCfg-&gt;imgStart.flashOffset + len - 1,
      bootImgCfg-&gt;aesRegionLock);

  //  Enable AES decryption
  SF_Ctrl_AES_Enable_BE();
  SF_Ctrl_AES_Enable();</code></pre></div><h1 id="bl602-firmware-boot-code"><a href="#bl602-firmware-boot-code">11 BL602 Firmware Boot Code</a></h1>
<p>Today we looked at the Boot Code in the <strong>BL602 Bootloader</strong> and <strong>BL602 Boot ROM</strong>‚Ä¶</p>
<p><em>We‚Äôve seen all the BL602 Boot Code right?</em></p>
<p>Wait‚Ä¶ There‚Äôs more!</p>
<p>Our <strong>BL602 Application Firmware</strong> includes these functions from the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c"><strong>BL602 Boot2 Hardware Abstraction Layer</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c#L104-L110"><strong><code>hal_boot2_get_flash_addr</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c#L113-L161"><strong><code>hal_boot2_partition_bus_addr</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c#L163-L176"><strong><code>hal_boot2_partition_bus_addr_active</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c#L193-L217"><strong><code>hal_boot2_partition_addr</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c#L219-L232"><strong><code>hal_boot2_partition_addr_active</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_boot2.c#L269-L281"><strong><code>hal_boot2_init</code></strong></a></p>
</li>
</ul>
<p>This is revealed by the <strong>Linker Map for our Blinky Firmware</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/releases/download/v8.0.1/sdk_app_blinky.map"><code>sdk_app_blinky.map</code></a></p>
<p>(We might talk about these functions in a future article‚Ä¶ Lemme know if you‚Äôre keen!)</p>
<p><img src="https://lupyuen.github.io/images/boot-code.png" alt="BL602 Boot Code in Application Firmware" /></p>
<p>Remember <strong>Table of ROM Driver Stub Functions</strong> loaded by the Bootloader into ITCM (Instruction Cache Memory)?</p>
<p>Our Application Firmware has a similar Table of ROM Driver Stub Functions. But it‚Äôs loaded into <strong>DTCM (Data Cache Memory)</strong> instead‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-driver2.png" alt="Table of ROM Driver Stub Functions in DTCM for Application Firmware" /></p>
<h1 id="other-bootloaders"><a href="#other-bootloaders">12 Other Bootloaders</a></h1>
<p><em>How does BL602 Bootloader compare with other Bootloaders?</em></p>
<ol>
<li>
<p><strong>ESP32 Secure Boot V2</strong></p>
<p>Similar to BL602, ESP32 supports <strong>XIP Flash Memory</strong> and <strong>EFuse Protection</strong>.</p>
<p>Hence the Bootloaders for ESP32 and BL602 probably work the same way.</p>
<p><a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/security/secure-boot-v2.html">More about ESP32 Secure Boot V2</a></p>
</li>
<li>
<p><strong>RP2040</strong></p>
<p>RP2040 also supports <strong>XIP Flash Memory</strong> in its Hardware Flash API (<code>hardware_flash</code>)</p>
<p>RP2040 has a <strong>Second Stage Bootloader</strong> (<code>boot_stage2</code>) that probably works like the BL602 Bootloader.</p>
<p>Remember the <strong>Boot ROM</strong> in BL602? RP2040 provides an API (<code>pico_bootrom</code>) to access functions and data in the Boot ROM.</p>
<p><a href="https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf">RP2040 SDK</a></p>
<p><a href="https://kevinboone.me/picoflash.html?i=2">More about RP2040 XIP Flash</a></p>
</li>
<li>
<p><strong>PineTime Smart Watch (Nordic nRF52832)</strong></p>
<p>PineTime doesn‚Äôt have XIP Flash Memory. But it has <strong>Internal Flash Memory</strong> (inside the microcontroller).</p>
<p>During startup, PineTime‚Äôs MCUBoot Bootloader installs new firmware by <strong>swapping in the firmware from External Flash Memory</strong> to Internal Flash Memory.</p>
<p>Similar to BL602 Bootloader, PineTime‚Äôs Bootloader supports <strong>Firmware Rollback</strong>. If the new firmware fails to start, PineTime <strong>swaps in the old firmware from External Flash Memory</strong>.</p>
<ul>
<li><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot"><strong>‚ÄúMCUBoot Bootloader for PineTime Smart Watch‚Äù</strong></a></li>
</ul>
<p>Check out this interview that explains the design rationale for the PineTime Bootloader‚Ä¶</p>
<ul>
<li><a href="https://www.ncartron.org/interview-with-lup-creator-of-pinetimes-bootloader.html"><strong>‚ÄúInterview with Lup, creator of PineTime‚Äôs bootloader‚Äù</strong></a></li>
</ul>
</li>
</ol>
<h1 id="whats-next"><a href="#whats-next">13 What‚Äôs Next</a></h1>
<p>Thanks for bearing with me as I attempted to unravel the secrets inside the BL602 Bootloader.</p>
<p>(This is my 20th article on BL602 yay! üéâ)</p>
<p>For my 21st article I shall explore Machine Learning with <strong>TensorFlow Lite on BL602</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/tflite"><strong>‚ÄúMachine Learning on RISC-V BL602 with TensorFlow Lite‚Äù</strong></a></p>
<p>Stay Tuned!</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/nvli0k/bl602_bootloader/">Discuss the article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/boot.md"><code>lupyuen.github.io/src/boot.md</code></a></p>
<h1 id="notes"><a href="#notes">14 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1398855867030593538">this Twitter Thread</a></p>
</li>
<li>
<p>We have been studying the Bootloader Source Code for <code>bl602_boot2</code>‚Ä¶ But the Bootloader Binary that‚Äôs actually flashed is <code>blsp_boot2</code>. How do we know that are the same?</p>
<p>We don‚Äôt have the source code for <code>blsp_boot2</code>. But we were able to disassemble <code>blsp_boot2</code> and verify that it contains the same code as <code>bl602_boot2</code>.</p>
<p>Compare <a href="https://github.com/lupyuen/bl_iot_sdk/releases/download/v8.0.2/bl602_boot2.S"><code>bl602_boot2.S</code></a> with <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/tools/flash_tool/bl602/builtin_imgs/blsp_boot2.S"><code>blsp_boot2.S</code></a> ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-compare.png" alt="Comparing bl602_boot2 with blsp_boot2" /></p>
</li>
<li>
<p><a href="https://github.com/9names"><code>9names</code></a> has created <strong>Rust Wrappers for the BL602 ROM Driver API</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/9names/bl602-rom-wrapper"><strong><code>bl602-rom-wrapper</code></strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/boot-rust.png" alt="Rust Wrappers for ROM Driver API" /></p>
</li>
</ol>

    
</body>
</html>