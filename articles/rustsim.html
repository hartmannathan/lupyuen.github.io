<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on RISC-V BL602: Simulated with WebAssembly</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on RISC-V BL602: Simulated with WebAssembly" 
    data-rh="true">
<meta property="og:description" 
    content="Can we run Rust Firmware for BL602 RISC-V SoC in a Web Browser... Simulated with WebAssembly?"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rustsim-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on RISC-V BL602: Simulated with WebAssembly</h1>
    <nav id="TOC"><ul>
<li><a href="#rust-firmware-for-bl602">1 Rust Firmware for BL602</a><ul></ul></li>
<li><a href="#build-bl602-firmware-for-webassembly">2 Build BL602 Firmware for WebAssembly</a><ul>
<li><a href="#compile-rust-firmware-into-webassembly">2.1 Compile Rust Firmware into WebAssembly</a><ul></ul></li>
<li><a href="#link-rust-firmware-with-emscripten">2.2 Link Rust Firmware with Emscripten</a><ul></ul></li>
<li><a href="#copy-the-webassembly-outputs">2.3 Copy the WebAssembly outputs</a><ul></ul></li></ul></li>
<li><a href="#json-stream-of-simulation-events">3 JSON Stream of Simulation Events</a><ul></ul></li>
<li><a href="#generate-simulation-events">4 Generate Simulation Events</a><ul>
<li><a href="#time-delay-event">4.1 Time Delay Event</a><ul></ul></li>
<li><a href="#intercept-calls-to-bl602-iot-sdk">4.2 Intercept Calls to BL602 IoT SDK</a><ul></ul></li>
<li><a href="#what-about-c">4.3 What about C?</a><ul></ul></li></ul></li>
<li><a href="#html-and-javascript-interface">5 HTML and JavaScript Interface</a><ul>
<li><a href="#run-rust-firmware">5.1 Run Rust Firmware</a><ul></ul></li>
<li><a href="#handle-simulation-events">5.2 Handle Simulation Events</a><ul></ul></li></ul></li>
<li><a href="#run-bl602-firmware-in-simulator">6 Run BL602 Firmware in Simulator</a><ul></ul></li>
<li><a href="#easier-embedded-development">7 Easier Embedded Development?</a><ul></ul></li>
<li><a href="#validate-calls-to-bl602-iot-sdk">8 Validate Calls to BL602 IoT SDK</a><ul></ul></li>
<li><a href="#pinedio-stack-bl604">9 PineDio Stack BL604</a><ul></ul></li>
<li><a href="#scripting-for-bl602-simulator">10 Scripting for BL602 Simulator</a><ul>
<li><a href="#drag-and-drop-scripting">10.1 Drag and Drop Scripting</a><ul></ul></li>
<li><a href="#run-scripts-on-bl602">10.2 Run Scripts on BL602</a><ul></ul></li></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-rhai-scripts-on-bl602">13 Appendix: Rhai Scripts on BL602</a><ul></ul></li>
<li><a href="#appendix-rust-simulation-events">14 Appendix: Rust Simulation Events</a><ul></ul></li></ul></nav><p>üìù <em>16 Aug 2021</em></p>
<p>One year ago I pondered‚Ä¶ Can we make <strong>Embedded Programming easier for Learners</strong>?</p>
<p><img src="https://lupyuen.github.io/images/cloud-title.jpg" alt="Fornite vs Embedded Programming" /></p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/cloud">(Source)</a></p>
<p><em>Maybe we need an easier way to build, test and debug our firmware‚Ä¶</em></p>
<p><em>Without using actual embedded hardware?</em></p>
<p>Today we shall explore whether it‚Äôs feasible to run <strong>Rust Firmware for BL602</strong> RISC-V SoC in a <strong>Web Browser</strong>‚Ä¶</p>
<p>By simulating the BL602 SoC with <strong>WebAssembly</strong>!</p>
<p>Read on to find how we created this bare-bones BL602 Simulator in WebAssembly‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/bl602-simulator/"><strong>BL602 Simulator in WebAssembly</strong></a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/pinecone">(More about BL602 RISC-V SoC)</a></p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
<h1 id="rust-firmware-for-bl602"><a href="#rust-firmware-for-bl602">1 Rust Firmware for BL602</a></h1>
<p>We start with this <strong>BL602 Rust Firmware <code>sdk_app_rust_gpio</code></strong> that blinks the LED: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/sdk_app_rust_gpio/rust/src/lib.rs"><code>sdk_app_rust_gpio/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This function will be called by the BL602 command-line interface
</span><span class="attribute">#[no_mangle]              </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>rust_main(  <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by BL602 firmware
  </span>_result: <span class="kw-2">*mut </span>u8,        <span class="comment">//  Result to be returned to command-line interface (char *)
  </span>_len:  i32,              <span class="comment">//  Size of result buffer (int)
  </span>_argc: i32,              <span class="comment">//  Number of command line args (int)
  </span>_argv: <span class="kw-2">*const *const </span>u8  <span class="comment">//  Array of command line args (char **)
</span>) {
  <span class="comment">//  Show a message on the serial console
  </span>puts(<span class="string">&quot;Hello from Rust!&quot;</span>);

  <span class="comment">//  PineCone Blue LED is connected on BL602 GPIO 11
  </span><span class="kw">const </span>LED_GPIO: u8 = <span class="number">11</span>;  <span class="comment">//  `u8` is 8-bit unsigned integer

  //  Configure the LED GPIO for output (instead of input)
  </span>gpio::enable_output(LED_GPIO, <span class="number">0</span>, <span class="number">0</span>)      <span class="comment">//  No pullup, no pulldown
    </span>.expect(<span class="string">&quot;GPIO enable output failed&quot;</span>);  <span class="comment">//  Halt on error

  //  Blink the LED 5 times
  </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{  <span class="comment">//  Iterates 10 times from 0 to 9 (`..` excludes 10)

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    </span>gpio::output_set(  <span class="comment">//  Set the GPIO output (from BL602 GPIO HAL)
      </span>LED_GPIO,        <span class="comment">//  GPIO pin number
      </span>i % <span class="number">2            </span><span class="comment">//  0 for low, 1 for high
    </span>).expect(<span class="string">&quot;GPIO output failed&quot;</span>);  <span class="comment">//  Halt on error

    //  Sleep 1 second
    </span>time_delay(                 <span class="comment">//  Sleep by number of ticks (from NimBLE Porting Layer)
      </span>time_ms_to_ticks32(<span class="number">1000</span>)  <span class="comment">//  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)
    </span>);
  }
  <span class="comment">//  Return to the BL602 command-line interface
</span>}</code></pre></div>
<p><em>What are <code>gpio::enable_output</code> and <code>gpio::output_set</code>?</em></p>
<p>They are <strong>BL602 GPIO Functions</strong> defined in the <a href="https://crates.io/crates/bl602-sdk"><strong>Rust Wrapper for BL602 IoT SDK</strong></a>, as explained here‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/adc#rust-wrapper-for-bl602-iot-sdk"><strong>‚ÄúRust Wrapper for BL602 IoT SDK‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/adc#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk"><strong>‚ÄúGenerating the BL602 Rust Wrapper‚Äù</strong></a></p>
</li>
</ul>
<p><code>time_delay</code> and <code>time_ms_to_ticks32</code> are also defined in the BL602 Rust Wrapper.</p>
<p><em>How do we build, flash and run this BL602 Rust Firmware?</em></p>
<p>To see the blinking BL602 LED, we‚Ä¶</p>
<ol>
<li>
<p><strong>Build</strong> this Rust Firmware</p>
<p><a href="https://lupyuen.github.io/articles/adc#build-the-bl602-rust-firmware">(‚Äú<code>cargo build</code>‚Äù with a Custom Rust Target)</a></p>
</li>
<li>
<p><strong>Link</strong> it with the BL602 IoT SDK</p>
</li>
<li>
<p><strong>Flash</strong> the firmware to BL602</p>
<p><a href="https://lupyuen.github.io/articles/adc#flash-the-bl602-rust-firmware">(With <code>blflash</code>)</a></p>
</li>
<li>
<p><strong>Connect</strong> to BL602 via the USB Serial Port and enter the command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>rust_main
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/adc#run-the-bl602-rust-firmware">(Similar to this)</a></p>
</li>
</ol>
<p><em>Can we run this BL602 Rust Firmware in a Web Browser? Without any BL602 hardware?</em></p>
<p>Let‚Äôs find out!</p>
<p>First we compile this BL602 Rust Firmware to WebAssembly‚Ä¶</p>
<h1 id="build-bl602-firmware-for-webassembly"><a href="#build-bl602-firmware-for-webassembly">2 Build BL602 Firmware for WebAssembly</a></h1>
<p>We‚Äôve created a <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile"><strong>Makefile</strong></a> that builds the above BL602 Rust Firmware into WebAssembly.</p>
<p>Here‚Äôs how we use it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Configure emscripten. See https://emscripten.org/docs/getting_started/downloads.html
## For Windows: emsdk\emsdk_env.bat
. ~/emsdk/emsdk_env.sh

## Download source code
git clone --recursive https://github.com/lupyuen/bl602-simulator
cd bl602-simulator

## Compile the Rust Firmware, Rust Simulator Library and link with Emscripten
make

## Produces outputs in the `docs` folder: wasm.js, wasm.wasm
</code></pre></div>
<p>This produces the JavaScript and WebAssembly files <strong><code>wasm.js</code> and <code>wasm.wasm</code></strong>, which we‚Äôll run in a Web Browser later.</p>
<p><em>What‚Äôs inside the Makefile?</em></p>
<p>Our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile">Makefile</a> does the following‚Ä¶</p>
<ol>
<li>
<p><strong>Compile</strong> the Rust Firmware into WebAssembly</p>
<p>(‚Äú<code>cargo build</code>‚Äù for target ‚Äú<code>wasm32-unknown-emscripten</code>‚Äù)</p>
</li>
<li>
<p><strong>Link</strong> the Rust Firmware with the Emscripten WebAssembly Runtime</p>
<p>(So that it runs in a Web Browser)</p>
</li>
</ol>
<p>Let‚Äôs go into the details‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-build.png" alt="Compile Rust Firmware into WebAssembly" /></p>
<h2 id="compile-rust-firmware-into-webassembly"><a href="#compile-rust-firmware-into-webassembly">2.1 Compile Rust Firmware into WebAssembly</a></h2>
<p>To compile our <strong>Rust Firmware into WebAssembly</strong>, our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile#L57-L58">Makefile</a> calls this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile the Rust Firmware and Rust Simulator Library into WebAssembly
cargo build --target wasm32-unknown-emscripten
</code></pre></div>
<p>This compiles three <strong>Rust Projects</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Rust Firmware:</strong> </p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/sdk_app_rust_gpio"><code>bl602-simulator/sdk_app_rust_gpio/rust</code></a></p>
<p>(The Rust Firmware we‚Äôve seen earlier. Should be portable across BL602 and WebAssembly)</p>
</li>
<li>
<p><strong>Rust Simulator Library:</strong> </p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-simulator"><code>bl602-simulator/bl602-simulator</code></a></p>
<p>(Simulates the BL602 IoT SDK. We‚Äôll see this in a while)</p>
</li>
<li>
<p><strong>Rust Scripting Library:</strong></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-script"><code>bl602-simulator/bl602-script</code></a></p>
<p>(More about this later)</p>
</li>
</ol>
<p>‚Äú<code>cargo build</code>‚Äù downloads the <a href="https://crates.io/crates/bl602-sdk"><strong>BL602 Rust Wrapper</strong></a> automagically from <code>crates.io</code> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>...
Compiling bl602-macros v0.0.2
Compiling bl602-sdk v0.0.6
Compiling app v0.0.1 (bl602-simulator/sdk_app_rust_gpio/rust)
Compiling bl602-simulator v0.0.1 (bl602-simulator/bl602-simulator)
Finished dev [unoptimized + debuginfo] target(s) in 1m 43s
</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602-simulator#build-log">See the complete log</a></p>
<p>(Great that BL602 Rust Wrapper builds OK for WebAssembly! Yep our WSL machine is slow)</p>
<p>However our Rust Firmware needs a slight tweak at the top to <strong>build correctly</strong> under WebAssembly: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/sdk_app_rust_gpio/rust/src/lib.rs#L3-L7"><code>sdk_app_rust_gpio/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// TODO: For BL602:
// #![no_std]  //  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems

// TODO: For WebAssembly:
</span><span class="attribute">#![feature(libc)]  </span><span class="comment">//  Allow C Standard Library, which will be mapped by emscripten to JavaScript</span></code></pre></div>
<p>We change <strong><code>no_std</code></strong> to <strong><code>feature(libc)</code></strong> for the build to succeed.</p>
<p>Probably because the Emscripten Runtime behaves more like the <strong>Standard C Runtime</strong>.</p>
<p>(Someday we might use <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><strong><code>build.rs</code></strong></a> to apply this mod automatically during compilation)</p>
<p><img src="https://lupyuen.github.io/images/rustsim-libc.png" alt="Changing no_std to feature(libc)" /></p>
<p><em>What are the outputs for ‚Äú<code>cargo build</code>‚Äù?</em></p>
<p>‚Äú<code>cargo build</code>‚Äù produces two <strong>Static Libraries</strong> (Rust Firmware and Rust Simulator)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>target/wasm32-unknown-emscripten/debug/libapp.a
target/wasm32-unknown-emscripten/debug/libbl602_simulator.a
</code></pre></div>
<p>Which we shall link with Emscripten‚Äôs WebAssembly Runtime.</p>
<p><em>Why did ‚Äú<code>cargo build</code>‚Äù emit Static Libraries? Instead of the default Rust Libraries?</em></p>
<p>Because we specified <strong><code>staticlib</code></strong> in <code>Cargo.toml</code> for the <a href="https://github.com/lupyuen/bl602-simulator/blob/main/sdk_app_rust_gpio/rust/Cargo.toml">Rust Firmware</a> and <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/Cargo.toml">Rust Simulator</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Build this module as a Static Library.
[lib]
name       = &quot;app&quot;          # Output will be named `libapp.a`
crate-type = [&quot;staticlib&quot;]  # And will be a Static Library
</code></pre></div>
<p><strong>Rust Libraries won‚Äôt link</strong> with Emscripten‚Äôs WebAssembly Runtime. </p>
<p>That‚Äôs why we switched to <strong>Static Libraries</strong>.</p>
<h2 id="link-rust-firmware-with-emscripten"><a href="#link-rust-firmware-with-emscripten">2.2 Link Rust Firmware with Emscripten</a></h2>
<p>We‚Äôre nearly ready to run our Rust Firmware in WebAssembly! We need a <strong>WebAssembly Runtime</strong> that will‚Ä¶</p>
<ol>
<li>
<p>Let our Rust Firmware interact with <strong>HTML and JavaScript</strong></p>
<p>(To render the Web Browser UI)</p>
</li>
<li>
<p>And <strong>print messages</strong>, errors and exceptions to the Web Browser</p>
</li>
</ol>
<p>We‚Äôll use the <a href="https://emscripten.org/"><strong>Emscripten WebAssembly Runtime</strong></a>.</p>
<p>Our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile#L60-L65">Makefile</a> links the <strong>Rust Firmware with Emscripten</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Link the Rust Firmware and Rust Simulator Library with Emscripten
emcc -o wasm/wasm.html \
  target/wasm32-unknown-emscripten/debug/libapp.a \
  target/wasm32-unknown-emscripten/debug/libbl602_simulator.a \
  wasm/wasm.o \
  -g \
  -s WASM=1 \
  -s DISABLE_EXCEPTION_CATCHING=0 \
  -s &quot;EXPORTED_FUNCTIONS=[ &#39;_rust_main&#39;, &#39;_clear_simulation_events&#39;, &#39;_get_simulation_events&#39; ]&quot; \
  -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[ &#39;cwrap&#39;, &#39;allocate&#39;, &#39;intArrayFromString&#39;, &#39;UTF8ToString&#39; ]&quot;
</code></pre></div>
<p><a href="https://emscripten.org/docs/getting_started/downloads.html">How to install Emscripten</a></p>
<p><em>What are the <code>EXPORTED_FUNCTIONS</code>?</em></p>
<p>These Rust Functions will be <strong>called from JavaScript</strong>‚Ä¶</p>
<ul>
<li>
<p><code>_rust_main</code> is the Rust Function that blinks the LED</p>
<p>(We‚Äôve seen this earlier)</p>
</li>
<li>
<p><code>_clear_simulation_events</code> and <code>_get_simulation_events</code> are functions from the Rust Simulator Library that will manage the <strong>JSON Stream of Simulation Events</strong></p>
<p>(More about this later)</p>
</li>
</ul>
<p><em>What are the <code>EXTRA_EXPORTED_RUNTIME_METHODS</code>?</em></p>
<p>These Emscripten Runtime Functions will be exported to JavaScript to allow <strong>strings to be passed</strong> between JavaScript and our Rust Firmware‚Ä¶</p>
<ul>
<li><code>cwrap</code>, <code>allocate</code>, <code>intArrayFromString</code>, <code>UTF8ToString</code></li>
</ul>
<h2 id="copy-the-webassembly-outputs"><a href="#copy-the-webassembly-outputs">2.3 Copy the WebAssembly outputs</a></h2>
<p><em>What are the outputs emitted by Emscripten?</em></p>
<p>Emscripten produces these files after linking our Rust Firmware‚Ä¶</p>
<ul>
<li>
<p><strong><code>wasm.wasm</code></strong>: WebAssembly binary file</p>
</li>
<li>
<p><strong><code>wasm.js</code></strong>: JavaScript that loads the WebAssembly binary file into the Web Browser</p>
</li>
<li>
<p><strong><code>wasm.html</code></strong>: HTML page that loads the above JavaScript to execute the WebAssembly binary</p>
</li>
</ul>
<p>Our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile#L67-L69">Makefile</a> copies the <strong>JavaScript and WebAssembly</strong> outputs to the <strong><code>docs</code></strong> folder‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Copy the WebAssembly outputs to the docs folder for GitHub Pages
cp wasm/wasm.js   docs
cp wasm/wasm.wasm docs
</code></pre></div>
<p>So that we may test the WebAssembly outputs with a Local Web Server.</p>
<p><em>What about the HTML file <code>wasm.html</code>?</em></p>
<p>We‚Äôre using a <strong>customised version</strong> of <code>wasm.html</code> in the <code>docs</code> folder.</p>
<p>It renders a <strong>Simulated BL602 Board</strong>, as we shall soon see.</p>
<p><em>Why did we use the Emscripten WebAssembly Runtime? Instead of the <a href="https://rustwasm.github.io/docs/book/">Rust WebAssembly Runtime</a>?</em></p>
<p>Because we copied the code from an earlier (non-Rust) WebAssembly project‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wasm"><strong>‚ÄúSimulate RISC-V BL602 with WebAssembly, uLisp and Blockly‚Äù</strong></a></li>
</ul>
<h1 id="json-stream-of-simulation-events"><a href="#json-stream-of-simulation-events">3 JSON Stream of Simulation Events</a></h1>
<p>Our story so far‚Ä¶</p>
<ol>
<li>
<p>We have compiled our <strong>Rust Firmware into WebAssembly</strong></p>
</li>
<li>
<p>Our firmware runs in a <strong>Web Browser</strong> and it‚Äôs capable of interacting with <strong>HTML and JavaScript</strong></p>
<p>(Thanks to Emscripten)</p>
</li>
<li>
<p>But our firmware <strong>won‚Äôt blink any LEDs</strong></p>
<p>(Because the <strong>BL602 IoT SDK is missing</strong> from WebAssembly)</p>
</li>
</ol>
<p><em>What if we simulate the LED with HTML and JavaScript?</em></p>
<p>Yep we could build a <strong>BL602 Simulator</strong> in HTML and JavaScript.</p>
<p>And we can make our Rust Firmware talk to the BL602 Simulator‚Ä¶</p>
<p>By emitting a <strong>JSON Stream of BL602 Simulation Events</strong>!</p>
<p><img src="https://lupyuen.github.io/images/rust-simulator.jpg" alt="JSON Stream of BL602 Simulation Events" /></p>
<p><em>What‚Äôs a BL602 Simulation Event?</em></p>
<p>When our firmware needs to <strong>set the GPIO Output</strong> to High or Low (to flip an LED On/Off)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Switch the LED On
</span>gpio::output_set(  <span class="comment">//  Set the GPIO output for...
  </span><span class="number">11</span>,              <span class="comment">//  GPIO pin number
  </span><span class="number">0                </span><span class="comment">//  0 for On, 1 for Off
</span>)...</code></pre></div>
<p>It sends a <strong>Simulation Event</strong> to the BL602 Simulator (in JSON format)‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ &quot;gpio_output_set&quot;: { 
  &quot;pin&quot;:  11, 
  &quot;value&quot;: 0 
} }
</code></pre></div>
<p>Which will be handled by the BL602 Simulator to <strong>flip the Simulated LED</strong> on or off.</p>
<p><em>Is our firmware directly controlling the BL602 Simulator?</em></p>
<p>Not quite. Our firmware is <strong>indirectly controlling the BL602 Simulator</strong> by sending Simulation Events.</p>
<p><a href="https://lupyuen.github.io/articles/wasm#why-simulate-a-stream-of-events">(More about this Inversion of Control)</a></p>
<p><em>What about time delays?</em></p>
<p>Our firmware shall generate <strong>Simulation Events for time delays</strong>.</p>
<p>To handle such events, our <strong>BL602 Simulator pauses</strong> for the specified duration.</p>
<p>(It‚Äôs like playing a MIDI Stream)</p>
<p>Hence this firmware code‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Sleep 1,000 milliseconds (or 1 second)
</span>time_delay(<span class="number">1000</span>);</code></pre></div>
<p>Shall generate this <strong>Time Delay</strong> Simulation Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
</code></pre></div>
<p><em>What‚Äôs inside the JSON Stream of Simulation Events?</em></p>
<p>To simulate our firmware on the BL602 Simulator, we shall transmit an <strong>array of Simulation Events</strong> (in JSON format) from our firmware to the BL602 Simulator.</p>
<p>Thus our Rust Blinky Firmware shall generate this <strong>JSON Stream of Simulation Events</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>[ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 0 } }, 
  { &quot;time_delay&quot;:      { &quot;ticks&quot;: 1000 } }, 

  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  { &quot;time_delay&quot;:      { &quot;ticks&quot;: 1000 } }, 
  ... 
]
</code></pre></div>
<p>That will simulate a <strong>blinking BL602 LED</strong>.</p>
<p>Let‚Äôs generate the Simulation Events now.</p>
<h1 id="generate-simulation-events"><a href="#generate-simulation-events">4 Generate Simulation Events</a></h1>
<p><em>How shall we generate this <strong>JSON Simulation Event</strong>‚Ä¶</em></p>
<div class="example-wrap"><pre class="language-json"><code>{ &quot;gpio_output_set&quot;: { 
  &quot;pin&quot;:  11, 
  &quot;value&quot;: 0 
} }
</code></pre></div>
<p><em>When we call this Rust Function?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Switch the LED On
</span>gpio::output_set(  <span class="comment">//  Set the GPIO output for...
  </span><span class="number">11</span>,              <span class="comment">//  GPIO pin number
  </span><span class="number">0                </span><span class="comment">//  0 for On, 1 for Off
</span>)...</code></pre></div>
<p>We start by defining the <strong>Enum Type</strong> for the Simulation Event: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L3-L21"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Import the serde crate for JSON Serialization
</span><span class="kw">use </span>serde::{Serialize, Deserialize};

<span class="doccomment">/// Event to be simulated by the BL602 Simulator
</span><span class="attribute">#[derive(Serialize, Deserialize, Debug)]
</span><span class="kw">enum </span>SimulationEvent {
  <span class="doccomment">/// GPIO Set Output:
  /// `{ &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 }`
  </span>gpio_output_set {
    pin:   u8,
    value: u8,
  },
}</code></pre></div>
<p>To represent a stream of events, we create a <strong>Vector of Simulation Events</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Create a vector of simulation events (i.e. event array)
</span><span class="kw">let </span><span class="kw-2">mut </span>simulation_events: Vec&lt;SimulationEvent&gt; = Vec::new();</code></pre></div>
<p>Here‚Äôs how we create a Simulation Event for <strong>GPIO Set Output</strong> and add it to the stream‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Create a GPIO Set Output event
</span><span class="kw">let </span>ev = SimulationEvent::gpio_output_set { 
  pin:  <span class="number">11</span>,
  value: <span class="number">0</span>,
};

<span class="comment">// Add the event to the vector
</span>simulation_events.push(ev);</code></pre></div>
<p>Thanks to the <a href="https://serde.rs/"><strong>Serde Crate</strong></a>, we may serialize the Vector of Simulation Events like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Convert vector of events to a JSON string
</span><span class="kw">let </span>serialized = serde_json::to_string(<span class="kw-2">&amp;</span>simulation_events)
  .unwrap();

<span class="comment">// Print the serialized JSON events
</span><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, serialized);</code></pre></div>
<p>The result is a <strong>JSON Array</strong> of Simulation Events‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>[{&quot;gpio_output_set&quot;:{&quot;pin&quot;:11,&quot;value&quot;:0}}]
</code></pre></div>
<p>Exactly what we need!</p>
<h2 id="time-delay-event"><a href="#time-delay-event">4.1 Time Delay Event</a></h2>
<p><em>What about the Time Delay Event?</em></p>
<div class="example-wrap"><pre class="language-json"><code>{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
</code></pre></div>
<p>We add <strong>Time Delay</strong> to our Enum Type like so: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L3-L21"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Event to be simulated by the BL602 Simulator
</span><span class="kw">enum </span>SimulationEvent {
    <span class="doccomment">/// Omitted: GPIO Set Output
    </span>...
    <span class="doccomment">/// Time Delay:
    /// `{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }`
    </span>time_delay {
        ticks: u32,
    },
}</code></pre></div>
<p>And we create the <strong>Time Delay Event</strong> like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Create a Time Delay event
</span><span class="kw">let </span>ev = SimulationEvent::time_delay { 
  ticks: <span class="number">1000</span>,
};

<span class="comment">// Add the event to the vector
</span>simulation_events.push(ev);</code></pre></div>
<p><a href="https://serde.rs/"><strong>Serde Crate</strong></a> does the rest!</p>
<p><img src="https://lupyuen.github.io/images/rustsim-events.png" alt="Generating Simulation Events in Rust" /></p>
<p><a href="https://gist.github.com/lupyuen/cec1a423062556263a7ba02971862001">(Source)</a></p>
<h2 id="intercept-calls-to-bl602-iot-sdk"><a href="#intercept-calls-to-bl602-iot-sdk">4.2 Intercept Calls to BL602 IoT SDK</a></h2>
<p>We‚Äôve just figured out how to <strong>compose the JSON Stream</strong> of Simulation Events.</p>
<p>Now let‚Äôs do this <strong>inside the calls</strong> to BL602 IoT SDK‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Switch the LED On
</span>gpio::output_set(  <span class="comment">//  Set the GPIO output for...
  </span><span class="number">11</span>,              <span class="comment">//  GPIO pin number
  </span><span class="number">0                </span><span class="comment">//  0 for On, 1 for Off
</span>)...</code></pre></div>
<p><em>Where is the Rust Wrapper Function <code>gpio::output_set</code> defined?</em></p>
<p>From the previous article we see that the Wrapper Function is generated by <code>bindgen</code> and <code>safe_wrap</code>: <a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/logs/sdk-expanded.rs#L649-L662"><code>sdk-expanded.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// BL602 Rust Wrapper Function that sets the GPIO output
</span><span class="kw">pub fn </span>output_set(pin: u8, value: u8) -&gt; BlResult&lt;()&gt; {
  <span class="comment">//  Import the C function from BL602 IoT SDK
  </span><span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="kw">pub fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; ::cty::c_int;
  }
  <span class="kw">unsafe </span>{
    <span class="comment">//  Call the BL602 IoT SDK
    </span><span class="kw">let </span>res = bl_gpio_output_set(pin <span class="kw">as </span>u8, value <span class="kw">as </span>u8);
    <span class="comment">//  Return the result
    </span><span class="kw">match </span>res { <span class="number">0 </span>=&gt; <span class="prelude-val">Ok</span>(()), <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(BlError::from(res)), }
  }
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/adc#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">(More about this)</a></p>
<p>This code calls <strong><code>bl_gpio_output_set</code></strong>, which is defined in the <strong>BL602 IoT SDK</strong>.</p>
<p><em>But <code>bl_gpio_output_set</code> won‚Äôt work on WebAssembly right?</em></p>
<p>Correcto! Because BL602 IoT SDK <strong>doesn‚Äôt exist on WebAssembly</strong>!</p>
<p>To fix this we introduce the <a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-simulator"><strong>Rust Simulator Library</strong></a>, which pretends to be the <strong>BL602 IoT SDK for WebAssembly</strong>.</p>
<p>Here‚Äôs how it works: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L116-L136"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Set the output value of a GPIO Pin. See `bl_gpio_output_set` in &quot;Read and Write GPIO&quot; &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;
</span><span class="attribute">#[no_mangle]  </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; c_int {
  <span class="comment">//  Omitted: If the GPIO Pin has not been configured for Output, halt
  </span>...
  <span class="comment">//  Create a GPIO Set Output event
  </span><span class="kw">let </span>ev = SimulationEvent::gpio_output_set { 
    pin,
    value,
  };
  <span class="comment">//  Add the event to the JSON Stream of Simulation Events.
  //  Unsafe because `SIMULATION_EVENTS` is a Static Variable.
  </span><span class="kw">unsafe </span>{
    SIMULATION_EVENTS.push(ev);
  }
  <span class="comment">//  Return OK
  </span><span class="number">0
</span>}</code></pre></div>
<p>See what we did there? To <strong>flip the LED</strong> on / off‚Ä¶</p>
<ol>
<li>
<p>Our Rust Firmware calls <strong><code>gpio::output_set</code></strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>gpio::output_set(<span class="number">11</span>, <span class="number">0</span>)</code></pre></div>
</li>
<li>
<p>Which is a wrapper function that calls <strong><code>bl_gpio_output_set</code></strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>output_set(pin: u8, value: u8) -&gt; BlResult&lt;()&gt; {
  <span class="comment">//  Call the BL602 IoT SDK
  </span>bl_gpio_output_set(pin <span class="kw">as </span>u8, value <span class="kw">as </span>u8);</code></pre></div>
</li>
<li>
<p>Which adds the <strong>Set GPIO Output</strong> event to the JSON Stream of Simulation Events</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; c_int {
  <span class="comment">//  Create a GPIO Set Output event
  </span><span class="kw">let </span>ev = SimulationEvent::gpio_output_set { pin, value };
  <span class="comment">//  Add the event to the JSON Stream of Simulation Events
  </span>SIMULATION_EVENTS.push(ev);</code></pre></div>
</li>
</ol>
<p>And that‚Äôs how we <strong>intercept calls to BL602 IoT SDK</strong>‚Ä¶ To emit a JSON Stream of Simulation Events!</p>
<p><img src="https://lupyuen.github.io/images/rustsim-events3.png" alt="Generating Simulation Events in Rust" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L94-L151">(Source)</a></p>
<h2 id="what-about-c"><a href="#what-about-c">4.3 What about C?</a></h2>
<p><em>Could we have done this in C instead of Rust?</em></p>
<p>Yep but it‚Äôs gonna get messy when we <strong>compose JSON in C</strong>.</p>
<p>Here‚Äôs the original <strong>implementation in C</strong> before converting to Rust‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-events2.png" alt="Generating Simulation Events in C" /></p>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c">(Source)</a></p>
<h1 id="html-and-javascript-interface"><a href="#html-and-javascript-interface">5 HTML and JavaScript Interface</a></h1>
<p>We‚Äôve done the Top Half of this pic: Emitting a <strong>JSON Stream of BL602 Simulation Events</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust-simulator.jpg" alt="JSON Stream of BL602 Simulation Events" /></p>
<p>Now we do the Bottom Half: <strong>Web Browser Interface in HTML and JavaScript</strong>!</p>
<p>First we save this sketchy pic of a PineCone BL602 Board as a <strong>PNG file: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/pinecone.png"><code>pinecone.png</code></a></strong></p>
<p><img src="https://lupyuen.github.io/images/wasm-photoshop.png" alt="Creating the BL602 simulator image" /></p>
<p>We <strong>load the PNG file</strong> in our web page: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L8-L14"><code>simulator.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  // Load the simulator pic and render it
  const image = new Image();
  image.onload = renderSimulator;  //  Draw when image has loaded
  image.src = &#39;pinecone.png&#39;;      //  Image to be loaded
};
</code></pre></div>
<p>When the pic has been loaded, <strong><code>renderSimulator</code></strong> renders the pic: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L16-L28"><code>simulator.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Render the simulator pic. Based on https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
function renderSimulator() {
  //  Get the HTML canvas and context
  const canvas = document.getElementById(&#39;canvas&#39;);
  const ctx = canvas.getContext(&#39;2d&#39;);

  //  Resize the canvas
  canvas.width  = 400;
  canvas.height = 300;

  //  Draw the image to fill the canvas
  ctx.drawImage(this, 0, 0, canvas.width, canvas.height);
}
</code></pre></div>
<p><em>What‚Äôs the <code>canvas</code>?</em></p>
<p>Emscripten has helpfully generated a <strong>HTML Canvas</strong> in <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/wasm.html#L1238-L1240"><code>wasm.html</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-html"><code>&lt;canvas id=&quot;canvas&quot; class=&quot;emscripten&quot; oncontextmenu=&quot;event.preventDefault()&quot; tabindex=-1&gt;&lt;/canvas&gt;
</code></pre></div>
<p><code>renderSimulator</code> renders our BL602 pic to the HTML Canvas like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
<p><em>What about the LED?</em></p>
<p>To simulate the LED switching on <em>(or off)</em>, let‚Äôs draw a <strong>blue rectangle</strong> <em>(or grey rectangle)</em> onto the HTML Canvas: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L121-L144"><code>simulator.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>//  Get the HTML Canvas Context
const ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);

//  For LED On: Set the fill colour to Blue
ctx.fillStyle = &#39;#B0B0FF&#39;;  //  Blue

//  For LED Off: Set the fill colour to Grey
//  ctx.fillStyle = &#39;#CCCCCC&#39;;  //  Grey

//  Draw the LED colour
ctx.fillRect(315, 116, 35, 74);
</code></pre></div><h2 id="run-rust-firmware"><a href="#run-rust-firmware">5.1 Run Rust Firmware</a></h2>
<p>Watch what happens when we click the <strong>‚ÄúRun‚Äù Button</strong> in our BL602 Simulator: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L30-L81"><code>simulator.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Run the command in the input box
function runScript() {
  //  Omitted: Read the command from input box and convert to a function (like `rust_main`)
  ...
  //  Clear the JSON Stream of Simulation Events in WebAssembly
  Module._clear_simulation_events();
</code></pre></div>
<p>We start by <strong>clearing the JSON Stream</strong> of Simulation Events.</p>
<p>(More about this in the Appendix)</p>
<p>Next we call the <strong><code>rust_main</code></strong> function from our Rust Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Execute the WebAssembly Function defined in Rust.
  //  TODO: Pass the command-line args
  Module._rust_main();  //  Omitted: Checking whether `rust_main` exists
</code></pre></div>
<p>(Yep that‚Äôs a Quantum Leap from JavaScript to WebAssembly to Rust and back!)</p>
<p>Remember: Our Rust Firmware <strong>doesn‚Äôt run in Real Time</strong>.</p>
<p>Our Rust Firmware completes in an instant and <strong>emits a stream of events</strong>. (Including Time Delays)</p>
<p>We <strong>fetch the stream of events</strong> emitted by our Rust Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Get the JSON string of Simulation Events from WebAssembly. Looks like...
  //  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  //    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
  const json_ptr = Module._get_simulation_events();
</code></pre></div>
<p>(More about this in the Appendix)</p>
<p>And convert it from <strong>WebAssembly to JSON</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Convert the JSON string from WebAssembly to JavaScript
  const json = Module.UTF8ToString(json_ptr);

  //  Parse the JSON Stream of Simulation Events
  simulation_events = JSON.parse(json);
</code></pre></div>
<p>Inside <strong><code>simulation_events</code></strong> we have a JSON Stream of Simulation Events, ready for processing!</p>
<h2 id="handle-simulation-events"><a href="#handle-simulation-events">5.2 Handle Simulation Events</a></h2>
<p>Our JavaScript code has <strong>received the JSON Stream</strong> of Simulation Events from the Rust Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>[ 
  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } },
  ...
]
</code></pre></div>
<p>Let‚Äôs <strong>process the events</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L83-L119"><code>simulator.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Simulate the BL602 Simulation Events recorded in simulate_events, which contains...
///  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
function simulateEvents() {
  //  Take the first event and update the queue
  if (simulation_events.length == 0) { return; }
  const event = simulation_events.shift();
  //  event looks like:
  //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }

  //  Get the event type and parameters
  const event_type = Object.keys(event)[0];
  const args = event[event_type];

  //  Timeout in milliseconds to the next event
  let timeout = 1;
</code></pre></div>
<p>Here we take the <strong>first event</strong> from the stream.</p>
<p>Then we <strong>handle the event</strong>: Set GPIO Output or Time Delay‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Handle each event type
  switch (event_type) {

    //  Set GPIO output
    //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
    case &quot;gpio_output_set&quot;: timeout += gpio_output_set(args.pin, args.value); break;

    //  Delay
    //  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
    case &quot;time_delay&quot;: timeout += time_delay(args.ticks); break;

    //  Unknown event type
    default: throw new Error(&quot;Unknown event type: &quot; + event_type);
  }
</code></pre></div>
<p>We use a timer to <strong>iterate through the events</strong> in the stream‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Simulate the next event
  if (simulation_events.length &gt; 0) {
    window.setTimeout(&quot;simulateEvents()&quot;, timeout);
  }
}
</code></pre></div>
<p><em>What happens inside <code>gpio_output_set</code>, the event handler for Set GPIO Output?</em></p>
<p><code>gpio_output_set</code> renders the <strong>Simulated BL602 LED</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L121-L144"><code>simulator.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Simulate setting GPIO pin output to value 0 (Low) or 1 (High):
/// { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
function gpio_output_set(pin, value) {
  //  Get the HTML Canvas Context
  const ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);

  //  Set the simulated LED colour depending on value
  switch (value) {
    //  Set GPIO to Low (LED on)
    case 0: ctx.fillStyle = &#39;#B0B0FF&#39;; break;  //  Blue

    //  Set GPIO to High (LED off)
    case 1: ctx.fillStyle = &#39;#CCCCCC&#39;; break;  //  Grey

    //  Unknown value
    default: throw new Error(&quot;Unknown gpio_output_set value: &quot; + args.value);
  }

  //  Draw the LED colour
  ctx.fillRect(315, 116, 35, 74);

  //  Simulate next event in 0 milliseconds
  return 0;
}
</code></pre></div>
<p>(Yep we‚Äôve seen this code earlier)</p>
<p>That‚Äôs how we <strong>blink the Simulated LED</strong> through the stream of simulation events!</p>
<p><em>What about <code>time_delay</code>, the event handler for Time Delays?</em></p>
<p><code>time_delay</code> is explained here: <a href="https://lupyuen.github.io/articles/wasm#simulate-delays">‚ÄúSimulate Delays‚Äù</a></p>
<p>(Hint: It simulates Time Delays by calling the JavaScript Timer that we‚Äôve seen earlier)</p>
<h1 id="run-bl602-firmware-in-simulator"><a href="#run-bl602-firmware-in-simulator">6 Run BL602 Firmware in Simulator</a></h1>
<p>Try the <strong>BL602 Rust Firmware Simulator</strong> for yourself!</p>
<ul>
<li><a href="https://lupyuen.github.io/bl602-simulator/"><strong>BL602 Simulator in WebAssembly</strong></a></li>
</ul>
<p>Click the <strong><code>Run</code></strong> Button and watch the LED blink!</p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
<p>To run the BL602 Simulator on our computer (Linux, macOS and Windows)‚Ä¶</p>
<ol>
<li>
<p>Build the <strong>BL602 Rust Firmware</strong> and the BL602 Simulator</p>
<p><a href="https://lupyuen.github.io/articles/rustsim#build-bl602-firmware-for-webassembly">(Instructions here)</a></p>
</li>
<li>
<p>Start a <strong>Local Web Server</strong>, because WebAssembly won‚Äôt run from a filesystem</p>
<p><a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/overview">(Web Server for Chrome works fine)</a></p>
</li>
<li>
<p>Browse to <strong><code>docs/wasm.html</code></strong></p>
</li>
<li>
<p>Click <strong><code>Run</code></strong></p>
</li>
</ol>
<h1 id="easier-embedded-development"><a href="#easier-embedded-development">7 Easier Embedded Development?</a></h1>
<p><em>Is this easier than building and testing firmware on Real BL602 Hardware?</em></p>
<p>BL602 Simulator could potentially shorten the <strong>Code - Build - Flash - Test Cycle</strong> for Embedded Development‚Ä¶</p>
<ol>
<li>
<p><strong>Code</strong> the firmware in Rust</p>
</li>
<li>
<p><strong>Build</strong> the firmware for WebAssembly</p>
<p>(With a single ‚Äú<code>make</code>‚Äù command on Linux / macOS / Windows)</p>
</li>
<li>
<p><strong>Test and Debug</strong> the firmware in the Simulator</p>
<p>(No BL602 hardware needed, just a Web Browser)</p>
</li>
<li>
<p><strong>Repeat</strong> until the firmware is hunky dory</p>
</li>
<li>
<p><strong>Flash</strong> the firmware to BL602</p>
<p>(Remember: Flashing BL602 via UART is kinda cumbersome)</p>
</li>
</ol>
<p><em>But not all firmware can be simulated right?</em></p>
<p>True, there are limits to what we can simulate.</p>
<p><a href="https://lupyuen.github.io/articles/adc">(Might be tricky to simulate Analog Inputs‚Ä¶ Do we draw a graph?)</a></p>
<p>Even so, the simulator could be really helpful for learners who are <strong>building basic firmware</strong>.</p>
<p>(Maybe attract more Embedded Learners too!)</p>
<p><em>What about the Embedded Pros?</em></p>
<p>Someday BL602 Simulator might also be helpful for Embedded Pros who are <strong>building complex firmware</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Automated Testing</strong> of BL602 Firmware</p>
<p>Remember that our firmware emits a <strong>JSON Stream</strong> of Simulation Events?</p>
<p>This JSON Stream is perfect for checking whether our firmware is <strong>behaving as expected</strong>‚Ä¶ Just <strong>‚Äú<code>diff</code>‚Äù the Expected and Actual</strong> JSON Streams!</p>
</li>
<li>
<p><strong>Tracing Calls to BL602 IoT SDK</strong> for debugging</p>
<p>(Like an embedded ‚Äú<code>strace</code>‚Äù)</p>
</li>
<li>
<p><strong>Validating Calls to BL602 IoT SDK</strong></p>
<p>(More about this in the next chapter)</p>
</li>
</ol>
<p><em>Can we simulate C Firmware? (Instead of Rust Firmware)</em></p>
<p>We could probably <strong>simulate C Firmware</strong> if we‚Ä¶</p>
<ol>
<li>
<p>Tweak the BL602 C Firmware to <strong>build with Emscripten</strong></p>
<p>(By modding the C Header Files and Makefiles)</p>
</li>
<li>
<p>And link the compiled C Firmware with our <strong>Rust Simulator Library</strong></p>
</li>
</ol>
<p>Remember that the BL602 Shim Functions in our Rust Simulator Library are declared <strong>‚Äú<code>extern C</code>‚Äù</strong>?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[no_mangle]  </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; c_int { ...</code></pre></div>
<p>Yep this means they can be <strong>called from C Firmware</strong>!</p>
<p>And the BL602 Shim Functions will <strong>emit simulation events</strong>‚Ä¶ Our C Firmware will work exactly like Rust Firmware!</p>
<h1 id="validate-calls-to-bl602-iot-sdk"><a href="#validate-calls-to-bl602-iot-sdk">8 Validate Calls to BL602 IoT SDK</a></h1>
<p><em>What if the Embedded HAL (like BL602 IoT SDK) could tell us how to fix our code?</em></p>
<p>(Wouldn‚Äôt that be great, especially for learners?)</p>
<p>Yep we can help Embedded Learners when we catch <strong>BL602 SDK Calling Errors</strong> and <strong>explain the errors</strong> in a friendly way.</p>
<p>Watch what happens when set the output for a GPIO Pin <strong>without configuring the GPIO</strong> for Output‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-validate2.png" alt="Simulator halts with a friendly message" /></p>
<p>Our simulator <strong>halts with a friendly message</strong>‚Ä¶ And explains how we can fix it!</p>
<p><em>How does our simulator validate calls to BL602 IoT SDK?</em></p>
<p>BL602 Simulator remembers the <strong>configuration of every GPIO Pin</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L33-L45"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Configuration for a BL602 GPIO Pin
</span><span class="attribute">#[derive(Clone, Copy, Debug, PartialEq)]
</span><span class="kw">enum </span>GpioConfig {
  <span class="doccomment">/// GPIO Pin is unconfigured
  </span>Unconfigured,
  <span class="doccomment">/// GPIO Pin is configured for Input
  </span>Input,
  <span class="doccomment">/// GPIO Pin is configured for Output
  </span>Output,
}

<span class="doccomment">/// Configurations for all BL602 GPIO Pins
</span><span class="kw">static </span><span class="kw-2">mut </span>GPIO_CONFIGS: [GpioConfig; <span class="number">32</span>] = [GpioConfig::Unconfigured; <span class="number">32</span>];</code></pre></div>
<p>We <strong>update the GPIO Configuration</strong> whenever the GPIO is configured for Input or Output: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L105-L114"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Configure a GPIO Pin for Output Mode. See `bl_gpio_enable_output` in &quot;Enable GPIO&quot; &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;
</span><span class="attribute">#[no_mangle]  </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>bl_gpio_enable_output(pin: u8, _pullup: u8, _pulldown: u8) -&gt; c_int {
  <span class="comment">//  Remember that the GPIO Pin has been configured for Output
  </span>GPIO_CONFIGS[pin <span class="kw">as </span>usize] = GpioConfig::Output;</code></pre></div>
<p>While setting the GPIO output value, we <strong>raise an error</strong> if the GPIO Configuration is incorrect: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L116-L136"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Set the output value of a GPIO Pin. See `bl_gpio_output_set` in &quot;Read and Write GPIO&quot; &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;
</span><span class="attribute">#[no_mangle]  </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; c_int {
  <span class="comment">//  If the GPIO Pin has not been configured for Output, halt
  </span><span class="macro">assert!</span>(
    GPIO_CONFIGS[pin <span class="kw">as </span>usize] == GpioConfig::Output,
    <span class="string">&quot;GPIO {} is {:?}, unable to set the GPIO Output Value. Please configure the GPIO for Output with `gpio::enable_output(pin, pullup, pulldown)` or `bl_gpio_enable_output(pin, pullup, pulldown)`. See \&quot;Enable GPIO\&quot; &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;&quot;</span>,
    pin, GPIO_CONFIGS[pin <span class="kw">as </span>usize]
  );</code></pre></div>
<p>That‚Äôs how we make BL602 Simulator a little more helpful for Embedded Learners‚Ä¶ By validating the calls to BL602 IoT SDK!</p>
<p><img src="https://lupyuen.github.io/images/rustsim-validate3.png" alt="Validate Calls to BL602 IoT SDK" /></p>
<h1 id="pinedio-stack-bl604"><a href="#pinedio-stack-bl604">9 PineDio Stack BL604</a></h1>
<p><em>Simulating a plain BL602 board (like PineCone BL602) is pointless, innit?</em></p>
<p>Yep simulating a <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a> ain‚Äôt particularly exciting because it only has‚Ä¶</p>
<ol>
<li>
<p>One <strong>RGB LED</strong></p>
</li>
<li>
<p>One <strong>Jumper</strong> (GPIO 8)</p>
</li>
<li>
<p>And everything else needs to be wired to the <strong>GPIO Pins</strong></p>
<p>(Which makes it harder to simulate actually)</p>
</li>
</ol>
<p>Compare this with the <a href="https://www.pine64.org/2021/08/15/introducing-the-pinenote/"><strong>PineDio Stack BL604</strong></a> which has‚Ä¶</p>
<ol>
<li>
<p><strong>SPI Display</strong> (with LVGL Graphics Library)</p>
</li>
<li>
<p><strong>LoRa SX1262 Transceiver</strong></p>
</li>
<li>
<p><strong>Motion Sensor</strong></p>
</li>
<li>
<p><strong>Heart Rate Sensor</strong></p>
</li>
<li>
<p><strong>Battery Charging Chip</strong> </p>
</li>
</ol>
<p>All this in a compact 3.5 cm¬≤ form factor!</p>
<p>It makes a lot more sense to <strong>simulate the PineDio Stack</strong>, because it‚Äôs a super interesting gadget for Embedded Learners.</p>
<p>Stay tuned for an updated simulator with support for <strong>LVGL, LoRa and LoRaWAN!</strong></p>
<p><img src="https://lupyuen.github.io/images/rustsim-pinedio.png" alt="PineDio Stack Schematic" /></p>
<h1 id="scripting-for-bl602-simulator"><a href="#scripting-for-bl602-simulator">10 Scripting for BL602 Simulator</a></h1>
<p>To make BL602 Simulator even more useful for Embedded Learners, we‚Äôre adding the <a href="https://rhai.rs/book/"><strong>Rhai Scripting Engine</strong></a> to the simulator‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-rust.jpg" alt="Rhai Script vs Rust Firmware" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-script">(Source)</a></p>
<p>Thus we‚Äôll allow BL602 Simulator to be used in two ways‚Ä¶</p>
<ol>
<li>
<p><strong>The Traditional Way:</strong></p>
<p>Code the program in Rust. Compile to WebAssembly. Test with Simulator.</p>
<p><em>‚Ä¶OR‚Ä¶</em></p>
</li>
<li>
<p><strong>The Scripted REPL Way:</strong></p>
<p>Code the program in <strong>Rhai Script</strong>. (Which looks like Rust)</p>
<p>Type the Rhai Script <strong>directly into the Web Browser</strong>. (No compiler needed)</p>
<p>Test with Simulator.</p>
</li>
</ol>
<p><em>Why would we need The Scripted REPL Way?</em></p>
<p>Because Scripted REPL platforms like <strong>uLisp</strong> and <strong>MicroPython</strong> are still popular with Embedded Learners.</p>
<p>For BL602, perhaps learners could <strong>start with (Rust-like) Rhai Script</strong>‚Ä¶ </p>
<p>And <strong>upgrade to Rust</strong> (or C) when they‚Äôre ready.</p>
<p>Check out the new article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rhai"><strong>‚ÄúRust on RISC-V BL602: Rhai Scripting‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/rhai-module.png" alt="Rhai Scripting for BL602 Simulator" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-script/src/lib.rs">(Source)</a></p>
<h2 id="drag-and-drop-scripting"><a href="#drag-and-drop-scripting">10.1 Drag and Drop Scripting</a></h2>
<p><em>I sense another upcoming enhancement?</em></p>
<p>Yes! Since we‚Äôre adding a <strong>Scripting Engine</strong> to the simulator‚Ä¶</p>
<p>Why not make it super easy to create scripts: The <strong>Drag-and-Drop Way</strong>!</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/rhai-blockly3.jpg" alt="BL602 Simulator with Blockly and Rhai Script" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lupyuen2/blockly-bl602">(Source)</a></p>
</blockquote>
<p><em>Can we do this through a Desktop App? (Instead of Web Browser)</em></p>
<p>Possibly, if we wrap the Web Browser Interface into a <strong>Desktop App with Tauri</strong>.</p>
<p><a href="https://tauri.studio/en/">(More about Tauri)</a></p>
<h2 id="run-scripts-on-bl602"><a href="#run-scripts-on-bl602">10.2 Run Scripts on BL602</a></h2>
<p><em>Rhai Scripts run OK on our simulator with WebAssembly. But will the scripts run on Real BL602 Hardware?</em></p>
<p>Sadly no. Rhai Scripting Engine is <strong>too heavy for BL602</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/sdk_app_rust_script">(See this)</a></p>
<p>But we could auto-convert / <strong>transcode Rhai Script to uLisp</strong>, which runs fine on BL602.</p>
<p>(More about Rhai Transcoding in the Appendix)</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode.jpg" alt="Transcode Rhai Script to uLisp" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/README.md#transcode-rhai-script-to-ulisp">(Source)</a></p>
<p><em>Can we transmit uLisp to BL602 from the Web Browser?</em></p>
<p>Yes, we may automagically transmit the transcoded uLisp from Web Browser to BL602 with the <strong>Web Serial API</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/lisp#web-browser-controls-bl602-with-web-serial-api">(More about Web Serial API)</a></p>
<p>Which means our learners will‚Ä¶</p>
<ol>
<li>
<p>Use a Web Browser to <strong>drag and drop</strong> the blocks to create a visual program</p>
</li>
<li>
<p>Which will <strong>auto-generate the Rhai Script</strong> for the visual program</p>
</li>
<li>
<p>And the Rhai Script will be <strong>auto-transmitted to BL602</strong> for execution</p>
<p>(After the Rhai Script has been transcoded to uLisp)</p>
</li>
</ol>
<p><em>You sound pretty confident about Drag-and-Drop Scripting. Have we done this before?</em></p>
<p>Yep we‚Äôve previously experimented with <strong>Blockly (Scratch), uLisp and Rust</strong>.</p>
<p>Now that we‚Äôre switching to <strong>Rhai Script</strong>, things might get simpler‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lisp"><strong>‚ÄúuLisp and Blockly on PineCone BL602 RISC-V Board‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/wasm"><strong>‚ÄúSimulate RISC-V BL602 with WebAssembly, uLisp and Blockly‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/visual-embedded-rust-programming-with-visual-studio-code"><strong>‚ÄúVisual Embedded Rust Programming with Visual Studio Code‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/advanced-topics-for-visual-embedded-rust-programming"><strong>‚ÄúAdvanced Topics for Visual Embedded Rust Programming‚Äù</strong></a></p>
</li>
</ul>
<p>(In the last article above we did some complicated Type Inference in Rust. Thankfully that‚Äôs no longer necessary for Rhai Script)</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/rhai-blockly4.png" alt="Blockly for BL602 / BL604 and Rhai Script" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lupyuen2/blockly-bl602">(Source)</a></p>
</blockquote>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>We have a lot of work coming up!</p>
<ol>
<li>
<p><strong>Rhai Scripting Engine</strong> <a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-script">(See this)</a></p>
</li>
<li>
<p><strong>Drag-and-Drop Scripting</strong> <a href="https://github.com/lupyuen2/blockly-bl602">(with Blockly)</a></p>
</li>
<li>
<p><strong>Transcoding Rhai Script to uLisp</strong> <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/README.md#transcode-rhai-script-to-ulisp">(See this)</a></p>
</li>
<li>
<p><strong>Integrating uLisp with BL602 IoT SDK</strong> <a href="https://github.com/lupyuen/ulisp-bl602/tree/sdk">(See this)</a></p>
</li>
</ol>
<p><a href="https://twitter.com/MisterTechBlog/status/1427758328004759552"><strong>(Follow the updates in this Twitter Thread)</strong></a></p>
<p>And soon we shall test all this on <a href="https://www.pine64.org/2021/08/15/introducing-the-pinenote/"><strong>PineDio Stack BL604 with LoRa SX1262</strong></a>‚Ä¶ As we explore whether it‚Äôs feasible to teach <strong>Rust (or Rhai) as a Safer Way</strong> to create firmware for BL602 and BL604.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/rust/comments/p5shdi/rust_on_riscv_bl602_simulated_with_webassembly/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rustsim.md"><code>lupyuen.github.io/src/rustsim.md</code></a></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1423169766080933891">this Twitter Thread</a></p>
</li>
<li>
<p><strong>Mbed OS</strong> has a simulator based on C++ and Emscripten. <a href="https://os.mbed.com/blog/entry/introducing-mbed-simulator/">(See this)</a></p>
</li>
</ol>
<h1 id="appendix-rhai-scripts-on-bl602"><a href="#appendix-rhai-scripts-on-bl602">13 Appendix: Rhai Scripts on BL602</a></h1>
<p><em>We can run Rhai Scripts in our Web Browser thanks to WebAssembly‚Ä¶</em></p>
<p><em>How will we run Rhai Scripts on Real BL602 Hardware?</em></p>
<p>Sadly Rhai Scripting Engine is <strong>too heavy for BL602</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/sdk_app_rust_script">(See this)</a></p>
<p>But we could auto-convert / <strong>transcode Rhai Script to uLisp</strong>, which runs fine on BL602.</p>
<p>We‚Äôll do the <strong>transcoding in the Web Browser</strong> with WebAssembly, since it has a lot more RAM than BL602.</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode.jpg" alt="Transcode Rhai Script to uLisp" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/README.md#transcode-rhai-script-to-ulisp">(Source)</a></p>
<p><em>Why uLisp?</em></p>
<p>Because uLisp is a <strong>tiny Lisp Interpreter</strong> (coded in C) that runs well on BL602 with little RAM.</p>
<p><a href="https://lupyuen.github.io/articles/lisp">(More about uLisp on BL602)</a></p>
<p>Transcoded uLisp will be in the <strong>S-Expression Format</strong>. (Which looks a little like WebAssembly)</p>
<p>Hence this Rust-like <strong>Rhai Script</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>gpio::output_set(<span class="number">11</span>, <span class="number">0</span>);</code></pre></div>
<p>Shall be transcoded to this <strong>uLisp S-Expression</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( bl_gpio_output_set 11 0 )
</code></pre></div>
<p><em>But will uLisp let us call C functions defined in BL602 IoT SDK?</em></p>
<p>Yep uLisp lets us <strong>expose a C function</strong> from BL602 IoT SDK like so: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4164-L4186"><code>ulisp.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Expose the C function `bl_gpio_output_set` to uLisp:
//  `int bl_gpio_output_set(uint8_t pin, uint8_t value)`
object *fn_bl_gpio_output_set(object *args, object *env) {
  //  Fetch the `pin` parameter from uLisp
  assert(args != NULL);
  int pin = checkinteger(BL_GPIO_OUTPUT_SET, car(args));
  args = cdr(args);

  //  Fetch the `value` parameter from uLisp
  assert(args != NULL);
  int value = checkinteger(BL_GPIO_OUTPUT_SET, car(args));
  args = cdr(args);

  //  No more parameters
  assert(args == NULL);

  //  Call the C function `bl_gpio_output_set`
  int result = bl_gpio_output_set(pin, value);

  //  Return the result to uLisp
  return number(result);
}
</code></pre></div>
<p>Which will be <strong>called from uLisp</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( bl_gpio_output_set 11 0 )
</code></pre></div>
<p><a href="http://www.ulisp.com/show?19Q4">(More about this)</a></p>
<p><em>How shall we transcode Rhai Script to uLisp?</em></p>
<p>The Rhai Scripting Engine compiles Rhai Script into an <strong>Abstract Syntax Tree</strong>. <a href="https://rhai.rs/book/engine/compile.html">(See this)</a></p>
<p>We shall <strong>traverse the nodes</strong> in the tree and <strong>emit uLisp S-Expressions</strong>.</p>
<p>Thus this <strong>Rhai Script</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>gpio::output_set(<span class="number">11</span>, <span class="number">0</span>);</code></pre></div>
<p>Shall emit this <strong>uLisp S-Expression</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( bl_gpio_output_set 11 0 )
</code></pre></div>
<p>The transcoding implementation will probably look similar to‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/ast"><strong>‚ÄúAuto Convert Go to Dart with an Abstract Syntax Tree‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs"><strong><code>safe_wrap</code> Procedural Macro</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rhai-ast.jpg" alt="Rhai Abstract Syntax Tree" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-script/README.md#transcode-rhai-script-to-ulisp">(Source)</a></p>
<p><em>Why are we doing this in Rust?</em></p>
<p>Because thanks to <code>bindgen</code>, we have complete info on the <strong>BL602 IoT SDK interfaces</strong> (functions, parameters, return types).</p>
<p>Which lets us <strong>manipulate the BL602 SDK interfaces</strong> and do cool things like‚Ä¶</p>
<ol>
<li>
<p><strong>Generate the uLisp Shims</strong> for BL602 IoT SDK</p>
</li>
<li>
<p><strong>Generate the Rhai Shims</strong> for BL602 IoT SDK</p>
</li>
<li>
<p><strong>Transcode Rhai Calls</strong> (BL602 IoT SDK) into uLisp</p>
</li>
<li>
<p><strong>Generate the Rust Wrapper</strong> for BL602 IoT SDK</p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs">(Via the <code>safe_wrap</code> Procedural Macro)</a></p>
</li>
</ol>
<h1 id="appendix-rust-simulation-events"><a href="#appendix-rust-simulation-events">14 Appendix: Rust Simulation Events</a></h1>
<p><em>How is the JSON Stream of Simulation Events accessed via the Rust Simulator Library?</em></p>
<p>Remember that we maintain a <strong>Vector of Simulation Events</strong> in Rust: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L23-L31"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Vector of Simulation Events (i.e. event array)
</span><span class="kw">static </span><span class="kw-2">mut </span>SIMULATION_EVENTS: Vec&lt;SimulationEvent&gt; = Vec::new();</code></pre></div>
<p>But we can‚Äôt expose this Rust Vector to WebAssembly and JavaScript.</p>
<p>Thus we define an <strong>Event Buffer</strong> that exposes the vector as a JSON String‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// String Buffer that returns the JSON Stream of Simulation Events:
/// `[ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///   { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, 
///   ... 
/// ]`
</span><span class="kw">static </span><span class="kw-2">mut </span>EVENT_BUFFER: [u8; <span class="number">1024</span>] = [<span class="number">0</span>; <span class="number">1024</span>];</code></pre></div>
<p>When our JavaScript code calls <code>get_simulation_events</code> to fetch the Simulation Events, we <strong>convert the Rust Vector to JSON</strong> and <strong>copy it into the Event Buffer</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L58-L92"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Return the JSON Stream of Simulation Events
</span><span class="attribute">#[no_mangle]  </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>get_simulation_events() -&gt; <span class="kw-2">*const </span>u8 {
    <span class="comment">//  Convert vector of events to a JSON string
    </span><span class="kw">let </span><span class="kw-2">mut </span>serialized = <span class="kw">unsafe </span>{
        serde_json::to_string(<span class="kw-2">&amp;</span>SIMULATION_EVENTS)
    }.unwrap();

    <span class="comment">//  Terminate the JSON string with null, since we will be returning to C
    </span>serialized.push(<span class="string">&#39;\0&#39;</span>);

    <span class="comment">//  Check that JSON string fits into the Event Buffer
    </span><span class="macro">assert!</span>(serialized.len() &lt;= <span class="kw">unsafe </span>{ EVENT_BUFFER.len() });

    <span class="comment">//  Copy the JSON string to the Event Buffer
    </span><span class="kw">unsafe </span>{                            <span class="comment">//  Unsafe because we are copying raw memory
        </span>std::ptr::copy(                 <span class="comment">//  Copy the memory...
            </span>serialized.as_ptr(),        <span class="comment">//  From Source (JSON String)
            </span>EVENT_BUFFER.as_mut_ptr(),  <span class="comment">//  To Destination (mutable pointer to Event Buffer)
            </span>serialized.len()            <span class="comment">//  Number of Items (each item is 1 byte)
        </span>);    
    }
      
    <span class="comment">//  Return the Event Buffer
    </span><span class="kw">unsafe </span>{
        EVENT_BUFFER.as_ptr()
    }
}</code></pre></div>
<p>Yep it‚Äôs possible that our serialized vector <strong>won‚Äôt fit into the Event Buffer</strong>.</p>
<p>To mitigate this, we ought to <strong>check the serialized vector size</strong> whenever we add an event‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Add an Simulation Event
</span><span class="kw">fn </span>add_event(ev: SimulationEvent) {
    <span class="comment">//  Add the event to the vector
    </span>SIMULATION_EVENTS.push(ev);

    <span class="comment">//  Convert vector of events to a JSON string
    </span><span class="kw">let </span><span class="kw-2">mut </span>serialized = <span class="kw">unsafe </span>{
        serde_json::to_string(<span class="kw-2">&amp;</span>SIMULATION_EVENTS)
    }.unwrap();

    <span class="comment">//  If the JSON string doesn&#39;t fit into the Event Buffer...
    </span><span class="kw">if </span>(serialized.len() + <span class="number">1 </span>&gt; <span class="kw">unsafe </span>{ EVENT_BUFFER.len() }) {
        <span class="comment">//  Remove the event from the vector and stop the simulation</span></code></pre></div>
<p>Here‚Äôs how we <strong>initialise the Vector of Simulation Events</strong> before use: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L47-L56"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Clear the JSON Stream of Simulation Events
</span><span class="attribute">#[no_mangle]  </span><span class="comment">//  Don&#39;t mangle the function name
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>clear_simulation_events() {
    <span class="comment">//  Clear the vector of Simulation Events
    </span><span class="kw">unsafe </span>{
        SIMULATION_EVENTS.clear();
    }
    <span class="comment">//  Show Rust Backtrace on error
    </span>std::env::set_var(<span class="string">&quot;RUST_BACKTRACE&quot;</span>, <span class="string">&quot;full&quot;</span>);
}</code></pre></div>

    
</body>
</html>