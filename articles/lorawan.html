<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>PineCone BL602 Talks LoRaWAN</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="PineCone BL602 Talks LoRaWAN" 
    data-rh="true">
<meta property="og:description" 
    content="How we connect PineCone BL602 RISC-V Board to LoRaWAN... With the Pine64 RFM90 LoRa Module"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lorawan-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">PineCone BL602 Talks LoRaWAN</h1>
    <nav id="TOC"><ul>
<li><a href="#connect-bl602-to-lora-module">1 Connect BL602 to LoRa Module</a><ul></ul></li>
<li><a href="#lora-transceiver-driver">2 LoRa Transceiver Driver</a><ul>
<li><a href="#how-it-works">2.1 How It Works</a><ul></ul></li>
<li><a href="#configure-lora-transceiver">2.2 Configure LoRa Transceiver</a><ul></ul></li>
<li><a href="#initialise-lora-transceiver">2.3 Initialise LoRa Transceiver</a><ul></ul></li>
<li><a href="#transmit-lora-packet">2.4 Transmit LoRa Packet</a><ul></ul></li>
<li><a href="#receive-lora-packet">2.5 Receive LoRa Packet</a><ul></ul></li>
<li><a href="#multitask-with-nimble-porting-layer">2.6 Multitask with NimBLE Porting Layer</a><ul></ul></li></ul></li>
<li><a href="#lorawan-driver">3 LoRaWAN Driver</a><ul>
<li><a href="#whats-inside">3.1 What‚Äôs Inside</a><ul></ul></li>
<li><a href="#join-network-request">3.2 Join Network Request</a><ul></ul></li>
<li><a href="#join-network-response">3.3 Join Network Response</a><ul></ul></li>
<li><a href="#open-lorawan-port">3.4 Open LoRaWAN Port</a><ul></ul></li>
<li><a href="#transmit-data-packet">3.5 Transmit Data Packet</a><ul></ul></li></ul></li>
<li><a href="#build-and-run-the-bl602-lorawan-firmware">4 Build and Run the BL602 LoRaWAN Firmware</a><ul>
<li><a href="#flash-the-firmware">4.1 Flash the firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">4.2 Run the firmware</a><ul></ul></li>
<li><a href="#enter-lorawan-commands">4.3 Enter LoRaWAN commands</a><ul></ul></li></ul></li>
<li><a href="#view-received-lorawan-packets">5 View Received LoRaWAN Packets</a><ul></ul></li>
<li><a href="#troubleshoot-lorawan">6 Troubleshoot LoRaWAN</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li>
<li><a href="#appendix-lora-transmit-power">9 Appendix: LoRa Transmit Power</a><ul>
<li><a href="#dc-dc-vs-ldo">9.1 DC-DC vs LDO</a><ul></ul></li>
<li><a href="#transmit-power">9.2 Transmit Power</a><ul></ul></li>
<li><a href="#over-current-protection">9.3 Over Current Protection</a><ul></ul></li></ul></li>
<li><a href="#appendix-lora-sync-word">10 Appendix: LoRa Sync Word</a><ul></ul></li>
<li><a href="#appendix-lora-carrier-sensing">11 Appendix: LoRa Carrier Sensing</a><ul></ul></li>
<li><a href="#appendix-packet-buffer-and-queue">12 Appendix: Packet Buffer and Queue</a><ul>
<li><a href="#packet-buffer">12.1 Packet Buffer</a><ul></ul></li>
<li><a href="#packet-buffer-queue">12.2 Packet Buffer Queue</a><ul></ul></li></ul></li>
<li><a href="#appendix-bl602-spi-functions">13 Appendix: BL602 SPI Functions</a><ul></ul></li>
<li><a href="#appendix-bl602-gpio-interrupts">14 Appendix: BL602 GPIO Interrupts</a><ul></ul></li></ul></nav><p>üìù <em>11 May 2021</em></p>
<p>Today we shall connect <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a> to the <a href="https://www.thethingsnetwork.org/docs/lorawan/"><strong>LoRaWAN Network</strong></a>‚Ä¶ With the <strong>Pine64 RFM90 LoRa Module</strong> based on <a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HT76/7Nka9W5WgugoZe.xwIHJy6ebj1hW8UJ.USO_Pt2CLLo"><strong>Semtech SX1262</strong></a>.</p>
<p>This will bring us one step closer to building <strong>low-power, long-range LoRaWAN IoT Devices with BL602</strong>.</p>
<p>The LoRaWAN Firmware in this article will run on <strong>PineCone, Pinenut and Any BL602 Board</strong>.</p>
<ul>
<li><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/lorawan-title.jpg" alt="PineCone BL602 RISC-V Board with Pine64 RFM90 LoRa Module (centre), PineBook Pro (left) and RAKwireless WisGate D4H LoRaWAN Gateway (right)" /></p>
<p><em>PineCone BL602 RISC-V Board with Pine64 RFM90 LoRa Module (centre), PineBook Pro (left) and RAKwireless WisGate D4H LoRaWAN Gateway (right)</em></p>
<h1 id="connect-bl602-to-lora-module"><a href="#connect-bl602-to-lora-module">1 Connect BL602 to LoRa Module</a></h1>
<p>Connect BL602 to Pine64 (HopeRF) RFM90 or Semtech SX1262 as follows‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-connect.jpg" alt="PineCone BL602 RISC-V Board connected to Pine64 RFM90 LoRa Module" /></p>
<div><table><thead><tr><th style="text-align: left">BL602 Pin</th><th style="text-align: left">RFM90 / SX1262 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong><code>GPIO 0</code></strong></td><td style="text-align: left"><code>BUSY</code></td><td style="text-align: left">Dark Green</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 1</code></strong></td><td style="text-align: left"><code>ISO</code> <em>(MISO)</em></td><td style="text-align: left">Light Green (Top)</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 2</code></strong></td><td style="text-align: left">Do Not Connect</td><td style="text-align: left">(Unused Chip Select)</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 3</code></strong></td><td style="text-align: left"><code>SCK</code></td><td style="text-align: left">Yellow (Top)</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 4</code></strong></td><td style="text-align: left"><code>OSI</code> <em>(MOSI)</em></td><td style="text-align: left">Blue (Top)</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 11</code></strong></td><td style="text-align: left"><code>DIO1</code></td><td style="text-align: left">Yellow (Bottom)</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 14</code></strong></td><td style="text-align: left"><code>NSS</code></td><td style="text-align: left">Orange</td></tr>
<tr><td style="text-align: left"><strong><code>GPIO 17</code></strong></td><td style="text-align: left"><code>RST</code></td><td style="text-align: left">White</td></tr>
<tr><td style="text-align: left"><strong><code>3V3</code></strong></td><td style="text-align: left"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: left"><strong><code>GND</code></strong></td><td style="text-align: left"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p><a href="https://electronics.stackexchange.com/questions/335912/can-i-break-a-radio-tranceiving-device-by-operating-it-with-no-antenna-connected"><strong>CAUTION: Always connect the Antenna before Powering On‚Ä¶ Or the LoRa Module may get damaged! See this</strong></a></p>
<p>Here‚Äôs a closer look at the pins connected on BL602‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-connect2.jpg" alt="PineCone BL602 RISC-V Board connected to Pine64 RFM90 LoRa Module" /></p>
<p><em>Why is BL602 Pin 2 unused?</em></p>
<p><strong><code>GPIO 2</code></strong> is the <strong>Unused SPI Chip Select</strong> on BL602.</p>
<p>We won‚Äôt use this pin because we‚Äôll control Chip Select ourselves on <code>GPIO 14</code>. <a href="https://lupyuen.github.io/articles/spi#control-our-own-chip-select-pin">(See this)</a></p>
<p>Here are the pins connected on our LoRa Module: RFM90 or SX1262‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-connect3.jpg" alt="PineCone BL602 RISC-V Board connected to Pine64 RFM90 LoRa Module" /></p>
<p><em>What‚Äôs Pin <code>DIO1</code>?</em></p>
<p>Our LoRa Module shifts <strong>Pin <code>DIO1</code></strong> from Low to High to signal that a <strong>LoRa Packet has been transmitted or received</strong>.</p>
<p>We shall configure BL602 to trigger a <strong>GPIO Interrupt</strong> when Pin <code>DIO1</code> shifts from Low to High.</p>
<ul>
<li>
<p><a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HT76/7Nka9W5WgugoZe.xwIHJy6ebj1hW8UJ.USO_Pt2CLLo"><strong>Semtech SX1262 Datasheet</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v9.0.0"><strong>HopeRF RFM90 Datasheet (Chinese)</strong></a></p>
</li>
</ul>
<h1 id="lora-transceiver-driver"><a href="#lora-transceiver-driver">2 LoRa Transceiver Driver</a></h1>
<p>The <strong>BL602 Driver for RFM90 / SX1262</strong> is located here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262"><code>components/3rdparty/lora-sx1262</code></a></li>
</ul>
<p>Let‚Äôs study the source code and learn how the driver is called by our Demo Firmware to <strong>transmit and receive LoRa Packets</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/sdk_app_lorawan"><code>customer_app/sdk_app_lorawan</code></a></li>
</ul>
<h2 id="how-it-works"><a href="#how-it-works">2.1 How It Works</a></h2>
<p>Our LoRa Driver has 3 layers: <strong>Radio Interface, Transceiver Interface and Board Interface</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-transceiver.png" alt="BL602 Driver for RFM90 / SX1262" /></p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c"><strong>Radio Interface: <code>radio.c</code></strong></a></p>
<p>Exposes the LoRa Radio Functions that will initialise the transceiver (<code>RadioInit</code>), send a LoRa Packet (<code>RadioSend</code>) and receive a LoRa Packet (<code>RadioRx</code>).</p>
<p>Our Demo Firmware calls the Radio Interface to send and receive LoRa Packets. (Our LoRaWAN Driver calls the Radio Interface too)</p>
<p>The Radio Interface is generic and works for various LoRa Transceivers (like SX1276).</p>
<p><a href="https://lupyuen.github.io/articles/usb#radioinit-initialise-lora-module">(<code>RadioInit</code> is explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/usb#radiosend-transmit-message">(<code>RadioSend</code> is explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/usb#radiorx-receive-message">(<code>RadioRx</code> is explained here)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x.c"><strong>Transceiver Interface: <code>sx126x.c</code></strong></a></p>
<p>Provides the functions specific to the SX1262 Transceiver: <code>SX126xInit</code>, <code>SX126xSendPayload</code>, <code>SX126xSetRx</code>, ‚Ä¶</p>
<p>Called by the Radio Interface.</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x-board.c"><strong>Board Interface: <code>sx126x-board.c</code></strong></a></p>
<p>Exposes the functions specific to our BL602 Board: <strong>SPI, GPIO, Events and Timers.</strong></p>
<p>SPI and GPIO Functions are implemented with the <strong>SPI and GPIO Hardware Abstraction Layers</strong> (HALs) from the BL602 IoT SDK.</p>
<p>Events and Timers are implemented with the <strong>NimBLE Porting Layer</strong>, a library that simplifies the FreeRTOS multitasking functions from the BL602 IoT SDK.</p>
<p>Called by the Transceiver Interface.</p>
</li>
</ol>
<p>The LoRa Driver was ported to BL602 from <strong>Semtech‚Äôs Reference Implementation of the SX1262 Driver</strong>. <a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x">(See this)</a></p>
<h2 id="configure-lora-transceiver"><a href="#configure-lora-transceiver">2.2 Configure LoRa Transceiver</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> We configure LoRaWAN via <code>Makefile</code>, not <code>#define</code>. Skip this section if we‚Äôre using LoRaWAN.)</p>
<p>We set the <strong>LoRa Frequency</strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L44-L80"><code>demo.c</code></a> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923</code></pre></div>
<p>Change <code>USE_BAND_923</code> to <code>USE_BAND_433</code>, <code>780</code>, <code>868</code> or <code>915</code>. Here‚Äôs the complete list‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#if defined(USE_BAND_433)
  #define RF_FREQUENCY               434000000 /* Hz */
#elif defined(USE_BAND_780)
  #define RF_FREQUENCY               780000000 /* Hz */
#elif defined(USE_BAND_868)
  #define RF_FREQUENCY               868000000 /* Hz */
#elif defined(USE_BAND_915)
  #define RF_FREQUENCY               915000000 /* Hz */
#elif defined(USE_BAND_923)
  #define RF_FREQUENCY               923000000 /* Hz */
#else
  #error &quot;Please define a frequency band in the compiler options.&quot;
#endif</code></pre></div>
<p>The <strong>LoRa Parameters</strong> are also defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L44-L80"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// LoRa Parameters
#define LORAPING_TX_OUTPUT_POWER            14        /* dBm */

#define LORAPING_BANDWIDTH                  0         /* [0: 125 kHz, */
                                                      /*  1: 250 kHz, */
                                                      /*  2: 500 kHz, */
                                                      /*  3: Reserved] */
#define LORAPING_SPREADING_FACTOR           7         /* [SF7..SF12] */
#define LORAPING_CODINGRATE                 1         /* [1: 4/5, */
                                                      /*  2: 4/6, */
                                                      /*  3: 4/7, */
                                                      /*  4: 4/8] */
#define LORAPING_PREAMBLE_LENGTH            8         /* Same for Tx and Rx */
#define LORAPING_SYMBOL_TIMEOUT             5         /* Symbols */
#define LORAPING_FIX_LENGTH_PAYLOAD_ON      false
#define LORAPING_IQ_INVERSION_ON            false

#define LORAPING_TX_TIMEOUT_MS              3000    /* ms */
#define LORAPING_RX_TIMEOUT_MS              5000    /* ms */
#define LORAPING_BUFFER_SIZE                64      /* LoRa message size */</code></pre></div>
<p>These should match the LoRa Parameters used by the LoRa Transmitter / Receiver.</p>
<p>I used this LoRa Transmitter and Receiver (based on RAKwireless WisBlock) for testing our LoRa Driver‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/wisblock"><strong>‚ÄúRAKwireless WisBlock talks LoRa with PineCone BL602 RISC-V Board‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/lorawan-transmit.png" alt="WisBlock receives LoRa packet from BL602" /></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lora2#start-the-rakwireless-wisblock-transmitter"><strong>‚ÄúRAKwireless WisBlock Transmitter‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/lorawan-receive.png" alt="BL602 receives LoRa packet from WisBlock" /></p>
</li>
</ul>
<h2 id="initialise-lora-transceiver"><a href="#initialise-lora-transceiver">2.3 Initialise LoRa Transceiver</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> Our LoRaWAN Driver initialises the LoRa Transceiver for us, when we run the <code>init_lorawan</code> command. Skip this section if we‚Äôre using LoRaWAN.)</p>
<p>The <code>init_driver</code> command in our Demo Firmware initialises the LoRa Transceiver like so: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L159-L212"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to initialise the LoRa Driver.
/// Assume that create_task has been called to init the Event Queue.
static void init_driver(char *buf, int len, int argc, char **argv) {
  //  Set the LoRa Callback Functions
  RadioEvents_t radio_events;
  memset(&amp;radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
  radio_events.TxDone    = on_tx_done;     //  Packet has been transmitted
  radio_events.RxDone    = on_rx_done;     //  Packet has been received
  radio_events.TxTimeout = on_tx_timeout;  //  Transmit Timeout
  radio_events.RxTimeout = on_rx_timeout;  //  Receive Timeout
  radio_events.RxError   = on_rx_error;    //  Receive Error</code></pre></div>
<p>Here we set the <strong>Callback Functions</strong> that will be called when a LoRa Packet has been transmitted or received, also when we encounter a transmit / receive timeout or error.</p>
<p>(We‚Äôll see the Callback Functions in a while)</p>
<p>Next we initialise the LoRa Transceiver and set the <strong>LoRa Frequency</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init the SPI Port and the LoRa Transceiver
  Radio.Init(&amp;radio_events);

  //  Set the LoRa Frequency
  Radio.SetChannel(RF_FREQUENCY);</code></pre></div>
<p>We set the <strong>LoRa Transmit Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the LoRa Transceiver for transmitting messages
  Radio.SetTxConfig(
    MODEM_LORA,
    LORAPING_TX_OUTPUT_POWER,
    0,        //  Frequency deviation: Unused with LoRa
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    LORAPING_TX_TIMEOUT_MS
  );</code></pre></div>
<p>Finally we set the <strong>LoRa Receive Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the LoRa Transceiver for receiving messages
  Radio.SetRxConfig(
    MODEM_LORA,
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    0,        //  AFC bandwidth: Unused with LoRa
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_SYMBOL_TIMEOUT,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    0,        //  Fixed payload length: N/A
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    true      //  Continuous receive mode
  );    
}</code></pre></div>
<p>The ‚Äú<code>Radio</code>‚Äù functions are defined in <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c"><code>radio.c</code></a> ‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L523-L559"><strong><code>RadioInit</code>:</strong></a> Init LoRa Transceiver</p>
<p><a href="https://lupyuen.github.io/articles/usb#radioinit-initialise-lora-module">(<code>RadioInit</code> is explained here)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L600-L604"><strong><code>RadioSetChannel</code>:</strong></a> Set LoRa Frequency</p>
<p><a href="https://lupyuen.github.io/articles/usb#radiosetchannel-set-lora-frequency">(<code>RadioSetChannel</code> is explained here)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L788-L908"><strong><code>RadioSetTxConfig</code>:</strong></a> Set LoRa Transmit Configuration</p>
<p><a href="https://lupyuen.github.io/articles/usb#radiosettxconfig-set-transmit-configuration">(<code>RadioSetTxConfig</code> is explained here)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L661-L786"><strong><code>RadioSetRxConfig</code>:</strong></a> Set LoRa Receive Configuration</p>
<p><a href="https://lupyuen.github.io/articles/usb#radiosetrxconfig-set-receive-configuration">(<code>RadioSetRxConfig</code> is explained here)</a></p>
</li>
</ul>
<h2 id="transmit-lora-packet"><a href="#transmit-lora-packet">2.4 Transmit LoRa Packet</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> Our LoRaWAN Driver calls the LoRa Driver to transmit LoRa Packets, when we run the <code>las_join</code> and <code>las_app_tx</code> commands. Skip this section if we‚Äôre using LoRaWAN to transmit data.)</p>
<p>To transmit a LoRa Packet, the <code>send_message</code> command in our Demo Firmware calls <code>send_once</code> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L214-L219"><code>demo.c</code></a> ‚Ä¶ </p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to send a LoRa message. Assume that the LoRa Transceiver driver has been initialised.
static void send_message(char *buf, int len, int argc, char **argv) {
  //  Send the &quot;PING&quot; message
  send_once(1);
}</code></pre></div>
<p><strong><code>send_once</code></strong> prepares a LoRa Packet containing the string ‚Äú<code>PING</code>‚Äù‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L221-L244"><code>demo.c</code></a> :</p>
<div class="example-wrap"><pre class="language-c"><code>/// We send a &quot;PING&quot; message and expect a &quot;PONG&quot; response
const uint8_t loraping_ping_msg[] = &quot;PING&quot;;
const uint8_t loraping_pong_msg[] = &quot;PONG&quot;;

/// 64-byte buffer for our LoRa message
static uint8_t loraping_buffer[LORAPING_BUFFER_SIZE];

/// Send a LoRa message. If is_ping is 0, send &quot;PONG&quot;. Otherwise send &quot;PING&quot;.
static void send_once(int is_ping) {
  //  Copy the &quot;PING&quot; or &quot;PONG&quot; message 
  //  to the transmit buffer
  if (is_ping) {
    memcpy(loraping_buffer, loraping_ping_msg, 4);
  } else {
    memcpy(loraping_buffer, loraping_pong_msg, 4);
  }</code></pre></div>
<p>Then pads the packet with values 0, 1, 2, ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Fill up the remaining space in the 
  //  transmit buffer (64 bytes) with values 
  //  0, 1, 2, ...
  for (int i = 4; i &lt; sizeof loraping_buffer; i++) {
    loraping_buffer[i] = i - 4;
  }</code></pre></div>
<p>And transmits the LoRa Packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Send the transmit buffer (64 bytes)
  Radio.Send(loraping_buffer, sizeof loraping_buffer);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/usb#radiosend-transmit-message">(<code>RadioSend</code> is explained here)</a></p>
<p>When the LoRa Packet is transmitted, the LoRa Driver calls our Callback Function <strong><code>on_tx_done</code></strong> ‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L399-L412"><code>demo.c</code></a> :</p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when our LoRa message has been transmitted
static void on_tx_done(void) {
  //  Log the success status
  loraping_stats.tx_success++;

  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();
}</code></pre></div>
<p>Here we log the number of packets transmitted, and put the LoRa Transceiver to low power, sleep mode.</p>
<p><a href="https://lupyuen.github.io/articles/usb#radiosleep-switch-to-sleep-mode">(<code>RadioSleep</code> is explained here)</a></p>
<h2 id="receive-lora-packet"><a href="#receive-lora-packet">2.5 Receive LoRa Packet</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> Our LoRaWAN Driver calls the LoRa Driver to receive LoRa Packets, when we run the <code>las_join</code> and <code>las_app_tx</code> commands. Skip this section if we‚Äôre using LoRaWAN to receive data.)</p>
<p>Here‚Äôs how the <code>receive_message</code> command in our Demo Firmware receives a LoRa Packet: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L246-L252"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to receive a LoRa message. Assume that LoRa Transceiver driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(char *buf, int len, int argc, char **argv) {
  //  Receive a LoRa message within the timeout period
  Radio.Rx(LORAPING_RX_TIMEOUT_MS);  //  Timeout in 5 seconds
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/usb#radiorx-receive-message">(<code>RadioRx</code> is explained here)</a></p>
<p>When the LoRa Driver receives a LoRa Packet, it calls our Callback Function <code>on_rx_done</code> ‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L414-L444"><code>demo.c</code></a> :</p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
  uint8_t *payload,  //  Buffer containing received LoRa message
  uint16_t size,     //  Size of the LoRa message
  int16_t rssi,      //  Signal strength
  int8_t snr) {      //  Signal To Noise ratio

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the signal strength, signal to noise ratio
  loraping_rxinfo_rxed(rssi, snr);</code></pre></div>
<p><strong><code>on_rx_done</code></strong> switches the LoRa Transceiver to low power, sleep mode and logs the received packet.</p>
<p>Next it <strong>copies the received packet</strong> into a buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Copy the received packet
  if (size &gt; sizeof loraping_buffer) {
    size = sizeof loraping_buffer;
  }
  loraping_rx_size = size;
  memcpy(loraping_buffer, payload, size);</code></pre></div>
<p>Finally it <strong>dumps the buffer</strong> containing the received packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Dump the contents of the received packet
  for (int i = 0; i &lt; loraping_rx_size; i++) {
    printf(&quot;%02x &quot;, loraping_buffer[i]);
  }
  printf(&quot;\r\n&quot;);
}</code></pre></div>
<p><em>What happens when we don‚Äôt receive a packet in 5 seconds?</em></p>
<p>The LoRa Driver calls our Callback Function <code>on_rx_timeout</code> ‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L461-L475"><code>demo.c</code></a> :</p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.rx_timeout++;
  loraping_rxinfo_timeout();
}</code></pre></div>
<p>We switch the LoRa Transceiver into sleep mode and log the timeout.</p>
<h2 id="multitask-with-nimble-porting-layer"><a href="#multitask-with-nimble-porting-layer">2.6 Multitask with NimBLE Porting Layer</a></h2>
<p>The LoRa Transceiver (RFM90 / SX1262) triggers a <strong>GPIO Interrupt</strong> on BL602 when it receives a LoRa Packet‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-interrupt.png" alt="GPIO Interrupt Handler" /></p>
<p>For safety we forward the GPIO Interrupt to a <strong>Background Task</strong> via an <strong>Event Queue</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-handler.png" alt="Handling LoRa Receive Event" /></p>
<p>So that the GPIO Interrupt is handled in the <strong>Application Context</strong>, where it‚Äôs safe to call SPI Functions, <code>printf</code> and other nice things.</p>
<p>The <strong>GPIO Interrupt Handling</strong> is explained in the Appendix‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts"><strong>‚ÄúBL602 GPIO Interrupts‚Äù</strong></a></li>
</ul>
<p>The Multitasking Functions (Event Queue and Background Task) are provided by the <strong>NimBLE Porting Layer</strong> library‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer"><strong>‚ÄúMultitask with NimBLE Porting Layer‚Äù</strong></a></li>
</ul>
<h1 id="lorawan-driver"><a href="#lorawan-driver">3 LoRaWAN Driver</a></h1>
<p>We‚Äôve seen the LoRa Transceiver Driver (for RFM90 / SX1262)‚Ä¶ Now let‚Äôs watch how the LoRaWAN Driver wraps around the LoRa Transceiver Driver to do <strong>secure, managed LoRaWAN Networking</strong>.</p>
<p>The <strong>BL602 Driver for LoRaWAN</strong> is located here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lorawan"><code>components/3rdparty/lorawan</code></a></li>
</ul>
<p>We shall study the source code and learn how the LoRaWAN Driver is called by our demo firmware to <strong>join the LoRaWAN Network and transmit data packets</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/sdk_app_lorawan"><code>customer_app/sdk_app_lorawan</code></a></li>
</ul>
<h2 id="whats-inside"><a href="#whats-inside">3.1 What‚Äôs Inside</a></h2>
<p>Our BL602 Driver for LoRaWAN has layers (like Onions, Shrek and Kueh Lapis): <strong>Application Layer, Node Layer and Medium Access Control Layer</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver.png" alt="BL602 LoRaWAN Driver" /></p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c"><strong>Application Layer: <code>lora_app.c</code></strong></a></p>
<p>The <strong>Application Layer</strong> exposes functions for our Demo Firmware to‚Ä¶</p>
<ul>
<li>
<p>Join the LoRaWAN Network: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c#L408-L437"><strong><code>lora_app_join</code></strong></a></p>
</li>
<li>
<p>Open a LoRaWAN Application Port: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c#L148-L205"><strong><code>lora_app_port_open</code></strong></a></p>
</li>
<li>
<p>Transmit a LoRaWAN Data Packet: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c#L262-L304"><strong><code>lora_app_port_send</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_node.c"><strong>Node Layer: <code>lora_node.c</code></strong></a></p>
<p>The <strong>Node Layer</strong> is called by the Application Layer to handle LoRaWAN Networking requests.</p>
<p>The Node Layer channels the networking requests to the Medium Access Control Layer via an <strong>Event Queue</strong> (provided by the NimBLE Porting Layer).</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c"><strong>Medium Access Control Layer: <code>LoRaMac.c</code></strong></a></p>
<p>The <strong>Medium Access Control Layer</strong> implements the LoRaWAN Networking functions by calling the LoRa Transceiver Driver (for RFM90 / SX1262).</p>
<p>(Yep the Medium Access Control Layer calls the ‚Äú<code>Radio</code>‚Äù functions we‚Äôve seen in the previous chapter)</p>
<p>This layer is fully aware of the <strong>LoRa Frequencies</strong> and the Encoding Schemes that should be used in each world region. And it enforces <strong>LoRaWAN Security</strong> (like encryption and authentication of messages).</p>
<p>The Medium Access Control Layer runs as a <strong>Background Task</strong>, communicating with the Node Layer in a queued, asynchronous way via an Event Queue.</p>
</li>
<li>
<p>We‚Äôre not using the <strong>Command-Line Interface</strong> <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_cli.c"><code>lora_cli.c</code></a> that‚Äôs bundled with our LoRaWAN Driver.</p>
<p>Instead we‚Äôre using the Command-Line Interface that‚Äôs coded inside our Demo Firmware.</p>
</li>
</ol>
<p>The LoRaWAN Driver was ported to BL602 from <strong>Apache Mynewt OS</strong>. <a href="https://github.com/apache/mynewt-core/tree/master/net/lora/node">(See this)</a></p>
<p>(This implementation of the LoRaWAN Driver seems outdated. There is a newer reference implementation by Semtech. <a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/mac">See this</a>)</p>
<h2 id="join-network-request"><a href="#join-network-request">3.2 Join Network Request</a></h2>
<p>Before transmitting a LoRaWAN Data Packet, our BL602 gadget needs to <strong>join the LoRaWAN Network</strong>.</p>
<p>(It‚Äôs like connecting to a WiFi Network, authenticated by a security key)</p>
<p>In the Demo Firmware, we enter this command to join the LoRaWAN Network (up to 3 attempts)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_join 3</code></pre></div>
<p>Let‚Äôs study what happens inside the <strong><code>las_join</code></strong> command‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/lorawan.c#L901-L935"><code>lorawan.c</code></a> :</p>
<div class="example-wrap"><pre class="language-c"><code>/// `las_join` command will send a Join Network Request
void las_cmd_join(char *buf0, int len0, int argc, char **argv) {
  ...
  //  Send a Join Network Request
  int rc = lora_app_join(
    g_lora_dev_eui,  //  Device EUI
    g_lora_app_eui,  //  Application EUI
    g_lora_app_key,  //  Application Key
    attempts         //  Number of join attempts
  );</code></pre></div>
<p>To join a LoRaWAN Network we need to have 3 things in our BL602 firmware‚Ä¶</p>
<ol>
<li>
<p><strong>Device EUI</strong>: A 64-bit number that uniquely identifies our LoRaWAN Device (BL602)</p>
</li>
<li>
<p><strong>Application EUI</strong>: A 64-bit number that uniquely identifies the LoRaWAN Server Application that will receive our LoRaWAN Data Packets</p>
</li>
<li>
<p><strong>Application Key</strong>: A 128-bit secret key that will authenticate our LoRaWAN Device for that LoRaWAN Server Application</p>
</li>
</ol>
<p>(EUI sounds like a Pungent Durian‚Ä¶ But it actually means <a href="https://lora-developers.semtech.com/library/tech-papers-and-guides/the-book/deveui/"><strong>Extended Unique Identifier</strong></a>)</p>
<p>How do we get the Device EUI, Application EUI and Application Key? We‚Äôll find out in a while.</p>
<p><strong><code>lora_app_join</code></strong> is defined in the <strong>Application Layer</strong> of our LoRaWAN Driver: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c#L408-L437"><code>lora_app.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Send a Join Network Request
int lora_app_join(uint8_t *dev_eui, uint8_t *app_eui, uint8_t *app_key, uint8_t trials) {
  //  Omitted: Validate the parameters
  ...

  //  Tell device to start join procedure
  int rc = lora_node_join(dev_eui, app_eui, app_key, trials);</code></pre></div>
<p>Here we validate the parameters and call <code>lora_node_join</code>.</p>
<p>Now we hop over from the Application Layer to the <strong>Node Layer</strong>: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_node.c#L473-L503"><code>lora_node.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Perform the join process
int lora_node_join(uint8_t *dev_eui, uint8_t *app_eui, uint8_t *app_key, uint8_t trials) {
  //  Omitted: Check if we have joined the network
  ...

  //  Set the Event parameters
  g_lm_join_ev_arg.dev_eui = dev_eui;
  g_lm_join_ev_arg.app_eui = app_eui;
  g_lm_join_ev_arg.app_key = app_key;
  g_lm_join_ev_arg.trials  = trials;

  //  Send Event to Medium Access Control Layer via Event Queue
  ble_npl_eventq_put(
    g_lora_mac_data.lm_evq,      //  Event Queue
    &amp;g_lora_mac_data.lm_join_ev  //  Event
  );</code></pre></div>
<p>Here we‚Äôre passing a Join Event to the <strong>Event Queue</strong> that‚Äôs provided by the NimBLE Porting Layer.</p>
<p>Again we hop, from the Node Layer to the <strong>Medium Access Control Layer</strong>: <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L3086-L3139"><code>LoRaMac.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Background Task that handles the Event Queue
LoRaMacStatus_t LoRaMacMlmeRequest(MlmeReq_t *mlmeRequest) {
  ...
  //  Check the request type
  switch (mlmeRequest-&gt;Type) {
    //  If this is a join request...
    case MLME_JOIN:
      //  Compose and send the join request
      status = Send(&amp;macHdr, 0, NULL);</code></pre></div>
<p><strong><code>LoRaMacMlmeRequest</code></strong> runs as a <strong>FreeRTOS Background Task</strong>, processing the Events that have been enqueued in the Event Queue.</p>
<p>(That‚Äôs how the Node Layer and the Medium Access Control Layer collaborate asynchronously)</p>
<p><code>LoRaMacMlmeRequest</code> calls <strong><code>Send</code></strong> to compose and transmit the Join Request as a LoRa Packet: <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L1932-L1954"><code>LoRaMac.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Compose and send a packet
LoRaMacStatus_t Send(LoRaMacHeader_t *macHdr, uint8_t fPort, struct pbuf *om) {
  ...
  //  Prepare the LoRa Packet
  status = PrepareFrame(macHdr, &amp;fCtrl, fPort, om);

  //  Send the LoRa Packet
  status = ScheduleTx();</code></pre></div>
<p>The call chain goes‚Ä¶</p>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L1932-L1954"><code>Send</code></a> ‚Üí <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L1956-L2062"><code>ScheduleTx</code></a> ‚Üí <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L2379-L2426"><code>SendFrameOnChannel</code></a> ‚Üí <a href="https://lupyuen.github.io/articles/usb#radiosend-transmit-message"><code>RadioSend</code></a></p>
<p>Eventually the Medium Access Control Layer calls <a href="https://lupyuen.github.io/articles/usb#radiosend-transmit-message"><strong><code>RadioSend</code></strong></a> (from our LoRa Transceiver Driver) to transmit the Join Request.</p>
<p><a href="https://lupyuen.github.io/articles/wisgate#join-network-request">(What‚Äôs inside the Join Request? Check this out)</a></p>
<p>And that‚Äôs how our LoRaWAN Driver sends a <strong>Join Network Request</strong>‚Ä¶</p>
<p>LoRaWAN Firmware ‚Üí Application Layer ‚Üí Node Layer ‚Üí Medium Access Control Layer ‚Üí LoRa Transceiver Driver!</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver5.png" alt="Medium Access Control Layer" /></p>
<h2 id="join-network-response"><a href="#join-network-response">3.3 Join Network Response</a></h2>
<p>But wait‚Ä¶ We‚Äôre not done yet!</p>
<p>We‚Äôve sent a Join Network Request to the LoRaWAN Gateway‚Ä¶ Now we need to <strong>wait for the response from the LoRaWAN Gateway</strong>.</p>
<p>The Medium Access Control Layer calls <a href="https://lupyuen.github.io/articles/usb#radiorx-receive-message"><strong><code>RadioRx</code></strong></a> (from the LoRa Transceiver Driver) to receive the response packet.</p>
<p>When the packet is received, the LoRa Transceiver Driver calls this Callback Function: <strong><code>OnRadioRxDone</code></strong> in <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L299-L323"><code>LoRaMac.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that&#39;s called when we receive a LoRa Packet
static void OnRadioRxDone(uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr) {
  //  Put the Receive Event into the Event Queue  
  ble_npl_eventq_put(
    lora_node_mac_evq_get(),    //  Event Queue
    &amp;g_lora_mac_radio_rx_event  //  Receive Event
  );

  //  Remember the received data
  g_lora_mac_data.rxbuf     = payload;
  g_lora_mac_data.rxbufsize = size;</code></pre></div>
<p><strong><code>OnRadioRxDone</code></strong> adds the <strong>Receive Event</strong> to the Event Queue for background processing.</p>
<p>Our <strong>Background Task</strong> receives the Receive Event from the Event Queue and processes the event: <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L906-L988"><code>LoRaMac.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Process the Receive Event
static void lora_mac_process_radio_rx(struct ble_npl_event *ev) {
  ...
  //  Put radio to sleep
  Radio.Sleep();

  //  Get the payload and size
  payload = g_lora_mac_data.rxbuf;
  size    = g_lora_mac_data.rxbufsize;

  //  Get the header from the received frame
  macHdr.Value = payload[0];

  //  Check the header type
  switch (macHdr.Bits.MType) {
    //  If this is a Join Accept Response...
    case FRAME_TYPE_JOIN_ACCEPT:
      //  Process the Join Accept Response
      lora_mac_join_accept_rxd(payload, size);
      break;</code></pre></div>
<p>(We assume that the Join Request was accepted by the LoRaWAN Gateway)</p>
<p><strong><code>lora_mac_process_radio_rx</code></strong> handles the Join Accept Response by calling <strong><code>lora_mac_join_accept_rxd</code></strong> ‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L574-L667"><code>LoRaMac.c</code></a> :</p>
<div class="example-wrap"><pre class="language-c"><code>/// Process the Join Accept Response
static void lora_mac_join_accept_rxd(uint8_t *payload, uint16_t size) {
  ...
  //  Decrypt the response
  LoRaMacJoinDecrypt(payload + 1, size - 1, LoRaMacAppKey, LoRaMacRxPayload + 1);
  ...
  //  Verify the Message Integrity Code
  LoRaMacJoinComputeMic(LoRaMacRxPayload, size - LORAMAC_MFR_LEN, LoRaMacAppKey, &amp;mic);
  ...
  //  Omitted: Update the Join Network Status
  ...
  //  Stop Second Receive Window
  lora_mac_rx_win2_stop();</code></pre></div>
<p><strong><code>lora_mac_join_accept_rxd</code></strong> handles the Join Accept Response‚Ä¶</p>
<ol>
<li>
<p>Decrypt the response</p>
</li>
<li>
<p>Verify the Message Integrity Code</p>
</li>
<li>
<p>Update the Join Network Status</p>
</li>
<li>
<p>Stop the Second Receive Window</p>
</li>
</ol>
<p><a href="https://lupyuen.github.io/articles/wisgate#join-network-request">(More about LoRaWAN Encryption and Message Integrity Code)</a></p>
<p><em>What‚Äôs a Receive Window?</em></p>
<p>Here‚Äôs what the LoRaWAN Specification says‚Ä¶</p>
<p>LoRaWAN Devices (Class A, like our BL602 gadget) don‚Äôt receive packets all the time.</p>
<p>We listen for incoming packets (for a brief moment) <strong>only after we transmit a packet</strong>. This is called a <strong>Receive Window</strong>.</p>
<p>We‚Äôve just transmitted a packet (Join Network Request), so <strong>we listen for an incoming packet</strong> (Join Accept Reponse).</p>
<p><em>Why do we stop the Second Receive Window?</em></p>
<p>Now the LoRaWAN Specification actually defines <strong>Two Receive Windows</strong>‚Ä¶</p>
<p>If we don‚Äôt receive a packet in the First Receive Window, we shall listen again (very briefly) in the <strong>Second Receive Window</strong>.</p>
<p>But since we have received a Join Accept Response in the First Receive Window, we may <strong>cancel the Second Receive Window</strong>.</p>
<p>And that‚Äôs how we handle the <strong>Join Network Response</strong> from the LoRaWAN Gateway!</p>
<p><a href="https://lupyuen.github.io/articles/wisgate#wisblock-talks-to-wisgate">(More about LoRaWAN Receive Windows)</a></p>
<h2 id="open-lorawan-port"><a href="#open-lorawan-port">3.4 Open LoRaWAN Port</a></h2>
<p>Our BL602 gadget has joined the LoRaWAN Network‚Ä¶ We‚Äôre almost ready to send data packets to the LoRaWAN Gateway! But before that, we need to <strong>open a LoRaWAN Application Port</strong>.</p>
<p>(It‚Äôs like opening a TCP or UDP socket)</p>
<p>In our Demo Firmware we enter this command to open LoRaWAN Application Port Number 2‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_app_port open 2</code></pre></div>
<p>(Port #2 seems to be a common port used by LoRaWAN Applications)</p>
<p>The <strong><code>las_app_port</code></strong> command calls this function in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/lorawan.c#L735-L808"><code>lorawan.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// `las_app_port open 2` command opens LoRaWAN Application Port 2
void las_cmd_app_port(char *buf0, int len0, int argc, char **argv) {
  ...
  //  If this is an `open` command...
  if (!strcmp(argv[1], &quot;open&quot;)) {
    //  Call the LoRaWAN Driver to open the LoRaWAN Application Port
    rc = lora_app_port_open(
      port,                     //  Port Number (2)
      lora_app_shell_txd_func,  //  Callback Function for Transmit
      lora_app_shell_rxd_func   //  Callback Function for Receive
    );</code></pre></div>
<p><strong><code>las_cmd_app_port</code></strong> calls our LoRaWAN Driver to open the LoRaWAN Port and provides two <strong>Callback Functions</strong>‚Ä¶</p>
<ul>
<li>
<p><strong><code>lora_app_shell_txd_func</code></strong>: Called when a LoRaWAN Packet has been transmitted</p>
</li>
<li>
<p><strong><code>lora_app_shell_rxd_func</code></strong>: Called when a LoRaWAN Packet has been received</p>
</li>
</ul>
<p>Here‚Äôs how our LoRaWAN Driver opens the LoRaWAN Port: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c#L148-L205"><code>lora_app.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Open a LoRaWAN Application Port. This function will 
/// allocate a LoRaWAN port, set port default values for 
/// datarate and retries, set the transmit done and
/// received data callbacks, and add port to list of open ports.
int lora_app_port_open(uint8_t port, lora_txd_func txd_cb, lora_rxd_func rxd_cb) {
  ...
  //  Make sure port is not opened
  avail = -1;
  for (i = 0; i &lt; LORA_APP_NUM_PORTS; ++i) {
    //  If port not opened, remember first available
    if (lora_app_ports[i].opened == 0) {
      if (avail &lt; 0) { avail = i; }
    } else {
      //  Make sure port is not already opened
      if (lora_app_ports[i].port_num == port) { return LORA_APP_STATUS_ALREADY_OPEN; }
    }
  }</code></pre></div>
<p><strong><code>lora_app_port_open</code></strong> allocates a port object for the requested port number.</p>
<p>Then it sets the port number, receive callback and transmit callback in the port object‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Open port if available
  if (avail &gt;= 0) {
    lora_app_ports[avail].port_num = port;  //  Port Number
    lora_app_ports[avail].rxd_cb = rxd_cb;  //  Receive Callback
    lora_app_ports[avail].txd_cb = txd_cb;  //  Transmit Callback
    lora_app_ports[avail].retries = 8;
    lora_app_ports[avail].opened = 1;
    rc = LORA_APP_STATUS_OK;
  } else {
    rc = LORA_APP_STATUS_ENOMEM;
  }
  return rc;
}</code></pre></div>
<p>We‚Äôre now ready to transmit data packets to LoRaWAN Port #2!</p>
<h2 id="transmit-data-packet"><a href="#transmit-data-packet">3.5 Transmit Data Packet</a></h2>
<p>We enter this command into our Demo Firmware to <strong>transmit a LoRaWAN Data Packet to port 2, containing 5 bytes (of null)</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_app_tx 2 5 0</code></pre></div>
<p>The ‚Äú<code>0</code>‚Äù at the end indicates that this is an <strong>Unconfirmed Message</strong>: We don‚Äôt expect any acknowledgement from the LoRaWAN Gateway.</p>
<p>This is the preferred way for a low-power LoRaWAN device to transmit sensor data, since it <strong>doesn‚Äôt need to wait for the acknowledgement</strong> (and consume additional power).</p>
<p>(It‚Äôs OK if a LoRaWAN Data Packet gets lost due to noise or inteference‚Ä¶ LoRaWAN sensor devices are supposed to transmit data packets periodically anyway)</p>
<p>The <strong><code>las_app_tx</code></strong> command is implemented here: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/lorawan.c#L810-L885"><code>lorawan.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// `las_app_tx 2 5 0` command transmits to LoRaWAN Port 2
/// a data packet of 5 bytes, as an Unconfirmed Message (0)
void las_cmd_app_tx(char *buf0, int len0, int argc, char **argv) {
  ...
  //  Allocate a Packet Buffer
  om = lora_pkt_alloc(len);
  ...
  //  Copy the data into the Packet Buffer
  int rc = pbuf_copyinto(
    om,  //  Packet Buffer
    0,   //  Offset into the Packet Buffer
    las_cmd_app_tx_buf,  //  Data to be copied
    len                  //  Data length
  );
  assert(rc == 0);

  //  Transmit the Packet Buffer
  rc = lora_app_port_send(
    port,       //  Port Number
    mcps_type,  //  Message Type: Unconfirmed
    om          //  Packet Buffer
  );</code></pre></div>
<p><strong><code>las_cmd_app_tx</code></strong> does the following‚Ä¶</p>
<ol>
<li>
<p>Allocate a Packet Buffer</p>
</li>
<li>
<p>Copy the transmit data into the Packet Buffer</p>
</li>
<li>
<p>Transmit the Packet Buffer by calling <code>lora_app_port_send</code></p>
</li>
</ol>
<p>We use <strong>Packet Buffers</strong> in the LoRaWAN Driver because they are more efficient for passing packets around. (More about Packet Buffers in the Appendix)</p>
<p>Now we hop from the Demo Firmware into the <strong>Application Layer</strong> of the LoRaWAN Driver: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_app.c#L262-L304"><code>lora_app.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Send a LoRaWAN Packet to a LoRaWAN Port
int lora_app_port_send(uint8_t port, Mcps_t pkt_type, struct pbuf *om) {
  ...
  //  Find the LoRaWAN port
  lap = lora_app_port_find_open(port);

  //  Set the header in the Packet Buffer
  lpkt = (struct lora_pkt_info *) get_pbuf_header(om, sizeof(struct lora_pkt_info));
  lpkt-&gt;port     = port;
  lpkt-&gt;pkt_type = pkt_type;
  lpkt-&gt;txdinfo.retries = lap-&gt;retries;

  //  Call the Node Layer to transmit the Packet Buffer
  lora_node_mcps_request(om);</code></pre></div>
<p><strong><code>lora_app_port_send</code></strong> transmits the Packet Buffer by calling <code>lora_node_mcps_request</code>.</p>
<p>Again we hop, from the Application Layer to the <strong>Node Layer</strong>: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_node.c#L142-L159"><code>lora_node.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Transmit a LoRaWAN Packet by adding it to the Transmit Queue
void lora_node_mcps_request(struct pbuf *om) {
  ...
  //  Add the Packet Buffer to the Transmit Queue
  rc = pbuf_queue_put(
    &amp;g_lora_mac_data.lm_txq,  //  Transmit Queue
    g_lora_mac_data.lm_evq,   //  Event Queue
    om                        //  Packet Buffer
  );</code></pre></div>
<p><strong><code>lora_node_mcps_request</code></strong> adds the Packet Buffer to the <strong>Transmit Queue</strong>, the queue for outgoing packets.</p>
<p>(Our Transmit Queue is implemented as a <strong>Packet Buffer Queue</strong>. More about Packet Buffer Queues in the Appendix.)</p>
<p>The <strong>Background Process</strong> receives the Packet Buffer from the Transmit Queue: <a href="https://github.com/lupyuen/lorawan/blob/main/src/lora_node.c#L265-L413"><code>lora_node.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Process a LoRaWAN Packet from the Transmit Queue
static void lora_mac_proc_tx_q_event(struct ble_npl_event *ev) {
  ...
  //  Get the next Packet Buffer from the Transmit Queue.
  //  STAILQ_FIRST returns the first node of the linked list
  //  See https://github.com/lupyuen/lorawan/blob/main/include/node/bsd_queue.h
  mp = STAILQ_FIRST(&amp;g_lora_mac_data.lm_txq.mq_head);
  ...
  //  Call the Medium Access Layer to transmit the Packet Buffer
  rc = LoRaMacMcpsRequest(om, lpkt);</code></pre></div>
<p>(Hang in there‚Ä¶ We‚Äôre almost done!)</p>
<p><strong><code>lora_mac_proc_tx_q_event</code></strong> passes the Packet Buffer to the <strong>Medium Access Control Layer</strong> (yep another hop): <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L3159-L3239"><code>LoRaMac.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Transmit the Packet Buffer
LoRaMacStatus_t LoRaMacMcpsRequest(struct pbuf *om, struct lora_pkt_info *txi) {
  ...
  //  Send the Packet Buffer
  status = Send(&amp;macHdr, txi-&gt;port, om);</code></pre></div>
<p><strong><code>LoRaMacMcpsRequest</code></strong> calls <code>Send</code> to transmit the packet.</p>
<p>We‚Äôve seen the <strong><code>Send</code></strong> function earlier, it‚Ä¶</p>
<ol>
<li>
<p><strong>Transmits the packet</strong> by calling the LoRa Transceiver Driver</p>
</li>
<li>
<p><strong>Opens two Receive Windows</strong> and listens briefly (twice) for incoming packets</p>
</li>
</ol>
<p>Since this is an <strong>Unconfirmed Message</strong>, we don‚Äôt expect an acknowledgement from the LoRaWAN Gateway.</p>
<p>Both Receive Windows will time out, and that‚Äôs perfectly fine.</p>
<p><em>Aha! So we use a Background Task because of the Receive Windows?</em></p>
<p>Yes, the Medium Access Control Layer might be <strong>busy waiting for a Receive Window</strong> to time out before transmitting the next packet.</p>
<p>Our LoRaWAN Driver uses the Background Task and the Transmit Queue to handle the deferred transmission of packets.</p>
<p>(This deferred processing of packets is known as <strong>MCPS: MAC Common Part Sublayer</strong>. <a href="https://stackforce.github.io/LoRaMac-doc/LoRaMac-doc-v4.4.7/index.html">More about this</a>)</p>
<h1 id="build-and-run-the-bl602-lorawan-firmware"><a href="#build-and-run-the-bl602-lorawan-firmware">4 Build and Run the BL602 LoRaWAN Firmware</a></h1>
<p>Let‚Äôs run the LoRaWAN Demo Firmware for BL602 to‚Ä¶</p>
<ol>
<li>
<p>Join a LoRaWAN Network</p>
</li>
<li>
<p>Open a LoRaWAN Application Port</p>
</li>
<li>
<p>Send a LoRaWAN Data Packet</p>
</li>
</ol>
<p>Find out which <strong>LoRa Frequency</strong> we should use for your region‚Ä¶</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>Download the <a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/sdk_app_lorawan">LoRaWAN firmware and driver source code</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Download the master branch of lupyuen&#39;s bl_iot_sdk
git clone --recursive --branch master https://github.com/lupyuen/bl_iot_sdk</code></pre></div>
<p>In the <code>customer_app/sdk_app_lorawan</code> folder, edit <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/Makefile"><code>Makefile</code></a> and find this setting‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CFLAGS += -DCONFIG_LORA_NODE_REGION=1</code></pre></div>
<p>Change ‚Äú<code>1</code>‚Äù to your LoRa Region‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Value</th><th style="text-align: left">Region</th></tr></thead><tbody>
<tr><td style="text-align: left">0</td><td style="text-align: left">No region</td></tr>
<tr><td style="text-align: left">1</td><td style="text-align: left">AS band on 923MHz</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">Australian band on 915MHz</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">Chinese band on 470MHz</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">Chinese band on 779MHz</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left">European band on 433MHz</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left">European band on 868MHz</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left">South Korean band on 920MHz</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left">India band on 865MHz</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left">North American band on 915MHz</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left">North American band on 915MHz with a maximum of 16 channels</td></tr>
</tbody></table>
</div>
<p>Then update the <strong>GPIO Pin Numbers</strong> in‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>components/3rdparty/lora-sx1262/include/sx126x-board.h</code></pre></div>
<p>Below are the GPIO Pin Numbers for the connection shown at the top of this article‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define SX126X_SPI_SDI_PIN       1  //  SPI Serial Data In Pin  (formerly MISO)
#define SX126X_SPI_SDO_PIN       4  //  SPI Serial Data Out Pin (formerly MOSI)
#define SX126X_SPI_CLK_PIN       3  //  SPI Clock Pin
#define SX126X_SPI_CS_PIN       14  //  SPI Chip Select Pin
#define SX126X_SPI_CS_OLD        2  //  Unused SPI Chip Select Pin
#define SX126X_NRESET           17  //  Reset Pin
#define SX126X_DIO1             11  //  DIO1
#define SX126X_BUSY_PIN          0  //  Busy Pin
#define SX126X_DEBUG_CS_PIN     -1  //  Debug Chip Select Pin, mirrors the High / Low State of SX1262 Chip Select Pin. Set to -1 if not needed.</code></pre></div>
<p>Build the Firmware Binary File <code>sdk_app_lorawan.bin</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602

cd bl_iot_sdk/customer_app/sdk_app_lorawan
make

# For WSL: Copy the firmware to /mnt/c/blflash, which refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp build_out/sdk_app_lorawan.bin /mnt/c/blflash</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<h2 id="flash-the-firmware"><a href="#flash-the-firmware">4.1 Flash the firmware</a></h2>
<p>Follow these steps to install <code>blflash</code>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>sdk_app_lorawan.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>sdk_app_lorawan.bin</code> to BL602 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># For Linux:
blflash flash build_out/sdk_app_lorawan.bin \
    --port /dev/ttyUSB0

# For macOS:
blflash flash build_out/sdk_app_lorawan.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

# For Windows: Change COM5 to the BL602 Serial Port
blflash flash c:\blflash\sdk_app_lorawan.bin --port COM5</code></pre></div>
<p>(For WSL: Do this under plain old Windows CMD, not WSL, because blflash needs to access the COM port)</p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h2 id="run-the-firmware"><a href="#run-the-firmware">4.2 Run the firmware</a></h2>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
<h2 id="enter-lorawan-commands"><a href="#enter-lorawan-commands">4.3 Enter LoRaWAN commands</a></h2>
<p>Let‚Äôs enter some commands to join the LoRaWAN Network and transmit a LoRaWAN Data Packet!</p>
<ol>
<li>
<p>Get the following from the LoRaWAN Gateway: <strong>Device EUI, Application EUI and Application Key</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wisgate#lorawan-application"><strong>‚ÄúLoRaWAN Application (ChirpStack)‚Äù</strong></a></li>
</ul>
<p>We shall use them in a while to join the LoRaWAN Network.</p>
</li>
<li>
<p>In the BL602 terminal, press Enter to reveal the command prompt.</p>
</li>
<li>
<p>First we <strong>create the Background Task</strong> that will process outgoing and incoming LoRa Packets.</p>
<p>Enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>create_task</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/lora2#event-queue">(<code>create_task</code> is explained here)</a></p>
</li>
<li>
<p>Then we <strong>initialise our LoRaWAN Driver</strong>. </p>
<p>Enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>init_lorawan</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/lorawan.c#L166-L168">(<code>init_lorawan</code> is defined here)</a></p>
</li>
<li>
<p>Let‚Äôs get ready to join the LoRaWAN Network. Enter the <strong>Device EUI</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_wr_dev_eui 0x4b:0xc1:0x5e:0xe7:0x37:0x7b:0xb1:0x5b</code></pre></div>
<p>In ChirpStack: Copy the Device EUI from <code>Applications ‚Üí app ‚Üí Device EUI</code></p>
</li>
<li>
<p>Enter the <strong>Application EUI</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_wr_app_eui 0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00</code></pre></div>
<p>ChirpStack doesn‚Äôt require an Application EUI, so we set it to zeros.</p>
</li>
<li>
<p>Enter the <strong>Application Key</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_wr_app_key 0xaa:0xff:0xad:0x5c:0x7e:0x87:0xf6:0x4d:0xe3:0xf0:0x87:0x32:0xfc:0x1d:0xd2:0x5d</code></pre></div>
<p>In ChirpStack: Copy the Application Key from <code>Applications ‚Üí app ‚Üí Devices ‚Üí device_otaa_class_a ‚Üí Keys (OTAA) ‚Üí Application Key</code></p>
</li>
<li>
<p>Now we <strong>join the LoRaWAN network</strong>, try up to 3 times‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_join 3</code></pre></div>
<p>This calls the <code>las_cmd_join</code> function that we‚Äôve seen earlier.</p>
</li>
<li>
<p>We <strong>open LoRaWAN Application Port 2</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_app_port open 2</code></pre></div>
<p>This calls the <code>las_cmd_app_port</code> function that we‚Äôve seen earlier.</p>
</li>
<li>
<p>Finally we <strong>send a data packet to LoRaWAN port 2</strong>: 5 bytes of zeros, unconfirmed (with no acknowledgement)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>las_app_tx 2 5 0</code></pre></div>
<p>This calls the <code>las_cmd_app_tx</code> function that we‚Äôve seen earlier.</p>
<p><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/README.md#output-log"><strong>See the output log</strong></a></p>
</li>
</ol>
<p>To see the available commands, enter <code>help</code>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-help.png" alt="LoRaWAN Firmware Commands" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L343-L372">(The commands are defined in <code>demo.c</code>)</a></p>
<p><a href="https://mynewt.apache.org/latest/tutorials/lora/lorawanapp.html">(The LoRaWAN commands were ported to BL602 from Apache Mynewt OS)</a></p>
<h1 id="view-received-lorawan-packets"><a href="#view-received-lorawan-packets">5 View Received LoRaWAN Packets</a></h1>
<p><em>How will we know if our LoRaWAN Gateway has received the data packet from BL602?</em></p>
<p>If we‚Äôre running <strong>ChirpStack on our LoRaWAN Gateway</strong>, here‚Äôs how we check‚Ä¶</p>
<ol>
<li>
<p>In ChirpStack, click <strong><code>Applications ‚Üí app ‚Üí device_otaa_class_a ‚Üí Device Data</code></strong></p>
</li>
<li>
<p>Restart BL602.</p>
<p>Run the LoRaWAN Commands from the previous section.</p>
</li>
<li>
<p>The <strong>Join Network Request</strong> appears in ChirpStack‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-join.png" alt="Join Network Request" /></p>
</li>
<li>
<p>Followed by the <strong>Data Packet</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-send.png" alt="Send Data Packet" /></p>
<p><strong><code>DecodedDataHex</code></strong> shows 5 bytes of zero, which is what we sent‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-joinsend.png" alt="WisGate receives LoRaWAN Data Packet from BL602" /></p>
</li>
<li>
<p>We may now configure ChirpStack to do something useful with the received packets, like publish them over MQTT, HTTP, ‚Ä¶</p>
<p>Click this link‚Ä¶</p>
<ul>
<li><a href="https://www.chirpstack.io/application-server/"><strong>ChirpStack Application Server</strong></a></li>
</ul>
<p>Then click the <strong>Menu</strong> (top left) and <strong>Integrations</strong></p>
</li>
</ol>
<h1 id="troubleshoot-lorawan"><a href="#troubleshoot-lorawan">6 Troubleshoot LoRaWAN</a></h1>
<p>If our LoRaWAN Gateway didn‚Äôt receive the data packet from BL602, here are some troubleshooting tips‚Ä¶</p>
<ol>
<li>
<p><strong>Check the LoRa Transceiver</strong></p>
<p>Follow the steps here to check our LoRa Transceiver‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#troubleshoot-lora"><strong>‚ÄúTroubleshoot LoRa‚Äù</strong></a></li>
</ul>
<p>For RFM90 / SX1262, the SPI registers should look like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-spi.jpg" alt="SPI Registers for RFM90 / SX1262" /></p>
</li>
<li>
<p><strong>Check the LoRaWAN Gateway logs</strong></p>
<p>For ChirpStack, follow the steps here to check the LoRaWAN Gateway logs, also to inspect the raw packets‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wisgate#troubleshoot-lorawan"><strong>‚ÄúTroubleshoot LoRaWAN‚Äù</strong></a></li>
</ul>
</li>
<li>
<p><strong>Check the LoRa Sync Word</strong></p>
<p>Typical LoRaWAN Networks will use the <strong>Public LoRa Sync Word <code>0x3444</code></strong>.</p>
<p>(Instead of the Private Sync Word <code>0x1424</code>)</p>
<p>This is defined in the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/Makefile#L66-L69"><code>Makefile</code></a> as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CFLAGS += -DLORA_NODE_PUBLIC_NWK=1</code></pre></div>
<p>The LoRaWAN Gateway will not respond to our packets if we transmit the wrong Sync Word.</p>
<p>See the Appendix for details.</p>
</li>
<li>
<p><strong>Sniff the packets with Software Defined Radio</strong></p>
<p>A <strong>Software Defined Radio</strong> may be helpful for sniffing the LoRaWAN packets to make sure that they look right and are centered at the right frequency‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wisgate#visualise-lorawan-with-software-defined-radio"><strong>‚ÄúVisualise LoRaWAN with Software Defined Radio‚Äù</strong></a></li>
</ul>
<p>Here‚Äôs the <strong>Join Network Request</strong> transmitted by BL602 with RFM90‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr1.png" alt="Join Request" /></p>
<p>And here‚Äôs the <strong>Join Network Response</strong> returned by our WisGate D4H LoRaWAN Gateway‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr2.png" alt="Join Response" /></p>
<p><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></p>
<p>(Yep BL602 + RFM90 seems to be transmitting packets with lower power than our WisGate LoRaWAN Gateway. More about this in the Appendix.)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lorawan-gateway.jpg" alt="Pine64 LoRa Gateway (the white box) and RAKwireless WisGate D4H LoRaWAN Gateway (the black box)" /></p>
<p><em>Pine64 LoRa Gateway (the white box) and RAKwireless WisGate D4H LoRaWAN Gateway (the black box)</em></p>
<h1 id="whats-next"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>Today we have completed <strong>Levels One and Two</strong> of our epic quest for the <a href="https://lupyuen.github.io/articles/lora#lora-vs-lorawan"><strong>Three Levels of LoRa</strong></a>!</p>
<ol>
<li>
<p>We have a <strong>BL602 LoRa Transceiver Driver</strong> (RFM90 / SX1262) that can transmit and receive LoRa Packets</p>
</li>
<li>
<p>We have a <strong>BL602 LoRaWAN Driver</strong> that can join a LoRaWAN Network and transmit LoRaWAN Data Packets</p>
</li>
<li>
<p>Soon we shall progress to <strong>LoRa Level Three</strong>‚Ä¶</p>
<p>Join BL602 to <strong>The Things Network</strong>!</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan2"><strong>‚ÄúLoRaWAN on PineDio Stack BL604 RISC-V Board‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/ttn"><strong>‚ÄúThe Things Network on PineDio Stack BL604 RISC-V Board‚Äù</strong></a></p>
</li>
</ul>
</li>
<li>
<p>And eventually we shall build <strong>BL602 Sensor Devices for The Things Network</strong>!</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tsen"><strong>‚ÄúInternal Temperature Sensor on BL602‚Äù</strong></a></li>
</ul>
</li>
</ol>
<p>But first we shall‚Ä¶</p>
<ol>
<li>
<p>Install ChirpStack on our pre-production <strong>Pine64 LoRa Gateway</strong>‚Ä¶</p>
<ul>
<li><a href="https://www.pine64.org/2021/05/06/lets-make-mirakles-happen/"><strong>‚ÄúLet‚Äôs make MiRAKles happen‚Äù</strong></a></li>
</ul>
<p>And test it with our BL602 LoRaWAN Driver.</p>
<p>(Maybe we‚Äôll quickly benchmark Pine64 LoRa Gateway with <a href="https://docs.rakwireless.com/Product-Categories/WisGate/RAK7248/Datasheet/">RAKwireless WisGate D4H</a>‚Ä¶ Both are based on LoRa Concentators by RAKwireless!)</p>
</li>
<li>
<p>Take a short diversion to explore <strong>Lisp and Blockly (Scratch)</strong> on BL602‚Ä¶</p>
<ul>
<li>
<p><a href="https://youtu.be/LNkmUIv7ZZc"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://twitter.com/MisterTechBlog/status/1389783215347429382"><strong>Follow the Twitter Thread</strong></a></p>
</li>
</ul>
<p>Because it shows lots of potential for <strong>IoT Education</strong>.</p>
<p>(My #1 passion)</p>
</li>
</ol>
<p>We have come a loooong way since I first <a href="https://github.com/lupyuen/LoRaArduino"><strong>experimented with LoRa in 2016</strong></a>‚Ä¶</p>
<ul>
<li>
<p><strong>Modern Transceivers and Gateways</strong>: Pine64 RFM90, Pine64 LoRa Gateway</p>
</li>
<li>
<p><strong>Mature Networks</strong>: LoRaWAN, The Things Network</p>
</li>
<li>
<p><strong>Better Drivers</strong>: Thanks to Apache Mynewt OS!</p>
</li>
<li>
<p><strong>Powerful Microcontrollers</strong>: Arduino Uno vs RISC-V BL602</p>
</li>
<li>
<p><strong>Awesome Tools</strong>: RAKwireless WisBlock, Airspy SDR, RF Explorer</p>
</li>
</ul>
<p>Now is the <strong>right time to build LoRa gadgets.</strong> Stay tuned for more LoRa and LoRaWAN Adventures!</p>
<p>Meanwhile there‚Äôs plenty more code in the <a href="https://github.com/bouffalolab/bl_iot_sdk"><strong>BL602 IoT SDK</strong></a> to be deciphered and documented: <strong>ADC, DAC, WiFi, Bluetooth LE,</strong> ‚Ä¶</p>
<p><a href="https://wiki.pine64.org/wiki/Nutcracker"><strong>Come Join Us‚Ä¶ Make BL602 Better!</strong></a></p>
<p>üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/n9q99g/pinecone_bl602_talks_lorawan/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lorawan.md"><code>lupyuen.github.io/src/lorawan.md</code></a></p>
<h1 id="notes"><a href="#notes">8 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of the Twitter Threads‚Ä¶</p>
<ul>
<li>
<p><a href="https://twitter.com/MisterTechBlog/status/1381870711124369413"><strong>RFM90 LoRa Driver for BL602</strong></a></p>
</li>
<li>
<p><a href="https://twitter.com/MisterTechBlog/status/1379926160377851910"><strong>LoRaWAN Driver for BL602</strong></a></p>
</li>
<li>
<p><a href="https://twitter.com/MisterTechBlog/status/1370224529222500352?s=20"><strong>LoRaWAN Specifications</strong></a></p>
</li>
</ul>
</li>
</ol>
<h1 id="appendix-lora-transmit-power"><a href="#appendix-lora-transmit-power">9 Appendix: LoRa Transmit Power</a></h1>
<p><a href="https://lupyuen.github.io/articles/lorawan2"><strong>UPDATE:</strong> The same code produces the right Transmit Power on PineDio Stack BL604 with SX1262. So the Low Transmit Power problem is probably specific to our Pine64 RFM90 LoRa Module</a></p>
<p>Our PineCone BL602 connected to Pine64 RFM90 LoRa Module seems to be <strong>transmitting with lower power</strong> compared with other devices‚Ä¶ Perhaps someone could help to fix this issue. (Hardware or Firmware?)</p>
<p>Here‚Äôs <strong>RFM90 (left)</strong> compared with <strong>WisGate D4H LoRaWAN Gateway (right)</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr3.jpg" alt="RFM90 vs WisGate" /></p>
<p><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></p>
<p>(Recorded by Airspy R2 SDR with CubicSDR. The SDR was placed near RFM90.)</p>
<p>And here‚Äôs <strong>RFM90 (left)</strong> compared with <strong>WisBlock RAK4631</strong> (which is also based on Semtech SX1262)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr4.jpg" alt="RFM90 vs WisBlock" /></p>
<h2 id="dc-dc-vs-ldo"><a href="#dc-dc-vs-ldo">9.1 DC-DC vs LDO</a></h2>
<p>I might have connected the RFM90 pins incorrectly. The Semtech docs refer to <strong>DC-DC vs LDO Regulator Options</strong>, which I don‚Äôt quite understand‚Ä¶</p>
<ul>
<li>
<p><a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HT76/7Nka9W5WgugoZe.xwIHJy6ebj1hW8UJ.USO_Pt2CLLo"><strong>Semtech SX1262 Datasheet</strong></a></p>
</li>
<li>
<p><a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HSSf/GT2IXjK2nH8bw6JdEXfFBd.HmFATeLOpL402mZwpSho"><strong>Application Note: Reference Design Explanation</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lorawan-ldo.png" alt="SX1262: DC-DC vs LDO" /></p>
<p>Our RFM90 / SX1262 LoRa Transceiver Driver is currently set to <strong>DC-DC Power Regulator Mode</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L535-L543"><code>radio.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  TODO: Declare the power regulation used to power the device
//  This command allows the user to specify if DC-DC or LDO is used for power regulation.
//  Using only LDO implies that the Rx or Tx current is doubled

// #warning SX126x is set to LDO power regulator mode (instead of DC-DC)
// SX126xSetRegulatorMode( USE_LDO );   //  Use LDO

#warning SX126x is set to DC-DC power regulator mode (instead of LDO)
SX126xSetRegulatorMode( USE_DCDC );  //  Use DC-DC</code></pre></div>
<p><a href="https://twitter.com/MisterTechBlog/status/1382510807116746753">(Check out this discussion on Twitter)</a></p>
<h2 id="transmit-power"><a href="#transmit-power">9.2 Transmit Power</a></h2>
<p>I have increased the <strong>Transmit Power to max 22 dBm</strong>. Also I have increased the <strong>Power Amplifier Ramp Up Time</strong> from 200 to the max 3,400 microseconds: <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L546-L547"><code>radio.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Previously: SX126xSetTxParams( 0, RADIO_RAMP_200_US );
SX126xSetTxParams( 22, RADIO_RAMP_3400_US );</code></pre></div>
<p>According to the log, the Power Amplifier seems to be enabled at the max settings: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/README.md#output-log"><code>README.md</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>SX126xSetPaConfig: 
paDutyCycle=4, 
hpMax=7, 
deviceSel=0, 
paLut=1 </code></pre></div><h2 id="over-current-protection"><a href="#over-current-protection">9.3 Over Current Protection</a></h2>
<p>I copied this <strong>Over Current Protection</strong> setting from WisBlock RAK4631 (which is also based on Semtech SX1262): <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x.c#L570-L571"><code>sx126x.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  TODO: Set the current max value in the over current protection.
//  From SX126x-Arduino/src/radio/sx126x/sx126x.cpp
SX126xWriteRegister(REG_OCP, 0x38); // current max 160mA for the whole device</code></pre></div>
<p>None of these changes seem to increase the RFM90 Transmit Power.</p>
<p>Would be great if you could suggest a fix for this üôè</p>
<p>(Or perhaps the Transmit Power isn‚Äôt an issue?)</p>
<h1 id="appendix-lora-sync-word"><a href="#appendix-lora-sync-word">10 Appendix: LoRa Sync Word</a></h1>
<p>Typical LoRaWAN Networks will use the <strong>Public LoRa Sync Word <code>0x3444</code></strong>.</p>
<p>(Instead of the Private Sync Word <code>0x1424</code>)</p>
<p>The LoRaWAN Gateway will <strong>not respond to our packets if we transmit the wrong Sync Word</strong>.</p>
<p><strong><code>LORA_NODE_PUBLIC_NWK</code></strong> should be set to <strong><code>1</code></strong> in the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/Makefile#L66-L69"><code>Makefile</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CFLAGS += -DLORA_NODE_PUBLIC_NWK=1</code></pre></div>
<p><img src="https://lupyuen.github.io/images/lorawan-syncword.png" alt="LORA_NODE_PUBLIC_NWK in Makefile" /></p>
<p><code>LORA_NODE_PUBLIC_NWK</code> sets the Sync Word in <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L2581-L2587"><code>LoRaMac.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Syncword for Private LoRa networks
#define LORA_MAC_PRIVATE_SYNCWORD                   0x1424

//  Syncword for Public LoRa networks
#define LORA_MAC_PUBLIC_SYNCWORD                    0x3444

//  Init the LoRaWAN Medium Access Control Layer
LoRaMacStatus_t LoRaMacInitialization(LoRaMacCallback_t *callbacks, LoRaMacRegion_t region) {
    ...
#if (LORA_NODE_PUBLIC_NWK)
    LM_F_IS_PUBLIC_NWK() = 1;
    Radio.SetPublicNetwork(true);
#else
    LM_F_IS_PUBLIC_NWK() = 0;
    Radio.SetPublicNetwork(false);
#endif</code></pre></div>
<p>It took me a while to troubleshoot this problem: ‚ÄúWhy is the LoRaWAN Gateway ignoring my packets?‚Äù</p>
<p><img src="https://lupyuen.github.io/images/lorawan-joinfail.png" alt="Join Request Fail" /></p>
<p>Till I got inspired by this quote from the <a href="https://github.com/Lora-net/sx1302_hal/tree/master/libloragw#61-spreading-factor-sf5--sf6">Semtech SX1302 LoRa Concentrator HAL User Manual</a></p>
<p><img src="https://lupyuen.github.io/images/lorawan-syncword2.jpg" alt="LoRa Concentrator HAL User Manual" /></p>
<h1 id="appendix-lora-carrier-sensing"><a href="#appendix-lora-carrier-sensing">11 Appendix: LoRa Carrier Sensing</a></h1>
<p>While troubleshooting the BL602 LoRaWAN Driver I compared <strong>3 implementations of the LoRaWAN Stack</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/apache/mynewt-core/tree/master/net/lora/node"><strong>Apache Mynewt LoRaWAN Stack</strong></a></p>
<p><a href="https://github.com/apache/mynewt-core/blob/master/net/lora/node/src/mac/LoRaMac.c#L15"><strong>(Dated 2017)</strong></a> This is the version that I ported to BL602.</p>
</li>
<li>
<p><a href="https://github.com/beegee-tokyo/SX126x-Arduino/tree/master/src/mac"><strong>SX126x-Arduino LoRaWAN Stack</strong></a></p>
<p><a href="https://github.com/beegee-tokyo/SX126x-Arduino/blob/master/src/mac/LoRaMac.cpp#L7"><strong>(Dated 2013)</strong></a> This is the Arduino version used by RAKwireless WisBlock RAK4631.</p>
<p>It looks similar to the Mynewt version.</p>
</li>
<li>
<p><a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/mac"><strong>Semtech Reference Implementation of LoRaWAN Stack</strong></a></p>
<p><a href="https://github.com/Lora-net/LoRaMac-node/commits/master/src/mac/LoRaMac.c"><strong>(Dated 2021)</strong></a> This is official, latest version of the LoRaWAN Stack.</p>
<p>However it looks totally different from the other two stacks.</p>
<p>(Why didn‚Äôt I port this stack to BL602? Because I wasn‚Äôt sure if it would run on FreeRTOS without Event Queues and Background Tasks.)</p>
</li>
</ol>
<p>When comparing the 3 stacks I discovered that they implement <strong>LoRa Carrier Sensing</strong> differently.</p>
<p><em>What is LoRa Carrier Sensing?</em></p>
<p>In some LoRa Regions (Japan and South Korea), devices are required (by local regulation) to <strong>sense whether the Radio Channel is in use before transmitting</strong>.</p>
<p>Here‚Äôs the Carrier Sensing logic from the Mynewt LoRaWAN Stack: <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/region/RegionAS923.c#L978-L1095"><code>RegionAS923.c</code></a></p>
<p><img src="https://lupyuen.github.io/images/lorawan-carrier2.png" alt="LoRa Carrier Sensing" /></p>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/region/RegionAS923.c#L911-L935">(Compare this with Semtech‚Äôs Reference Implementation)</a></p>
<p><a href="https://github.com/beegee-tokyo/SX126x-Arduino/blob/master/src/mac/region/RegionAS923.cpp#L979-L996">(SX126x-Arduino skips Carrier Sensing for Japan)</a></p>
<p><em>But you‚Äôre in Sunny Singapore, no?</em></p>
<p>Yes, but Mynewt‚Äôs version of the LoRaWAN Stack (from 2017) applies Carrier Sensing across the <strong>entire LoRa AS923 Region</strong>, which includes Singapore‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-carrier.png" alt="LoRa Carrier Sensing" /></p>
<p>Unfortunately the Carrier Sensing code doesn‚Äôt work, so <strong>Carrier Sensing has been disabled in the BL602 LoRaWAN Driver</strong>. <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/region/RegionAS923.c#L1026-L1029">(See this)</a></p>
<p>(My apologies to BL602 Fans in Japan and South Korea, we will have to fix this üôè)</p>
<p>After disabling the Carrier Sensing I hit a RISC-V Exception‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-stack.png" alt="Carrier Sensing Stack Trace" /></p>
<p>Which I traced (via the RISC-V Disassembly) to a Null Pointer problem in <a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/LoRaMac.c#L2379-L2426"><code>LoRaMac.c</code></a> ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-nullpointer.png" alt="Null pointer exception" /></p>
<p><em>Anything else we should note?</em></p>
<p>The <strong>LoRa Region Settings seem to have major differences</strong> across the 3 LoRaWAN Stacks. We will have to patch Semtech‚Äôs latest version into BL602.</p>
<p>Check out the <strong>LoRa Region Settings for AS923</strong> across the 3 LoRaWAN Stacks‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/mac/region/RegionAS923.h"><strong>BL602 LoRaWAN Stack: AS923</strong></a></p>
</li>
<li>
<p><a href="https://github.com/beegee-tokyo/SX126x-Arduino/blob/master/src/mac/region/RegionAS923.h"><strong>SX126x-Arduino: AS923</strong></a></p>
</li>
<li>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/region/RegionAS923.h"><strong>Semtech Reference Implementation: AS923</strong></a></p>
</li>
</ol>
<h1 id="appendix-packet-buffer-and-queue"><a href="#appendix-packet-buffer-and-queue">12 Appendix: Packet Buffer and Queue</a></h1>
<p>The LoRaWAN Driver from Apache Mynewt OS uses <strong>Mbufs and Mbuf Queues</strong> to manage packets efficiently. <a href="https://mynewt.apache.org/latest/os/core_os/mbuf/mbuf.html">(More about this)</a></p>
<p>Here‚Äôs how we ported Mbufs and Mbuf Queues to BL602.</p>
<h2 id="packet-buffer"><a href="#packet-buffer">12.1 Packet Buffer</a></h2>
<p>Mbufs are not available on BL602, but we have something similar: <a href="https://www.nongnu.org/lwip/2_0_x/group__pbuf.html"><strong><code>pbuf</code> Packet Buffer</strong> from Lightweight IP Stack (LWIP)</a></p>
<p>Stored inside a <code>pbuf</code> Packet Buffer are‚Ä¶</p>
<ol>
<li>
<p><strong>Packet Header</strong>: Variable size, up to a limit (max 182 bytes)</p>
</li>
<li>
<p><strong>Packet Payload</strong>: Fixed size</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lorawan-pbuf1.png" alt="pbuf Packet Buffer" /></p>
<p>Here‚Äôs how we fetch the LoRaWAN Packet Header from a LoRaWAN Packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Get the LoRaWAN Packet Header
header = get_pbuf_header(
    pb,                           //  LoRaWAN Packet Buffer
    sizeof(struct lora_pkt_info)  //  Size of LoRaWAN Packet Header
);</code></pre></div>
<p><code>pbuf</code> Packet Buffers have an unusual <strong>Sliding Payload Pointer</strong> for extracting the header. </p>
<p>Here‚Äôs how we implement <code>get_pbuf_header</code> in <a href="https://github.com/lupyuen/lorawan/blob/main/src/pbuf_queue.c#L165-L197"><code>pbuf_queue.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Return the pbuf Packet Buffer header
void *
get_pbuf_header(
    struct pbuf *buf,    //  pbuf Packet Buffer
    size_t header_size)  //  Size of header
{
    assert(buf != NULL);
    assert(header_size &gt; 0);

    //  Warning: This code mutates the pbuf payload pointer, so we need a critical section
    //  Enter critical section
    OS_ENTER_CRITICAL(pbuf_header_mutex);

    //  Slide the pbuf payload pointer BACKWARD
    //  to locate the header.
    u8_t rc1 = pbuf_add_header(buf, header_size);

    //  Payload now points to the header
    void *header = buf-&gt;payload;

    //  Slide the pbuf payload pointer FORWARD
    //  to locate the payload.
    u8_t rc2 = pbuf_remove_header(buf, header_size);

    //  Exit critical section
    OS_EXIT_CRITICAL(pbuf_header_mutex);

    //  Check for errors
    assert(rc1 == 0);
    assert(rc2 == 0);
    assert(header != NULL);
    return header;
}</code></pre></div>
<p><strong><code>pbuf_add_header</code></strong> comes from the Lightweight IP Library. It slides the <code>payload</code> pointer backwards to point at the requested header‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-pbuf2.png" alt="pbuf Packet Buffer after sliding the payload pointer" /></p>
<p>(<code>pbuf_add_header</code> returns a non-zero error code if there‚Äôs isn‚Äôt sufficient space for the header)</p>
<p>Because this code <strong>mutates the Payload Pointer</strong>, we need to be extra careful when extracting the header.</p>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/pbuf_queue.c#L27-L30">(Note: Critical Sections are needed for <code>pbuf_add_header</code> to work correctly during multitasking‚Ä¶ But Critical Sections have not been implemented yet)</a></p>
<h2 id="packet-buffer-queue"><a href="#packet-buffer-queue">12.2 Packet Buffer Queue</a></h2>
<p>Mynewt‚Äôs LoRaWAN Driver uses <a href="https://mynewt.apache.org/latest/os/core_os/mbuf/mbuf.html#mqueue"><strong>Mqueues</strong></a> to enqueue packets for processing.</p>
<p>The Lightweight IP Stack doesn‚Äôt have the equivalent of Mqueues, so we build our own <strong>Packet Buffer Queues</strong>.</p>
<p>A <strong><code>pbuf_queue</code></strong> Packet Buffer Queue is a <strong>First-In First-Out List of Packet Buffers</strong>. It supports these operations‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/lorawan/blob/main/src/pbuf_queue.c#L210-L322"><code>pbuf_queue.c</code></a> </p>
<div class="example-wrap"><pre class="language-c"><code>//  Initializes a pbuf_queue.  A pbuf_queue is a queue of pbufs that ties to a
//  particular task&#39;s event queue.  pbuf_queues form a helper API around a common
//  paradigm: wait on an event queue until at least one packet is available,
//  then process a queue of packets.
int pbuf_queue_init(struct pbuf_queue *mq, ble_npl_event_fn *ev_cb, void *arg, uint16_t header_len);

//  Remove and return a single pbuf from the pbuf queue.  Does not block.
struct pbuf *pbuf_queue_get(struct pbuf_queue *mq);

//  Adds a packet (i.e. packet header pbuf) to a pbuf_queue. The event associated
//  with the pbuf_queue gets posted to the specified eventq.
int pbuf_queue_put(struct pbuf_queue *mq, struct ble_npl_eventq *evq, struct pbuf *m);</code></pre></div>
<p>To build a <strong>Linked List</strong> of Packet Buffers, we insert a <strong><code>pbuf_list</code> Header</strong> just before the LoRaWAN Header in the LoRaWAN Packet‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-pbuf3.png" alt="pbuf Packet Buffer with pbuf_list header" /></p>
<p>(Yes the Lightweight IP Stack allows multiple headers per Packet Buffer, because of the Sliding Payload Pointer)</p>
<p>The <code>pbuf_list</code> Header points to the next Packet Buffer in the <strong>Singly-Linked List</strong>‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/lorawan/blob/main/include/node/pbuf_queue.h#L29-L58"><code>pbuf_queue.h</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Structure representing a list of pbufs inside a pbuf_queue.
//  pbuf_list is stored in the header of the pbuf, before the LoRaWAN Header.
struct pbuf_list {
    //  Header length
    u16_t header_len;
    //  Payload length
    u16_t payload_len;
    //  Pointer to pbuf
    struct pbuf *pb;
    //  Pointer to header in pbuf
    struct pbuf *header;
    //  Pointer to payload in pbuf
    struct pbuf *payload;
    //  Pointer to next node in the pbuf_list
    STAILQ_ENTRY(pbuf_list) next;
    //  STAILQ_ENTRY is defined in https://github.com/lupyuen/lorawan/blob/main/include/node/bsd_queue.h
};</code></pre></div>
<p>The <strong><code>next</code></strong> field lets us link up the Packet Buffers like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-pbuf4.png" alt="pbuf Packet Buffer linked via pbuf_list header" /></p>
<p>Here‚Äôs how we <strong>allocate a Packet Buffer</strong> and initialise both headers: <code>pbuf_list</code> Header and LoRaWAN Header‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/lorawan/blob/main/src/pbuf_queue.c#L38-L98"><code>pbuf_queue.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Allocate a pbuf for LoRaWAN transmission. This returns a pbuf with 
/// pbuf_list Header, LoRaWAN Header and LoRaWAN Payload.
struct pbuf *
alloc_pbuf(
    uint16_t header_len,   //  Header length of packet (LoRaWAN Header only, excluding pbuf_list header)
    uint16_t payload_len)  //  Payload length of packet, excluding header
{
    //  Init LWIP Buffer Pool
    static bool lwip_started = false;
    if (!lwip_started) {
        lwip_started = true;
        lwip_init();
    }
    
    //  Allocate a pbuf Packet Buffer with sufficient header space for pbuf_list header and LoRaWAN header
    struct pbuf *buf = pbuf_alloc(
        PBUF_TRANSPORT,   //  Buffer will include 182-byte transport header
        payload_len,      //  Payload size
        PBUF_RAM          //  Allocate as a single block of RAM
    );                    //  TODO: Switch to pooled memory (PBUF_POOL), which is more efficient
    assert(buf != NULL);

    //  Erase packet
    memset(buf-&gt;payload, 0, payload_len);

    //  Packet Header will contain two structs: pbuf_list Header, followed by LoRaWAN Header
    size_t combined_header_len = sizeof(struct pbuf_list) + header_len;

    //  Get pointer to pbuf_list Header and LoRaWAN Header
    void *combined_header = get_pbuf_header(buf, combined_header_len);
    void *header          = get_pbuf_header(buf, header_len);
    assert(combined_header != NULL);
    assert(header != NULL);

    //  Erase pbuf_list Header and LoRaWAN Header
    memset(combined_header, 0, combined_header_len);

    //  Init pbuf_list header at the start of the combined header
    struct pbuf_list *list = combined_header;
    list-&gt;header_len  = header_len;
    list-&gt;payload_len = payload_len;
    list-&gt;header      = header;
    list-&gt;payload     = buf-&gt;payload;
    list-&gt;pb          = buf;

    //  Verify integrity of pbuf_list: pbuf_list Header is followed by LoRaWAN Header and LoRaWAN Payload
    assert((uint32_t) list + sizeof(struct pbuf_list) + list-&gt;header_len == (uint32_t) list-&gt;payload);
    assert((uint32_t) list + sizeof(struct pbuf_list) == (uint32_t) list-&gt;header);
    assert((uint32_t) list-&gt;header + list-&gt;header_len == (uint32_t) list-&gt;payload);

    return buf;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lorawan/blob/main/src/pbuf_queue.c#L27-L30">(Note: Critical Sections are needed for <code>pbuf_queue_get</code> and <code>pbuf_queue_put</code> to work correctly during multitasking‚Ä¶ But Critical Sections have not been implemented yet)</a></p>
<h1 id="appendix-bl602-spi-functions"><a href="#appendix-bl602-spi-functions">13 Appendix: BL602 SPI Functions</a></h1>
<p>Here‚Äôs how our LoRa Transceiver Driver <strong>initialises the BL602 SPI Port</strong> by calling the <strong>BL602 SPI Hardware Abstraction Layer (HAL)</strong>‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x-board.c#L166-L197"><code>sx126x-board.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// SPI Device Instance
spi_dev_t spi_device;

/// Initialise GPIO Pins and SPI Port. Called by SX126xIoIrqInit.
/// Note: This is different from the Reference Implementation,
/// which initialises the GPIO Pins and SPI Port at startup.
void SX126xIoInit( void ) {
    GpioInitOutput( SX126X_SPI_CS_PIN, 1 );
    GpioInitInput( SX126X_BUSY_PIN, 0, 0 );
    GpioInitInput( SX126X_DIO1, 0, 0 );

    //  Configure the SPI Port
    int rc = spi_init(
        &amp;spi_device,     //  SPI Device
        SX126X_SPI_IDX,  //  SPI Port
        0,               //  SPI Mode: 0 for Controller
        //  TODO: Due to a quirk in BL602 SPI, we must set
        //  SPI Polarity-Phase to 1 (CPOL=0, CPHA=1).
        //  But actually Polarity-Phase for SX126X should be 0 (CPOL=0, CPHA=0). 
        1,                    //  SPI Polarity-Phase
        SX126X_SPI_BAUDRATE,  //  SPI Frequency
        2,                    //  Transmit DMA Channel
        3,                    //  Receive DMA Channel
        SX126X_SPI_CLK_PIN,   //  SPI Clock Pin 
        SX126X_SPI_CS_OLD,    //  Unused SPI Chip Select Pin
        SX126X_SPI_SDI_PIN,   //  SPI Serial Data In Pin  (formerly MISO)
        SX126X_SPI_SDO_PIN    //  SPI Serial Data Out Pin (formerly MOSI)
    );
    assert(rc == 0);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/master/include/sx126x-board.h#L36-L61">(The pins are defined in <code>sx126x-board.h</code>)</a></p>
<p>The BL602 SPI HAL is explained in the article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi"><strong>‚ÄúPineCone BL602 talks SPI too!‚Äù</strong></a></li>
</ul>
<p>Note that the <strong>SPI Polarity-Phase</strong> has been modified. <a href="https://lupyuen.github.io/articles/spi#spi-phase-looks-sus">(More about this)</a></p>
<p>Here‚Äôs how our LoRa Transceiver Driver calls the BL602 SPI HAL to <strong>transmit and receive a single byte</strong> to RFM90 / SX1262‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x-board.c#L120-L164"><code>sx126x-board.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// SPI Transmit Buffer (1 byte)
static uint8_t spi_tx_buf[1];

/// SPI Receive Buffer (1 byte)
static uint8_t spi_rx_buf[1];

/// Blocking call to send a value on the SPI. Returns the value received from the SPI Peripheral.
/// Assume that we are sending and receiving 8-bit values on SPI.
/// Assume Chip Select Pin has already been set to Low by caller.
/// TODO: We should combine multiple SPI DMA Requests, instead of handling one byte at a time
uint16_t SpiInOut(int spi_num, uint16_t val) {
    //  Populate the transmit buffer
    spi_tx_buf[0] = val;

    //  Clear the receive buffer
    memset(&amp;spi_rx_buf, 0, sizeof(spi_rx_buf));

    //  Prepare SPI Transfer
    static spi_ioc_transfer_t transfer;
    memset(&amp;transfer, 0, sizeof(transfer));    
    transfer.tx_buf = (uint32_t) spi_tx_buf;  //  Transmit Buffer
    transfer.rx_buf = (uint32_t) spi_rx_buf;  //  Receive Buffer
    transfer.len    = 1;                      //  How many bytes

    //  Assume Chip Select Pin has already been set to Low by caller

    //  Execute the SPI Transfer with the DMA Controller
    int rc = hal_spi_transfer(
        &amp;spi_device,  //  SPI Device
        &amp;transfer,    //  SPI Transfers
        1             //  How many transfers (Number of requests, not bytes)
    );
    assert(rc == 0);

    //  Assume Chip Select Pin will be set to High by caller

    //  Return the received byte
    return spi_rx_buf[0];
}</code></pre></div><h1 id="appendix-bl602-gpio-interrupts"><a href="#appendix-bl602-gpio-interrupts">14 Appendix: BL602 GPIO Interrupts</a></h1>
<p>The LoRa Transceiver (RFM90 / SX1262) triggers a <strong>GPIO Interrupt</strong> on BL602 when it receives a LoRa Packet‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-interrupt.png" alt="GPIO Interrupt Handler" /></p>
<p>Our LoRa Transceiver Driver handles this GPIO Interrupt by registering a <strong>GPIO Interrupt Handler</strong> like so: <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/radio.c#L523-L532"><code>radio.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Init the LoRa Transceiver
void RadioInit( RadioEvents_t *events ) {
    ...
    SX126xInit( RadioOnDioIrq );</code></pre></div>
<p><strong><code>RadioOnDioIrq</code></strong> is the function that will handle the GPIO Interrupt. <a href="https://lupyuen.github.io/articles/usb#radioondioirq">(See this)</a></p>
<p><strong><code>SX126xInit</code></strong> is defined in <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x.c#L112-L131"><code>sx126x.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Init the SX1262 LoRa Transceiver
void SX126xInit( DioIrqHandler dioIrq ) {
    ...
    //  dioIrq is the GPIO Handler Function RadioOnDioIrq
    SX126xIoIrqInit( dioIrq );</code></pre></div>
<p>We call <strong><code>SX126xIoIrqInit</code></strong> to set <code>RadioOnDioIrq</code> as the GPIO Handler Function: <a href="https://github.com/lupyuen/lora-sx1262/blob/master/src/sx126x-board.c#L199-L232"><code>sx126x-board.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Initialise GPIO Pins and SPI Port. Register GPIO Interrupt Handler for DIO1.
/// Based on hal_button_register_handler_with_dts in https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c
/// Note: This is different from the Reference Implementation,
/// which initialises the GPIO Pins and SPI Port at startup.
void SX126xIoIrqInit( DioIrqHandler dioIrq ) {
    //  Initialise GPIO Pins and SPI Port.
    //  Note: This is different from the Reference Implementation,
    //  which initialises the GPIO Pins and SPI Port at startup.
    SX126xIoInit();

    assert(SX126X_DIO1 &gt;= 0);
    assert(dioIrq != NULL);
    int rc = register_gpio_handler(   //  Register GPIO Handler...
        SX126X_DIO1,                  //  GPIO Pin Number
        dioIrq,                       //  GPIO Handler Function: RadioOnDioIrq
        GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
        GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High 
        0,                            //  No pullup
        0                             //  No pulldown
    );
    assert(rc == 0);

    //  Register Common Interrupt Handler for GPIO Interrupt
    bl_irq_register_with_ctx(
        GPIO_INT0_IRQn,         //  GPIO Interrupt
        handle_gpio_interrupt,  //  Interrupt Handler
        NULL                    //  Argument for Interrupt Handler
    );

    //  Enable GPIO Interrupt
    bl_irq_enable(GPIO_INT0_IRQn);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/usb#radioondioirq">(<code>RadioOnDioIrq</code> is explained here)</a></p>
<p>This code is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#bl602-gpio-interrupts"><strong>‚ÄúBL602 GPIO Interrupts‚Äù</strong></a></li>
</ul>
<p>For safety we don‚Äôt call <code>RadioOnDioIrq</code> directly from the Interrupt Context.</p>
<p>Instead we <strong>forward the GPIO Interrupt to an Event Queue</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan-handler.png" alt="Handling LoRa Receive Event" /></p>
<p>A <strong>FreeRTOS Background Task</strong> will execute <code>RadioOnDioIrq</code> in the Application Context, where it‚Äôs safe to call SPI Functions, <code>printf</code> and other nice things.</p>
<p>This is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler"><strong>‚ÄúGPIO Interrupt Handler‚Äù</strong></a></li>
</ul>

    
</body>
</html>