<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Build a LoRaWAN Network with RAKwireless WisGate Developer Gateway</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Build a LoRaWAN Network with RAKwireless WisGate Developer Gateway" 
    data-rh="true">
<meta property="og:description" 
    content="How we set up our own LoRaWAN Network with RAKwireless RAK7248 WisGate Developer D4H Gateway... And test it with RAKwireless WisBlock in Arduino"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/wisgate-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Build a LoRaWAN Network with RAKwireless WisGate Developer Gateway</h1>
    <nav id="rustdoc"><ul>
<li><a href="#wisgate-d4h-hardware" title="WisGate D4H Hardware">1 WisGate D4H Hardware</a><ul></ul></li>
<li><a href="#chirpstack-lorawan-stack" title="ChirpStack LoRaWAN Stack">2 ChirpStack LoRaWAN Stack</a><ul></ul></li>
<li><a href="#lorawan-application" title="LoRaWAN Application">3 LoRaWAN Application</a><ul></ul></li>
<li><a href="#lorawan-arduino-client" title="LoRaWAN Arduino Client">4 LoRaWAN Arduino Client</a><ul>
<li><a href="#configure-lorawan-client" title="Configure LoRaWAN Client">4.1 Configure LoRaWAN Client</a><ul></ul></li>
<li><a href="#initialise-lorawan-client" title="Initialise LoRaWAN Client">4.2 Initialise LoRaWAN Client</a><ul></ul></li>
<li><a href="#join-lorawan-network" title="Join LoRaWAN Network">4.3 Join LoRaWAN Network</a><ul></ul></li>
<li><a href="#send-lorawan-data-packet" title="Send LoRaWAN Data Packet">4.4 Send LoRaWAN Data Packet</a><ul></ul></li></ul></li>
<li><a href="#wisblock-talks-to-wisgate" title="WisBlock Talks To WisGate">5 WisBlock Talks To WisGate</a><ul></ul></li>
<li><a href="#view-received-lorawan-packets" title="View Received LoRaWAN Packets">6 View Received LoRaWAN Packets</a><ul></ul></li>
<li><a href="#troubleshoot-lorawan" title="Troubleshoot LoRaWAN">7 Troubleshoot LoRaWAN</a><ul>
<li><a href="#inspect-the-raw-packets" title="Inspect the raw packets">7.1 Inspect the raw packets</a><ul></ul></li>
<li><a href="#check-the-log" title="Check the log">7.2 Check the log</a><ul></ul></li>
<li><a href="#snoop-with-software-defined-radio" title="Snoop with Software Defined Radio">7.3 Snoop with Software Defined Radio</a><ul></ul></li></ul></li>
<li><a href="#visualise-lorawan-with-software-defined-radio" title="Visualise LoRaWAN with Software Defined Radio">8 Visualise LoRaWAN with Software Defined Radio</a><ul></ul></li>
<li><a href="#lorawan-security" title="LoRaWAN Security">9 LoRaWAN Security</a><ul>
<li><a href="#join-network-request" title="Join Network Request">9.1 Join Network Request</a><ul></ul></li>
<li><a href="#message-integrity-code" title="Message Integrity Code">9.2 Message Integrity Code</a><ul></ul></li>
<li><a href="#nonce" title="Nonce">9.3 Nonce</a><ul></ul></li>
<li><a href="#more-about-security" title="More About Security">9.4 More About Security</a><ul></ul></li></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes" title="Notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-log-transmitted-packets" title="Appendix: Log Transmitted Packets">12 Appendix: Log Transmitted Packets</a><ul></ul></li></ul></nav><p>üìù <em>30 Apr 2021</em></p>
<p>While testing a new LoRaWAN gadget (<a href="https://lupyuen.github.io/articles/lora2">PineCone BL602</a>), I bought a LoRaWAN Gateway from RAKwireless: <a href="https://docs.rakwireless.com/Product-Categories/WisGate/RAK7248/Datasheet/"><strong>RAK7248 WisGate Developer D4H Gateway</strong></a>.</p>
<p>Here‚Äôs what I learnt about <strong>settting up a LoRaWAN Network</strong> with WisGate Developer D4H‚Ä¶ And testing it with the <strong>RAKwireless WisBlock dev kit in Arduino</strong>.</p>
<p><img src="https://lupyuen.github.io/images/wisgate-title.jpg" alt="RAKwireless RAK7248 WisGate Developer D4H LoRaWAN Gateway" /></p>
<p><em>RAKwireless RAK7248 WisGate Developer D4H LoRaWAN Gateway</em></p>
<h1 id="wisgate-d4h-hardware"><a class="doc-anchor" href="#wisgate-d4h-hardware">¬ß</a>1 WisGate D4H Hardware</h1>
<p>WisGate D4H is essentially a <strong>Raspberry Pi 4 + LoRa Network Concentrator (Semtech SX1302)</strong> in a sturdy IP30 box.</p>
<p>It exposes the same ports and connectors as a Raspberry Pi 4: <strong>Ethernet port, USB 2 and 3 ports, USB-C power, microSD Card.</strong></p>
<p>But the <strong>HDMI and GPIO ports</strong> are no longer accessible. (We control the box over HTTP and SSH)</p>
<p><img src="https://lupyuen.github.io/images/wisgate-hw.jpg" alt="RAKwireless RAK7248 WisGate Developer D4H LoRaWAN Gateway" /></p>
<p>2 new connectors have been added‚Ä¶</p>
<ol>
<li>
<p><strong>LoRa Antenna</strong> (left)</p>
</li>
<li>
<p><strong>GPS Antenna</strong> (right)</p>
</li>
</ol>
<p>(The two connectors are slightly different, so we won‚Äôt connect the wrong antenna)</p>
<p>The GPS Antenna will be used when we connect WisGate to The Things Network (the worldwide free-access LoRaWAN network).</p>
<p>WisGate D4H is shipped with the open-source <strong>ChirpStack LoRaWAN stack</strong>, preinstalled in the microSD card.</p>
<p>(Yep please don‚Äôt peel off the sticky tape and insert your own microSD card)</p>
<p><img src="https://lupyuen.github.io/images/wisgate-hw2.jpg" alt="microSD Slot on WisGate D4H" /></p>
<p><em>microSD Slot on WisGate D4H</em></p>
<h1 id="chirpstack-lorawan-stack"><a class="doc-anchor" href="#chirpstack-lorawan-stack">¬ß</a>2 ChirpStack LoRaWAN Stack</h1>
<p>Connect the <strong>LoRa Antenna and GPS Antenna</strong> to WisGate before powering on. (To prevent damage to the RF modules)</p>
<p>Follow the instructions here to start the WisGate box and to connect to the preinstalled ChirpStack LoRaWAN stack‚Ä¶</p>
<ul>
<li><a href="https://docs.rakwireless.com/Product-Categories/WisGate/RAK7244C/Quickstart/"><strong>‚ÄúRAK7244C Quick Start Guide‚Äù</strong></a></li>
</ul>
<p>(RAK7244C is quite similar to our RAK7248 gateway)</p>
<p>I connected an Ethernet cable to WisGate and used SSH to configure the WiFi and LAN settings (via <code>sudo gateway-config</code>).</p>
<p>Here‚Äôs the <strong>ChirpStack web admin</strong> page that we will see‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-chirpstack.png" alt="ChirpStack web admin on WisGate" /></p>
<p>(Nope I‚Äôm nowhere near Jervois Road)</p>
<p>In the left bar, click <strong><code>Gateways</code></strong> to see our pre-configured LoRaWAN Gateway‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-chirpstack2.png" alt="ChirpStack web admin on WisGate" /></p>
<p>Click <strong><code>rak-gateway</code></strong> to see the Gateway Details‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-chirpstack3.png" alt="ChirpStack web admin on WisGate" /></p>
<p>This shows that my WisGate gateway receives <strong>1,200 LoRaWAN Packets a day</strong> from unknown LoRaWAN Devices nearby.</p>
<p>WisGate won‚Äôt do anything with the received LoRaWAN Packets since it‚Äôs not configured to process packets with mysterious origins.</p>
<p>(But we may click <strong><code>Live LoRaWAN Frames</code></strong> at top right to see the encrypted contents of the received LoRaWAN Packets)</p>
<h1 id="lorawan-application"><a class="doc-anchor" href="#lorawan-application">¬ß</a>3 LoRaWAN Application</h1>
<p>When we allow a LoRaWAN Device to talk to our LoRaWAN Gateway, we need to set 2 things in the device‚Ä¶</p>
<ol>
<li>
<p><strong>Device EUI</strong>: A 64-bit number that uniquely identifies our LoRaWAN Device</p>
</li>
<li>
<p><strong>Application Key</strong>: A 128-bit secret key that will authenticate that specific LoRaWAN Device</p>
</li>
</ol>
<p>Here‚Äôs how we get the Device EUI and Application Key from ChirpStack‚Ä¶</p>
<p>Click <strong><code>Applications</code></strong> then <strong><code>app</code></strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-app.png" alt="ChirpStack Application" /></p>
<p>Take note of the second <strong>Device EUI</strong> (for the OTAA Device Profile)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-app2.png" alt="ChirpStack Application" /></p>
<p>(EUI sounds like we stepped on something unpleasant‚Ä¶ But it actually means <a href="https://lora-developers.semtech.com/library/tech-papers-and-guides/the-book/deveui/"><strong>Extended Unique Identifier</strong></a>)</p>
<p>We shall set this Device EUI in our Arduino program in a while‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>uint8_t nodeDeviceEUI[8] = { 0x4b, 0xc1, 0x5e, 0xe7, 0x37, 0x7b, 0xb1, 0x5b };</code></pre></div>
<p>Click <strong><code>device_ptaa_class_a</code></strong> because we‚Äôll be doing <strong>Over-The-Air Activation (OTAA)</strong> for our Arduino device</p>
<p><img src="https://lupyuen.github.io/images/wisgate-app3.png" alt="ChirpStack Application" /></p>
<p>Click <strong><code>Keys (OTAA)</code></strong></p>
<p>Under <code>Application Key</code>, click the circular arrow to generate a random key.</p>
<p>Take note of the generated <strong>Application Key</strong>, we shall set this in our Arduino program‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>uint8_t nodeAppKey[16] = { 0xaa, 0xff, 0xad, 0x5c, 0x7e, 0x87, 0xf6, 0x4d, 0xe3, 0xf0, 0x87, 0x32, 0xfc, 0x1d, 0xd2, 0x5d };</code></pre></div>
<p>Click <strong><code>Set Device-Keys</code></strong></p>
<p>We‚Äôre all set to connect our Arduino LoRaWAN Device to WisGate!</p>
<h1 id="lorawan-arduino-client"><a class="doc-anchor" href="#lorawan-arduino-client">¬ß</a>4 LoRaWAN Arduino Client</h1>
<p>I tested WisGate with an Arduino LoRaWAN Device: <a href="https://docs.rakwireless.com/Product-Categories/WisBlock/RAK4631/Overview/"><strong>RAKwireless RAK4631 WisBlock</strong></a>, based on Nordic nRF52840 with Semtech SX1262‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisblock-title.jpg" alt="RAKwireless RAK4631 WisBlock LPWAN Module mounted on WisBlock Base Board" /></p>
<p><em>RAKwireless RAK4631 WisBlock LPWAN Module mounted on WisBlock Base Board</em></p>
<p>The Arduino source code is here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/wisblock-lorawan"><code>github.com/lupyuen/wisblock-lorawan</code></a></p>
</li>
<li>
<p><a href="https://youtu.be/xdyi6XCo8Z8"><strong>Watch the demo video on YouTube</strong></a></p>
</li>
</ul>
<p>To download the source code, enter this at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>git clone --recursive https://github.com/lupyuen/wisblock-lorawan</code></pre></div>
<p>Note that the program requires the <a href="https://github.com/beegee-tokyo/SX126x-Arduino"><strong><code>SX126x-Arduino</code></strong></a> Library version <strong>2.0.0 or later</strong>.</p>
<p>With PlatformIO, we set the <code>SX126x-Arduino</code> version in <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/platformio.ini"><code>platformio.ini</code></a> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>lib_deps = beegee-tokyo/SX126x-Arduino@^2.0.0</code></pre></div>
<p>The Arduino program in this article is based on the RAKwireless LoRaWAN sample <a href="https://github.com/RAKWireless/WisBlock/blob/master/examples/RAK4630/communications/LoRa/LoRaWAN/LoRaWAN_OTAA_ABP/LoRaWAN_OTAA_ABP.ino"><code>LoRaWAN_OTAA_ABP.ino</code></a></p>
<p><a href="https://github.com/RAKWireless/WisBlock/tree/master/examples/RAK4630/communications/LoRa/LoRaWAN">(More about LoRaWAN on WisBlock RAK4631)</a></p>
<h2 id="configure-lorawan-client"><a class="doc-anchor" href="#configure-lorawan-client">¬ß</a>4.1 Configure LoRaWAN Client</h2>
<p>Let‚Äôs look at the Arduino code in our LoRaWAN Client‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L38-L58"><code>wisblock-lorawan/src/main.cpp</code></a></p>
<p><strong>Important:</strong> Set your <strong>LoRaWAN Region</strong> in <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L38-L58"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  TODO: Set this to your LoRaWAN Region
LoRaMacRegion_t g_CurrentRegion = LORAMAC_REGION_AS923;</code></pre></div>
<p>Before sending a LoRaWAN Data Packet to WisGate, we shall join our LoRaWAN Device to the LoRaWAN Network with <strong>Over-The-Air Activation (OTAA)</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Set to true to select Over-The-Air Activation 
//  (OTAA), false for Activation By Personalisation (ABP)
bool doOTAA = true;</code></pre></div>
<p>We won‚Äôt be using Activation By Personalisation (ABP) today.</p>
<p><a href="https://www.thethingsnetwork.org/docs/lorawan/addressing/index.html">(More about OTAA vs ABP)</a></p>
<p>Remember the <strong>Device EUI and Application Key</strong> from ChirpStack?</p>
<p>(Did we step on something?)</p>
<p>We paste the Device EUI and Application Key here‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  TODO: (For OTAA Only) Set the OTAA keys. KEYS ARE MSB !!!!

//  Device EUI: Copy from ChirpStack: 
//  Applications -&gt; app -&gt; Device EUI
uint8_t nodeDeviceEUI[8] = { 0x4b, 0xc1, 0x5e, 0xe7, 0x37, 0x7b, 0xb1, 0x5b };

//  App EUI: Not needed for ChirpStack, 
//  set to default 0000000000000000
uint8_t nodeAppEUI[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

//  App Key: Copy from ChirpStack: 
//  Applications -&gt; app -&gt; Devices -&gt; 
//  device_otaa_class_a -&gt; Keys (OTAA) -&gt; 
//  Application Key
uint8_t nodeAppKey[16] = { 0xaa, 0xff, 0xad, 0x5c, 0x7e, 0x87, 0xf6, 0x4d, 0xe3, 0xf0, 0x87, 0x32, 0xfc, 0x1d, 0xd2, 0x5d };</code></pre></div>
<p>The <strong>Application EUI</strong> is not used by ChirpStack, so we may set it to <code>0000000000000000</code></p>
<p>Since we‚Äôre not Activating By Personalisation, we may ignore this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  TODO: (For ABP Only) Set the ABP keys
uint32_t nodeDevAddr = 0x260116F8;
uint8_t nodeNwsKey[16] = { 0x7E, 0xAC, 0xE2, 0x55, 0xB8, 0xA5, 0xE2, 0x69, 0x91, 0x51, 0x96, 0x06, 0x47, 0x56, 0x9D, 0x23 };
uint8_t nodeAppsKey[16] = { 0xFB, 0xAC, 0xB6, 0x47, 0xF3, 0x58, 0x45, 0xC7, 0x50, 0x7D, 0xBF, 0x16, 0x8B, 0xA8, 0xC1, 0x7C };</code></pre></div><h2 id="initialise-lorawan-client"><a class="doc-anchor" href="#initialise-lorawan-client">¬ß</a>4.2 Initialise LoRaWAN Client</h2>
<p>Following the Arduino convention, our <strong><code>setup</code></strong> function shall be executed at startup: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L110-L213"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>// At startup, we join the LoRaWAN network, in either OTAA or ABP mode
void setup() {
  ...
  //  Initialize LoRa chip
  lora_rak4630_init();

  //  Omitted: Initialize Serial for debug output
  ...
  
  //  Create a timer to send data to server every 20 seconds
  uint32_t err_code err_code = timers_init();
  if (err_code != 0) { return; }</code></pre></div>
<p>Here we <strong>initialise the LoRa Transceiver</strong> (SX1262) and create a timer that will send a LoRaWAN Packet every 20 seconds.</p>
<p>(More about <code>timers_init</code> in a while)</p>
<p>Next we set the <strong>Device EUI, Application EUI and Application Key</strong> that will be used for joining the LoRaWAN Network‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Setup the EUIs and Keys
  if (doOTAA) {
    //  Set the EUIs and Keys for OTAA
    lmh_setDevEui(nodeDeviceEUI);
    lmh_setAppEui(nodeAppEUI);
    lmh_setAppKey(nodeAppKey);
  } else {
    //  Omitted: Set the EUIs and Keys for ABP
    ...
  }</code></pre></div>
<p>Then we <strong>initialise the LoRaWAN Client</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Initialise LoRaWAN
  err_code = lmh_init(  //  lmh_init now takes 3 parameters instead of 5
    &amp;g_lora_callbacks,  //  Callbacks 
    g_lora_param_init,  //  Functions
    doOTAA,             //  Set to true for OTAA
    g_CurrentClass,     //  Class 
    g_CurrentRegion     //  Region
  );
  if (err_code != 0) { return; }</code></pre></div>
<p>(More about <code>g_lora_callbacks</code> in a while)</p>
<p>Finally we send the <strong>Join LoRaWAN Network Request</strong> to WisGate‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Start Join procedure
  lmh_join();
}</code></pre></div>
<p><em>What‚Äôs in <code>g_lora_callbacks</code>?</em></p>
<p><code>g_lora_callbacks</code> contains a list of Callback Functions that will be called by the LoRaWAN Client: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L87-L97"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Structure containing LoRaWan callback functions, 
//  needed for lmh_init()
static lmh_callback_t g_lora_callbacks = {
    BoardGetBatteryLevel, 
    BoardGetUniqueId, 
    BoardGetRandomSeed,
    lorawan_rx_handler, 
    lorawan_has_joined_handler, 
    lorawan_confirm_class_handler, 
    lorawan_join_failed_handler
};</code></pre></div>
<p>We shall see the Callback Functions in action soon.</p>
<p><em>What about <code>loop</code>, the Arduino function that will be called to do work?</em></p>
<p>Our program uses the Callback Functions to trigger actions, so we won‚Äôt be <code>loop</code>ing today.</p>
<p>Here‚Äôs our <code>loop</code> function in <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L215-L220"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Nothing here for now
void loop() {
  //  Put your application tasks here, like reading of sensors,
  //  controlling actuators and other functions.
}</code></pre></div><h2 id="join-lorawan-network"><a class="doc-anchor" href="#join-lorawan-network">¬ß</a>4.3 Join LoRaWAN Network</h2>
<p>During startup we called <code>lmh_join</code> to send the <strong>Join LoRaWAN Network Request</strong> to WisGate‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Start Join procedure
</span>lmh_join();</code></pre></div>
<p>When <strong>WisGate accepts the Join Request</strong> and returns an acknowledgement packet, this Callback Function will be called: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L222-L236"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Function that is called when we have joined the LoRaWAN network
void lorawan_has_joined_handler(void) {

  //  Request for a different LoRaWAN Device Class, if necessary
  lmh_error_status ret = lmh_class_request(g_CurrentClass);</code></pre></div>
<p>Here we switch to the desired <strong>LoRaWAN Device Class</strong> (A, B or C) if necessary.</p>
<p><strong>Class A</strong> is the most basic Device Class (for simple LoRaWAN sensors). <strong>Classes B and C</strong> are more sophisticated.</p>
<p>We have configured our LoRaWAN Client for <strong>Class A</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>DeviceClass_t g_CurrentClass = CLASS_A;</code></pre></div>
<p>So <code>lmh_class_request</code> won‚Äôt switch our Device Class.</p>
<p>Our Callback Function then starts a <strong>timer that expires in 20 seconds</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  When we have joined the LoRaWAN network, 
  //  start a 20-second timer
  if (ret == LMH_SUCCESS) {
    delay(1000);
    TimerSetValue(&amp;appTimer, LORAWAN_APP_INTERVAL);
    TimerStart(&amp;appTimer);
  }
}</code></pre></div>
<p>We‚Äôll learn more about the timer in a while. (Hint: It triggers the sending of a LoRaWAN Data Packet)</p>
<p>We have another Callback Function that‚Äôs called when our <strong>Join Request is rejected</strong> by WisGate: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L238-L246"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  LoRa function for handling OTAA join failed
static void lorawan_join_failed_handler(void) {
  //  If we can&#39;t join the LoRaWAN network, show the error
  Serial.println(&quot;OTAA join failed!&quot;);
}</code></pre></div>
<p>The LoRaWAN Gateway (WisGate) rejects our Join Request if the Device EUI and/or Application Key are incorrect.</p>
<p>In case you‚Äôre curious: WisBlock transmits this LoRaWAN Packet to WisGate when requesting to join the LoRaWAN network‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-join.png" alt="Join LoRaWAN Network Request" /></p>
<p>We‚Äôll learn about the Nonce and the Message Integrity Code later.</p>
<h2 id="send-lorawan-data-packet"><a class="doc-anchor" href="#send-lorawan-data-packet">¬ß</a>4.4 Send LoRaWAN Data Packet</h2>
<p>Now that we‚Äôve joined the LoRaWAN Network, let‚Äôs <strong>send a LoRaWAN Data Packet</strong> to WisGate!</p>
<p>Remember that when our Join Request succeeds, it starts a 20-second timer.</p>
<p>Here‚Äôs what happens 20 seconds later: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L302-L311"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Function for handling timeout event
void tx_lora_periodic_handler(void) {
  //  When the 20-second timer has expired, 
  //  send a LoRaWAN Packet and restart the timer
  TimerSetValue(&amp;appTimer, LORAWAN_APP_INTERVAL);
  TimerStart(&amp;appTimer);
  send_lora_frame();
}</code></pre></div>
<p>We restart the 20-second timer and call <code>send_lora_frame</code> to send a LoRaWAN Data Packet to WisGate.</p>
<p><code>send_lora_frame</code> is defined in <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L269-L300"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  This is called when the 20-second timer expires. 
//  We send a LoRaWAN Data Packet.
void send_lora_frame(void) {
  if (lmh_join_status_get() != LMH_SET) {
    //  Not joined, try again later
    return;
  }</code></pre></div>
<p>First we verify that we have joined the LoRaWAN Network. (Because WisGate won‚Äôt process our data packet unless we‚Äôre in the network)</p>
<p>Then we set the packet port and populate the packet with 6 bytes: ‚Äú<code>Hello!</code>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Copy &quot;Hello!&quot; into the transmit buffer
  m_lora_app_data.port = gAppPort;  //  Set to LORAWAN_APP_PORT
  memset(m_lora_app_data.buffer, 0, LORAWAN_APP_DATA_BUFF_SIZE);
  memcpy(m_lora_app_data.buffer, &quot;Hello!&quot;, 6);
  m_lora_app_data.buffsize = 6;</code></pre></div>
<p>Finally we transmit the data packet to WisGate‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Transmit the LoRaWAN Data Packet
  lmh_error_status error = lmh_send(
    &amp;m_lora_app_data,  //  Data Packet
    g_CurrentConfirm   //  LMH_UNCONFIRMED_MSG: Unconfirmed Message
  );
  if (error == LMH_SUCCESS) { count++; } 
  else { count_fail++; }
}</code></pre></div>
<p>Here we‚Äôre sending an <strong>Unconfirmed LoRaWAN Message</strong> to WisGate. Which means that we don‚Äôt expect an acknowledgement from WisGate.</p>
<p>This is the preferred way for a low-power LoRaWAN device to transmit sensor data, since it <strong>doesn‚Äôt need to wait for the acknowledgement</strong> (and consume additional power).</p>
<p>(It‚Äôs OK if a LoRaWAN Data Packet gets lost due to noise or inteference‚Ä¶ LoRaWAN sensor devices are supposed to transmit data packets periodically anyway)</p>
<p><em>What about receiving data from our LoRaWAN Gateway (WisGate)?</em></p>
<p>We haven‚Äôt configured WisGate to transmit data to our LoRaWAN Device.</p>
<p>But the Callback Function to <strong>handle received packets</strong> is here: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L248-L257"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Function for handling LoRaWan received data from Gateway
void lorawan_rx_handler(lmh_app_data_t *app_data) {
  //  When we receive a LoRaWAN Packet from the 
  //  LoRaWAN Gateway, display it.
  //  TODO: Ensure that app_data-&gt;buffer is null-terminated.
  Serial.printf(&quot;LoRa Packet received on port %d, size:%d, rssi:%d, snr:%d, data:%s\n&quot;,
    app_data-&gt;port, app_data-&gt;buffsize, app_data-&gt;rssi, app_data-&gt;snr, app_data-&gt;buffer);
}</code></pre></div>
<p>There‚Äôs one more Callback Function (that we‚Äôre not using) for <strong>switching the LoRaWAN Device Class</strong>: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L259-L267"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Callback Function that is called when the
//  LoRaWAN Class has been changed
void lorawan_confirm_class_handler(DeviceClass_t Class) {
  //  Informs the server that switch has occurred ASAP
  m_lora_app_data.buffsize = 0;
  m_lora_app_data.port = gAppPort;
  lmh_send(&amp;m_lora_app_data, g_CurrentConfirm);
}</code></pre></div>
<p><em>How did we initialise the 20-second timer?</em></p>
<p>During startup, the <code>setup</code> function calls <code>timers_init</code> to initialise the timer: <a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/src/main.cpp#L313-L321"><code>main.cpp</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise the timer
uint32_t timers_init(void) {
  TimerInit(&amp;appTimer, tx_lora_periodic_handler);
  return 0;
}</code></pre></div><h1 id="wisblock-talks-to-wisgate"><a class="doc-anchor" href="#wisblock-talks-to-wisgate">¬ß</a>5 WisBlock Talks To WisGate</h1>
<p>Let‚Äôs <strong>run the Arduino program on WisBlock</strong> and watch what happens in the Arduino Log!</p>
<ol>
<li>
<p>Our Arduino program starts by reminding us of the Over-The-Air Activation (OTAA) configuration: <strong>Device EUI, Application EUI (unused) and Application Key</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>OTAA 
DevEui=4B-C1-5E-E7-37-7B-B1-5B
DevAdd=00000000
AppEui=00-00-00-00-00-00-00-00
AppKey=AA-FF-AD-5C-7E-87-F6-4D-E3-F0-87-32-FC-1D-D2-5D</code></pre></div>
<p>(Device Address will be assigned by WisGate when we join the LoRaWAN Network)</p>
</li>
<li>
<p>We <strong>transmit the Join Network Request</strong> to WisGate‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Selected subband 1
Joining LoRaWAN network...
RadioSend: 00 00 00 00 00 00 00 00 00 5b b1 7b 37 e7 5e c1 4b 55 ed 7e 9b d6 af
OnRadioTxDone</code></pre></div>
<p>The Join Network Request contains these fields‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-join.png" alt="Join LoRaWAN Network Request" /></p>
<p><em>But the Application Key is missing from the Join Network Request!?</em></p>
<p>Yep! We‚Äôll learn why in a while.</p>
</li>
<li>
<p>To conserve power, LoRaWAN Devices (Class A) don‚Äôt receive packets all the time.</p>
<p>We listen for incoming packets (for a brief moment) <strong>only after we transmit a packet</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>OnRadioTxDone =&gt; RX Windows #1 5002 #2 6002
OnRadioTxDone =&gt; TX was Join Request</code></pre></div>
<p>We‚Äôve just transmitted a packet (Join Network Request), so <strong>we listen for an incoming packet</strong>. (Hopefully, the Join Network Response from WisGate)</p>
<p>The LoRaWAN Specification actually defines <strong>Two Receive Windows</strong>. Which means that <strong>we listen twice (very briefly) for incoming packets</strong>, after sending every packet‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-window.png" alt="LoRaWAN Receive Window" /></p>
</li>
<li>
<p>And indeed, we <strong>receive the Join Network Accepted Response</strong> from WisGate‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>OnRadioRxDone
OnRadioRxDone =&gt; FRAME_TYPE_JOIN_ACCEPT
OTAA Mode, Network Joined!</code></pre></div>
<p>The LoRaWAN Spec says we don‚Äôt open the Second Receive Window if we receive a packet in the First Receive Window.</p>
<p>So‚Ä¶ We‚Äôre good!</p>
</li>
<li>
<p>20 seconds later we <strong>transmit our first data packet</strong> (‚Äú<code>Hello!</code>‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Sending frame now...
RadioSend: 40 3c 59 7a 00 80 00 00 02 17 77 31 fd 99 86 8f 4f cc ef 
lmh_send ok count 1
OnRadioTxDone</code></pre></div></li>
<li>
<p>Once again we open the <strong>Two Receive Windows</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>OnRadioTxDone =&gt; RX Windows #1 1002 #2 2002
RadioIrqProcess =&gt; IRQ_RX_TX_TIMEOUT
OnRadioRxTimeout</code></pre></div>
<p>We haven‚Äôt configured WisGate to respond to our data packet. (Remember that we‚Äôre sending Unconfirmed LoRaWAN Messages‚Ä¶ No ack needed)</p>
<p>So we get a <strong>Receive Timeout</strong>. Which is expected.</p>
</li>
<li>
<p>20 seconds later we <strong>transmit our second data packet</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Sending frame now...
RadioSend: 40 3c 59 7a 00 80 01 00 02 0b 1f 7e 4d e1 94 c9 16 fa ea 
lmh_send ok count 2
OnRadioTxDone</code></pre></div>
<p>We open the <strong>Two Receive Windows</strong> and we get a <strong>Receive Timeout</strong>, which is OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>OnRadioTxDone =&gt; RX Windows #1 1002 #2 2002
RadioIrqProcess =&gt; IRQ_RX_TX_TIMEOUT
OnRadioRxTimeout</code></pre></div>
<p><a href="https://youtu.be/xdyi6XCo8Z8"><strong>Watch the demo video on YouTube</strong></a></p>
<p><a href="https://github.com/lupyuen/wisblock-lorawan/blob/master/README.md#output-log"><strong>See the complete Arduino log</strong></a></p>
</li>
</ol>
<h1 id="view-received-lorawan-packets"><a class="doc-anchor" href="#view-received-lorawan-packets">¬ß</a>6 View Received LoRaWAN Packets</h1>
<p>Let‚Äôs head back to <strong>ChirpStack on our WisGate LoRaWAN Gateway</strong>, to observe the LoRaWAN Packets received from our Arduino Device (WisBlock)‚Ä¶</p>
<ol>
<li>
<p>In ChirpStack, click <strong><code>Applications ‚Üí app ‚Üí device_otaa_class_a ‚Üí Device Data</code></strong></p>
</li>
<li>
<p>Restart our Arduino LoRaWAN Device (WisBlock)</p>
</li>
<li>
<p>The <strong>Join Network Request</strong> appears‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-devicedata1.png" alt="LoRaWAN Device Data" /></p>
</li>
<li>
<p>20 seconds later the <strong>Data Packet</strong> appears‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-devicedata2.png" alt="LoRaWAN Device Data" /></p>
<p><code>DecodedDataString</code> says ‚Äú<code>Hello!</code>‚Äù</p>
</li>
<li>
<p>We may now configure ChirpStack to do something useful with the received packets, like publish them over MQTT, HTTP, ‚Ä¶</p>
<p>Click this link‚Ä¶</p>
<ul>
<li><a href="https://www.chirpstack.io/application-server/"><strong>ChirpStack Application Server</strong></a></li>
</ul>
<p>Then click the <strong>Menu</strong> (top left) and <strong>Integrations</strong></p>
</li>
</ol>
<h1 id="troubleshoot-lorawan"><a class="doc-anchor" href="#troubleshoot-lorawan">¬ß</a>7 Troubleshoot LoRaWAN</h1>
<p>If our packets don‚Äôt appear in ChirpStack, here are a couple of things to check‚Ä¶</p>
<h2 id="inspect-the-raw-packets"><a class="doc-anchor" href="#inspect-the-raw-packets">¬ß</a>7.1 Inspect the raw packets</h2>
<p>To troubleshoot LoRaWAN problems, we may inspect the <strong>Raw LoRaWAN Packets</strong> received by our LoRaWAN Gateway (WisGate).</p>
<p>In ChirpStack there are two ways do this‚Ä¶</p>
<ol>
<li>
<p>Click <strong><code>Gateways ‚Üí rak-gateway ‚Üí Live LoRaWAN Frames</code></strong></p>
<p>This shows ALL LoRaWAN Packets received, even from unknown devices.</p>
<p>(The packet data is encrypted, so we won‚Äôt be able to read other people‚Äôs messages)</p>
</li>
<li>
<p>Or click <strong><code>Applications ‚Üí app ‚Üí device_otaa_class_a ‚Üí LoRaWAN Frames</code></strong></p>
<p>This only shows LoRaWAN Packets from identified devices.</p>
</li>
</ol>
<p>Here‚Äôs the <strong>Raw Packet for Join Network Request</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-frame1.png" alt="Raw LoRaWAN Join Network Request Packet" /></p>
<p>And here‚Äôs the <strong>Raw Data Packet</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-frame2.png" alt="Raw LoRaWAN Data Packet" /></p>
<p>This is the mystery LoRaWAN Packet that my LoRaWAN Gateway (WisGate) receives every minute (with encrypted contents)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-frame3.png" alt="Raw LoRaWAN Data Packet from unknown device" /></p>
<h2 id="check-the-log"><a class="doc-anchor" href="#check-the-log">¬ß</a>7.2 Check the log</h2>
<p>SSH to WisGate and look at the <strong>Linux System Log</strong> while our LoRaWAN Device is transmitting packets‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>tail -f /var/log/syslog</code></pre></div>
<p>Sometimes it‚Äôs helpful to scan the log for <strong>Message Integrity Code</strong> errors (‚Äúinvalid MIC‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>grep MIC /var/log/syslog

Apr 28 04:02:05 rak-gateway 
chirpstack-application-server[568]: 
time=&quot;2021-04-28T04:02:05+01:00&quot; 
level=error 
msg=&quot;invalid MIC&quot; 
dev_eui=4bc15ee7377bb15b 
type=DATA_UP_MIC</code></pre></div>
<p>Also for <strong>Nonce Errors</strong> (‚Äúvalidate dev-nonce error‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>grep nonce /var/log/syslog

Apr 28 04:02:41 rak-gateway chirpstack-application-server[568]:
time=&quot;2021-04-28T04:02:41+01:00&quot; 
level=error 
msg=&quot;validate dev-nonce error&quot; 
dev_eui=4bc15ee7377bb15b 
type=OTAA</code></pre></div>
<p>Another way to check for <strong>Nonce Errors</strong>: Click‚Ä¶</p>
<p><strong>Applications</strong> ‚Üí <strong>app</strong> ‚Üí <strong>device_otaa_class_a</strong>  ‚Üí <strong>Device Data</strong></p>
<p>Look for <strong>‚Äúvalidate dev-nonce error‚Äù</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/auto-nonce.png" alt="Duplicate LoRaWAN Nonce" /></p>
<p>We‚Äôll talk about Message Integrity Code and Nonce in a while.</p>
<h2 id="snoop-with-software-defined-radio"><a class="doc-anchor" href="#snoop-with-software-defined-radio">¬ß</a>7.3 Snoop with Software Defined Radio</h2>
<p>To verify the actual frequency that our LoRaWAN Device is transmitting on, we may sniff the airwaves with a <strong>Software Defined Radio</strong>.</p>
<p>Or use a Spectrum Analyser like <strong>RF Explorer</strong>. <a href="https://lupyuen.github.io/articles/lora#troubleshoot-lora">(See this)</a></p>
<p>Let‚Äôs talk about Software Defined Radio‚Ä¶</p>
<h1 id="visualise-lorawan-with-software-defined-radio"><a class="doc-anchor" href="#visualise-lorawan-with-software-defined-radio">¬ß</a>8 Visualise LoRaWAN with Software Defined Radio</h1>
<p>A <strong>Software Defined Radio (SDR)</strong> is a USB gadget that scans the airwaves (for a range of frequencies) and feeds the data to our computer for processing.</p>
<p>I use the <a href="https://www.itead.cc/airspy.html"><strong>Airspy R2 SDR</strong></a> to sniff the airwaves and verify that our LoRaWAN Device is transmitting at the <strong>right frequency with sufficient power</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-airspy.jpg" alt="Airspy R2 SDR" /></p>
<p>Here‚Äôs the <strong>Join Network Request</strong> transmitted by WisBlock to WisGate, captured by Airspy SDR and visualised with <a href="https://cubicsdr.com/"><strong>Cubic SDR</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-chirp1.png" alt="LoRaWAN Chirp: Device to Gateway" /></p>
<p>And here‚Äôs the <strong>Join Network Response</strong> returned by WisGate to WisBlock‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-chirp2.png" alt="LoRaWAN Chirp: Gateway to Device" /></p>
<p>(Our SDR is located near WisBlock, hence the WisGate signal looks slightly weaker)</p>
<p>LoRaWAN Packets have a distinct cross-hatch pattern known as the <strong>LoRa Chirp</strong>. By transmitting packets in this unique chirping pattern, LoRa ensures that packets will be delivered over long distances in spite of the noise and interference.</p>
<ul>
<li>
<p><a href="https://youtu.be/xdyi6XCo8Z8"><strong>Watch the video on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#visualise-lora-with-software-defined-radio"><strong>More about LoRa Chirps and Software Defined Radio</strong></a></p>
</li>
</ul>
<h1 id="lorawan-security"><a class="doc-anchor" href="#lorawan-security">¬ß</a>9 LoRaWAN Security</h1>
<p>I‚Äôm no Security Expert‚Ä¶ But lemme attempt to explain the high-level bits of LoRaWAN Security to the best of my understanding üôè</p>
<h2 id="join-network-request"><a class="doc-anchor" href="#join-network-request">¬ß</a>9.1 Join Network Request</h2>
<p>Let‚Äôs start by looking at the <strong>Join Network Request</strong> transmitted by our LoRaWAN Device (WisBlock) to our LoRaWAN Gateway (WisGate). And understand why it‚Äôs secure‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-join.png" alt="Join LoRaWAN Network Request" /></p>
<p>There are 5 parts in the request‚Ä¶</p>
<ol>
<li>
<p><strong>Header</strong> (1 byte): Identifies this LoRaWAN Packet as a Join Network Request</p>
</li>
<li>
<p><strong>Application EUI</strong> (8 bytes): Unused</p>
</li>
<li>
<p><strong>Device EUI</strong> (8 bytes): Uniquely identifies our LoRaWAN Device. (The bytes are flipped)</p>
</li>
<li>
<p><strong>Nonce</strong> (2 bytes): We‚Äôll explain in a while</p>
</li>
<li>
<p><strong>Message Integrity Code</strong> (4 bytes): We‚Äôll explain now</p>
</li>
</ol>
<h2 id="message-integrity-code"><a class="doc-anchor" href="#message-integrity-code">¬ß</a>9.2 Message Integrity Code</h2>
<p><em>Why isn‚Äôt the Application Key inside the Join Network Request?</em></p>
<p>Because the <strong>Application Key is a Secret Key</strong>. It should never be revealed to others, otherwise our gateway will accept Join Network Requests from unauthorised devices.</p>
<p>Instead we use the Application Key to compute a <strong><a href="https://en.wikipedia.org/wiki/Message_authentication_code">Message Authentication Code</a> (AES-128 CMAC)</strong>. And we transmit the first 4 bytes of the authentication code as the <strong>Message Integrity Code</strong>.</p>
<p>According to the LoRaWAN Spec, the Message Authentication Code (for the Join Network Request) is computed with these input values‚Ä¶</p>
<ol>
<li>
<p><strong>Application Key</strong></p>
</li>
<li>
<p><strong>Header</strong></p>
</li>
<li>
<p><strong>Application EUI</strong></p>
</li>
<li>
<p><strong>Device EUI</strong></p>
</li>
<li>
<p><strong>Nonce</strong> (We‚Äôll explain in the next section)</p>
</li>
</ol>
<p><em>What happens when we transmit an invalid Message Integrity Code?</em></p>
<p>Our LoRaWAN Gateway (ChirpStack on WisGate) will <strong>reject LoRaWAN Packets with invalid Message Integrity Codes</strong>.</p>
<p>To see Message Integrity Code errors, SSH to our LoRaWAN Gateway and search for ‚Äúinvalid MIC‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>grep MIC /var/log/syslog

Apr 28 04:02:05 rak-gateway 
chirpstack-application-server[568]: 
time=&quot;2021-04-28T04:02:05+01:00&quot; 
level=error 
msg=&quot;invalid MIC&quot; 
dev_eui=4bc15ee7377bb15b 
type=DATA_UP_MIC

Apr 28 04:02:05 rak-gateway 
chirpstack-network-server[1378]: 
time=&quot;2021-04-28T04:02:05+01:00&quot; 
level=error 
msg=&quot;uplink: processing uplink frame error&quot;
ctx_id=0ccd1478-3b79-4ded-9e26-a28e4c143edc 
error=&quot;get device-session error: invalid MIC&quot;</code></pre></div><h2 id="nonce"><a class="doc-anchor" href="#nonce">¬ß</a>9.3 Nonce</h2>
<p><em>There isn‚Äôt a Timestamp in the request. Could someone record and replay the Join Network Request?</em></p>
<p>That‚Äôs why we have the <strong>Nonce</strong>: A 16-bit number that‚Äôs only <strong>used once and never reused</strong> by our LoRaWAN Device.</p>
<p>The Nonce appears in the Join Network Request, and it‚Äôs also used for computing the Message Integrity Code.</p>
<p><em>What happens when we replay a Join Network Request?</em></p>
<p>Our LoRaWAN Gateway (ChirpStack on WisGate) will <strong>reject Join Network Requests that have a reused Nonce</strong>.</p>
<p>(Yep the gateway will remember the Nonces from previous requests)</p>
<p>To see Nonce errors, SSH to our LoRaWAN Gateway and search for <strong>‚Äúvalidate dev-nonce error‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>grep nonce /var/log/syslog

Apr 28 04:02:41 rak-gateway chirpstack-application-server[568]:
time=&quot;2021-04-28T04:02:41+01:00&quot; 
level=error 
msg=&quot;validate dev-nonce error&quot; 
dev_eui=4bc15ee7377bb15b 
type=OTAA

Apr 28 04:02:41 rak-gateway chirpstack-network-server[1378]:
time=&quot;2021-04-28T04:02:41+01:00&quot; 
level=error 
msg=&quot;uplink: processing uplink frame error&quot; ctx_id=01ae296e-8ce1-449a-83cc-fb0771059d89 
error=&quot;validate dev-nonce error: object already exists&quot;</code></pre></div>
<p>Nonce errors will also appear in ChirpStack. Click‚Ä¶</p>
<p><strong>Applications</strong> ‚Üí <strong>app</strong> ‚Üí <strong>device_otaa_class_a</strong>  ‚Üí <strong>Device Data</strong></p>
<p>Look for <strong>‚Äúvalidate dev-nonce error‚Äù</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/auto-nonce.png" alt="Duplicate LoRaWAN Nonce" /></p>
<p>Here‚Äôs the LoRaWAN Spec for the Nonce and Message Integrity Code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-join2.png" alt="Join LoRaWAN Network Request" /></p>
<p>For other LoRaWAN Packets (besides the Join Network Request), the Message Integrity Code is computed differently‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-mic.png" alt="LoRaWAN Message Integrity Code" /></p>
<h2 id="more-about-security"><a class="doc-anchor" href="#more-about-security">¬ß</a>9.4 More About Security</h2>
<p>LoRaWAN Payloads are <strong>encrypted with AES-128</strong>, says the LoRaWAN Spec‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wisgate-encrypt.png" alt="LoRaWAN Encryption" /></p>
<p>And that‚Äôs the limit of my security know-how üôÅ</p>
<p>To learn more about LoRaWAN Security, I recommend this article‚Ä¶</p>
<ul>
<li><a href="https://lora-alliance.org/resource_hub/lorawan-is-secure-but-implementation-matters/"><strong>‚ÄúLoRaWAN¬Æ Is Secure (but Implementation Matters)‚Äù</strong></a></li>
</ul>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>10 What‚Äôs Next</h1>
<p>Pine64‚Äôs upcoming <strong>PineDio LoRa Gateway</strong> works very much like WisGate, here‚Äôs my hands-on experience‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/gateway"><strong>‚ÄúPineDio LoRa Gateway: Testing The Prototype‚Äù</strong></a></li>
</ul>
<p>To learn about configuring WisGate for <strong>The Things Network</strong>, check out this article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/ttn"><strong>‚ÄúThe Things Network on PineDio Stack BL604 RISC-V Board‚Äù</strong></a></li>
</ul>
<p>This has been a fun experience for me, diving deep into LoRaWAN with the RAKwireless WisGate LoRaWAN Gateway‚Ä¶ <strong>My first time using LoRaWAN!</strong></p>
<p>I hope you find this article useful. Now that I know some LoRaWAN, I‚Äôm heading back to <a href="https://lupyuen.github.io/articles/lora2"><strong>PineCone BL602</strong></a> to finish what I started‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan"><strong>‚ÄúPineCone BL602 Talks LoRaWAN‚Äù</strong></a></li>
</ul>
<p>And then to <strong>PineDio Stack BL604</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan2"><strong>‚ÄúLoRaWAN on PineDio Stack BL604 RISC-V Board‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://lupyuen.github.io/articles/sponsor"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sponsor">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/Lora/comments/n1qv3l/build_a_lorawan_network_with_rakwireless_wisgate/?utm_source=share&amp;utm_medium=web2x&amp;context=3">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/wisgate.md"><code>lupyuen.github.io/src/wisgate.md</code></a></p>
<h1 id="notes"><a class="doc-anchor" href="#notes">¬ß</a>11 Notes</h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1379926160377851910">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-log-transmitted-packets"><a class="doc-anchor" href="#appendix-log-transmitted-packets">¬ß</a>12 Appendix: Log Transmitted Packets</h1>
<p>To log transmitted packets in our Arduino program, modify this source file‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>.pio/libdeps/wiscore_rak4631/SX126x-Arduino/src/mac/LoRaMac.cpp</code></pre></div>
<p>Insert the section marked below‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>LoRaMacStatus_t SendFrameOnChannel(uint8_t channel)
{
    TxConfigParams_t txConfig;
    int8_t txPower = 0;

    txConfig.Channel = channel;
    txConfig.Datarate = LoRaMacParams.ChannelsDatarate;
    txConfig.TxPower = LoRaMacParams.ChannelsTxPower;
    txConfig.MaxEirp = LoRaMacParams.MaxEirp;
    txConfig.AntennaGain = LoRaMacParams.AntennaGain;
    txConfig.PktLen = LoRaMacBufferPktLen;

    // If we are connecting to a single channel gateway we use always the same predefined channel and datarate
    if (singleChannelGateway)
    {
        txConfig.Channel = singleChannelSelected;
        txConfig.Datarate = singleChannelDatarate;
    }

    RegionTxConfig(LoRaMacRegion, &amp;txConfig, &amp;txPower, &amp;TxTimeOnAir);

    MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
    McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
    McpsConfirm.Datarate = LoRaMacParams.ChannelsDatarate;
    McpsConfirm.TxPower = txPower;

    // Store the time on air
    McpsConfirm.TxTimeOnAir = TxTimeOnAir;
    MlmeConfirm.TxTimeOnAir = TxTimeOnAir;

    // Starts the MAC layer status check timer
    TimerSetValue(&amp;MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT);
    TimerStart(&amp;MacStateCheckTimer);

    if (IsLoRaMacNetworkJoined != JOIN_OK)
    {
        JoinRequestTrials++;
    }

    //////////////// INSERT THIS CODE

    // To replay a Join Network Request...
    // if (LoRaMacBuffer[0] == 0) {
    // 	static uint8_t replay[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0xb1, 0x7b, 0x37, 0xe7, 0x5e, 0xc1, 0x4b, 0x67, 0xaa, 0xbb, 0x07, 0x70, 0x7d};
    // 	memcpy(LoRaMacBuffer, replay, LoRaMacBufferPktLen);
    // }

    // To dump transmitted packets...
    printf(&quot;RadioSend: size=%d, channel=%d, datarate=%d, txpower=%d, maxeirp=%d, antennagain=%d\r\n&quot;, (int) LoRaMacBufferPktLen, (int) txConfig.Channel, (int) txConfig.Datarate, (int) txConfig.TxPower, (int) txConfig.MaxEirp, (int) txConfig.AntennaGain);
    for (int i = 0; i &lt; LoRaMacBufferPktLen; i++) {
        printf(&quot;%02x &quot;, LoRaMacBuffer[i]);
    }
    printf(&quot;\r\n&quot;);
    
    //////////////// END OF INSERTION

    // Send now
    Radio.Send(LoRaMacBuffer, LoRaMacBufferPktLen);

    LoRaMacState |= LORAMAC_TX_RUNNING;

    return LORAMAC_STATUS_OK;
}</code></pre></div>
    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>