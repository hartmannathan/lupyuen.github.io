<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tinyemu3-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/tinyemu3.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)</h1>
    <nav id="TOC"><ul>
<li><a href="#scripting-the-expected">1 Scripting The Expected</a><ul></ul></li>
<li><a href="#daily-automated-testing">2 Daily Automated Testing</a><ul></ul></li>
<li><a href="#boot-nuttx-in-supervisor-mode">3 Boot NuttX in Supervisor Mode</a><ul></ul></li>
<li><a href="#emulate-the-uart-interrupts">4 Emulate the UART Interrupts</a><ul></ul></li>
<li><a href="#emulate-the-system-timer">5 Emulate the System Timer</a><ul></ul></li>
<li><a href="#whats-next">6 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-boot-nuttx-in-supervisor-mode">7 Appendix: Boot NuttX in Supervisor Mode</a><ul></ul></li>
<li><a href="#appendix-start-the-system-timer">8 Appendix: Start the System Timer</a><ul></ul></li>
<li><a href="#appendix-read-the-system-time">9 Appendix: Read the System Time</a><ul></ul></li>
<li><a href="#appendix-trigger-the-timer-interrupt">10 Appendix: Trigger the Timer Interrupt</a><ul></ul></li></ul></nav><p>üìù <em>29 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/tinyemu3-title.png" alt="Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)" /></p>
<p><em>Every day we‚Äôre auto-building Apache NuttX RTOS for Ox64 BL808 SBC‚Ä¶</em></p>
<p><em>Can we test NuttX on Ox64 automatically after building?</em></p>
<p>Yes we can! With a little help from the <strong>Ox64 BL808 Emulator</strong> that we created last week‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tinyemu2"><strong>‚ÄúEmulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p><em>But our Ox64 Emulator was incomplete?</em></p>
<p>Today we fill in the missing pieces of our Ox64 Emulator and call it for <strong>Automated Testing</strong>‚Ä¶</p>
<ul>
<li>
<p>TODO: Boot NuttX in Supervisor Mode</p>
</li>
<li>
<p>TODO: Emulate UART Interrupts for Console Input</p>
</li>
<li>
<p>TODO: Emulate OpenSBI for System Timer</p>
</li>
<li>
<p>TODO: Fix the System Timer</p>
</li>
<li>
<p>TODO: Scripting The Expected</p>
</li>
<li>
<p>TODO: Daily Automated Testing</p>
</li>
</ul>
<p>We begin with the easier bit: Scripting our Ox64 Emulator‚Ä¶</p>
<h1 id="scripting-the-expected"><a href="#scripting-the-expected">1 Scripting The Expected</a></h1>
<p><em>What‚Äôs this ‚ÄúExpect Scripting‚Äù?</em></p>
<p><strong><code>expect</code></strong> is a cool Command-Line Tool that sends commands to another app and checks the responses.</p>
<p><em>How is it used for Automated Testing?</em></p>
<p>Normally when we start our Ox64 Emulator, it boots NuttX and <strong>waits for our command</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Start our Ox64 Emulator with NuttX
$ ./temu nuttx.cfg

TinyEMU Emulator for Ox64 BL808 RISC-V SBC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt;
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.cfg">(<strong>nuttx.cfg</strong> is our <strong>TinyEMU Config</strong>)</a></p>
<p>But with an <strong>Expect Script</strong>, we can <strong>feed our commands automatically</strong> into the Emulator!</p>
<div class="example-wrap"><pre class="language-text"><code>## Run our Expect Script...
$ ./nuttx.exp

## Which starts the Ox64 Emulator...
spawn ./temu nuttx.cfg

  ## And sends a Command to the Emulator
  nsh&gt; uname -a
  NuttX 12.4.0-RC0 55ec92e181 Jan 24 2024 00:11:08 risc-v ox64
  nsh&gt; 
</code></pre></div>
<p>That‚Äôs why we create an Expect Script to test Ox64 NuttX.</p>
<p><em>What‚Äôs nuttx.exp?</em></p>
<p>That‚Äôs our <strong>Expect Script</strong> containing the commands that will be sent to our Emulator: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.exp">nuttx.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX with Ox64 BL808 Emulator

## For every 1 character sent, wait 0.001 milliseconds
set send_slow {1 0.001}

## Start the Ox64 BL808 Emulator
spawn ./temu nuttx.cfg

## Wait for the prompt and enter `uname -a`
## `send -s` will send slowly (0.001 ms per char)
expect &quot;nsh&gt; &quot;
send -s &quot;uname -a\r&quot;
</code></pre></div>
<p><em>Will it work for complicated tests?</em></p>
<p>Yep we may use <strong>Pattern Matching</strong> and <strong>Timeout Detection</strong> in our script: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.exp">nuttx.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Wait for the prompt and enter `ostest`
expect &quot;nsh&gt; &quot;
send -s &quot;ostest\r&quot;

## Wait at most 30 seconds
set timeout 30

## Check the response...
expect {
  ## If we see this message, exit normally
  &quot;ostest_main: Exiting with status -1&quot; { exit 0 }

  ## If timeout, exit with an error
  timeout { exit 1 }
}
</code></pre></div>
<p>Which works great for thoroughly exercising <strong>NuttX on our Ox64 Emulator</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Run our Expect Script to start Ox64 Emulator...
$ ./nuttx.exp
spawn ./temu nuttx.cfg

  ## And run all kinds of NuttX Tests
  nsh&gt; ostest
  ...
  ostest_main: Exiting with status -1
  nsh&gt;

## Our Expect Script completes successfully
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/actions/workflows/ox64-test.yml">(See the <strong>Test Log</strong>)</a></p>
<h1 id="daily-automated-testing"><a href="#daily-automated-testing">2 Daily Automated Testing</a></h1>
<p><em>We run this every day?</em></p>
<p><strong>GitHub Actions</strong> will start our Automated Test every day at 12:55am (GMT): <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml">ox64-test.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## Run our Automated Test
## Every day at 0:55 UTC
## (After Daily Build at 0:00 UTC)
on:
  schedule:
    - cron: &#39;55 0 * * *&#39;
</code></pre></div>
<p><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule">(Why not one o‚Äôclock? <strong>It‚Äôs too busy</strong>)</a></p>
<p>We build our <strong>Ox64 BL808 Emulator</strong>: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml#L18-L58">ox64-test.yml</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Install `expect` and the Build Prerequisites on Ubuntu
sudo apt -y update
sudo apt -y install \
  expect libcurl4-openssl-dev libssl-dev zlib1g-dev libsdl2-dev wget

## Build Ox64 BL808 Emulator
git clone https://github.com/lupyuen/ox64-tinyemu
pushd ox64-tinyemu
make
cp temu ..
popd
</code></pre></div>
<p>Download the <strong>Daily NuttX Build</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Location of Daily NuttX Builds
## `outputs.date` looks like `2024-01-25`
url=https://github.com/lupyuen/nuttx-ox64/releases/download/nuttx-ox64-${{ steps.date.outputs.date }}

## Download the NuttX Build and show the Git Hash
wget $url/Image
wget $url/nuttx.hash
cat nuttx.hash
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/tags">(<strong>NuttX Builds</strong> are here)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml#L25-L29">(<strong>outputs.date</strong> is defined here)</a></p>
<p>And start our <strong>Test Script</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Test Script from
## https://github.com/lupyuen/nuttx-ox64
url=https://github.com/lupyuen/nuttx-ox64/raw/main
wget $url/nuttx.cfg
wget $url/nuttx.exp

## Run the Test Script
chmod +x nuttx.exp
./nuttx.exp
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.cfg">(<strong>nuttx.cfg</strong> is our <strong>TinyEMU Config</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.exp">(<strong>nuttx.exp</strong> is our <strong>Expect Script</strong>)</a></p>
<p>That‚Äôs everything we need for Daily Automated Testing! Our Ox64 Emulator will emulate <a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/ostest_main.c"><strong><code>ostest</code></strong></a> and launch a whole bunch of tests‚Ä¶</p>
<span style="font-size:90%">
<p><a href="https://github.com/lupyuen/nuttx-ox64/actions/workflows/ox64-test.yml">(See the <strong>Test Log</strong>)</a></p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/ostest_main.c#L622-L639"><strong>Standard I/O</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/ostest_main.c#L146-L209"><strong>Environment Variables</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/setvbuf.c"><strong>Stream VBuf</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/mutex.c"><strong>Mutex</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/cancel.c"><strong>Start Thread</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/robust.c"><strong>Robust Mutex</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/sem.c"><strong>Semaphore</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/semtimed.c"><strong>Timed Semaphore</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/cond.c"><strong>Condition Variables</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/pthread_exit.c"><strong>PThread Exit</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/timedwait.c"><strong>Timed Wait</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/mqueue.c"><strong>Message Queue</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/timedmqueue.c"><strong>Timed Message Queue</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/sighand.c"><strong>Signal Handler</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/signest.c"><strong>Nested Signal Handler</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/posixtimer.c"><strong>POSIX Timer</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/roundrobin.c"><strong>Round-Robin Scheduler</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/barrier.c"><strong>PThread Barrier</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/schedlock.c"><strong>Scheduler Lock</strong></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div></span>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow2.jpg" alt="NuttX Kernel won‚Äôt work in Machine Mode" /></p>
<h1 id="boot-nuttx-in-supervisor-mode"><a href="#boot-nuttx-in-supervisor-mode">3 Boot NuttX in Supervisor Mode</a></h1>
<p><em>Ox64 Automated Testing doesn‚Äôt look so hard?</em></p>
<p>That‚Äôs because most of the tough work was done in our <strong>Ox64 BL808 Emulator</strong>! Let‚Äôs look back at the challenging bits‚Ä¶</p>
<p><em>What‚Äôs this Supervisor Mode? Why does it matter?</em></p>
<p>TinyEMU Emulator boots NuttX in <strong>RISC-V Machine Mode</strong>. (Pic above)</p>
<p>Which won‚Äôt work because NuttX expects to run in <strong>RISC-V Supervisor Mode</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tinyemu2#machine-mode-vs-supervisor-mode"><strong>‚ÄúMachine Mode vs Supervisor Mode‚Äù</strong></a></li>
</ul>
<p><em>But all Operating Systems should boot in Machine Mode. Right?</em></p>
<p>Actually a <strong>RISC-V SBC</strong> (like Ox64) will boot the <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI Supervisor Binary Interface</strong></a> in <strong>Machine Mode</strong>‚Ä¶</p>
<p>Followed by the <a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow"><strong>NuttX Kernel</strong></a> (or Linux Kernel) in <strong>Supervisor Mode</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow.jpg" alt="Ox64 SBC will run in Machine, Supervisor AND User Modes" /></p>
<p><em>How to fix this?</em></p>
<p>We tweak TinyEMU to boot NuttX in <strong>Supervisor Mode</strong> (instead of Machine Mode)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<p>We do this in the <strong>TinyEMU Boot Code</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L874-L885">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At Startup: Init the TinyEMU Boot Code...
void copy_bios(...) {
  ...
  // Load RAM_BASE_ADDR into Register T0.
  // That&#39;s 0x5020_0000, the Start Address of
  // NuttX Kernel (Linux too)
  auipc t0, RAM_BASE_ADDR

  // Load the Device Tree into Register A1.
  // (Used by Linux but not NuttX)
  auipc a1, dtb
  addi  a1, a1, dtb

  // Load the Hart ID (CPU ID: 0) into Register A0
  csrr  a0, mhartid
</code></pre></div>
<p>The code above comes from the original TinyEMU Emulator.</p>
<p>Next comes the code that we specially inserted for our <strong>Ox64 Emulator</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L882-L960">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Previously: We jump to RAM_BASE_ADDR in Machine Mode
  // Now: We jump to RAM_BASE_ADDR in Supervisor Mode...

  // Delegate all Exceptions to Supervisor Mode (instead of Machine Mode)
  // We set MEDELEG CSR Register to 0xFFFF
  lui   a5, 0x10   ; nop  // A5 is 0x10000
  addiw a5, a5, -1 ; nop  // A5 is 0xFFFF
  csrw  medeleg, a5

  // Delegate all Interrupts to Supervisor Mode (instead of Machine Mode)
  // We set MIDELEG CSR Register to 0xFFFF
  csrw  mideleg, a5

  // Rightfully: Follow the OpenSBI Settings for Ox64
  // Boot HART MIDELEG: 0x0222
  // Boot HART MEDELEG: 0xB109
</code></pre></div>
<p>(Why <strong>NOP</strong>? Because TinyEMU needs every instruction padded to 32 bits)</p>
<p>The code above delegates all <strong>Exceptions and Interrupts</strong> to <strong>RISC-V Supervisor Mode</strong>. (Instead of Machine Mode)</p>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-trap-delegation-registers-medeleg-and-mideleg">(<strong>MIDELEG and MEDELEG</strong> are explained here)</a></p>
<p>Next we set the <strong>Previous Privilege Mode</strong> to Supervisor Mode (we‚Äôll see why)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Clear these bits in MSTATUS CSR Register...
  // MPP (Bits 11 and 12): Clear the Previous Privilege Mode
  lui   a5, 0xffffe ; nop
  addiw a5, a5, 2047
  csrc  mstatus, a5

  // Set these bits in MSTATUS CSR Register...
  // MPPS (Bit 11): Previous Privilege Mode is Supervisor Mode
  // SUM  (Bit 18): Allow Supervisor Mode to access Memory of User Mode
  lui   a5, 0x41
  addiw a5, a5, -2048
  csrs  mstatus, a5
</code></pre></div>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush">(<strong>MSTATUS</strong> is explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/app#kernel-accesses-app-memory">(<strong>SUM</strong> is needed for NuttX Apps)</a></p>
<p><a href="https://gist.github.com/lupyuen/368744ef01b7feba10c022cd4f4c5ef2#file-nuttx-start-s-L1282-L1314">(Why <strong>Register A5</strong>? Because we copied from the <strong>NuttX QEMU Boot Code</strong>)</a></p>
<p>Why set Previous Privilege to Supervisor Mode? So we can execute an <strong>MRET (Return from Machine Mode)</strong> that will jump to the Previous Privilege‚Ä¶ <strong>Supervisor Mode!</strong></p>
<div class="example-wrap"><pre class="language-c"><code>  // Jump to RAM_BASE_ADDR in Supervisor Mode:
  // Set the MEPC CSR Register, then Return from Machine Mode
  csrw  mepc, t0
  mret
</code></pre></div>
<p><em>Do we need so much Boot Code?</em></p>
<p>Yes! Check out what happens if we remove some bits of our Boot Code from TinyEMU‚Ä¶</p>
<p>TODO: Appendix</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="UART Interrupts for Ox64 BL808 SBC" /></p>
<h1 id="emulate-the-uart-interrupts"><a href="#emulate-the-uart-interrupts">4 Emulate the UART Interrupts</a></h1>
<p><em>Ox64 SBC has a UART Controller that will handle Console Input‚Ä¶</em></p>
<p><em>How did we emulate the Ox64 UART Controller?</em></p>
<p>Previously we emulated the <strong>BL808 UART Registers</strong> to do Console Output‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tinyemu2#intercept-the-uart-registers"><strong>‚ÄúIntercept the UART Registers‚Äù</strong></a></li>
</ul>
<p>But Console Input is a little more tricky‚Ä¶ We need to emulate <strong>UART Interrupts</strong>! (Pic above)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/plic2"><strong>‚ÄúUART Interrupt and Platform-Level Interrupt Controller‚Äù</strong></a></li>
</ul>
<p><em>Is there a TinyEMU UART Controller that we can reuse?</em></p>
<p>TinyEMU has a <a href="https://lupyuen.github.io/articles/tinyemu#virtio-console"><strong>VirtIO Console</strong></a> that emulates a UART Controller.</p>
<p>Let‚Äôs hack TinyEMU‚Äôs VirtIO Console so that it behaves like <a href="https://lupyuen.github.io/articles/plic2#appendix-uart-driver-for-ox64"><strong>BL808 UART Controller</strong></a>.</p>
<p>We tweak the <strong>VirtIO Interrupt Number</strong> so it works like BL808 UART3: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L69-L85">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// VirtIO now emulates
// BL808 UART3 Interrupt
#define VIRTIO_IRQ 20
</code></pre></div>
<p>When we detect a keypress, we trigger the <strong>UART Interrupt</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/virtio.c#L1338-L1347">virtio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// When we receive a keypress...
int virtio_console_write_data(VIRTIODevice *s, const uint8_t *buf, int buf_len) {

  // Pass the keypress to NuttX later
  set_input(buf[0]);

  // Trigger the UART Interrupt
  s-&gt;int_status |= 1;
  set_irq(s-&gt;irq, 1);
</code></pre></div>
<p>TODO: set_input is defined here</p>
<p>TODO: set_irq is defined here</p>
<p>When we run this: TinyEMU loops forever handling UART Interrupts :-(</p>
<p><em>Surely we need to Clear the UART Interrupt?</em></p>
<p>We check our <strong>NuttX UART Driver</strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_serial.c#L166-L224">bl808_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Interrupt Handler for BL808 UART
int uart_interrupt(int irq, void *context, void *arg) {

  // At 0x3000_2020: Read the UART Interrupt Status (uart_int_sts)
  int_status = getreg32(BL808_UART_INT_STS(uart_idx));

  // At 0x3000_2024: Read the UART Interrupt Mask (uart_int_mask)
  int_mask = getreg32(BL808_UART_INT_MASK(uart_idx));

  // If there&#39;s UART Input...
  if ((int_status &amp; UART_INT_STS_URX_END_INT) &amp;&amp;
    !(int_mask &amp; UART_INT_MASK_CR_URX_END_MASK)) {

    // At 0x3000_2028: Clear the UART Interrupt (uart_int_clear)
    putreg32(UART_INT_CLEAR_CR_URX_END_CLR, BL808_UART_INT_CLEAR(uart_idx));

    // At 0x3000_208C: Read the UART Input (uart_fifo_rdata)
    uart_recvchars(dev);
</code></pre></div>
<p>TODO: uart_recvchars is defined here</p>
<p>Aha! We must emulate the <strong>BL808 UART Registers</strong> above‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L402-L407"><strong>UART Interrupt Status</strong></a> should say there‚Äôs UART Input</p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>uart_int_sts</strong>, Page 419)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L407-L412"><strong>UART Interrupt Mask</strong></a> should return 0</p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>uart_int_mask</strong>, Page 420)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L526-L532"><strong>UART Clear Interrupt</strong></a> should clear the VirtIO Interrupt</p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>uart_int_clear</strong>, Page 421)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L412-L422"><strong>UART Input</strong></a> should return the keypress</p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>uart_fifo_rdata</strong>, Page 428)</a></p>
</li>
</ol>
<p>Now we see NuttX correctly handling the UART Interrupt triggered by TinyEMU‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## When we press a key...
## TinyEMU triggers the UART Interrupt
plic_set_irq: irq_num=20, state=1
plic_update_mip: set_mip, pending=0x80000, served=0x0
raise_exception: cause=-2147483639
raise_exception2: cause=-2147483639, tval=0x0

## NuttX Claims the UART Interrupt
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000, served=0x80000

## NuttX handles the UART Interrupt in Interrupt Handler
virtio_ack_irq
plic_set_irq: irq_num=20, state=0
plic_update_mip: reset_mip, pending=0x0, served=0x80000

## NuttX Completes the UART Interrupt
plic_write: offset=0x201004, val=0x14
plic_update_mip: reset_mip, pending=0x0, served=0x0
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/de071bf54b603f4aaff3954648dcc340#file-ox64-tinyemu-log-L129-L172">(See the Complete Log)</a></p>
<p>Finally Console Input works OK yay!</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/timer">Live Demo of <strong>Ox64 BL808 Emulator</strong></a></p>
</li>
<li>
<p><a href="https://youtu.be/FAxaMt6A59I">Watch the <strong>Demo on YouTube</strong></a></p>
</li>
</ul>
<p>A few more tweaks to TinyEMU VirtIO for Console Input‚Ä¶</p>
<ol>
<li>
<p>We disable the <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/virtio.c#L1370-L1382"><strong>Console Resize Event</strong></a></p>
<p>(Because it crashes NuttX at startup)</p>
</li>
<li>
<p>We always allow <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/virtio.c#L1297-L1313"><strong>VirtIO to Write Data</strong></a></p>
</li>
<li>
<p>We‚Äôre always <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/virtio.c#L1313-L1338"><strong>Ready for VirtIO Writes</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will emulate the System Timer" /></p>
<h1 id="emulate-the-system-timer"><a href="#emulate-the-system-timer">5 Emulate the System Timer</a></h1>
<p><em>NuttX can‚Äôt access the System Timer because it runs in RISC-V Supervisor Mode‚Ä¶</em></p>
<p><em>What can we do to help NuttX?</em></p>
<p>NuttX will make a <strong>System Call (ECALL)</strong> to OpenSBI to start the System Timer (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nim#appendix-opensbi-timer-for-nuttx"><strong>‚ÄúOpenSBI Timer for NuttX‚Äù</strong></a></li>
</ul>
<p>And NuttX reads the System Time through the <strong>TIME CSR Register</strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/supervisor/riscv_sbi.c#L108-L141">riscv_sbi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fetch the System Time...
uint64_t riscv_sbi_get_time(void) {

  // Read the TIME CSR Register, which becomes
  // the `RDTIME` RISC-V Instruction
  return READ_CSR(time);
}
</code></pre></div>
<p>Thus we emulate the <a href="https://lupyuen.github.io/articles/sbi#set-a-system-timer"><strong>OpenSBI System Timer</strong></a> and the <a href="https://five-embeddev.com/riscv-isa-manual/latest/counters.html#zicntr-standard-extension-for-base-counters-and-timers"><strong>TIME CSR Register</strong></a>.</p>
<p><strong>At Startup:</strong> We search for the ECALL to OpenSBI and remember the <strong>ECALL Address</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L916-L927">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Scan the Kernel Image for Special Instructions...
uint8_t *kernel_ptr = get_ram_ptr(s, RAM_BASE_ADDR, TRUE);
for (int i = 0; i &lt; 0x10000; i++) {

  // If we find the ECALL Instruction:
  // 00000073 ecall
  const uint8_t ecall[] = { 0x73, 0x00, 0x00, 0x00 };
  if (memcmp(&amp;kernel_ptr[i], ecall, sizeof(ecall)) == 0) {

    // Remember the ECALL Address
    ecall_addr = RAM_BASE_ADDR + i;
  }
</code></pre></div>
<p>The <a href="https://five-embeddev.com/riscv-isa-manual/latest/counters.html#zicntr-standard-extension-for-base-counters-and-timers"><strong>TIME CSR Register</strong></a> gets assembled into the <a href="https://five-embeddev.com/riscv-isa-manual/latest/counters.html#zicntr-standard-extension-for-base-counters-and-timers"><strong>RDTIME RISC-V Instruction</strong></a>‚Ä¶</p>
<p>But <strong>RDTIME</strong> isn‚Äôt supported by TinyEMU. <a href="https://five-embeddev.com/riscv-isa-manual/latest/counters.html#zicntr-standard-extension-for-base-counters-and-timers">(Needs the <strong>Zicntr Extension</strong>)</a></p>
<p>Hence we patch <strong>RDTIME</strong> to become <strong>ECALL</strong> and we emulate later: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L927-L937">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // If we find the RDTIME Instruction: (Read System Time)
  // c0102573 rdtime a0
  const uint8_t rdtime[] = { 0x73, 0x25, 0x10, 0xc0 };
  if (memcmp(&amp;kernel_ptr[i], rdtime, sizeof(rdtime)) == 0) {

    // Patch RDTIME to become ECALL
    memcpy(&amp;kernel_ptr[i], ecall,  sizeof(ecall));

    // Remember the RDTIME Address
    rdtime_addr = RAM_BASE_ADDR + i;
  }
</code></pre></div>
<p>How to handle both ECALLs? Check the details here‚Ä¶</p>
<p>TODO: Appendix</p>
<p><em>Anything else we patched?</em></p>
<p>We patched these Special RISC-V Instructions to become ECALL:  <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L937-L956"><strong>DCACHE.IALL</strong> and <strong>SYNC.S</strong></a></p>
<p>These instructions are specific to <strong>T-Head C906 CPU</strong>. NuttX calls them to <a href="https://lupyuen.github.io/articles/mmu#appendix-flush-the-mmu-cache-for-t-head-c906"><strong>Flush the MMU Cache</strong></a>.</p>
<p>(Though we won‚Äôt emulate them yet)</p>
<p>TODO: <a href="https://gist.github.com/lupyuen/31bde9c2563e8ea2f1764fb95c6ea0fc">Emulator Timer Log</a></p>
<p>Test <code>ostest</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>semtimed_test: Starting poster thread
semtimed_test: Set thread 1 priority to 191
semtimed_test: Starting poster thread 3
semtimed_test: Set thread 3 priority to 64
semtimed_test: Waiting for two second timeout
poster_func: Waiting for 1 second
semtimed_test: ERROR: sem_timedwait failed with: 110
_assert: Current Version: NuttX  12.4.0-RC0 55ec92e181 Jan 24 2024 00:11:51 risc
-v
_assert: Assertion failed (_Bool)0: at file: semtimed.c:240 task: ostest process
: ostest 0x8000004a
up_dump_register: EPC: 0000000050202008
</code></pre></div>
<p>TODO: <a href="https://github.com/lupyuen/ox64-tinyemu/commit/169dd727a5e06bdc95ac3f32e1f1b119c3cbbb75">Remove the Timer Interrupt Interval because ostest will fail</a></p>
<p>TODO: <a href="https://lupyuen.github.io/nuttx-tinyemu/timer/"><code>ostest</code> is OK yay!</a></p>
<h1 id="whats-next"><a href="#whats-next">6 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tinyemu3.md"><strong>lupyuen.github.io/src/tinyemu3.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<h1 id="appendix-boot-nuttx-in-supervisor-mode"><a href="#appendix-boot-nuttx-in-supervisor-mode">7 Appendix: Boot NuttX in Supervisor Mode</a></h1>
<p>Earlier we saw a big chunk of <strong>TinyEMU Boot Code</strong> (pic above) that will start <strong>NuttX in RISC-V Supervisor Mode</strong> (instead of Machine Mode)‚Ä¶</p>
<p>TODO</p>
<p><em>Can‚Äôt we call MRET directly? And jump from Machine Mode to Supervisor Mode?</em></p>
<p>TODO: machine exception delegation register (medeleg) and machine interrupt delegation register ( mideleg)</p>
<p>TODO: <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#sec:mcause">MCAUSE</a></p>
<p>TODO</p>
<p><em>NuttX needs to boot in Supervisor Mode, not Machine Mode. How to fix this in TinyEMU?</em></p>
<p>We copy to TinyEMU Boot Code the Machine-Mode Start Code from <a href="https://gist.github.com/lupyuen/368744ef01b7feba10c022cd4f4c5ef2">NuttX Start Code for 64-bit RISC-V Kernel Mode (rv-virt:knsh64)</a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/e62d49f1a8b27002871f712e80b1785442e23393">Execute the MRET Instruction to jump from Machine Mode to Supervisor Mode</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/37c2d1169706a56afbd2d7d2a13624b58269e1ef#diff-2080434ac7de762b1948a6bc493874b21b9e3df3de8b9e52de23bfdcec354abd">Dump the RISC-V Registers MCAUSE 2: Illegal Instruction</a> (for easier troubleshooting)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<div class="example-wrap"><pre class="language-text"><code>TinyEMU Emulator for Ox64 BL808 RISC-V SBC
virtio_console_init
csr_write: csr=0x341 val=0x0000000050200000
raise_exception2: cause=2, tval=0x10401073
pc =0000000050200074 ra =0000000000000000 sp =0000000050407c00 gp =0000000000000000
tp =0000000000000000 t0 =0000000050200000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000000 s1 =0000000000000000 a0 =0000000000000000 a1 =0000000000001040
a2 =0000000000000000 a3 =0000000000000000 a4 =0000000000000000 a5 =0000000000000000
a6 =0000000000000000 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =fffffffffffffff3 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a00000080 cycles=13
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
raise_exception2: cause=2, tval=0x0
pc =0000000000000000 ra =0000000000000000 sp =0000000050407c00 gp = 
</code></pre></div>
<p>Which fails with an Illegal Instuction. The offending code comes from‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/bl808_head.S:124
2:
  /* Disable all interrupts (i.e. timer, external) in sie */
  csrw	sie, zero
    50200074:	10401073          	csrw	sie,zero
</code></pre></div>
<p><em>Why is this instruction invalid?</em></p>
<p><code>csrw sie,zero</code> is invalid because we‚Äôre in User Mode (<code>priv=U</code>), not Supervisor Mode. And SIE is a Supervisor-Mode CSR Register.</p>
<p>So we <a href="https://github.com/lupyuen/ox64-tinyemu/commit/d379d92bfe544681e0560306a1aad96f5792da9e">set MSTATUS to Supervisor Mode and enable SUM</a>.</p>
<div class="example-wrap"><pre class="language-text"><code>TinyEMU Emulator for Ox64 BL808 RISC-V SBC
virtio_console_init
raise_exception2: cause=2, tval=0x879b0000
pc =0000000000001012 ra =0000000000000000 sp =0000000000000000 gp =0000000000000000
tp =0000000000000000 t0 =0000000050200000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000000 s1 =0000000000000000 a0 =0000000000000000 a1 =0000000000001040
a2 =0000000000000000 a3 =0000000000000000 a4 =0000000000000000 a5 =ffffffffffffe000
a6 =0000000000000000 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=M mstatus=0000000a00000000 cycles=4
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
tinyemu: Unknown mcause 2, quitting
</code></pre></div>
<p>Now we hit an Illegal Instruction caused by an unpadded 16-bit instruction: 0x879b0000.</p>
<p>TinyEMU requires all Boot Code Instructions to be 32-bit. So we <a href="https://github.com/lupyuen/ox64-tinyemu/commit/23a36478cf03561d40f357f876284c09722ce455">insert NOP (0x0001) to pad 16-bit RISC-V Instructions to 32-bit</a>.</p>
<div class="example-wrap"><pre class="language-text"><code>work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
up_exit: TCB=0x504098d0 exiting

raise_exception2: cause=8, tval=0x0
pc =00000000800019c6 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a000400a1 cycles=79648442
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080

raise_exception2: cause=2, tval=0x0
pc =0000000000000000 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=M mstatus=0000000a000400a1 cycles=79648467
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
tinyemu: Unknown mcause 2, quitting
</code></pre></div>
<p>But the ECALL goes from User Mode (<code>priv=U</code>) to Machine Mode (<code>priv=M</code>), not Supervisor Mode!</p>
<p>We <a href="https://github.com/lupyuen/ox64-tinyemu/commit/9536e86217bcccbe15272dc4450eac9fab173b03">set the Exception and Interrupt delegation for Supervisor Mode</a>.</p>
<p>Finally NuttX Shell starts OK yay! User Mode ECALLs are working perfectly!</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/timer"><em>(Live Demo of Ox64 BL808 Emulator)</em></a></p>
<p><a href="https://youtu.be/FAxaMt6A59I"><em>(Watch the Demo on YouTube)</em></a></p>
<div class="example-wrap"><pre class="language-text"><code>work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
up_exit: TCB=0x504098d0 exiting
NuttShell (NSH) NuttX-12.4.0
nsh&gt;
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/de071bf54b603f4aaff3954648dcc340">(See the Complete Log)</a></p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will emulate the System Timer" /></p>
<h1 id="appendix-start-the-system-timer"><a href="#appendix-start-the-system-timer">8 Appendix: Start the System Timer</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L1164-L1182">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Called by TinyEMU to handle RISC-V Exceptions
void raise_exception2(RISCVCPUState *s, uint32_t cause, target_ulong tval) {
  ...
  // If this is an ECALL from Supervisor Mode...
  // (Not ECALL from User Mode)
  if (cause == CAUSE_SUPERVISOR_ECALL) {

    // If Program Counter is the
    // ECALL to OpenSBI...
    if (s-&gt;pc == ecall_addr) {

      // We emulate the OpenSBI Set Timer Function:
      // https://github.com/riscv-non-isa/riscv-sbi-doc/blob/v1.0.0/riscv-sbi.adoc#61-function-set-timer-fid-0

      // If Parameter A0 is not -1, set the System Timer (timecmp)
      // Parameter A0 is Register X10
      uint64_t timecmp = s-&gt;reg[10];
      if (timecmp != (uint64_t) -1) {
        set_timecmp(NULL, timecmp);
        // TODO: We clear the Pending Timer Interrupt Bit.
      }

      // Skip to the next instruction (RET)
      s-&gt;pc += 4;
      return;          
</code></pre></div>
<p><strong>set_timecmp</strong> sets the System Timer: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L1225-L1235">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Set the System Timer
void set_timecmp(RISCVMachine *machine0, uint64_t timecmp) {

  // At Startup: Remember the RISC-V Machine and return
  static RISCVMachine *machine = NULL;
  if (machine0 != NULL) { machine = machine0; return; }

  // Otherwise set the System Timer
  if (machine == NULL) { puts(&quot;set_timecmp: machine is null&quot;); return; }
  machine-&gt;timecmp = timecmp;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L1136-L1140">(<strong>set_timecmp</strong> is initialised by <strong>riscv_machine_init</strong>)</a></p>
<h1 id="appendix-read-the-system-time"><a href="#appendix-read-the-system-time">9 Appendix: Read the System Time</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L1183-L1195">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Called by TinyEMU to handle RISC-V Exceptions
void raise_exception2(RISCVCPUState *s, uint32_t cause, target_ulong tval) {
  ...
  // If this is an ECALL from Supervisor Mode...
  // (Not ECALL from User Mode)
  if (cause == CAUSE_SUPERVISOR_ECALL) {

    // If Program Counter is the
    // (formerly) RDTIME Instruction...
    if (s-&gt;pc == rdtime_addr) {

      // We emulate the RDTIME Instruction to fetch the System Time:
      // https://five-embeddev.com/riscv-isa-manual/latest/counters.html#zicntr-standard-extension-for-base-counters-and-timers

      // Return the System Time in Register A0
      // Which is aliased to Register X10
      s-&gt;reg[10] = real_time;

      // Skip to the next instruction (RET)
      s-&gt;pc += 4;
      return; 
</code></pre></div>
<p>TODO: <strong>set_timecmp</strong> is here</p>
<p>TODO: real_time is set by</p>
<h1 id="appendix-trigger-the-timer-interrupt"><a href="#appendix-trigger-the-timer-interrupt">10 Appendix: Trigger the Timer Interrupt</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L1172-L1182">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Called by TinyEMU periodically to check the System Timer
static int riscv_machine_get_sleep_duration(VirtMachine *s1, int delay) {
  ...
  // Pass the System Time to raise_exception2()
  real_time = rtc_get_time(m);

  // If the System Timer has expired...
  if (!(riscv_cpu_get_mip(s) &amp; MIP_STIP)) {

    // Trigger the Timer Interrupt for Supervisor Mode
    const int64_t delay2 = m-&gt;timecmp - rtc_get_time(m);
    if (delay2 &lt;= 0) {
      riscv_cpu_set_mip(s, MIP_STIP);
    }
  }
</code></pre></div>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/758287cc3aa8165303c6a726292e665af099aefd">For OpenSBI Set Timer: Clear the pending timer interrupt bit</a></p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/1bcf19a4b2354bc47b515a3fe2f2e8a427e3900d">For RDTIME: Return the time</a></p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/ddedb862a786e52b17cf3331752d50662eddffd3">Regularly trigger the Supervisor-Mode Timer Interrupt</a></p>
<p><code>usleep</code> works OK yay!</p>
<div class="example-wrap"><pre class="language-text"><code>Loading...
TinyEMU Emulator for Ox64 BL808 RISC-V SBC
ABC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; usleep 1
nsh&gt; 
</code></pre></div>
    
</body>
</html>