<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tinyemu3-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/tinyemu3.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)</h1>
    <nav id="TOC"><ul>
<li><a href="#scripting-the-expected">1 Scripting The Expected</a><ul></ul></li>
<li><a href="#daily-automated-testing">2 Daily Automated Testing</a><ul></ul></li>
<li><a href="#boot-nuttx-in-supervisor-mode">3 Boot NuttX in Supervisor Mode</a><ul></ul></li>
<li><a href="#emulate-uart-interrupts">4 Emulate UART Interrupts</a><ul></ul></li>
<li><a href="#emulate-opensbi-for-system-timer">5 Emulate OpenSBI for System Timer</a><ul></ul></li>
<li><a href="#fix-the-system-timer">6 Fix the System Timer</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-boot-nuttx-in-supervisor-mode">8 Appendix: Boot NuttX in Supervisor Mode</a><ul></ul></li></ul></nav><p>üìù <em>29 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/tinyemu3-title.png" alt="Automated Testing with Ox64 BL808 Emulator (Apache NuttX RTOS)" /></p>
<p><em>Every day we‚Äôre auto-building Apache NuttX RTOS for Ox64 BL808 SBC‚Ä¶</em></p>
<p><em>Can we test NuttX on Ox64 automatically after building?</em></p>
<p>Yes we can! With a little help from the <strong>Ox64 BL808 Emulator</strong> that we created last week‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tinyemu2"><strong>‚ÄúEmulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p><em>But our Ox64 Emulator was incomplete?</em></p>
<p>Today we fill in the missing pieces of our Ox64 Emulator and call it for <strong>Automated Testing</strong>‚Ä¶</p>
<ul>
<li>
<p>TODO: Boot NuttX in Supervisor Mode</p>
</li>
<li>
<p>TODO: Emulate UART Interrupts for Console Input</p>
</li>
<li>
<p>TODO: Emulate OpenSBI for System Timer</p>
</li>
<li>
<p>TODO: Fix the System Timer</p>
</li>
<li>
<p>TODO: Scripting The Expected</p>
</li>
<li>
<p>TODO: Daily Automated Testing</p>
</li>
</ul>
<p>We begin with the easier bit: Scripting our Ox64 Emulator‚Ä¶</p>
<h1 id="scripting-the-expected"><a href="#scripting-the-expected">1 Scripting The Expected</a></h1>
<p><em>What‚Äôs this ‚ÄúExpect Scripting‚Äù?</em></p>
<p><strong><code>expect</code></strong> is a cool Command-Line Tool that sends commands to another app and checks the responses.</p>
<p><em>How is it used for Automated Testing?</em></p>
<p>Normally when we start our Ox64 Emulator, it boots NuttX and <strong>waits for our command</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Start our Ox64 Emulator with NuttX
$ ./temu nuttx.cfg

TinyEMU Emulator for Ox64 BL808 RISC-V SBC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt;
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.cfg">(<strong>nuttx.cfg</strong> is our <strong>TinyEMU Config</strong>)</a></p>
<p>But with an <strong>Expect Script</strong>, we can <strong>feed our commands automatically</strong> into the Emulator!</p>
<div class="example-wrap"><pre class="language-text"><code>## Run our Expect Script...
$ ./nuttx.exp

## Which starts the Ox64 Emulator...
spawn ./temu nuttx.cfg

  ## And sends a Command to the Emulator
  nsh&gt; uname -a
  NuttX 12.4.0-RC0 55ec92e181 Jan 24 2024 00:11:08 risc-v ox64
  nsh&gt; 
</code></pre></div>
<p>That‚Äôs why we create an Expect Script to test Ox64 NuttX.</p>
<p><em>What‚Äôs nuttx.exp?</em></p>
<p>That‚Äôs our <strong>Expect Script</strong> containing the commands that will be sent to our Emulator: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.exp">nuttx.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX with Ox64 BL808 Emulator

## For every 1 character sent, wait 0.001 milliseconds
set send_slow {1 0.001}

## Start the Ox64 BL808 Emulator
spawn ./temu nuttx.cfg

## Wait for the prompt and enter `uname -a`
## `send -s` will send slowly (0.001 ms per char)
expect &quot;nsh&gt; &quot;
send -s &quot;uname -a\r&quot;
</code></pre></div>
<p><em>Will it work for complicated tests?</em></p>
<p>Yep we may use <strong>Pattern Matching</strong> and <strong>Timeout Detection</strong> in our script: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.exp">nuttx.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Wait for the prompt and enter `ostest`
expect &quot;nsh&gt; &quot;
send -s &quot;ostest\r&quot;

## Wait at most 30 seconds
set timeout 30

## Check the response...
expect {
  ## If we see this message, exit normally
  &quot;ostest_main: Exiting with status -1&quot; { exit 0 }

  ## If timeout, exit with an error
  timeout { exit 1 }
}
</code></pre></div>
<p>Which works great for thoroughly exercising <strong>NuttX on our Ox64 Emulator</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Run our Expect Script to start Ox64 Emulator...
$ ./nuttx.exp
spawn ./temu nuttx.cfg

  ## And run all kinds of NuttX Tests
  nsh&gt; ostest
  ...
  ostest_main: Exiting with status -1
  nsh&gt;

## Our Expect Script completes successfully
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/actions/workflows/ox64-test.yml">(See the <strong>Test Log</strong>)</a></p>
<h1 id="daily-automated-testing"><a href="#daily-automated-testing">2 Daily Automated Testing</a></h1>
<p><em>We run this every day?</em></p>
<p><strong>GitHub Actions</strong> will start our Automated Test every day at 12:55am (GMT): <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml">ox64-test.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## Run our Automated Test
## Every day at 0:55 UTC
## (After Daily Build at 0:00 UTC)
on:
  schedule:
    - cron: &#39;55 0 * * *&#39;
</code></pre></div>
<p><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#schedule">(Why not one o‚Äôclock? <strong>It‚Äôs too busy</strong>)</a></p>
<p>We build our <strong>Ox64 BL808 Emulator</strong>: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml#L18-L58">ox64-test.yml</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Install `expect` and the Build Prerequisites on Ubuntu
sudo apt -y update
sudo apt -y install \
  expect libcurl4-openssl-dev libssl-dev zlib1g-dev libsdl2-dev wget

## Build Ox64 BL808 Emulator
git clone https://github.com/lupyuen/ox64-tinyemu
pushd ox64-tinyemu
make
cp temu ..
popd
</code></pre></div>
<p>Download the <strong>Daily NuttX Build</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Location of Daily NuttX Builds
## `outputs.date` looks like `2024-01-25`
url=https://github.com/lupyuen/nuttx-ox64/releases/download/nuttx-ox64-${{ steps.date.outputs.date }}

## Download the NuttX Build and show the Git Hash
wget $url/Image
wget $url/nuttx.hash
cat nuttx.hash
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/tags">(<strong>NuttX Builds</strong> are here)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml#L25-L29">(<strong>outputs.date</strong> is defined here)</a></p>
<p>And start our <strong>Test Script</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Test Script from
## https://github.com/lupyuen/nuttx-ox64
url=https://github.com/lupyuen/nuttx-ox64/raw/main
wget $url/nuttx.cfg
wget $url/nuttx.exp

## Run the Test Script
chmod +x nuttx.exp
./nuttx.exp
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.cfg">(<strong>nuttx.cfg</strong> is our <strong>TinyEMU Config</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64/blob/main/nuttx.exp">(<strong>nuttx.exp</strong> is our <strong>Expect Script</strong>)</a></p>
<p>That‚Äôs everything we need for Daily Automated Testing! Our Ox64 Emulator will emulate <a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/ostest_main.c"><strong><code>ostest</code></strong></a> and launch a whole bunch of tests‚Ä¶</p>
<span style="font-size:90%">
<p><a href="https://github.com/lupyuen/nuttx-ox64/actions/workflows/ox64-test.yml">(See the <strong>Test Log</strong>)</a></p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/ostest_main.c#L622-L639"><strong>Standard I/O</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/ostest_main.c#L146-L209"><strong>Environment Variables</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/setvbuf.c"><strong>Stream VBuf</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/mutex.c"><strong>Mutex</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/cancel.c"><strong>Start Thread</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/robust.c"><strong>Robust Mutex</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/sem.c"><strong>Semaphore</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/semtimed.c"><strong>Timed Semaphore</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/cond.c"><strong>Condition Variables</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/pthread_exit.c"><strong>PThread Exit</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/timedwait.c"><strong>Timed Wait</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/mqueue.c"><strong>Message Queue</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/timedmqueue.c"><strong>Timed Message Queue</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/sighand.c"><strong>Signal Handler</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/signest.c"><strong>Nested Signal Handler</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/posixtimer.c"><strong>POSIX Timer</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/roundrobin.c"><strong>Round-Robin Scheduler</strong></a></td><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/barrier.c"><strong>PThread Barrier</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx-apps/tree/master/testing/ostest/schedlock.c"><strong>Scheduler Lock</strong></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div></span>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow2.jpg" alt="NuttX Kernel won‚Äôt work in Machine Mode" /></p>
<h1 id="boot-nuttx-in-supervisor-mode"><a href="#boot-nuttx-in-supervisor-mode">3 Boot NuttX in Supervisor Mode</a></h1>
<p><em>Ox64 Automated Testing doesn‚Äôt look so hard?</em></p>
<p>That‚Äôs because most of the tough work was done in our <strong>Ox64 BL808 Emulator</strong>! Let‚Äôs look back at the challenging bits‚Ä¶</p>
<p><em>What‚Äôs this Supervisor Mode? Why does it matter?</em></p>
<p>TinyEMU Emulator boots NuttX in <strong>RISC-V Machine Mode</strong>. (Pic above)</p>
<p>Which won‚Äôt work because NuttX expects to run in <strong>RISC-V Supervisor Mode</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tinyemu2#machine-mode-vs-supervisor-mode"><strong>‚ÄúMachine Mode vs Supervisor Mode‚Äù</strong></a></li>
</ul>
<p><em>But all Operating Systems should boot in Machine Mode. Right?</em></p>
<p>Actually a <strong>RISC-V SBC</strong> (like Ox64) will boot the <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI Supervisor Binary Interface</strong></a> in <strong>Machine Mode</strong>‚Ä¶</p>
<p>Followed by the <a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow"><strong>NuttX Kernel</strong></a> (or Linux Kernel) in <strong>Supervisor Mode</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow.jpg" alt="Ox64 SBC will run in Machine, Supervisor AND User Modes" /></p>
<p><em>How to fix this?</em></p>
<p>We tweak TinyEMU to boot NuttX in <strong>Supervisor Mode</strong> (instead of Machine Mode)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<p>We do this in the <strong>TinyEMU Boot Code</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L874-L885">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At Startup: Init the TinyEMU Boot Code...
void copy_bios(...) {
  ...
  // Load RAM_BASE_ADDR into Register T0.
  // That&#39;s 0x5020_0000, the Start Address of
  // NuttX Kernel (Linux too)
  auipc t0, RAM_BASE_ADDR

  // Load the Device Tree into Register A1.
  // (Used by Linux but not NuttX)
  auipc a1, dtb
  addi  a1, a1, dtb

  // Load the Hart ID (CPU ID: 0) into Register A0
  csrr  a0, mhartid
</code></pre></div>
<p>The code above comes from the original TinyEMU Emulator.</p>
<p>Next comes the code that we specially inserted for our <strong>Ox64 Emulator</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L882-L960">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Previously: We jump to RAM_BASE_ADDR in Machine Mode
  // Now: We jump to RAM_BASE_ADDR in Supervisor Mode...

  // Delegate all Exceptions to Supervisor Mode (instead of Machine Mode)
  // We set MEDELEG CSR Register to 0xFFFF
  lui   a5, 0x10   ; nop  // A5 is 0x10000
  addiw a5, a5, -1 ; nop  // A5 is 0xFFFF
  csrw  medeleg, a5

  // Delegate all Interrupts to Supervisor Mode (instead of Machine Mode)
  // We set MIDELEG CSR Register to 0xFFFF
  csrw  mideleg, a5

  // Rightfully: Follow the OpenSBI Settings for Ox64
  // Boot HART MIDELEG: 0x0222
  // Boot HART MEDELEG: 0xB109
</code></pre></div>
<p>(Why <strong>NOP</strong>? Because TinyEMU needs every instruction padded to 32 bits)</p>
<p>The code above delegates all <strong>Exceptions and Interrupts</strong> to <strong>RISC-V Supervisor Mode</strong>. (Instead of Machine Mode)</p>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-trap-delegation-registers-medeleg-and-mideleg">(<strong>MIDELEG and MEDELEG</strong> are explained here)</a></p>
<p>Next we set the <strong>Previous Privilege Mode</strong> to Supervisor Mode (we‚Äôll see why)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Clear these bits in MSTATUS CSR Register...
  // MPP (Bits 11 and 12): Clear the Previous Privilege Mode
  lui   a5, 0xffffe ; nop
  addiw a5, a5, 2047
  csrc  mstatus, a5

  // Set these bits in MSTATUS CSR Register...
  // MPPS (Bit 11): Previous Privilege Mode is Supervisor Mode
  // SUM  (Bit 18): Allow Supervisor Mode to access Memory of User Mode
  lui   a5, 0x41
  addiw a5, a5, -2048
  csrs  mstatus, a5
</code></pre></div>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush">(<strong>MSTATUS</strong> is explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/app#kernel-accesses-app-memory">(<strong>SUM</strong> is needed for NuttX Apps)</a></p>
<p><a href="https://gist.github.com/lupyuen/368744ef01b7feba10c022cd4f4c5ef2#file-nuttx-start-s-L1282-L1314">(Why <strong>Register A5</strong>? Because we copied from the <strong>NuttX QEMU Boot Code</strong>)</a></p>
<p>Why set Previous Privilege to Supervisor Mode? So we can execute an <strong>MRET (Return from Machine Mode)</strong> that will jump to the Previous Privilege‚Ä¶ <strong>Supervisor Mode!</strong></p>
<div class="example-wrap"><pre class="language-c"><code>  // Jump to RAM_BASE_ADDR in Supervisor Mode:
  // Set the MEPC CSR Register, then Return from Machine Mode
  csrw  mepc, t0
  mret
</code></pre></div>
<p><em>Do we need so much Boot Code?</em></p>
<p>Yes! Check out what happens if we remove some bits of our Boot Code from TinyEMU‚Ä¶</p>
<p>TODO: Appendix</p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="UART Interrupts for Ox64 BL808 SBC" /></p>
<h1 id="emulate-uart-interrupts"><a href="#emulate-uart-interrupts">4 Emulate UART Interrupts</a></h1>
<p><em>Ox64 SBC has a UART Controller that will handle Console Input‚Ä¶</em></p>
<p><em>How did we emulate the Ox64 UART Controller?</em></p>
<p>Previously we emulated the <strong>BL808 UART Registers</strong> to do Console Output‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tinyemu2#intercept-the-uart-registers"><strong>‚ÄúIntercept the UART Registers‚Äù</strong></a></li>
</ul>
<p>But Console Input is a little more tricky‚Ä¶ We need to emulate <strong>UART Interrupts</strong>! (Pic above)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/plic2"><strong>‚ÄúUART Interrupt and Platform-Level Interrupt Controller‚Äù</strong></a></li>
</ul>
<p><em>Is there a TinyEMU UART Controller that we can reuse?</em></p>
<p>TinyEMU has a <a href="https://lupyuen.github.io/articles/tinyemu#virtio-console"><strong>VirtIO Console</strong></a> that emulates a UART Controller.</p>
<p>Let‚Äôs hack TinyEMU‚Äôs VirtIO Console so that it behaves like <a href="https://lupyuen.github.io/articles/plic2#appendix-uart-driver-for-ox64"><strong>BL808 UART Controller</strong></a>.</p>
<p>We tweak the <strong>VirtIO Interrupt Number</strong> so it works like BL808 UART3: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L69-L85">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// VirtIO now emulates
// BL808 UART3 Interrupt
#define VIRTIO_IRQ 20
</code></pre></div>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/dc869fe6a9a726d413e8a83c56cf40f271c6fe3c">Disable Console Resize event because it crashes VM Guest at startup</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/93cd86a7311986e5063cb0c8e368f89cdae73e27">We always allow VirtIO Write Data</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/b893255b42a8aaa443f7264dc06537b96326b414">Ww‚Äôre always ready for VirtIO Writes</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/a3d029e6e08d1ee3147f41536df76dc3986cb23e">Handle a keypress</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/3deaef2a5d5ca3ad8a4339c21be3b054fba4fda2">To handle a keypress, we trigger the UART3 Interrupt</a></p>
</li>
</ul>
<p>When we press a key, we see the UART Interrupt fired in NuttX!</p>
<div class="example-wrap"><pre class="language-text"><code>nx_start: CPU0: Beginning Idle Loop
[a]
plic_set_irq: irq_num=20, state=1
plic_update_mip: set_mip, pending=0x80000, served=0x0
raise_exception: cause=-2147483639
raise_exception: sleep
raise_exception2: cause=-2147483639, tval=0x0

## Claim Interrupt
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000, served=0x80000

## Handle Interrupt in Interrupt Handler
target_read_slow: invalid physical address 0x0000000030002020
target_read_slow: invalid physical address 0x0000000030002024

## Complete Interrupt
plic_write: offset=0x201004, val=0x14

## Loop Again
plic_update_mip: set_mip, pending=0x80000, served=0x0
raise_exception: cause=-2147483639
raise_exception: sleep
raise_exception2: cause=-2147483639, tval=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000, served=0x80000
target_read_slow: invalid physical address 0x0000000030002020
target_read_slow: invalid physical address 0x0000000030002024
plic_write: offset=0x201004, val=0x14
</code></pre></div>
<p>But TinyEMU loops forever handling UART Interrupts. We check our NuttX UART Driver: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu4/arch/risc-v/src/bl808/bl808_serial.c#L166-L224">bl808_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Interrupt Handler for BL808 UART
static int __uart_interrupt(int irq, void *context, void *arg) {
  // 0x000020  /* UART interrupt status */
  int_status = getreg32(BL808_UART_INT_STS(uart_idx));

  // 0x000024  /* UART interrupt mask */
  int_mask = getreg32(BL808_UART_INT_MASK(uart_idx));

  /* Length of uart rx data transfer arrived interrupt */
  if ((int_status &amp; UART_INT_STS_URX_END_INT) &amp;&amp;
      !(int_mask &amp; UART_INT_MASK_CR_URX_END_MASK))
    {
      // 0x000028  /* UART interrupt clear */
      putreg32(UART_INT_CLEAR_CR_URX_END_CLR,
               BL808_UART_INT_CLEAR(uart_idx));
      /* Receive Data ready */
      uart_recvchars(dev);
    }
</code></pre></div>
<p>To make the NuttX Interrupt Handler work‚Ä¶</p>
<ul>
<li>
<p>Fix the UART Interrupt Status: <a href="https://github.com/lupyuen/ox64-tinyemu/commit/074f8c30cb4a39a0d2d0dfd195be31858c5c9e52">BL808_UART_INT_STS (0x30002020) must return UART_INT_STS_URX_END_INT (1 &lt;&lt; 1)</a></p>
</li>
<li>
<p>Fix the UART Interrupt Mask: <a href="https://github.com/lupyuen/ox64-tinyemu/commit/074f8c30cb4a39a0d2d0dfd195be31858c5c9e52">BL808_UART_INT_MASK (0x30002024) must NOT return UART_INT_MASK_CR_URX_END_MASK (1 &lt;&lt; 1)</a></p>
</li>
<li>
<p>To prevent looping: <a href="https://github.com/lupyuen/ox64-tinyemu/commit/f9c1841d7699ecc04f9ce4499f1c081ae50aa225">Clear the interrupt after setting BL808_UART_INT_CLEAR (0x30002028)</a></p>
</li>
</ul>
<p>Now it doesn‚Äôt loop!</p>
<div class="example-wrap"><pre class="language-text"><code>nx_start: CPU0: Beginning Idle Loop
[a]
plic_set_irq: irq_num=20, state=1
plic_update_mip: set_mip, pending=0x80000, served=0x0
raise_exception: cause=-2147483639
raise_exception2: cause=-2147483639, tval=0x0

## Claim Interrupt
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000, served=0x80000

## Handle Interrupt in Interrupt Handler
virtio_ack_irq
plic_set_irq: irq_num=20, state=0
plic_update_mip: reset_mip, pending=0x0, served=0x80000

## Complete Interrupt
plic_write: offset=0x201004, val=0x14
plic_update_mip: reset_mip, pending=0x0, served=0x0
</code></pre></div>
<p>We pass the keypress from VirtIO Console to the Emulated UART Input Register‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/ox64-tinyemu/commit/63cba6275c850b668598120355240f5d485c4538">BL808_UART_FIFO_RDATA_OFFSET (0x3000208c) returns the Input Char</a></li>
</ul>
<p>Console Input works OK yay!</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/smode"><em>(Live Demo of Ox64 BL808 Emulator)</em></a></p>
<p><a href="https://youtu.be/FAxaMt6A59I"><em>(Watch the Demo on YouTube)</em></a></p>
<div class="example-wrap"><pre class="language-text"><code>Loading...
TinyEMU Emulator for Ox64 BL808 RISC-V SBC
ABCnx_start: Entry
uart_register: Registering /dev/console
work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
up_exit: TCB=0x504098d0 exiting
 
NuttShell (NSH) NuttX-12.4.0
nsh&gt; nx_start: CPU0: Beginning Idle Loop
 
nsh&gt; ls
posix_spawn: pid=0x80202978 path=ls file_actions=0x80202980 attr=0x80202988 argv
=0x80202a28
nxposix_spawn_exec: ERROR: exec failed: 2
/:
 dev/
 proc/
 system/
nsh&gt; uname -a
posix_spawn: pid=0x80202978 path=uname file_actions=0x80202980 attr=0x80202988 a
rgv=0x80202a28
nxposix_spawn_exec: ERROR: exec failed: 2
NuttX 12.4.0 96c2707 Jan 18 2024 12:07:28 risc-v ox64
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/de071bf54b603f4aaff3954648dcc340">(See the Complete Log)</a></p>
<h1 id="emulate-opensbi-for-system-timer"><a href="#emulate-opensbi-for-system-timer">5 Emulate OpenSBI for System Timer</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<p><em>How to emulate the OpenSBI ECALL to start the System Timer?</em></p>
<p>For now we ignore the OpenSBI ECALL from NuttX, we‚Äôll fix later‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/ox64-tinyemu/commit/ab58cd2dc6a1d94b9bd13faa0f402a7ada4b270d">Emulate OpenSBI for System Timer</a></li>
</ul>
<p>Strangely TinyEMU crashes with an Illegal Instruction Exception at RDTTIME (Read System Timer). We patch it with NOP and handle later‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/ox64-tinyemu/commit/5cb2fb4e263b9e965777f567b053a0914f3cf368">Patch the RDTTIME (Read System Timer) with NOP for now. We will support later.</a></li>
</ul>
<p>The <a href="https://github.com/lupyuen/nuttx-ox64/releases/tag/nuttx-ox64-2024-01-20">Latest NuttX Build</a> includes an OpenSBI ECALL. And it works OK with TinyEMU yay!</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/smode"><em>(Live Demo of Ox64 BL808 Emulator)</em></a></p>
<p><a href="https://youtu.be/FAxaMt6A59I"><em>(Watch the Demo on YouTube)</em></a></p>
<div class="example-wrap"><pre class="language-text"><code>Loading...
TinyEMU Emulator for Ox64 BL808 RISC-V SBC
Patched RDTTIME (Read System Timer) at 0x5020bad6
ABC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; uname -a
NuttX 12.4.0-RC0 4c41d84d21 Jan 20 2024 00:10:33 risc-v ox64
nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]
 
    .           cp          exit        mkrd        set         unset
    [           cmp         false       mount       sleep       uptime
    ?           dirname     fdinfo      mv          source      usleep
    alias       dd          free        pidof       test        xd
    unalias     df          help        printf      time
    basename    dmesg       hexdump     ps          true
    break       echo        kill        pwd         truncate
    cat         env         ls          rm          uname
    cd          exec        mkdir       rmdir       umount
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/de071bf54b603f4aaff3954648dcc340">(See the Complete Log)</a></p>
<h1 id="fix-the-system-timer"><a href="#fix-the-system-timer">6 Fix the System Timer</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/758287cc3aa8165303c6a726292e665af099aefd">For OpenSBI Set Timer: Clear the pending timer interrupt bit</a></p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/1bcf19a4b2354bc47b515a3fe2f2e8a427e3900d">For RDTIME: Return the time</a></p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/ddedb862a786e52b17cf3331752d50662eddffd3">Regularly trigger the Supervisor-Mode Timer Interrupt</a></p>
<p><code>usleep</code> works OK yay!</p>
<div class="example-wrap"><pre class="language-text"><code>Loading...
TinyEMU Emulator for Ox64 BL808 RISC-V SBC
ABC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; usleep 1
nsh&gt; 
</code></pre></div>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/b8671f76414747b6902a7dcb89f6fc3c8184075f">Patch DCACHE.IALL and SYNC.S to become ECALL</a></p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/f00d40c0de3d97e93844626c0edfd3b19e8252db">Handle System Timer with mtimecmp</a></p>
<p><a href="https://gist.github.com/lupyuen/31bde9c2563e8ea2f1764fb95c6ea0fc">Emulator Timer Log</a></p>
<p>Test <code>ostest</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>semtimed_test: Starting poster thread
semtimed_test: Set thread 1 priority to 191
semtimed_test: Starting poster thread 3
semtimed_test: Set thread 3 priority to 64
semtimed_test: Waiting for two second timeout
poster_func: Waiting for 1 second
semtimed_test: ERROR: sem_timedwait failed with: 110
_assert: Current Version: NuttX  12.4.0-RC0 55ec92e181 Jan 24 2024 00:11:51 risc
-v
_assert: Assertion failed (_Bool)0: at file: semtimed.c:240 task: ostest process
: ostest 0x8000004a
up_dump_register: EPC: 0000000050202008
</code></pre></div>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/169dd727a5e06bdc95ac3f32e1f1b119c3cbbb75">Remove the Timer Interrupt Interval because ostest will fail</a></p>
<p><code>ostest</code> is OK yay!</p>
<p>https://lupyuen.github.io/nuttx-tinyemu/timer/</p>
<p><code>expect</code> script works OK with Ox64 BL808 Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
set send_slow {1 0.001}
spawn /Users/Luppy/riscv/ox64-tinyemu/temu root-riscv64.cfg

expect &quot;nsh&gt; &quot;
send -s &quot;uname -a\r&quot;

expect &quot;nsh&gt; &quot;
send -s &quot;ostest\r&quot;
expect &quot;ostest_main: Exiting with status -1&quot;
expect &quot;nsh&gt; &quot;
</code></pre></div>
<p>We‚Äôll run this for Daily Automated Testing, right after the Daily Automated Build.</p>
<h1 id="whats-next"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tinyemu3.md"><strong>lupyuen.github.io/src/tinyemu3.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<h1 id="appendix-boot-nuttx-in-supervisor-mode"><a href="#appendix-boot-nuttx-in-supervisor-mode">8 Appendix: Boot NuttX in Supervisor Mode</a></h1>
<p>Earlier we saw a big chunk of <strong>TinyEMU Boot Code</strong> (pic above) that will start <strong>NuttX in RISC-V Supervisor Mode</strong> (instead of Machine Mode)‚Ä¶</p>
<p>TODO: machine exception delegation register (medeleg) and machine interrupt delegation register ( mideleg)</p>
<p>TODO: <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#sec:mcause">MCAUSE</a></p>
<p>TODO</p>
<p><em>NuttX needs to boot in Supervisor Mode, not Machine Mode. How to fix this in TinyEMU?</em></p>
<p>We copy to TinyEMU Boot Code the Machine-Mode Start Code from <a href="https://gist.github.com/lupyuen/368744ef01b7feba10c022cd4f4c5ef2">NuttX Start Code for 64-bit RISC-V Kernel Mode (rv-virt:knsh64)</a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/e62d49f1a8b27002871f712e80b1785442e23393">Execute the MRET Instruction to jump from Machine Mode to Supervisor Mode</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/37c2d1169706a56afbd2d7d2a13624b58269e1ef#diff-2080434ac7de762b1948a6bc493874b21b9e3df3de8b9e52de23bfdcec354abd">Dump the RISC-V Registers MCAUSE 2: Illegal Instruction</a> (for easier troubleshooting)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/tinyemu2-flow3.jpg" alt="TinyEMU will boot NuttX in Supervisor Mode" /></p>
<div class="example-wrap"><pre class="language-text"><code>TinyEMU Emulator for Ox64 BL808 RISC-V SBC
virtio_console_init
csr_write: csr=0x341 val=0x0000000050200000
raise_exception2: cause=2, tval=0x10401073
pc =0000000050200074 ra =0000000000000000 sp =0000000050407c00 gp =0000000000000000
tp =0000000000000000 t0 =0000000050200000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000000 s1 =0000000000000000 a0 =0000000000000000 a1 =0000000000001040
a2 =0000000000000000 a3 =0000000000000000 a4 =0000000000000000 a5 =0000000000000000
a6 =0000000000000000 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =fffffffffffffff3 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a00000080 cycles=13
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
raise_exception2: cause=2, tval=0x0
pc =0000000000000000 ra =0000000000000000 sp =0000000050407c00 gp = 
</code></pre></div>
<p>Which fails with an Illegal Instuction. The offending code comes from‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/bl808_head.S:124
2:
  /* Disable all interrupts (i.e. timer, external) in sie */
  csrw	sie, zero
    50200074:	10401073          	csrw	sie,zero
</code></pre></div>
<p><em>Why is this instruction invalid?</em></p>
<p><code>csrw sie,zero</code> is invalid because we‚Äôre in User Mode (<code>priv=U</code>), not Supervisor Mode. And SIE is a Supervisor-Mode CSR Register.</p>
<p>So we <a href="https://github.com/lupyuen/ox64-tinyemu/commit/d379d92bfe544681e0560306a1aad96f5792da9e">set MSTATUS to Supervisor Mode and enable SUM</a>.</p>
<div class="example-wrap"><pre class="language-text"><code>TinyEMU Emulator for Ox64 BL808 RISC-V SBC
virtio_console_init
raise_exception2: cause=2, tval=0x879b0000
pc =0000000000001012 ra =0000000000000000 sp =0000000000000000 gp =0000000000000000
tp =0000000000000000 t0 =0000000050200000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000000 s1 =0000000000000000 a0 =0000000000000000 a1 =0000000000001040
a2 =0000000000000000 a3 =0000000000000000 a4 =0000000000000000 a5 =ffffffffffffe000
a6 =0000000000000000 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=M mstatus=0000000a00000000 cycles=4
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
tinyemu: Unknown mcause 2, quitting
</code></pre></div>
<p>Now we hit an Illegal Instruction caused by an unpadded 16-bit instruction: 0x879b0000.</p>
<p>TinyEMU requires all Boot Code Instructions to be 32-bit. So we <a href="https://github.com/lupyuen/ox64-tinyemu/commit/23a36478cf03561d40f357f876284c09722ce455">insert NOP (0x0001) to pad 16-bit RISC-V Instructions to 32-bit</a>.</p>
<div class="example-wrap"><pre class="language-text"><code>work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
up_exit: TCB=0x504098d0 exiting

raise_exception2: cause=8, tval=0x0
pc =00000000800019c6 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a000400a1 cycles=79648442
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080

raise_exception2: cause=2, tval=0x0
pc =0000000000000000 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=M mstatus=0000000a000400a1 cycles=79648467
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
tinyemu: Unknown mcause 2, quitting
</code></pre></div>
<p>But the ECALL goes from User Mode (<code>priv=U</code>) to Machine Mode (<code>priv=M</code>), not Supervisor Mode!</p>
<p>We <a href="https://github.com/lupyuen/ox64-tinyemu/commit/9536e86217bcccbe15272dc4450eac9fab173b03">set the Exception and Interrupt delegation for Supervisor Mode</a>.</p>
<p>Finally NuttX Shell starts OK yay! User Mode ECALLs are working perfectly!</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/smode"><em>(Live Demo of Ox64 BL808 Emulator)</em></a></p>
<p><a href="https://youtu.be/FAxaMt6A59I"><em>(Watch the Demo on YouTube)</em></a></p>
<div class="example-wrap"><pre class="language-text"><code>work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
up_exit: TCB=0x504098d0 exiting
NuttShell (NSH) NuttX-12.4.0
nsh&gt;
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/de071bf54b603f4aaff3954648dcc340">(See the Complete Log)</a></p>

    
</body>
</html>