<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS to NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX OS talks I2C with Bosch BME280 Sensor on BL602 RISC-V SoC... Thanks to the BME280 Driver ported from Zephyr OS"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/bme280-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS to NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#test-and-connect-bme280">1 Test and Connect BME280</a><ul></ul></li>
<li><a href="#start-with-bmp280-driver">2 Start with BMP280 Driver</a><ul>
<li><a href="#change-i2c-address-and-device-id">2.1 Change I2C Address and Device ID</a><ul></ul></li>
<li><a href="#register-bmp280-driver">2.2 Register BMP280 Driver</a><ul></ul></li>
<li><a href="#invalid-device-id">2.3 Invalid Device ID</a><ul></ul></li>
<li><a href="#incorrect-register-id">2.4 Incorrect Register ID</a><ul></ul></li>
<li><a href="#set-i2c-sub-address">2.5 Set I2C Sub Address</a><ul></ul></li>
<li><a href="#bmp280-driver-loads-ok">2.6 BMP280 Driver Loads OK</a><ul></ul></li>
<li><a href="#run-sensor-test-app">2.7 Run Sensor Test App</a><ul></ul></li></ul></li>
<li><a href="#port-bme280-driver-from-zephyr-os">3 Port BME280 Driver from Zephyr OS</a><ul>
<li><a href="#zephyr-to-nuttx">3.1 Zephyr to NuttX</a><ul></ul></li>
<li><a href="#read-sensor-data-from-zephyr-driver">3.2 Read Sensor Data from Zephyr Driver</a><ul></ul></li>
<li><a href="#power-management">3.3 Power Management</a><ul></ul></li>
<li><a href="#standby-interval">3.4 Standby Interval</a><ul></ul></li></ul></li>
<li><a href="#combined-barometer-and-humidity-sensor">4 Combined Barometer and Humidity Sensor</a><ul>
<li><a href="#sensor-operations">4.1 Sensor Operations</a><ul></ul></li>
<li><a href="#register-sensors">4.2 Register Sensors</a><ul></ul></li></ul></li>
<li><a href="#bundle-nuttx-and-zephyr-drivers">5 Bundle NuttX and Zephyr Drivers</a><ul>
<li><a href="#inside-the-bundle">5.1 Inside the Bundle</a><ul></ul></li>
<li><a href="#zephyr-driver-modified-for-nuttx">5.2 Zephyr Driver Modified For NuttX</a><ul></ul></li></ul></li>
<li><a href="#run-bme280-driver">6 Run BME280 Driver</a><ul></ul></li>
<li><a href="#sensor-test-app">7 Sensor Test App</a><ul>
<li><a href="#print-sensor-data">7.1 Print Sensor Data</a><ul></ul></li></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">9 Notes</a><ul></ul></li>
<li><a href="#appendix-quirks-in-bl602-nuttx-i2c-driver">10 Appendix: Quirks in BL602 NuttX I2C Driver</a><ul>
<li><a href="#read-i2c-register">10.1 Read I2C Register</a><ul></ul></li>
<li><a href="#write-i2c-register">10.2 Write I2C Register</a><ul></ul></li>
<li><a href="#must-read-after-write">10.3 Must Read After Write</a><ul></ul></li>
<li><a href="#i2c-sub-address">10.4 I2C Sub Address</a><ul></ul></li>
<li><a href="#bl602-i2c-driver">10.5 BL602 I2C Driver</a><ul></ul></li>
<li><a href="#configure-i2c-transfer">10.6 Configure I2C Transfer</a><ul></ul></li></ul></li>
<li><a href="#appendix-log-i2c-transfers">11 Appendix: Log I2C Transfers</a><ul></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">12 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#download-nuttx">12.1 Download NuttX</a><ul></ul></li>
<li><a href="#configure-nuttx">12.2 Configure NuttX</a><ul></ul></li>
<li><a href="#build-nuttx">12.3 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx">12.4 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx">12.5 Run NuttX</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>10 Mar 2022</em></p>
<p><img src="https://lupyuen.github.io/images/bme280-title.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<p><em>‚ÄúWill <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX RTOS</strong></a> talk I2C with <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>‚Ä¶ On the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V SoC</strong></a>?‚Äù</em></p>
<p>‚Ä¶A friend and I pondered (8,000 miles apart) while working on the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide"><strong>Temperature + Humidity + Air Pressure</strong></a> combo sensor.</p>
<p>Sounds like a fun challenge‚Ä¶</p>
<ul>
<li>
<p>NuttX <strong>doesn‚Äôt have a driver</strong> for the BME280 Sensor</p>
<p>(Though it supports BMP280)</p>
</li>
<li>
<p>Can we port the BME280 Driver from <a href="https://docs.zephyrproject.org/latest/"><strong>Zephyr OS</strong></a> with a few tweaks?</p>
<p>(Spoiler: Yes we can!)</p>
</li>
<li>
<p>What‚Äôs inside a <strong>NuttX Sensor Driver</strong> anyway?</p>
<p>(How to build our own driver)</p>
</li>
<li>
<p>NuttX on BL602 is <strong>kinda new-ish</strong></p>
<p>(Some features might not work the way we expect)</p>
</li>
<li>
<p>BL602‚Äôs I2C Port has <strong>interesting quirks</strong>. Will it work?</p>
<p>(Specifically: I2C Sub Address)</p>
</li>
</ul>
<p>Read on to find out how we solved the challenge and created this driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bme280-nuttx"><strong>lupyuen/bme280-nuttx</strong></a></li>
</ul>
<p>(This BME280 Driver should work OK on other NuttX platforms, like ESP32)</p>
<p><strong>Note:</strong> The NuttX Sensor API has been updated in Jul / Aug 2022. <a href="https://lupyuen.github.io/articles/sensor#appendix-updates-to-nuttx-sensor-api">(See the changes)</a></p>
<p><img src="https://lupyuen.github.io/images/i2c-buspirate.jpg" alt="Bus Pirate connected to BME280" /></p>
<h1 id="test-and-connect-bme280"><a href="#test-and-connect-bme280">1 Test and Connect BME280</a></h1>
<p>Before we begin our exploration, verify that our BME280 Sensor works OK.</p>
<p>(Because we‚Äôll see some unexpected behaviour in a while)</p>
<p>We used <a href="http://dangerousprototypes.com/docs/Bus_Pirate"><strong>Bus Pirate</strong></a> (pic above) for testing our BME280 Sensor.</p>
<p><a href="https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate">(Here‚Äôs how)</a></p>
<p>Next we connect BME280 to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL602 Pin</th><th style="text-align: center">BME280 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 1</code></strong></td><td style="text-align: center"><code>SDA</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 2</code></strong></td><td style="text-align: center"><code>SCL</code></td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong><code>3V3</code></strong></td><td style="text-align: center"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong><code>GND</code></strong></td><td style="text-align: center"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/sensor-connect.jpg" alt="Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor" /></p>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L91-L98">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN2)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN1)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<p><em>What if we‚Äôre connecting to ESP32?</em></p>
<p><strong>For ESP32:</strong> The GPIO Pin Numbers for the I2C Port (I2C0) are defined in <a href="https://github.com/lupyuen/nuttx/blob/master/arch/xtensa/src/esp32/Kconfig#L797-L805">Kconfig</a> and menuconfig‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config ESP32_I2C0_SCLPIN
  int &quot;I2C0 SCL Pin&quot;
  default 22
  range 0 39

config ESP32_I2C0_SDAPIN
  int &quot;I2C0 SDA Pin&quot;
  default 23
  range 0 39
</code></pre></div>
<p><em>Do we need Pull-Up Resistors?</em></p>
<p>We‚Äôre using the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide/all"><strong>SparkFun BME280 Breakout Board</strong></a>, which has <strong>Pull-Up Resistors</strong>. (So we don‚Äôt need to add our own)</p>
<p><em>What happens now?</em></p>
<p>Coming up we have a lengthy exploration of BME280 on BL602.</p>
<p>If we‚Äôre only interesting in <strong>running the NuttX BME280 Driver</strong> (on BL602, ESP32 and other platforms), jump to this section for the instructions‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280#run-bme280-driver"><strong>‚ÄúRun BME280 Driver‚Äù</strong></a></li>
</ul>
<p>But if we‚Äôre keen to go deep inside the BME280 driver‚Ä¶ Read on!</p>
<h1 id="start-with-bmp280-driver"><a href="#start-with-bmp280-driver">2 Start with BMP280 Driver</a></h1>
<p>NuttX doesn‚Äôt have a BME280 Driver, but there‚Äôs a <strong>NuttX Driver for BMP280</strong>, the downsized (rightsized?) sibling of BME280.</p>
<p>(BMP280 works like BME280 for sensing Air Pressure and Temperature, but <strong>without Humidity</strong>)</p>
<p>Let‚Äôs test the <strong>BMP280 Driver on BL602</strong> and fix any I2C quirks.</p>
<ol>
<li>
<p>Follow these steps to <strong>download and configure</strong> NuttX‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/bme280#download-nuttx"><strong>‚ÄúDownload NuttX‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>‚ÄúConfigure NuttX‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/bme280-config1.jpg" alt="Enable the I2C Port and I2C Character Driver" /></p>
</li>
<li>
<p>Enable the <strong>BMP280 Driver</strong> in menuconfig‚Ä¶</p>
<p>Check the box for <strong>‚ÄúDevice Drivers‚Äù</strong> ‚Üí <strong>‚ÄúSensor Device Support‚Äù</strong></p>
<p>Select <strong>‚ÄúSensor Device Support‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúBosch BMP280 Barometic Pressure Sensor‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/bme280-config3.png" alt="BMP280 Driver" /></p>
</li>
</ol>
<h2 id="change-i2c-address-and-device-id"><a href="#change-i2c-address-and-device-id">2.1 Change I2C Address and Device ID</a></h2>
<p><em>Will NuttX‚Äôs BMP280 Driver really work with our BME280?</em></p>
<p>Yep the BMP280 Driver ought to read the <strong>Air Pressure</strong> and <strong>Temperature</strong> from our BME280 Sensor. (But not Humidity)</p>
<p>Just that we need to we change the <strong>I2C Address</strong> and <strong>Device ID</strong> in the BMP280 Driver: <a href="https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Previously: I2C Address of BMP280
//  #define BMP280_ADDR     0x76

//  Testing: I2C Address of BME280
#define BMP280_ADDR         0x77

//  Previously: Device ID of BMP280
//  #define DEVID           0x58

//  Testing: Device ID of BME280
#define DEVID               0x60
</code></pre></div>
<p><a href="https://github.com/zephyrproject-rtos/zephyr/issues/1709">(FYI: Zephyr uses the same driver for BMP280 and BME280)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-code1.png" alt="Change I2C Address and Device ID" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57">(Source)</a></p>
<h2 id="register-bmp280-driver"><a href="#register-bmp280-driver">2.2 Register BMP280 Driver</a></h2>
<p>Next we <strong>load the BMP280 Driver</strong> at startup: <a href="https://github.com/lupyuen/nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_SENSORS_BMP280
#include &lt;nuttx/sensors/bmp280.h&gt;
#endif  //  CONFIG_SENSORS_BMP280
...
int bl602_bringup(void) {
...
#ifdef CONFIG_SENSORS_BMP280
  //  Init I2C bus for BMP280
  struct i2c_master_s *bmp280_i2c_bus = 
    bl602_i2cbus_initialize(0);
  if (!bmp280_i2c_bus) {
    _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0);
  }

  //  Register the BMP280 driver
  ret = bmp280_register(0, bmp280_i2c_bus);
  if (ret &lt; 0) {
    _err(&quot;ERROR: Failed to register BMP280\n&quot;);
  }
#endif  //  CONFIG_SENSORS_BMP280
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760">(<strong>bmp280_register</strong> is defined here)</a></p>
<p><strong>For ESP32:</strong> Edit the function <a href="https://github.com/lupyuen/nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497">esp32_bringup</a> in <a href="https://github.com/lupyuen/nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497">esp32_bringup.c</a> so that it calls <a href="https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760">bmp280_register</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-code2a.png" alt="Register BMP280 Driver" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640">(Source)</a></p>
<h2 id="invalid-device-id"><a href="#invalid-device-id">2.3 Invalid Device ID</a></h2>
<p>We‚Äôre ready to test the BMP280 Driver! <strong>Build, flash and run</strong> NuttX with these steps‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#flash-nuttx"><strong>‚ÄúFlash NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#run-nuttx"><strong>‚ÄúRun NuttX‚Äù</strong></a></p>
</li>
</ol>
<p>Something unexpected happens when we boot NuttX on BL602‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_i2c_transfer: i2c transfer success
bmp280_checkid:  devid: 0x00
bmp280_checkid:  Wrong Device ID! 00
bmp280_register: Failed to register driver: -19
bl602_bringup:   ERROR: Failed to register BMP280
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#invalid-device-id">(See the complete log)</a></p>
<p>This says that the BMP280 Driver was expecting <strong>Device ID <code>0x60</code></strong>‚Ä¶ But it got <strong><code>0x00</code></strong> instead!</p>
<p>Let‚Äôs find out why ü§î</p>
<p><img src="https://lupyuen.github.io/images/bme280-run1.png" alt="Invalid Device ID" /></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx#invalid-device-id">(Source)</a></p>
<h2 id="incorrect-register-id"><a href="#incorrect-register-id">2.4 Incorrect Register ID</a></h2>
<p>To track down why we‚Äôre not reading the right Device ID, let‚Äôs connect a <strong>Logic Analyser</strong> and inspect the bits on the I2C Bus‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-logic2.jpg" alt="Logic Analyser connected between BL602 and BME280" /></p>
<p>The I2C Data captured by our Logic Analyser looks surprising‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-logic1.jpg" alt="I2C Data captured by Logic Analyser" /></p>
<p>The pic above shows that BL602 sent the <strong>wrong Register ID</strong> to BME280‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Write  [0xEE]
0x00 + ACK (Register ID is 0x00, which is incorrect!)
Read   [0xEF]
0x00 + NAK (Invalid result, because Register ID is incorrect!)
</code></pre></div>
<p>To read the Device ID, the Register ID should be <strong><code>0xD0</code></strong>, not <strong><code>0x00</code></strong>!</p>
<p>Let‚Äôs fix this ü§î</p>
<p><a href="https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate">(Here‚Äôs why Register ID should be <code>0xD0</code>)</a></p>
<h2 id="set-i2c-sub-address"><a href="#set-i2c-sub-address">2.5 Set I2C Sub Address</a></h2>
<p><em>Is there something special about BL602‚Äôs I2C Port?</em></p>
<p>BL602 has a peculiar I2C Port‚Ä¶</p>
<p>We need to send the <strong>I2C Sub Address</strong> (Register ID) separately from the I2C Data! </p>
<p>(Which might have caused the BMP280 Driver to fail)</p>
<p><img src="https://lupyuen.github.io/images/bme280-subaddress2.png" alt="I2C Sub Address" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en">(From BL602 Reference Manual)</a></p>
<p>When we browse the NuttX code for BL602‚Äôs I2C Driver, we realise that it <strong>supports I2C Sub Addresses</strong>: <a href="https://github.com/lupyuen/nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L719-L738">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  //  if msgs[i].flag I2C_M_NOSTOP,means start i2c with subddr
  if (msgs[i].flags &amp; I2C_M_NOSTOP) {
    priv-&gt;subflag = 1;
    priv-&gt;subaddr = 0;
    for (j = 0; j &lt; msgs[i].length; j++) {
      priv-&gt;subaddr += msgs[i].buffer[j] &lt;&lt; (j * 8);
    }
    priv-&gt;sublen = msgs[i].length;
    i++;
</code></pre></div>
<p>But it needs the flag <strong>I2C_M_NOSTOP</strong> to be set!</p>
<p>Let‚Äôs patch the NuttX BMP280 Driver to send the <strong>Register ID as I2C Sub Address</strong> (instead of I2C Data) when we‚Äôre reading a BMP280 Register: <a href="https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L209-L219">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Read a single BME280 Register
static uint8_t bmp280_getreg8(FAR struct bmp280_dev_s *priv, uint8_t regaddr) {
  ...
  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;

#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0

  msg[0].buffer    = &amp;regaddr;
  msg[0].length    = 1;
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L238-L327">(We patch <strong>bmp280_getregs</strong> and <strong>bmp280_putreg8</strong> too)</a></p>
<p><em>What about writing to BMP280 Registers? Do we need to set the I2C Sub Address?</em></p>
<p>Yes we need to send the <strong>Register ID and Register Value</strong> as I2C Sub Address, followed by an <strong>I2C Read</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/bme280#appendix-quirks-in-bl602-nuttx-i2c-driver">(More about BL602 I2C Quirks)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-code5a.png" alt="Send the Register ID as I2C Sub Address (instead of I2C Data) when we‚Äôre reading a BMP280 Register" /></p>
<h2 id="bmp280-driver-loads-ok"><a href="#bmp280-driver-loads-ok">2.6 BMP280 Driver Loads OK</a></h2>
<p>We‚Äôve patched the BMP280 Driver to send the Register ID as I2C Sub Address. Let‚Äôs run it!</p>
<div class="example-wrap"><pre class="language-text"><code>sensor_custom_register: Registering /dev/uorb/sensor_baro0
bmp280_register: BMP280 driver loaded successfully!
NuttShell (NSH) NuttX-10.2.0-RC0
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#bmp280-driver-loads-ok">(See the complete log)</a></p>
<p>Yep our patched BMP280 Driver <strong>loads successfully</strong>!</p>
<p>(Because it receives the correct Device ID from BMP280)</p>
<p>BMP280 appears on NuttX as <strong>/dev/uorb/sensor_baro0</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; ls /dev/uorb
/dev/uorb:
 sensor_baro0
</code></pre></div>
<p>Let‚Äôs read the <strong>baro0</strong> device.</p>
<p><a href="https://lupyuen.github.io/articles/bme280#appendix-log-i2c-transfers">(How we enable logging for BL602 I2C Driver)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-run2a.jpg" alt="Our patched BMP280 Driver loads successfully" /></p>
<h2 id="run-sensor-test-app"><a href="#run-sensor-test-app">2.7 Run Sensor Test App</a></h2>
<p>NuttX provides a <strong>Sensor Test App</strong> that will read our BMP280 Device at <strong>/dev/uorb/sensor_baro0</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c"><strong>testing/sensortest/sensortest.c</strong></a></li>
</ul>
<p>(We‚Äôll study the code later)</p>
<p>We configure NuttX to enable the <strong>Sensor Test App</strong>‚Ä¶</p>
<ul>
<li>‚ÄúApplication Configuration‚Äù ‚Üí ‚ÄúTesting‚Äù ‚Üí ‚ÄúSensor Driver Test‚Äù</li>
</ul>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx">(Details here)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-config4a.png" alt="Enable the Sensor Test App" /></p>
<p>Build, flash and run NuttX. To read 10 sensor values from <strong>/dev/uorb/sensor_baro0</strong>, enter this at the NuttX Shell‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/uorb/sensor_baro0 with interval(1000000us), latency(0us)
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:1006.21 value2:30.78
baro0: timestamp:30690000 value1:1006.21 value2:30.78
SensorTest: Received message: baro0, number:10/10
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#run-sensor-test-app">(See the complete log)</a></p>
<p>We see the Air Pressure and Temperature: <strong>1,006.21 millibars</strong> at <strong>30.78 ¬∞C</strong>.</p>
<p>(Air Pressure at Sea Level is 1,013.25 millibars)</p>
<p>Yep this looks reasonable for Sunny Singapore by the Seaside!</p>
<p><img src="https://lupyuen.github.io/images/bme280-run5a.png" alt="Read sensor values from BMP280" /></p>
<p>Now let‚Äôs port the BME280 Driver from Zephyr OS to NuttX, so we can get the Humidity.</p>
<p><img src="https://lupyuen.github.io/images/bme280-code6a.jpg" alt="NuttX BMP280 Driver vs Zephyr BME280 Driver" /></p>
<p><em><a href="https://github.com/apache/nuttx/blob/master/drivers/sensors/bmp280.c">NuttX BMP280 Driver</a> vs <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c">Zephyr BME280 Driver</a></em></p>
<h1 id="port-bme280-driver-from-zephyr-os"><a href="#port-bme280-driver-from-zephyr-os">3 Port BME280 Driver from Zephyr OS</a></h1>
<p>NuttX‚Äôs BMP280 Driver works OK with our BME280 Sensor. But we‚Äôre missing one thing: <strong>Humidity</strong>.</p>
<p>Let‚Äôs port the BME280 Driver from <strong>Zephyr OS</strong> to NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c"><strong>Zephyr BME280 Driver</strong></a></li>
</ul>
<p><em>Why not code the BME280 Driver based on the datasheet?</em></p>
<p>Well yes we could‚Ä¶ But then the rest of this article would become an academic exercise üòâ</p>
<p><em>Why port from Zephyr OS?</em></p>
<p>Zephyr has an <a href="https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers"><strong>extensive collection</strong></a> of drivers. </p>
<p>The NuttX porting steps that we establish today might work for other Zephyr drivers, with minimal changes!</p>
<p><em>Porting a driver from Zephyr to NuttX sounds hard!</em></p>
<p>Zephyr‚Äôs BME280 Driver looks <strong>highly similar</strong> to NuttX‚Äôs BMP280 Driver. (Pic above)</p>
<p>Thus porting Zephyr‚Äôs BME280 Driver to NuttX might not be so hard!</p>
<h2 id="zephyr-to-nuttx"><a href="#zephyr-to-nuttx">3.1 Zephyr to NuttX</a></h2>
<p><strong>Zephyr‚Äôs BME280 Driver</strong> exposes these functions: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c">bme280-nuttx/bme280.c</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-port2.jpg" alt="Zephyr BME280 Driver" /></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L348-L417"><strong>bme280_chip_init</strong></a>: Initialise the BME280 Sensor</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L419-L446"><strong>bme280_pm_action</strong></a>: Suspend the BME280 Sensor (Low Power Mode) or resume to Normal Power Mode</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245"><strong>bme280_sample_fetch</strong></a>: Fetch a sample from the BME280 Sensor</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286"><strong>bme280_channel_get</strong></a>: Get the Temperature / Humidity / Pressure from the fetched sample</p>
</li>
</ul>
<p><a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html">(<strong>bme280_sample_fetch</strong> and <strong>bme280_channel_get</strong> are explained in the Zephyr Sensor Docs)</a></p>
<p>But NuttX expects a different interface for <strong>Sensor Drivers</strong>: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c">bme280-nuttx/driver.c</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-port3.jpg" alt="NuttX Driver" /></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773"><strong>bme280_register</strong></a>: Register the sensor at startup and suspend the sensor</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431"><strong>bme280_activate</strong></a>: Suspend the sensor (Low Power Mode) or resume to Normal Power Mode</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572"><strong>bme280_fetch</strong></a>: Fetch the sensor values (Temperature / Humidity / Pressure)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341"><strong>bme280_set_interval</strong></a>: Set the Standby Interval for the sensor</p>
</li>
</ul>
<p>Our job is to <strong>map the Zephyr BME280 Driver</strong> to the Sensor Driver Interface expected by NuttX‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-port4.jpg" alt="Zephyr BME280 Driver mapped to NuttX Driver" /></p>
<div><table><thead><tr><th>Zephyr Driver</th><th>NuttX Driver</th></tr></thead><tbody>
<tr><td>bme280_chip_init,<br>bme280_pm_action</td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773"><strong>bme280_register</strong></a></td></tr>
<tr><td>bme280_pm_action</td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431"><strong>bme280_activate</strong></a></td></tr>
<tr><td>bme280_sample_fetch,<br>bme280_channel_get</td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572"><strong>bme280_fetch</strong></a></td></tr>
<tr><td><em>(Static Interval)</em></td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341"><strong>bme280_set_interval</strong></a></td></tr>
</tbody></table>
</div>
<p>We‚Äôll cover the details in the next section.</p>
<p><em>What about bme280_set_interval?</em></p>
<p>Zephyr assumes that the <strong>Standby Interval is Static</strong>. (Defined at compile time)</p>
<p>Whereas NuttX expects the Standby Interval to be <strong>set at runtime</strong>.</p>
<p>To handle this, we code the <strong>bme280_set_interval</strong> function ourselves in NuttX.</p>
<h2 id="read-sensor-data-from-zephyr-driver"><a href="#read-sensor-data-from-zephyr-driver">3.2 Read Sensor Data from Zephyr Driver</a></h2>
<p>Our NuttX BME280 Driver reads the <strong>Sensor Data</strong> from the Zephyr Driver in two steps‚Ä¶</p>
<ol>
<li>
<p><strong>Fetch a sample</strong> from the BME280 Sensor</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245">(<strong>bme280_sample_fetch</strong>)</a></p>
</li>
<li>
<p>Get the <strong>Temperature, Humidity and Pressure</strong> from the fetched sample</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286">(<strong>bme280_channel_get</strong>)</a></p>
</li>
</ol>
<p>This is how we do it: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Fetch pressure, temperature and humidity from sensor
static int bme280_fetch(
  FAR struct device *priv,  //  NuttX Device Struct
  FAR struct sensor_baro *baro_data,  //  Returns pressure and temperature (if non-null)
  FAR struct sensor_humi *humi_data   //  Returns humidity (if non-null)
) {

  //  Zephyr BME280 Driver assumes that sensor is not in sleep mode
  if (!priv-&gt;activated) {
    snerr(&quot;Device must be active before fetch\n&quot;);
    return -EIO;
  }
</code></pre></div>
<p>We begin by verifying that the sensor is in <strong>Normal Power Mode</strong>.</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431">(<strong>activated</strong> is set by <strong>bme280_activate</strong>)</a></p>
<p>Next we call the Zephyr Driver to <strong>fetch a sample</strong> from BME280‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Fetch the sensor sample (from Zephyr BME280 Driver)
  int ret = bme280_sample_fetch(
    priv,            //  NuttX Device Struct
    SENSOR_CHAN_ALL  //  Fetch Temperature, Humidity and Pressure
  );
  if (ret &lt; 0) { return ret; }
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245">(<strong>bme280_sample_fetch</strong> is defined here)</a></p>
<p>The fetched sample contains <strong>Temperature, Humidity and Pressure</strong>.</p>
<p>To get the Pressure we call the Zephyr Driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the pressure (from Zephyr BME280 Driver)
  struct sensor_value val;
  ret = bme280_channel_get(
    priv,               //  NuttX Device Struct
    SENSOR_CHAN_PRESS,  //  Get Pressure from fetched sample
    &amp;val                //  Pressure in Fixed Point format
  );
  if (ret &lt; 0) { return ret; }
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286">(<strong>bme280_channel_get</strong> is defined here)</a></p>
<p>This returns a Zephyr <a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_value"><strong>sensor_value</strong></a> struct that stores the Pressure as a <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic"><strong>Fixed-Point Number</strong></a>.</p>
<p>We convert the <a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_channel.SENSOR_CHAN_PRESS"><strong>Pressure</strong> (kilopascal)</a> from <strong>Fixed Point to Float</strong> (in millibars)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Convert pressure to float, scale up by 10 to convert kilopascal to millibars
  float pressure = get_sensor_value(&amp;val) * 10;
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L93-L107">(<strong>get_sensor_value</strong> is defined here)</a></p>
<p>We do the same to get the <a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_channel.SENSOR_CHAN_AMBIENT_TEMP"><strong>Temperature</strong> (¬∞C)</a> from the fetched sample‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the temperature (from Zephyr BME280 Driver)
  ret = bme280_channel_get(
    priv,                      //  NuttX Device Struct
    SENSOR_CHAN_AMBIENT_TEMP,  //  Get Temperature from fetched sample
    &amp;val                       //  Temperature in Fixed Point format
  );
  if (ret &lt; 0) { return ret; }
  float temperature = get_sensor_value(&amp;val);
</code></pre></div>
<p>And the <a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_channel.SENSOR_CHAN_HUMIDITY"><strong>Humidity</strong> (relative %)</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the humidity (from Zephyr BME280 Driver)
  ret = bme280_channel_get(
    priv,                  //  NuttX Device Struct
    SENSOR_CHAN_HUMIDITY,  //  Get Humidity from fetched sample
    &amp;val                   //  Humidity in Fixed Point format
  );
  if (ret &lt; 0) { return ret; }
  float humidity = get_sensor_value(&amp;val);
</code></pre></div>
<p>Sensor Values in NuttX are <strong>timestamped</strong>. We get the timestamp like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the timestamp  
  struct timespec ts;
  clock_systime_timespec(&amp;ts);
  uint64_t timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;
</code></pre></div>
<p>Finally we return the <strong>Pressure and Temperature</strong> data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Return the pressure and temperature data
  if (baro_data != NULL) {
    baro_data-&gt;pressure    = pressure;
    baro_data-&gt;temperature = temperature;
    baro_data-&gt;timestamp   = timestamp;
  }
</code></pre></div>
<p>And the <strong>Humidity</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Return the humidity data
  if (humi_data != NULL) {
    humi_data-&gt;humidity    = humidity;
    humi_data-&gt;timestamp   = timestamp;
  }
  return 0;
}
</code></pre></div>
<p>That‚Äôs how we call the Zephyr Driver to fetch the BME280 Sensor Data!</p>
<p><em>Why did we return the Sensor Data as two structs: baro_data and humi_data?</em></p>
<p>That‚Äôs because our NuttX BME280 Driver is implemented as a <strong>Composite Sensor</strong>: Barometer Sensor + Humidity Sensor.</p>
<p>More about this in the next chapter.</p>
<p><img src="https://lupyuen.github.io/images/bme280-code8a.png" alt="Read Sensor Data from Zephyr Driver" /></p>
<h2 id="power-management"><a href="#power-management">3.3 Power Management</a></h2>
<p>Mapping the <strong>Power Management</strong> functions (Low Power Mode) from Zephyr to NuttX is straightforward: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  If enable is true, set Power Mode to normal. Else set to sleep mode.
static int bme280_activate(
    FAR struct device *priv,  //  NuttX Device Struct
    bool enable               //  True for Normal Mode, False for Sleep Mode
) {
  int ret = 0;
  if (enable) {
    //  Set power mode to normal (from Zephyr BME280 Driver)
    ret = bme280_pm_action(
      priv,                     //  NuttX Device Struct
      PM_DEVICE_ACTION_RESUME   //  Resume from Sleep Mode
    );
  } else {
    //  Set to sleep mode (from Zephyr BME280 Driver)
    ret = bme280_pm_action(
      priv,                     //  NuttX Device Struct
      PM_DEVICE_ACTION_SUSPEND  //  Suspend to Sleep Mode
    );
  }
  //  Remember the power mode
  if (ret &gt;= 0) { priv-&gt;activated = enable; }
  return ret;
}
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/bme280-standby.png" alt="BME280 Standby Interval" /></p>
<p><a href="https://cdn.sparkfun.com/assets/learn_tutorials/4/1/9/BST-BME280_DS001-10.pdf">(From BME280 Datasheet)</a></p>
<h2 id="standby-interval"><a href="#standby-interval">3.4 Standby Interval</a></h2>
<p><em>What‚Äôs the Standby Interval?</em></p>
<p>BME280 automatically measures the Temperature, Humidity and Pressure at periodic intervals. (Without any intervention from our microcontroller)</p>
<p>The time interval between measurements is the <strong>Standby Interval</strong>. </p>
<p>(<em>t_standby</em> in the pic above)</p>
<p><em>Standby Intervals work differently in Zephyr vs NuttX?</em></p>
<p>Zephyr defines the Standby Interval at <strong>Compile Time</strong>, it can‚Äôt be changed at runtime. <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/Kconfig#L81-L103">(See this)</a></p>
<p>But NuttX configures the Standby Interval <strong>at runtime</strong>. That‚Äôs why we coded this function to set the Standby Interval: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Set Standby Interval for the sensor
static int bme280_set_interval(
  FAR struct device *priv,     //  NuttX Device Struct
  FAR unsigned int *period_us  //  Standby Interval in microseconds
) {
  //  Convert the Standby Interval to BME280 constant
  int ret = 0;
  uint8_t regval;
  switch (*period_us) {
    case 500: 
      regval = BME280_STANDBY_05_MS; break;
    ...
    case 4000000:
      regval = BME280_STANDBY_4000_MS; break;
    default:
      ret = -EINVAL; break;
  }

  //  Set the Standby Interval
  if (ret == 0) {
    ret = bme280_set_standby(priv, regval);
  }
  return ret;
}
</code></pre></div>
<p><strong>bme280_set_standby</strong> is defined below: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L237-L285">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Set Standby Duration. Zephyr assumes that Standby Duration is static, so we set it in NuttX.
static int bme280_set_standby(
  FAR struct device *priv,  //  NuttX Device Struct
  uint8_t value             //  BME280 constant for Standby Duration
) {
  //  Set the standby duration value by writing to BME280 Register
  int ret = bme280_reg_read(priv, BME280_REG_CONFIG, &amp;v_data_u8, 1);
  uint8_t v_data_u8 = (v_data_u8 &amp; ~(0x07 &lt;&lt; 5)) | (value &lt;&lt; 5);
  ret = bme280_reg_write(priv, BME280_REG_CONFIG, v_data_u8);
  ...
  //  Check the standby duration value by reading from BME280 Register
  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &amp;v_data_u8, 1);
  uint8_t v_sb_u8 = (v_data_u8 &gt;&gt; 5) &amp; 0x07;
  //  Omitted: Return error if v_sb_u8 != value
</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L147-L235">(<strong>bme280_reg_read</strong> and <strong>bme280_reg_write</strong> are defined here)</a></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/drivers/sensors/bmp280.c#L330-L565">(<strong>bme280_set_interval</strong> and <strong>bme280_set_standby</strong> were cloned from the NuttX BMP280 Driver)</a></p>
<p>We‚Äôll cover <strong>bme280_register</strong> in the next chapter.</p>
<p><img src="https://lupyuen.github.io/images/bme280-combine1.png" alt="Combined Barometer and Humidity Sensor" /></p>
<h1 id="combined-barometer-and-humidity-sensor"><a href="#combined-barometer-and-humidity-sensor">4 Combined Barometer and Humidity Sensor</a></h1>
<p><em>What kinds of Sensors are supported by NuttX?</em></p>
<p>Temperature, Humidity, Pressure, GPS, ECG, PM 2.5 and many more. <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/sensors/sensor.h">(Here‚Äôs the list)</a></p>
<p>NuttX‚Äôs BMP280 Driver implements a <a href="https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L326-L331"><strong>Barometer Sensor</strong></a> that provides Pressure and Temperature values.</p>
<p><em>What about BME280? Is there a NuttX Sensor that supports Pressure + Temperature + Humidity?</em></p>
<p>Sadly no. Thus our BME280 Driver shall implement a <strong>Composite Sensor</strong> that behaves like two NuttX Sensors combined‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L326-L331"><strong>Barometer Sensor: /dev/uorb/sensor_baro0</strong></a></p>
<p>(For Pressure and Temperature)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L345-L349"><strong>Humidity Sensor: /dev/uorb/sensor_humi0</strong></a></p>
<p>(For Humidity)</p>
</li>
</ul>
<p>We mash together the two sensors like so: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/device.h#L36-L49">device.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  NuttX Device for BME280
struct device {
  //  Barometer Sensor (Pressure + Temperature)
  FAR struct sensor_lowerhalf_s sensor_baro;  
  //  Humidity Sensor
  FAR struct sensor_lowerhalf_s sensor_humi;  

  FAR struct i2c_master_s *i2c;  //  NuttX I2C interface
  uint8_t addr;                  //  BME280 I2C address
  int     freq;                  //  BME280 Frequency &lt;= 3.4MHz
  bool    activated;             //  True if device is not in sleep mode
  char    *name;                 //  Name of the device (BME280)
  struct  bme280_data *data;     //  Compensation parameters (bme280.c)
};
</code></pre></div>
<p>Let‚Äôs dive into the implementation of the two NuttX Sensors.</p>
<h2 id="sensor-operations"><a href="#sensor-operations">4.1 Sensor Operations</a></h2>
<p>Earlier we talked about the functions exposed by our NuttX Sensor Driver‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-port4.jpg" alt="Zephyr BME280 Driver mapped to NuttX Driver" /></p>
<p>Now we expose the functions twice (double exposure?) as the <strong>Sensor Operations</strong> for our Barometer and Humidity Sensors: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L71-L87">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Operations for Barometer Sensor
static const struct sensor_ops_s g_baro_ops = {
  .activate      = bme280_activate_baro,
  .fetch         = bme280_fetch_baro,
  .set_interval  = bme280_set_interval_baro,
};

//  Operations for Humidity Sensor
static const struct sensor_ops_s g_humi_ops = {
  .activate      = bme280_activate_humi,
  .fetch         = bme280_fetch_humi,
  .set_interval  = bme280_set_interval_humi,
};
</code></pre></div>
<p><em>Barometer Sensor vs Humidity Sensor‚Ä¶ How different are the Sensor Operations?</em></p>
<p>The Sensor Operations look highly similar. This is how we fetch the <strong>Barometer Sensor Data</strong>: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L574-L617">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Called by NuttX to fetch pressure and temperature from sensor
static int bme280_fetch_baro(
  FAR struct sensor_lowerhalf_s *lower,  //  Barometer Sensor
  FAR struct file *filep,  // NuttX File
  FAR char *buffer,  //  Buffer to return Sensor Data
  size_t buflen      //  Size of Buffer
) {
  //  Get NuttX Device Struct
  FAR struct device *priv = container_of(
    lower,              //  Barometer Sensor
    FAR struct device,  //  NuttX Device Struct
    sensor_baro         //  Barometer Sensor Struct
  );

  //  Validate buffer size
  struct sensor_baro baro_data;
  if (buflen != sizeof(baro_data)) { return -EINVAL; }

  //  Fetch the sensor data
  int ret = bme280_fetch(priv, &amp;baro_data, NULL);
  if (ret &lt; 0) { return ret; }

  //  Return the sensor data
  memcpy(buffer, &amp;baro_data, sizeof(baro_data));
  return buflen;
}
</code></pre></div>
<p>And this is how we fetch the <strong>Humidity Sensor Data</strong>: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L619-L662">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Called by NuttX to fetch humidity from sensor
static int bme280_fetch_humi(
  FAR struct sensor_lowerhalf_s *lower,  //  Humidity Sensor
  FAR struct file *filep,  // NuttX File
  FAR char *buffer,  //  Buffer to return Sensor Data
  size_t buflen      //  Size of Buffer
) {
  //  Get NuttX Device Struct
  FAR struct device *priv = container_of(
    lower,              //  Humidity Sensor
    FAR struct device,  //  NuttX Device Struct
    sensor_humi         //  Humidity Sensor Struct
  );

  //  Validate buffer size
  struct sensor_humi humi_data;
  if (buflen != sizeof(humi_data)) { return -EINVAL; }

  //  Fetch the sensor data
  int ret = bme280_fetch(priv, NULL, &amp;humi_data);
  if (ret &lt; 0) { return ret; }

  //  Return the sensor data
  memcpy(buffer, &amp;humi_data, sizeof(humi_data));
  return buflen;
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/bme280#read-sensor-data-from-zephyr-driver">(We‚Äôve seen <strong>bme280_fetch</strong> earlier)</a></p>
<p>The other Sensor Operations look similar too‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L433-L458"><strong>bme280_activate_baro</strong></a> vs <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L460-L485"><strong>bme280_activate_humi</strong></a></p>
<p>(Both functions call <a href="https://lupyuen.github.io/articles/bme280#power-management"><strong>bme280_activate</strong></a>)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L343-L368"><strong>bme280_set_interval_baro</strong></a> vs <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L370-L395"><strong>bme280_set_interval_humi</strong></a></p>
<p>(Both functions call <a href="https://lupyuen.github.io/articles/bme280#standby-interval"><strong>bme280_set_interval</strong></a>)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/bme280-combine3a.png" alt="Register Sensors" /></p>
<h2 id="register-sensors"><a href="#register-sensors">4.2 Register Sensors</a></h2>
<p>At NuttX Startup we <strong>register the Barometer and Humidity Sensors</strong>: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Register the BME280 device at startup
int bme280_register(
  int devno,  //  Instance number for driver
  FAR struct i2c_master_s *i2c  //  I2C Interface
) {
  //  Initialize the NuttX Device Struct
  FAR struct device *priv = (FAR struct device *)kmm_zalloc(sizeof(struct device));
  ...
  //  Allocate the Compensation Parameters
  struct bme280_data *data = (FAR struct bme280_data *)kmm_zalloc(sizeof(struct bme280_data));
  priv-&gt;data = data;
  ...
  //  Initialize the Barometer Sensor
  priv-&gt;sensor_baro.ops  = &amp;g_baro_ops;
  priv-&gt;sensor_baro.type = SENSOR_TYPE_BAROMETER;

  //  Initialize the Humidity Sensor
  priv-&gt;sensor_humi.ops  = &amp;g_humi_ops;
  priv-&gt;sensor_humi.type = SENSOR_TYPE_RELATIVE_HUMIDITY;

  //  Initialize the Sensor Hardware (Zephyr BME280 Driver)
  int ret = bme280_chip_init(priv);
  ...
  //  Set Power Mode to sleep (Zephyr BME280 Driver)
  ret = bme280_pm_action(priv, PM_DEVICE_ACTION_SUSPEND);
  ...
  //  Register the Barometer Sensor
  ret = sensor_register(&amp;priv-&gt;sensor_baro, devno);
  ...
  //  Register the Humidity Sensor
  ret = sensor_register(&amp;priv-&gt;sensor_humi, devno);
</code></pre></div>
<p>The function above is called at startup by <strong>bl602_bringup</strong>: <a href="https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_SENSORS_BME280
#include &lt;nuttx/sensors/bme280.h&gt;
#endif /* CONFIG_SENSORS_BME280 */
...
int bl602_bringup(void) {
  ...
#ifdef CONFIG_SENSORS_BME280
  //  Init I2C bus for BME280
  struct i2c_master_s *bme280_i2c_bus = bl602_i2cbus_initialize(0);
  if (!bme280_i2c_bus) { _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0); }

  //  Register the BME280 driver
  ret = bme280_register(0, bme280_i2c_bus);
  if (ret &lt; 0) { _err(&quot;ERROR: Failed to register BME280\n&quot;); }
#endif  //  CONFIG_SENSORS_BME280
</code></pre></div>
<p><strong>For ESP32:</strong> Edit the function <a href="https://github.com/lupyuen/nuttx/blob/master/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497">esp32_bringup</a> in <a href="https://github.com/lupyuen/nuttx/blob/master/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497">esp32_bringup.c</a> so that it calls <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773">bme280_register</a></p>
<p>One last thing before running the BME280 Driver: We need to bundle together the NuttX and Zephyr Drivers.</p>
<p><img src="https://lupyuen.github.io/images/bme280-port4.jpg" alt="Zephyr BME280 Driver mapped to NuttX Driver" /></p>
<h1 id="bundle-nuttx-and-zephyr-drivers"><a href="#bundle-nuttx-and-zephyr-drivers">5 Bundle NuttX and Zephyr Drivers</a></h1>
<p><em>Our BME280 Driver consists of two source files: bme280.c and driver.c. Will this work with NuttX?</em></p>
<p>Nope this won‚Äôt compile with NuttX, because it assumes that every Sensor Driver <strong>lives in its own file</strong>. <a href="https://github.com/lupyuen/nuttx/blob/master/drivers/sensors/bmp280.c">(Like bmp280.c)</a></p>
<p>To work around this, we bundle together the Zephyr Driver (bme280.c) and NuttX Driver (driver.c) into a <strong>single source file</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c"><strong>bme280-nuttx/bundle.c</strong></a></li>
</ul>
<p>And we create a <strong>Symbolic Link</strong> at <a href="https://github.com/lupyuen/nuttx/blob/master/drivers/sensors/bme280.c"><strong>drivers/sensors/bme280.c</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Go to the NuttX Sensors Source directory
pushd nuttx/nuttx/drivers/sensors

## Add the BME280 Driver as a submodule
git submodule add \
  https://github.com/lupyuen/bme280-nuttx \
  bme280

## Create the Symbolic Link to the bundled source file
ln -s \
  bme280/bundle.c \
  bme280.c

## Return to the top directory
popd
</code></pre></div>
<p>We do the same for the bundled include file <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.h"><strong>bme280-nuttx/bundle.h</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Go to the NuttX Sensors Include directory
pushd nuttx/nuttx/include/nuttx/sensors

## Create the Symbolic Link to the bundled include file
ln -s \
  ../../../drivers/sensors/bme280/bundle.h \
  bme280.h

## Return to the top directory
popd
</code></pre></div>
<p>Which is Sym-Linked at <a href="https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/bme280.h"><strong>include/nuttx/sensors/bme280.h</strong></a></p>
<p><em>This bundling looks complicated. Why not merge the Zephyr and NuttX Drivers into a single source file?</em></p>
<p>We wanted to reuse the Zephyr Driver with <strong>minimal changes</strong> so that‚Ä¶</p>
<ul>
<li>
<p>We can <strong>track changes</strong> to the Zephyr source code‚Ä¶</p>
</li>
<li>
<p>By <strong>isolating the parts</strong> that were modified for NuttX</p>
</li>
</ul>
<p>And hopefully we can apply the same steps to port other Zephyr Drivers to NuttX.</p>
<p>Let‚Äôs look inside the bundle.</p>
<p><img src="https://lupyuen.github.io/images/bme280-code7a.png" alt="Inside the bundle" /></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c">(Source)</a></p>
<h2 id="inside-the-bundle"><a href="#inside-the-bundle">5.1 Inside the Bundle</a></h2>
<p><em>What‚Äôs inside the bundled source file <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c"><strong>bundle.c</strong></a>?</em></p>
<p>We define the <strong>Constants and Macros</strong> needed by the Zephyr Driver: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c#L12-L29">bundle.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Zephyr BME280 Options from
//  https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/Kconfig
#define CONFIG_BME280_MODE_NORMAL        //  Normal Sampling Mode (continuous measurements)
#define CONFIG_BME280_TEMP_OVER_2X       //  Temperature Oversamling 2x
#define CONFIG_BME280_PRESS_OVER_16X     //  Pressure Oversampling 16x
#define CONFIG_BME280_HUMIDITY_OVER_16X  //  Humidity Oversampling 16x
#define CONFIG_BME280_STANDBY_1000MS     //  Standby Time 1000ms. Note: Will be overwritten in bme280_set_standby
#define CONFIG_BME280_FILTER_4           //  Filter Coefficient 4
#define CONFIG_PM_DEVICE                 //  Enable Power Management

//  Other Zephyr Defines
#define BME280_BUS_I2C  0  //  I2C Bus
#define BME280_BUS_SPI  0  //  SPI Bus
#define __ASSERT_NO_MSG DEBUGASSERT  //  Assertion check
#define LOG_DBG         sninfo       //  Log info message
#define K_MSEC(ms)      (ms * 1000)  //  Convert milliseconds to microseconds
#define k_sleep(us)     usleep(us)   //  Sleep for microseconds
#define sys_le16_to_cpu(x) (x)       //  Convert from little endian to host endian. TODO: Handle big endian
</code></pre></div>
<p>Followed by the <strong>Zephyr Types</strong>: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c#L31-L55">bundle.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Zephyr Sensor Channel to be fetched from the sensor
enum sensor_channel {
  SENSOR_CHAN_ALL,           //  All Channels
  SENSOR_CHAN_AMBIENT_TEMP,  //  Ambient Temperature
  SENSOR_CHAN_PRESS,         //  Pressure
  SENSOR_CHAN_HUMIDITY,      //  Humidity
};

//  Zephyr Power Management Action
enum pm_device_action {
  PM_DEVICE_ACTION_SUSPEND,  //  Suspend the sensor
  PM_DEVICE_ACTION_RESUME,   //  Resume the sensor
};

//  Zephyr Power Management State
enum pm_device_state {
  PM_DEVICE_STATE_ACTIVE,     //  Sensor is active
  PM_DEVICE_STATE_SUSPENDED,  //  Sensor is suspended
};
 
//  Zephyr Sensor Value
struct sensor_value {
  int32_t val1;  //  Integer part of the value
  int32_t val2;  //  Fractional part of the value (in one-millionth parts)
};
</code></pre></div>
<p>And finally we <strong>embed the source code</strong> of the Zephyr and NuttX Drivers: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c#L74-L78">bundle.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Embed Zephyr BME280 Driver
#include &quot;bme280/bme280.c&quot;

//  Embed NuttX Driver Wrapper
#include &quot;bme280/driver.c&quot;
</code></pre></div>
<p>Yes this looks peculiar‚Ä¶</p>
<h2 id="zephyr-driver-modified-for-nuttx"><a href="#zephyr-driver-modified-for-nuttx">5.2 Zephyr Driver Modified For NuttX</a></h2>
<p><em>Sacrilege! We‚Äôre #include-ing C source files?!</em></p>
<p>Yeah this is probably the only way to port the Zephyr Driver to NuttX with the <strong>fewest changes</strong>.</p>
<p>Check out the <strong>minor modifications</strong> we made to the Zephyr BME280 Driver while porting to NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65"><strong>Changes to bme280.c</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-e13ff0ab44de7ead31a3dd6cbbbbf2a6fbfb2f04889300993b87ff5a31ffc233"><strong>Changes to bme280.h</strong></a></p>
</li>
</ul>
<p>In future we might merge the source files to clean this up. Not that hard!</p>
<p><img src="https://lupyuen.github.io/images/bme280-code12.png" alt="Changes to Zephyr BME280 Driver" /></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65">(Source)</a></p>
<h1 id="run-bme280-driver"><a href="#run-bme280-driver">6 Run BME280 Driver</a></h1>
<p>We‚Äôre finally ready to run our BME280 Driver!</p>
<ol>
<li>
<p>Follow these steps to <strong>build, flash and run</strong> NuttX (with our driver inside)‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/bme280#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>At the NuttX Shell, enter this command to list the <strong>NuttX Sensors</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev/uorb
</code></pre></div></li>
<li>
<p>We should see our BME280 <strong>Barometer and Humidity Sensors</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/dev/uorb:
 baro0
 humi0
</code></pre></div></li>
<li>
<p>To read the BME280 <strong>Barometer Sensor</strong> once, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sensortest -n 1 baro0
</code></pre></div></li>
<li>
<p>We should see the <strong>Air Pressure</strong> and <strong>Temperature</strong> readings‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SensorTest: Test /dev/uorb/sensor_baro0 with interval(1000000us), latency(0us)
baro0: 
  timestamp: 43760000 
  value1:     1011.29 
  value2:       29.09
SensorTest: Received message: baro0, number:1/1
</code></pre></div>
<p>This says that the Air Pressure is <strong>1,011.29 millibars</strong> and the Temperature is <strong>29.09 ¬∞C</strong>.</p>
</li>
<li>
<p>Now enter this command to read the BME280 <strong>Humidity Sensor</strong> once‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sensortest -n 1 humi0
</code></pre></div></li>
<li>
<p>We should see the <strong>Relative Humidity</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SensorTest: Test /dev/uorb/sensor_humi0 with interval(1000000us), latency(0us)
humi0: 
  timestamp: 60120000 
  value:     90.58
SensorTest: Received message: humi0, number:1/1
</code></pre></div>
<p>This says that the Relative Humidity is <strong>90.58 %</strong>.</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx#combined-barometer-and-humidity-sensor">(See the complete log)</a></p>
</li>
</ol>
<p>Yep our BME280 Driver runs successfully on NuttX!</p>
<p><img src="https://lupyuen.github.io/images/bme280-run8a.png" alt="Running our NuttX BME280 Driver" /></p>
<h1 id="sensor-test-app"><a href="#sensor-test-app">7 Sensor Test App</a></h1>
<p>Just now we ran the <strong>Sensor Test App</strong> to read BME280‚Äôs Barometer and Humidity Sensors (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; sensortest -n 1 baro0
baro0: 
  timestamp: 43760000 
  value1:     1011.29 
  value2:       29.09

nsh&gt; sensortest -n 1 humi0
humi0: 
  timestamp: 60120000 
  value:     90.58
</code></pre></div>
<p>(That‚Äôs 1,011.29 millibars, 29.09 ¬∞C, 90.58 % Humidity)</p>
<p>Let‚Äôs take a quick look inside the Sensor Test App, so that we can code our own Sensor Apps: <a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L233-L401">sensortest.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Sensor Test App
int main(int argc, FAR char *argv[]) {
  ...
  //  Allocate buffer for Sensor Data.
  //  len is Sensor Data size: sizeof(struct sensor_baro)
  FAR char *buffer = calloc(1, len);
</code></pre></div>
<p>The app begins by allocating a buffer for the Sensor Data Struct: <strong>sensor_baro</strong> (Barometer) or <strong>sensor_humi</strong> (Humidity).</p>
<p>Next we open the Sensor Device: <strong>/dev/uorb/sensor_baro0</strong> (Barometer) or <strong>/dev/uorb/sensor_humi0</strong> (Humidity)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Open the Sensor Device.
  //  devname looks like &quot;/dev/uorb/sensor_baro0&quot;
  int fd = open(devname, O_RDONLY | O_NONBLOCK);
  if (fd &lt; 0) { /* Handle error */ ... }
</code></pre></div>
<p>We set the <a href="https://lupyuen.github.io/articles/bme280#standby-interval"><strong>Standby Interval</strong></a> and <strong>Batch Latency</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set Standby Interval
  int ret = ioctl(fd, SNIOC_SET_INTERVAL, interval);
  if (ret &lt; 0) { /* Handle error */ ... }

  //  Set Batch Latency
  ret = ioctl(fd, SNIOC_BATCH, latency);
  if (ret &lt; 0) { /* Handle error */ ... }
</code></pre></div>
<p>We prepare to <strong>poll our sensor</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Prepare to poll the Sensor
  struct pollfd fds;
  fds.fd     = fd;
  fds.events = POLLIN;
</code></pre></div>
<p>Then we <strong>poll, read and print the Sensor Data</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Repeat until all samples have been read
  while ((!count || received &lt; count) &amp;&amp; !g_should_exit) {

    //  If Sensor Data is available...
    if (poll(&amp;fds, 1, -1) &gt; 0) {

      //  Read the Sensor Data
      if (read(fd, buffer, len) &gt;= len) {

        //  Print the Sensor Data
        received++;
        g_sensor_info[idx]
          .print(buffer, name);
      }
    }
  }
</code></pre></div>
<p>(We‚Äôll see <strong>g_sensor_info</strong> and <strong>print</strong> in a while)</p>
<p>Finally we <strong>close the sensor</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Close the Sensor Device and free the buffer
  close(fd);
  free(buffer);
</code></pre></div>
<p>Let‚Äôs talk about the printing of Sensor Data.</p>
<h2 id="print-sensor-data"><a href="#print-sensor-data">7.1 Print Sensor Data</a></h2>
<p>Earlier we saw this code for <strong>printing Sensor Data</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Print the Sensor Data
g_sensor_info[idx]
  .print(buffer, name);
</code></pre></div>
<p><em>What‚Äôs g_sensor_info?</em></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L77-L110"><strong>g_sensor_info</strong></a> is a Lookup Table that defines the <strong>Print Function</strong> for every Sensor Type.</p>
<p>(Remember that the Sensor Test App needs to handle all Sensor Types)</p>
<p>Here‚Äôs the Print Function for our <strong>Barometer Sensor</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L146-L151">sensortest.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Print Barometer Sensor Data: Pressure and Temperature
static void print_valf2(const char *buffer, const char *name) {

  //  Cast buffer as Barometer Sensor Data
  struct sensor_baro *event = 
    (struct sensor_baro *) buffer;

  //  Print Pressure and Temperature
  printf(
    &quot;%s: timestamp:%&quot; PRIu64 &quot; value1:%.2f value2:%.2f\n&quot;,
    name, 
    event-&gt;timestamp, 
    event-&gt;pressure, 
    event-&gt;temperature
  );
}
</code></pre></div>
<p>And here‚Äôs the Print Function for our <strong>Humidity Sensor</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L139-L144">sensortest.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Print Humidity or Proximity Sensor Data
static void print_valf(const char *buffer, const char *name) {

  //  Cast buffer as Proximity Sensor Data,
  //  which has same size as Humidity Sensor Data
  struct sensor_prox *event = 
    (struct sensor_prox *) buffer;

  //  Print Humidity or Proximity
  printf(
    &quot;%s: timestamp:%&quot; PRIu64 &quot; value:%.2f\n&quot;,
    name, 
    event-&gt;timestamp, 
    event-&gt;proximity
  );
}
</code></pre></div>
<p><em>But we‚Äôre printing Humidity, not Proximity‚Ä¶ Why cast to sensor_prox?</em></p>
<p>Yep we should cast to <strong>sensor_humi</strong> instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Cast buffer as Humidity Sensor Data
struct sensor_humi *event = 
  (struct sensor_humi *) buffer;
</code></pre></div>
<p>The Sensor Test App reuses the same function <strong>print_valf</strong> for printing both Humidity and Proximity Sensor Data. Which is OK because both structs contain the same field types.</p>
<p><em>How is the Print Function defined for each Sensor Type?</em></p>
<p>The Print Functions are defined in the Lookup Table <strong>g_sensor_info</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L77-L110">sensortest.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Lookup Table of all Sensor Types
static const struct sensor_info g_sensor_info[] = {
  ...
  //  Print Barometer Sensor Data with print_valf2
  { print_valf2, 
    sizeof(struct sensor_baro), 
    &quot;baro&quot; },

  //  Print Humidity Sensor Data with print_valf
  { print_valf,  
    sizeof(struct sensor_humi), 
    &quot;humi&quot; },
</code></pre></div>
<p>For our own Sensor App we probably won‚Äôt need this Lookup Table, since we know which Sensor Type we‚Äôre using.</p>
<p>(And we don‚Äôt need to cast our Sensor Data Structs too)</p>
<p><img src="https://lupyuen.github.io/images/bme280-pot.jpg" alt="Connect BME280 to #RISCV PineCone #BL602 @PINE64 ‚Ä¶ Preferably not on a cooking pot üòÇ" /></p>
<h1 id="whats-next"><a href="#whats-next">8 What‚Äôs Next</a></h1>
<p>Today we described the steps for porting the BME280 Driver from Zephyr OS to NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/bme280#set-i2c-sub-address">(And we fixed an I2C quirk on BL602)</a></p>
<p>I hope you‚Äôll be inspired to port <a href="https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers"><strong>other Zephyr drivers</strong></a> to NuttX!</p>
<p><em>Besides Zephyr OS, where else can we find drivers for NuttX?</em></p>
<p><a href="https://lupyuen.github.io/articles/rust2"><strong>Embedded Rust</strong></a> might be a terrific source of drivers for NuttX.</p>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">(Check out the Embedded Rust drivers)</a></p>
<p>But first we need to wrap up the <a href="https://github.com/lupyuen/nuttx-apps/tree/master/system/i2c"><strong>NuttX I2C ioctl Interface</strong></a> as a <a href="https://docs.rs/embedded-hal/0.2.6/embedded_hal/blocking/i2c/index.html"><strong>Rust Embedded HAL</strong></a>.</p>
<p>We‚Äôll cover this in the next article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rusti2c"><strong>‚ÄúRust talks I2C on Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>The BME280 Driver can also be called from Zig‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sensor"><strong>‚ÄúRead NuttX Sensor Data with Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/t9x9yk/apache_nuttx_driver_for_bme280_sensor_ported_from/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/bme280.md"><code>lupyuen.github.io/src/bme280.md</code></a></p>
<h1 id="notes"><a href="#notes">9 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1494301654186823683">this Twitter Thread</a></p>
</li>
<li>
<p>The design of the <strong>NuttX Sensor API</strong> is discussed here‚Ä¶</p>
<p><a href="https://github.com/apache/nuttx/pull/2039"><strong>‚ÄúUnified Management for Sensor‚Äù</strong></a></p>
</li>
<li>
<p>How to access the I2C Port in a <strong>NuttX App</strong> via ioctl? See this‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/rusti2c#appendix-read-i2c-register-in-c"><strong>‚ÄúRead I2C Register in C (NuttX App)‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/bme280-code3a.png" alt="Log I2C Transfers" /></p>
<h1 id="appendix-quirks-in-bl602-nuttx-i2c-driver"><a href="#appendix-quirks-in-bl602-nuttx-i2c-driver">10 Appendix: Quirks in BL602 NuttX I2C Driver</a></h1>
<p>The BL602 NuttX I2C Driver works in mysterious ways (because of the I2C Sub Address). In this section we‚Äôll explain how to make the driver work correctly, and attempt to decipher the original intentions of the driver‚Äôs creator.</p>
<p>BL602 has a peculiar I2C Port that requires us to send the Register ID as <strong>I2C Sub Address</strong> (I2C_SUB_ADDR), separately from the I2C Data‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-subaddress2.png" alt="I2C Sub Address" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en">(From BL602 Reference Manual)</a></p>
<p><em>Will BL602 I2C work if we disable I2C Sub Address?</em></p>
<p>Nope. If we disable I2C Sub Address, the Register ID sent will be <code>0x00</code>. <a href="https://lupyuen.github.io/articles/bme280#incorrect-register-id">(See this)</a></p>
<p>Thus we must set the Register ID as I2C Sub Address when reading and writing I2C Registers. Here‚Äôs how we do this by passing the <strong>I2C_M_NOSTOP</strong> flag‚Ä¶</p>
<h2 id="read-i2c-register"><a href="#read-i2c-register">10.1 Read I2C Register</a></h2>
<p>When <strong>reading an I2C Register</strong>, we set the flag <strong>I2C_M_NOSTOP</strong> like so: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L147-L198">bme280-nuttx/driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Read from 8-bit BME280 registers
static int bme280_reg_read(const struct device *priv,
  uint8_t start, uint8_t *buf, int size) {
  struct i2c_msg_s msg[2];
  int ret;

  //  Send Register ID
  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;
#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0
  msg[0].buffer    = &amp;start;
  msg[0].length    = 1;

  //  Receive Register Value
  msg[1].frequency = priv-&gt;freq;
  msg[1].addr      = priv-&gt;addr;
  msg[1].flags     = I2C_M_READ;
  msg[1].buffer    = buf;
  msg[1].length    = size;

  //  Execute I2C transfers
  ret = I2C_TRANSFER(priv-&gt;i2c, msg, 2);
</code></pre></div>
<p>This transmits the Register ID as I2C Sub Address, then receives the Register Value.</p>
<h2 id="write-i2c-register"><a href="#write-i2c-register">10.2 Write I2C Register</a></h2>
<p>When <strong>writing an I2C Register</strong>, we need two steps‚Ä¶</p>
<ol>
<li>
<p>Send the <strong>Register ID and Register Value</strong> (in a single chunk) as I2C Sub Address</p>
</li>
<li>
<p>Followed by <strong>I2C Read</strong></p>
</li>
</ol>
<p>Here‚Äôs how: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L200-L247">bme280-nuttx/driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Write to an 8-bit BME280 register
static int bme280_reg_write(const struct device *priv, uint8_t reg,
  uint8_t val) {
  struct i2c_msg_s msg[2];
  uint8_t txbuffer[2];
  uint8_t rxbuffer[1];
  int ret;

  //  Transmit buffer contains Register ID and value
  txbuffer[0] = reg;
  txbuffer[1] = val;

  //  Send Register ID and value
  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;
#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID and value must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID and value as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0
  msg[0].buffer    = txbuffer;
  msg[0].length    = 2;

  //  For BL602: We read I2C Data because this 
  //  forces BL602 to send the first message correctly
  msg[1].frequency = priv-&gt;freq;
  msg[1].addr      = priv-&gt;addr;
  msg[1].flags     = I2C_M_READ;
  msg[1].buffer    = rxbuffer;
  msg[1].length    = sizeof(rxbuffer);

  //  Execute I2C transfers
  ret = I2C_TRANSFER(priv-&gt;i2c, msg, 2);
</code></pre></div><h2 id="must-read-after-write"><a href="#must-read-after-write">10.3 Must Read After Write</a></h2>
<p><em>Why must we do I2C Read after sending the Register ID and value?</em></p>
<p>We‚Äôre not sure why this happens with the BL602 I2C Driver. But it works correctly when we checked with a Logic Analyser.</p>
<p>Here‚Äôs what happens when we run the code above to write <code>0xA0</code> to Register ID <code>0xF5</code> at I2C Address <code>0x77</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0xEE] + ACK
0xF5 + ACK
0xA0 + ACK
Setup Read to [0xEF] + ACK
0xA0 + NAK
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-logic3a.png" alt="Write 0xA0 to Register 0xF4" /></p>
<p>Which looks correct. There‚Äôs an extra I2C Read at the end, but it‚Äôs harmless.</p>
<p><em>What if we write to the I2C Register without reading?</em></p>
<p>The I2C Address is sent incorrectly (<code>0x02</code>) and the I2C Write gets truncated‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0x02] + NAK
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-noread.png" alt="Write to I2C Register without reading" /></p>
<p><em>What if we send the Register ID and Register Value as I2C Data (flags = 0) instead of I2C Sub Address?</em></p>
<p>The Register ID and value are sent incorrectly as <code>0x00 0x00</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0xEE] + ACK
0x00 + ACK
0x00 + ACK
(...600 microseconds later...)
Setup Read to [0xEF] + ACK
0x00 + NAK
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-nosubaddr.png" alt="Send the Register ID and Register Value as I2C Data instead of I2C Sub Address" /></p>
<p>Let‚Äôs try to make sense of this mysterious behaviour‚Ä¶</p>
<h2 id="i2c-sub-address"><a href="#i2c-sub-address">10.4 I2C Sub Address</a></h2>
<p><em>How is I2C Sub Address supposed to work on BL602 anyway?</em></p>
<p>Let‚Äôs compare with the I2C Driver from Bouffalo Lab‚Äôs official <strong>BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/i2c#set-i2c-device-address-and-register-address"><strong>‚ÄúSet I2C Device Address and Register Address‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/i2c#create-i2c-message"><strong>‚ÄúCreate I2C Message‚Äù</strong></a></p>
</li>
</ul>
<p>Here‚Äôs the code that reads Register ID <code>0xD0</code> from I2C Address <code>0x77</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Define I2C message and buffer
static i2c_msg_t read_msg;    //  Message for reading I2C Data
static uint8_t read_buf[32];  //  Buffer for reading I2C Data

static void test_i2c_start_read(char *buf, int len, int argc, char **argv) {
  //  Start reading data from I2C device
  //  Expect result 0x60 for BME280, 0x58 for BMP280
  int data_len = 1;  //  Bytes to be read
  memset(read_buf, 0, sizeof(read_buf));

  //  Set the I2C operation    
  read_msg.i2cx    = 0;            //  I2C Port
  read_msg.direct  = I2C_M_READ;   //  Read I2C data
  read_msg.block   = I2C_M_BLOCK;  //  Wait until data has been read

  //  Set the I2C buffer
  read_msg.buf     = read_buf;     //  Read buffer
  read_msg.len     = data_len;     //  Number of bytes to be read
  read_msg.idex    = 0;            //  Index of next byte to be read into buf

  //  Set device address and register address
  read_msg.addr    = 0x77;   //  BME280 I2C Secondary Address (Primary Address is 0x76)
  read_msg.subflag = 1;      //  Enable Register Address
  read_msg.subaddr = 0xd0;   //  Register Address (BME280 Chip ID)
  read_msg.sublen  = 1;      //  Length of Register Address (bytes)

  //  Start the I2C transfer and enable I2C interrupts
  gpstmsg = &amp;read_msg;
  i2c_transfer_start(&amp;read_msg);
</code></pre></div>
<p>Note that this code executes <strong>only one I2C Transfer</strong>.</p>
<p>(BL602 NuttX requires <strong>two I2C Transfers</strong>: One for Register ID, another for Register Value)</p>
<p>From BL602 IoT SDK we see that each I2C Transfer is allowed to specify an <strong>I2C Sub Address on top of each I2C Read / Write Transfer</strong>.</p>
<h2 id="bl602-i2c-driver"><a href="#bl602-i2c-driver">10.5 BL602 I2C Driver</a></h2>
<p>But on NuttX it seems that this overlay of I2C Sub Address on I2C Read / Write Transfers is <strong>not supported</strong>.</p>
<p>The creator of the BL602 NuttX I2C Driver has decided to split the I2C Sub Address and I2C Read / Write as <strong>two separate I2C Transfers</strong>.</p>
<p>We see this in the BL602 NuttX I2C Driver: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L710-L742">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Execute the I2C transfers
static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  priv-&gt;msgv = msgs;

  //  Execute each I2C Transfer...
  for (i = 0; i &lt; count; i++)
    {
      priv-&gt;bytes    = 0;
      priv-&gt;i2cstate = EV_I2C_END_INT;

      bl602_i2c_set_freq(msgs[i].frequency);

      //  If I2C_M_NOSTOP is specified, 
      //  send entire message as I2C Sub Address
      if (msgs[i].flags &amp; I2C_M_NOSTOP)
        {
          priv-&gt;subflag = 1;
          priv-&gt;subaddr = 0;
          for (j = 0; j &lt; msgs[i].length; j++)
            {
              priv-&gt;subaddr += msgs[i].buffer[j] &lt;&lt; (j * 8);
            }

          //  Note: Entire message is the I2C Sub Address!
          priv-&gt;sublen = msgs[i].length;
          i++;
        }
      //  Else send message as I2C Data
      //  (Read / Write Transfer)
      else
        {
          priv-&gt;subflag = 0;
          priv-&gt;subaddr = 0;
          priv-&gt;sublen  = 0;
        }

      priv-&gt;msgid = i;
      bl602_i2c_start_transfer(priv);
</code></pre></div>
<p>This driver code shows that each I2C Transfer is either‚Ä¶</p>
<ol>
<li>
<p><strong>I2C Sub Address</strong></p>
</li>
<li>
<p>Or <strong>I2C Data</strong> (Read / Write Transfer)</p>
</li>
</ol>
<p>No mixing of the two is allowed.</p>
<p>I haven‚Äôt deciphered the rest of the I2C Driver, but I think this separation of I2C Sub Address causes problems for I2C Write. Hence the need to do I2C Read after I2C Write.</p>
<p>In summary: The creator of the BL602 NuttX I2C Driver might have <strong>force-fitted I2C Sub Address</strong> into the NuttX I2C Interface, causing problems for I2C Write.</p>
<p>The solution? We might need to <strong>extend the NuttX I2C Interface</strong> to support I2C Sub Addresses. (Instead of I2C_M_NOSTOP)</p>
<p><a href="https://mcuxpresso.nxp.com/api_doc/dev/116/group__i2c.html">(Besides BL602, NXP Microcontrollers are probably the only ones that support I2C Sub Addresses)</a></p>
<h2 id="configure-i2c-transfer"><a href="#configure-i2c-transfer">10.6 Configure I2C Transfer</a></h2>
<p><em>How is the I2C Sub Address configured on NuttX?</em></p>
<p>Below is the code from the BL602 I2C Driver that configures the I2C Sub Address for each I2C Transfer: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L275-L319">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Configure the parameters for an I2C Transfer
static void bl602_i2c_config_para(struct bl602_i2c_priv_s *priv) {
  struct i2c_msg_s *msg = &amp;priv-&gt;msgv[priv-&gt;msgid];

  //  Set the I2C Direction: Read or write
  if (msg-&gt;flags &amp; I2C_M_READ)
    {
      modifyreg32(BL602_I2C_CONFIG, 0, I2C_CONFIG_CR_I2C_PKT_DIR);
    }
  else
    {
      modifyreg32(BL602_I2C_CONFIG, I2C_CONFIG_CR_I2C_PKT_DIR, 0);
    }

  //  Set the I2C Address
  modifyreg32(BL602_I2C_CONFIG,
              I2C_CONFIG_CR_I2C_SLV_ADDR_MASK,
              msg-&gt;addr &lt;&lt; I2C_CONFIG_CR_I2C_SLV_ADDR_SHIFT);

  //  If this I2C Transfer is for I2C Sub Address...
  if (priv-&gt;subflag &gt; 0)
    {
      //  Enable I2C Sub Address
      modifyreg32(BL602_I2C_CONFIG, 0, I2C_CONFIG_CR_I2C_SUB_ADDR_EN);
      //  Set the I2C Sub Address length
      modifyreg32(BL602_I2C_CONFIG,
                  I2C_CONFIG_CR_I2C_SUB_ADDR_BC_MASK,
                  (priv-&gt;sublen - 1) &lt;&lt; I2C_CONFIG_CR_I2C_SUB_ADDR_BC_SHIFT);
    }
  else
    {
      //  Else disable I2C Sub Address
      modifyreg32(BL602_I2C_CONFIG, I2C_CONFIG_CR_I2C_SUB_ADDR_EN, 0);
    }

  //  Set the I2C Message Length
  modifyreg32(BL602_I2C_CONFIG,
              I2C_CONFIG_CR_I2C_PKT_LEN_MASK,
              (msg-&gt;length - 1) &lt;&lt; I2C_CONFIG_CR_I2C_PKT_LEN_SHIFT);

  //  If this I2C Transfer is for I2C Sub Address...
  if (priv-&gt;subflag &gt; 0)
    {
      //  Set the I2C Sub Address
      putreg32(priv-&gt;subaddr, BL602_I2C_SUB_ADDR);
    }
}
</code></pre></div><h1 id="appendix-log-i2c-transfers"><a href="#appendix-log-i2c-transfers">11 Appendix: Log I2C Transfers</a></h1>
<p>Here‚Äôs how we modded the BL602 I2C Driver on NuttX to <strong>log the I2C transfers</strong>‚Ä¶</p>
<p>For sending I2C data: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L194-L197">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_i2c_send_data(struct bl602_i2c_priv_s *priv)
{
  ...
  putreg32(temp, BL602_I2C_FIFO_WDATA);
  priv-&gt;bytes += count;
  //  Insert this
  i2cinfo(&quot;count=%d, temp=0x%x\n&quot;, count, temp);
}
</code></pre></div>
<p>For receiving I2C data: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L207-L216">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_i2c_recvdata(struct bl602_i2c_priv_s *priv)
{
  ...
  count = msg-&gt;length - priv-&gt;bytes;
  temp  = getreg32(BL602_I2C_FIFO_RDATA);
  //  Insert this
  i2cinfo(&quot;count=%d, temp=0x%x\n&quot;, count, temp);
</code></pre></div>
<p>For I2C transfers: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L740-L742">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev,
                              struct i2c_msg_s *   msgs,
                              int                      count)
{
  ...
  for (i = 0; i &lt; count; i++)
    {
      ...
      priv-&gt;msgid = i;
      //  Insert this before bl602_i2c_start_transfer
      i2cinfo(&quot;subflag=%d, subaddr=0x%x, sublen=%d\n&quot;, priv-&gt;subflag, priv-&gt;subaddr, priv-&gt;sublen);
</code></pre></div><h1 id="appendix-build-flash-and-run-nuttx"><a href="#appendix-build-flash-and-run-nuttx">12 Appendix: Build, Flash and Run NuttX</a></h1>
<p><em>(For BL602, BL604 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602, BL604 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="download-nuttx"><a href="#download-nuttx">12.1 Download NuttX</a></h2>
<p>To use the NuttX BME280 Driver, download the modified source code for <strong>NuttX OS and NuttX Apps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive https://github.com/lupyuen/nuttx nuttx
git clone --recursive https://github.com/lupyuen/nuttx-apps apps
</code></pre></div>
<p>Or if we prefer to <strong>add the BME280 Driver</strong> to our NuttX Project, follow these instructions‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bme280-nuttx#install-driver"><strong>‚ÄúInstall BME280 Driver‚Äù</strong></a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features">(<strong>For PineDio Stack BL604:</strong> The BME280 Driver is already preinstalled)</a></p>
<h2 id="configure-nuttx"><a href="#configure-nuttx">12.2 Configure NuttX</a></h2>
<p>Now we configure our NuttX project‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Edit the Build Config
make menuconfig 
</code></pre></div></li>
<li>
<p>Enable <strong>I2C0 Port</strong>‚Ä¶</p>
<p><strong>For BL602 / BL604:</strong> Check the box for <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúBL602 Peripheral Support‚Äù</strong> ‚Üí <strong>‚ÄúI2C0‚Äù</strong></p>
<p><strong>For ESP32:</strong> Check the box for <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúESP32 Peripheral Select‚Äù</strong> ‚Üí <strong>‚ÄúI2C 0‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/bme280-config1.jpg" alt="Enable the I2C Port and I2C Character Driver" /></p>
</li>
<li>
<p>Enable <strong>I2C Character Driver</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúDevice Drivers‚Äù</strong> ‚Üí <strong>‚ÄúI2C Driver Support‚Äù</strong> ‚Üí <strong>‚ÄúI2C Character Driver‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>BME280 Driver</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúDevice Drivers‚Äù</strong> ‚Üí <strong>‚ÄúSensor Device Support‚Äù</strong></p>
<p>Select <strong>‚ÄúSensor Device Support‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúBosch BME280 Sensor‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p>The BME280 Driver will appear in NuttX at <strong>/dev/uorb/sensor_baro0</strong> and <strong>/dev/uorb/sensor_humi0</strong></p>
</li>
<li>
<p>Enable <strong>Sensor Driver Test App</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúTesting‚Äù</strong> ‚Üí <strong>‚ÄúSensor Driver Test‚Äù</strong></p>
<p>Set <strong>‚ÄúSensor Driver Test Stack Size‚Äù</strong> to <strong>4096</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/bme280-config4a.png" alt="Enable the Sensor Test App" /></p>
</li>
<li>
<p>Enable <strong>ls</strong> command‚Ä¶</p>
<p>Select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúNSH Library‚Äù</strong> ‚Üí <strong>‚ÄúDisable Individual commands‚Äù</strong></p>
<p>Uncheck <strong>‚ÄúDisable ls‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>Logging and Assertion Checks</strong>‚Ä¶</p>
<p>Select <strong>‚ÄúBuild Setup‚Äù</strong> ‚Üí <strong>‚ÄúDebug Options‚Äù</strong></p>
<p>Check the boxes for the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable Debug Features
Enable Error Output
Enable Warnings Output
Enable Informational Debug Output
Enable Debug Assertions
I2C Debug Features
I2C Error Output
I2C Warnings Output
I2C Informational Output  
Sensor Debug Features
Sensor Error Output
Sensor Warnings Output  
Sensor Informational Output 
</code></pre></div>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/9d84889f5e2415ecb0f28cea2c2a657f">(See the .config for BL602)</a></p>
</li>
</ol>
<h2 id="build-nuttx"><a href="#build-nuttx">12.3 Build NuttX</a></h2>
<p>Follow these steps to build NuttX for BL602, BL604 or ESP32‚Ä¶</p>
<ol>
<li>
<p>To build NuttX, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make
</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746">(See the complete log for BL602 / BL604)</a></p>
</li>
<li>
<p><strong>For WSL:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>c:\blflash</strong> directory in the Windows File System‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  /mnt/c/blflash refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash
</code></pre></div>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 / BL604 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx"><a href="#flash-nuttx">12.4 Flash NuttX</a></h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602 / BL604:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux: Change &quot;/dev/ttyUSB0&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change &quot;/dev/tty.usbserial-1410&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change &quot;COM5&quot; to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx"><a href="#run-nuttx">12.5 Run NuttX</a></h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0
</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602 / BL604:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;
</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p><strong>macOS Tip:</strong> Here‚Äôs the script I use to build, flash and run NuttX on macOS, all in a single step: <a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">run.sh</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="Script to build, flash and run NuttX on macOS" /></p>
<p><a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">(Source)</a></p>

    
</body>
</html>