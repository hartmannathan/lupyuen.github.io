<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Simulate RISC-V BL602 with WebAssembly, uLisp and Blockly</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Simulate RISC-V BL602 with WebAssembly, uLisp and Blockly" 
    data-rh="true">
<meta property="og:description" 
    content="How we simulate the BL602 RISC-V SoC with uLisp in WebAssembly... And preview Blockly uLisp Apps in the Web Browser"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/wasm-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Simulate RISC-V BL602 with WebAssembly, uLisp and Blockly</h1>
    <nav id="rustdoc"><ul>
<li><a href="#emscripten-and-webassembly" title="Emscripten and WebAssembly">1 Emscripten and WebAssembly</a><ul></ul></li>
<li><a href="#repl-in-a-web-browser" title="REPL in a Web Browser">2 REPL in a Web Browser</a><ul></ul></li>
<li><a href="#render-the-bl602-simulator" title="Render the BL602 Simulator">3 Render the BL602 Simulator</a><ul></ul></li>
<li><a href="#simulate-bl602-hardware" title="Simulate BL602 Hardware">4 Simulate BL602 Hardware</a><ul></ul></li>
<li><a href="#add-a-simulation-event" title="Add a Simulation Event">5 Add a Simulation Event</a><ul></ul></li>
<li><a href="#get-the-simulation-events" title="Get the Simulation Events">6 Get the Simulation Events</a><ul></ul></li>
<li><a href="#flip-the-simulated-led" title="Flip the Simulated LED">7 Flip the Simulated LED</a><ul></ul></li>
<li><a href="#simulate-delays" title="Simulate Delays">8 Simulate Delays</a><ul></ul></li>
<li><a href="#simulate-loops" title="Simulate Loops">9 Simulate Loops</a><ul></ul></li>
<li><a href="#add-simulator-to-blockly" title="Add Simulator to Blockly">10 Add Simulator to Blockly</a><ul></ul></li>
<li><a href="#simulate-blockly-programs" title="Simulate Blockly Programs">11 Simulate Blockly Programs</a><ul></ul></li>
<li><a href="#can-we-simulate-any-bl602-firmware" title="Can We Simulate Any BL602 Firmware?">12 Can We Simulate Any BL602 Firmware?</a><ul></ul></li>
<li><a href="#why-simulate-a-stream-of-events" title="Why Simulate A Stream Of Events?">13 Why Simulate A Stream Of Events?</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">14 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes" title="Notes">15 Notes</a><ul></ul></li></ul></nav><p>üìù <em>27 May 2021</em></p>
<p><em>Drag-and-drop uLisp programs for microcontrollers‚Ä¶ And run them WITHOUT a microcontroller!</em></p>
<p>What if we‚Ä¶</p>
<ol>
<li>
<p>Compile the <strong>uLisp Interpreter <a href="https://lupyuen.github.io/articles/lisp">(from the previous article)</a> to WebAssembly</strong>‚Ä¶</p>
</li>
<li>
<p>Use the WebAssembly version of uLisp to <strong>simulate BL602 in a Web Browser</strong>‚Ä¶</p>
<p>(Including GPIO, I2C, SPI, Display Controller, Touch Controller, LVGL, LoRa‚Ä¶ <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/simulator">Similar to this</a>)</p>
</li>
<li>
<p>Integrate the <strong>BL602 Simulator with Blockly</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/lisp">(Also from the previous article)</a></p>
</li>
<li>
<p>So that Embedded Developers may <strong>preview their Blockly uLisp Apps in the Web Browser</strong>?</p>
</li>
</ol>
<p>Today we shall build a simple simulator for the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V + WiFi SoC</strong></a> that will run Blockly uLisp Apps in a Web Browser.</p>
<p>(No BL602 hardware needed!)</p>
<ul>
<li><a href="https://youtu.be/Ag2CERd1OzQ"><strong>Watch the BL602 Simulator demo on YouTube</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-title.png" alt="BL602 Simulator with Blockly and uLisp in WebAssembly" /></p>
<p><em>BL602 Simulator with Blockly and uLisp in WebAssembly</em></p>
<h1 id="emscripten-and-webassembly"><a class="doc-anchor" href="#emscripten-and-webassembly">¬ß</a>1 Emscripten and WebAssembly</h1>
<p><em>What is Emscripten?</em></p>
<p><a href="https://emscripten.org/"><strong>Emscripten compiles C programs into WebAssembly</strong></a> so that we can run them in a Web Browser.</p>
<p>(Think of WebAssembly as a kind of Machine Code that runs natively in any Web Browser)</p>
<p>Here‚Äôs how we compile our uLisp Interpreter <code>ulisp.c</code> <a href="https://lupyuen.github.io/articles/lisp">(from the last article)</a> with the <strong>Emscripten Compiler <code>emcc</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>emcc -g -s WASM=1 \
    src/ulisp.c wasm/wasm.c \
    -o ulisp.html \
    -I include \
    -s &quot;EXPORTED_FUNCTIONS=[ &#39;_setup_ulisp&#39;, &#39;_execute_ulisp&#39;, &#39;_clear_simulation_events&#39;, &#39;_get_simulation_events&#39; ]&quot; \
    -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[ &#39;cwrap&#39;, &#39;allocate&#39;, &#39;intArrayFromString&#39;, &#39;UTF8ToString&#39; ]&quot;</code></pre></div>
<p>(See the Makefile <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm.mk"><strong><code>wasm.mk</code></strong></a>. More about <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c"><strong><code>wasm.c</code></strong></a> in a while)</p>
<p>C programs that call the <strong>Standard C Libraries</strong> should build OK with Emscripten: <code>printf</code>, <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, <code>&lt;string.h&gt;</code>, ‚Ä¶</p>
<p>The Emscripten Compiler generates 3 output files‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.wasm"><strong><code>ulisp.wasm</code></strong></a>: Contains the <strong>WebAssembly Code</strong> generated for our C program.</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.js"><strong><code>ulisp.js</code></strong></a>: JavaScript module that <strong>loads the WebAssembly Code</strong> into a Web Browser and runs it</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html"><strong><code>ulisp.html</code></strong></a>: HTML file that we may open in a Web Browser to <strong>load the JavaScript module</strong> and run the WebAssembly Code</p>
</li>
</ul>
<p><a href="https://emscripten.org/docs/getting_started/downloads.html">(Instructions for installing Emscripten)</a></p>
<p><img src="https://lupyuen.github.io/images/lisp-wasm.png" alt="Compiling uLisp to WebAssembly with Emscripten" /></p>
<p><em>What are the <code>EXPORTED_FUNCTIONS</code>?</em></p>
<div class="example-wrap"><pre class="language-text"><code>-s &quot;EXPORTED_FUNCTIONS=[ &#39;_setup_ulisp&#39;, &#39;_execute_ulisp&#39;, &#39;_clear_simulation_events&#39;, &#39;_get_simulation_events&#39; ]&quot;</code></pre></div>
<p>These are the C functions from our uLisp Interpreter <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L5312-L5384"><code>ulisp.c</code></a> that will be <strong>exported to JavaScript</strong>.</p>
<p>Our uLisp Interpreter won‚Äôt do anything meaningful in a Web Browser unless these 2 functions are called‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L5312-L5319"><strong><code>_setup_ulisp</code></strong></a>: Initialise the uLisp Interpreter</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L5377-L5384"><strong><code>_execute_ulisp</code></strong></a>: Execute a uLisp script</p>
</li>
</ol>
<p>(We‚Äôll see the other 2 functions later)</p>
<p><em>How do we call the <code>EXPORTED_FUNCTIONS</code> from JavaScript?</em></p>
<p>Here‚Äôs how we call the WebAssembly functions <code>_setup_ulisp</code> and <code>_execute_ulisp</code> from JavaScript: <a href="https://github.com/lupyuen/ulisp-bl602/blob/f520d0d8bb1583828a0ab456c90df187cd1eef68/docs/ulisp.html#L1300-L1321"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  //  Init uLisp interpreter
  Module._setup_ulisp();

  //  Set the uLisp script 
  var scr = &quot;( list 1 2 3 )&quot;;

  //  Allocate WebAssembly memory for the script
  var ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);

  //  Execute the uLisp script in WebAssembly
  Module._execute_ulisp(ptr);

  //  Free the WebAssembly memory allocated for the script
  Module._free(ptr);
};</code></pre></div>
<p><a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html">(More about <code>allocate</code> and <code>free</code>)</a></p>
<p>To run this in a Web Browser, we browse to <code>ulisp.html</code> in a Local Web Server. (Sorry, WebAssembly won‚Äôt run from a Local Filesystem)</p>
<p>Our uLisp Interpreter in WebAssembly shows the result‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>(1 2 3)</code></pre></div>
<p><img src="https://lupyuen.github.io/images/lisp-wasm2.png" alt="Testing uLisp compiled with Emscripten" /></p>
<p><em>But <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c"><code>ulisp.c</code></a> contains references to the BL602 IoT SDK, so it won‚Äôt compile for WebAssembly?</em></p>
<p>For now, we replace the <strong>hardware-specific functions for BL602</strong> by Stub Functions (which will be fixed in a while)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef __EMSCRIPTEN__  //  If building for WebAssembly...
//  Use stubs for BL602 functions, will fix later.
int bl_gpio_enable_input(uint8_t pin, uint8_t pullup, uint8_t pulldown) 
    { return 0; }
int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown) 
    { return 0; }
int bl_gpio_output_set(uint8_t pin, uint8_t value) 
    { return 0; }
uint32_t time_ms_to_ticks32(uint32_t millisec) 
    { return millisec; }
void time_delay(uint32_t millisec)
    {}

#else                    //  If building for BL602...
#include &lt;bl_gpio.h&gt;     //  For BL602 GPIO Hardware Abstraction Layer
#include &quot;nimble_npl.h&quot;  //  For NimBLE Porting Layer (mulitasking functions)
#endif  //  __EMSCRIPTEN__</code></pre></div>
<p>The symbol <code>__EMSCRIPTEN__</code> is defined when we use the Emscripten compiler.</p>
<p>(Yep it‚Äôs possible to reuse the same <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c"><code>ulisp.c</code></a> for BL602 and WebAssembly!)</p>
<p><img src="https://lupyuen.github.io/images/wasm-stub.png" alt="BL602 IoT SDK stubbed out" /></p>
<h1 id="repl-in-a-web-browser"><a class="doc-anchor" href="#repl-in-a-web-browser">¬ß</a>2 REPL in a Web Browser</h1>
<p><em>uLisp in WebAssembly looks underwhelming. Where‚Äôs the REPL (Read-Evaluate-Print Loop)?</em></p>
<p>As we‚Äôve seen, <strong><code>printf</code> works perfectly fine</strong> in WebAssembly‚Ä¶ The output appears automagically in the HTML Text Box provided by Emscripten.</p>
<p>Console Input is a little more tricky. Let‚Äôs‚Ä¶</p>
<ol>
<li>
<p><strong>Add a HTML Text Box</strong> for input</p>
</li>
<li>
<p><strong>Execute the input text</strong> with uLisp</p>
</li>
</ol>
<p>Here‚Äôs how we add the HTML Text Box: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1242-L1248"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-html"><code>&lt;!-- HTML Text Box for input --&gt;
&lt;textarea id=&quot;input&quot;&gt;&lt;/textarea&gt;

&lt;!-- HTML Button that runs the uLisp script --&gt;
&lt;input id=&quot;run&quot; type=&quot;button&quot; value=&quot;Run&quot; onclick=&quot;runScript()&quot;&gt;&lt;/input&gt;</code></pre></div>
<p>Also we add a <strong>‚Äú<code>Run</code>‚Äù Button</strong> that will execute the uLisp Script entered into the Text Box.</p>
<p>Let‚Äôs refactor our JavaScript to <strong>separate the uLisp Initialisation and Execution</strong>.</p>
<p>Here‚Äôs how we initialise the uLisp Interpreter: <a href="https://github.com/lupyuen/ulisp-bl602/blob/88e4fb6fad8025ceb7a88ff7154db053cc2ab861/docs/ulisp.html#L1324-L1350"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  //  Init uLisp interpreter
  Module._setup_ulisp();
};</code></pre></div>
<p>In the <strong><code>runScript</code></strong> function (called by the ‚Äú<code>Run</code>‚Äù Button), we grab the uLisp Script from the text box and run it‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Run the script in the input box
function runScript() {
  //  Get the uLisp script from the input text box
  var scr = document.getElementById(&quot;input&quot;).value;

  //  Allocate WebAssembly memory for the script
  var ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);

  //  Execute the uLisp script
  Module._execute_ulisp(ptr);

  //  Free the WebAssembly memory allocated for the script
  Module._free(ptr);
}</code></pre></div>
<p>And our <strong>uLisp REPL in WebAssembly</strong> is done!</p>
<ul>
<li>
<p><a href="https://youtu.be/9uegWNcokxY"><strong>Watch the uLisp WebAssembly REPL demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try the uLisp WebAssembly REPL</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-repl.png" alt="uLisp REPL in WebAssembly" /></p>
<h1 id="render-the-bl602-simulator"><a class="doc-anchor" href="#render-the-bl602-simulator">¬ß</a>3 Render the BL602 Simulator</h1>
<p><em>How shall we render the Simulated BL602 Board?</em></p>
<p>Remember how we built the uLisp REPL with <strong>HTML and JavaScript</strong>?</p>
<p>Let‚Äôs do the same for the <strong>BL602 Simulator</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-simulator2.png" alt="BL602 Simulator in HTML and JavaScript" /></p>
<p>First we save this sketchy image of a PineCone BL602 Board as a <strong>PNG file: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/pinecone.png"><code>pinecone.png</code></a></strong></p>
<p><img src="https://lupyuen.github.io/images/wasm-photoshop.png" alt="Creating the BL602 simulator image" /></p>
<p>We <strong>load the PNG file</strong> in our web page: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1336-L1360"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  //  Omitted: Init uLisp interpreter
  ...
  // Load the simulator pic and render it
  const image = new Image();
  image.onload = renderSimulator;  //  Draw when image has loaded
  image.src = &#39;pinecone.png&#39;;      //  Image to be loaded
};</code></pre></div>
<p>This code calls the <strong><code>renderSimulator</code></strong> function when our BL602 image has been loaded into memory.</p>
<p>Emscripten has helpfully generated a <strong>HTML Canvas</strong> in <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1238-L1240"><code>ulisp.html</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-html"><code>&lt;canvas id=&quot;canvas&quot; class=&quot;emscripten&quot; oncontextmenu=&quot;event.preventDefault()&quot; tabindex=-1&gt;&lt;/canvas&gt;</code></pre></div>
<p>In the <strong><code>renderSimulator</code></strong> function, let‚Äôs <strong>render our BL602 image</strong> onto the HTML Canvas: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1348-L1360"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Render the simulator pic. Based on https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
function renderSimulator() {
  //  Get the HTML canvas and context
  const canvas = document.getElementById(&#39;canvas&#39;);
  const ctx = canvas.getContext(&#39;2d&#39;);

  //  Resize the canvas
  canvas.width  = 400;
  canvas.height = 300;

  //  Draw the image to fill the canvas
  ctx.drawImage(this, 0, 0, canvas.width, canvas.height);
}</code></pre></div>
<p>Our <strong>rendered BL602 Simulator</strong> looks like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wasm-image.png" alt="Rendering the BL602 simulator image" /></p>
<p><em>What about the LED?</em></p>
<p>To simulate the LED switching on, let‚Äôs draw a <strong>blue rectangle</strong> onto the HTML Canvas: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1447-L1470"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>//  Get the HTML Canvas Context
const ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);

//  LED On: Set the fill colour to Blue
ctx.fillStyle = &#39;#B0B0FF&#39;;  //  Blue

//  Draw the LED colour
ctx.fillRect(315, 116, 35, 74);</code></pre></div>
<p>Our <strong>rendered BL602 LED</strong> looks good‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wasm-led.png" alt="Rendering the LED" /></p>
<p>And to simulate the LED switching off, we draw a <strong>grey rectangle</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1447-L1470"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>//  LED Off: Set the fill colour to Grey
ctx.fillStyle = &#39;#CCCCCC&#39;;  //  Grey

//  Draw the LED colour
ctx.fillRect(315, 116, 35, 74);</code></pre></div>
<p>Now we wire up the Simulated BL602 LED to uLisp!</p>
<h1 id="simulate-bl602-hardware"><a class="doc-anchor" href="#simulate-bl602-hardware">¬ß</a>4 Simulate BL602 Hardware</h1>
<p>Our story so far‚Ä¶</p>
<ol>
<li>
<p>Our <strong>uLisp Interpreter lives in WebAssembly</strong> (compiled from C with Emscripten)</p>
</li>
<li>
<p>Our <strong>BL602 Simulator lives in JavaScript</strong> (rendered onto a HTML Canvas)</p>
</li>
</ol>
<p><em>How shall we connect uLisp to the BL602 Simulator‚Ä¶ And blink the Simulated LED?</em></p>
<p>Oh yes we have ways of <strong>making uLisp talk to BL602 Simulator</strong>‚Ä¶ From WebAssembly to JavaScript!</p>
<p>Here‚Äôs one way: A <strong>JSON Stream of BL602 Simulation Events</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-simulator.jpg" alt="BL602 Simulator Design" /></p>
<p><em>What‚Äôs a BL602 Simulation Event?</em></p>
<p>When uLisp needs to <strong>set the GPIO Output</strong> to High or Low (to flip an LED On/Off)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( digitalwrite 11 :high )</code></pre></div>
<p>It sends a <strong>Simulation Event</strong> to the BL602 Simulator (in JSON format)‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ &quot;gpio_output_set&quot;: { 
  &quot;pin&quot;: 11, 
  &quot;value&quot;: 1 
} }</code></pre></div>
<p>Which is handled by the BL602 Simulator to <strong>flip the Simulated LED</strong> on or off.</p>
<p>(Yes the blue LED we‚Äôve seen earlier)</p>
<p><em>Is uLisp directly controlling the BL602 Simulator?</em></p>
<p>Not quite. uLisp is <strong>indirectly controlling the BL602 Simulator</strong> by sending Simulation Events.</p>
<p>(There are good reasons for doing this <a href="https://en.wikipedia.org/wiki/Inversion_of_control"><strong>Inversion of Control</strong></a>, as well shall learn in a while)</p>
<p><em>What about time delays like <code>( delay 1000 )</code>?</em></p>
<p>uLisp generates <strong>Simulation Events for time delays</strong>. To handle such events, our BL602 Simulator pauses for the specified duration.</p>
<p>(It‚Äôs like playing a MIDI Stream)</p>
<p>Hence this uLisp script‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( delay 1000 )</code></pre></div>
<p>Will generate this Simulation Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }</code></pre></div>
<p><em>What‚Äôs a JSON Stream of Simulation Events?</em></p>
<p>To simulate a uLisp program on the BL602 Simulator, we shall pass an <strong>array of Simulation Events</strong> (in JSON format) from uLisp to the BL602 Simulator.</p>
<p>This (partial) uLisp program that sets the GPIO Output and waits 1 second‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( list
  ( digitalwrite 11 :high )
  ( delay 1000 )
  ...
)</code></pre></div>
<p>Will generate this <strong>JSON Stream of Simulation Events</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>[ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, 
  ... 
]</code></pre></div>
<p>That will simulate a blinking BL602 LED (eventually).</p>
<h1 id="add-a-simulation-event"><a class="doc-anchor" href="#add-a-simulation-event">¬ß</a>5 Add a Simulation Event</h1>
<p>Let‚Äôs watch how uLisp <strong>adds an event</strong> to the JSON Stream of Simulation Events.</p>
<p>We <strong>define a string buffer</strong> for the JSON array of events: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L8-L17"><code>wasm.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Buffer for JSON Stream of Simulation Events
static char events[1024] = &quot;[]&quot;;</code></pre></div>
<p>To <strong>append a GPIO Output Event</strong> to the buffer, uLisp calls the function <strong><code>bl_gpio_output_set</code></strong> from <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L60-L77"><code>wasm.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Add a GPIO event to set output (0 for low, 1 for high)
int bl_gpio_output_set(uint8_t pin, uint8_t value) {
    //  How many chars in the Simulation Events buffer to keep
    int keep = 
        strlen(events)  //  Keep the existing events
        - 1;            //  Skip the trailing &quot;]&quot;

    //  Append the GPIO Output Event to the buffer
    snprintf(
        events + keep,
        sizeof(events) - keep,
        &quot;, { \&quot;gpio_output_set\&quot;: { &quot;
            &quot;\&quot;pin\&quot;: %d, &quot;
            &quot;\&quot;value\&quot;: %d &quot;
        &quot;} } ]&quot;,
        pin,
        value
    );
    return 0; 
}</code></pre></div>
<p>This code appends a JSON event to the string buffer, which will look like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>[, { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } } ]</code></pre></div>
<p>We‚Äôll fix the leading comma ‚Äú<code>,</code>‚Äù in a while.</p>
<p><img src="https://lupyuen.github.io/images/wasm-add.png" alt="Add an event to the JSON Stream of Simulation Events" /></p>
<p><em>How is <code>bl_gpio_output_set</code> called by uLisp?</em></p>
<p>When we enter this uLisp script to set the GPIO Output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( digitalwrite 11 :high )</code></pre></div>
<p>The uLisp Interpreter calls <code>fn_digitalwrite</code> defined in <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L3544-L3562"><code>ulisp.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Set the GPIO Output to High or Low
object *fn_digitalwrite (object *args, object *env) {
    //  Omitted: Parse the GPIO pin number and High / Low
    ...
    //  Set the GPIO output (from BL602 GPIO HAL)
    int rc = bl_gpio_output_set(
        pin,  //  GPIO pin number
        mode  //  0 for low, 1 for high
    );</code></pre></div>
<p>Which calls our function <code>bl_gpio_output_set</code> to add the GPIO Output Event.</p>
<p><em>Will this work when running on real BL602 hardware?</em></p>
<p>Yep it does! <code>bl_gpio_output_set</code> is a real function defined in the <strong>BL602 IoT SDK</strong> for setting the GPIO Output.</p>
<p>Thus <code>fn_digitalwrite</code> (and the rest of uLisp) works fine on <strong>Real BL602 (hardware) and Simulated BL602 (WebAssembly)</strong>.</p>
<h1 id="get-the-simulation-events"><a class="doc-anchor" href="#get-the-simulation-events">¬ß</a>6 Get the Simulation Events</h1>
<p><em>uLisp (in WebAssembly) has generated the JSON Stream of BL602 Simulation Events. How will our BL602 Simulator (in JavaScript) fetch the Simulation Events?</em></p>
<p>To <strong>fetch the Simulation Events</strong>, we expose a getter function in WebAssembly like so: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L24-L32"><code>wasm.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Return the JSON Stream of Simulation Events
const char *get_simulation_events(void) {
  assert(events[0] == &#39;[&#39;);
  assert(events[strlen(events) - 1] == &#39;]&#39;);

  //  Erase the leading comma: &quot;[,...]&quot; becomes &quot;[ ...]&quot;
  if (events[1] == &#39;,&#39;) { events[1] = &#39; &#39;; }
  return events;
}</code></pre></div>
<p><strong><code>get_simulation_events</code></strong> returns the WebAssembly string buffer that contains the Simulation Events (in JSON format).</p>
<p><img src="https://lupyuen.github.io/images/wasm-stream2.png" alt="Clearing and getting Simulation Events" /></p>
<p>Switching over from uLisp WebAssembly to our <strong>BL602 Simulator in JavaScript</strong>‚Ä¶</p>
<p>Remember the <strong><code>runScript</code></strong> function we wrote for our uLisp REPL?</p>
<p>Let‚Äôs rewrite <code>runScript</code> to <strong>fetch the Simulation Events</strong> by calling <code>get_simulation_events</code>. From <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1362-L1407"><code>ulisp.html</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>/// JSON Stream of Simulation Events emitted by uLisp Interpreter. Looks like...
///  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
let simulation_events = [];

/// Run the script in the input box
function runScript() {
  //  Get the uLisp script 
  //  var scr = &quot;( list 1 2 3 )&quot;;
  const scr = document.getElementById(&quot;input&quot;).value;

  //  Allocate WebAssembly memory for the script
  const scr_ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);

  //  Catch any errors so that we can free the allocated memory
  try {
    //  Clear the JSON Stream of Simulation Events in WebAssembly
    Module._clear_simulation_events();

    //  Execute the uLisp script in WebAssembly
    Module.print(&quot;\nExecute uLisp: &quot; + scr + &quot;\n&quot;);
    Module._execute_ulisp(scr_ptr);</code></pre></div>
<p>This is similar to the earlier version of <code>runScript</code> except‚Ä¶</p>
<ol>
<li>
<p>We now have a static variable <strong><code>simulation_events</code></strong> that will store the Simulation Events</p>
</li>
<li>
<p>We use a <strong><code>try...catch...finally</code></strong> block to deallocate the WebAssembly memory.</p>
<p>(In case we hit errors in the JSON parsing)</p>
</li>
<li>
<p>We call <strong><code>_clear_simulation_events</code></strong> to erase the buffer of Simulation Events (in WebAssembly).</p>
<p>(More about this later)</p>
</li>
</ol>
<p>After calling <code>_execute_ulisp</code> to execute the uLisp Script, we <strong>fetch the generated Simulation Events</strong> by calling <code>_get_simulation_events</code> (which we‚Äôve seen earlier)‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>    //  Get the JSON string of Simulation Events from WebAssembly. Looks like...
    //  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
    //    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
    const json_ptr = Module._get_simulation_events();

    //  Convert the JSON string from WebAssembly to JavaScript
    const json = Module.UTF8ToString(json_ptr);</code></pre></div>
<p><code>_get_simulation_events</code> returns a <strong>pointer to a WebAssembly String</strong>.</p>
<p>Here we call <strong><code>UTF8ToString</code></strong> (from Emscripten) to convert the pointer to a <strong>JavaScript String</strong>.</p>
<p>We <strong>parse the returned string</strong> as a JSON array of Simulation Events‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>    //  Parse the JSON Stream of Simulation Events
    simulation_events = JSON.parse(json);
    Module.print(&quot;Events: &quot; + JSON.stringify(simulation_events, null, 2) + &quot;\n&quot;);</code></pre></div>
<p>And we store the parsed array of events into the static variable <strong><code>simulation_events</code></strong></p>
<p>In case the JSON Parsing fails, we have a <strong><code>try...catch...finally</code></strong> block to ensure that the WebAssembly memory is properly deallocated‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  } catch(err) {
    //  Catch and show any errors
    console.error(err);
  } finally {
    //  Free the WebAssembly memory allocated for the script
    Module._free(scr_ptr);
  }</code></pre></div>
<p>Now we‚Äôre ready to <strong>run the Simulated BL602 Events</strong> and blink the Simulated BL602 LED!</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Start a timer to simulate the returned events
  if (simulation_events.length &gt; 0) {
    window.setTimeout(&quot;simulateEvents()&quot;, 1);
  }
}</code></pre></div>
<p>We call a JavaScript Timer to trigger the function <strong><code>simulateEvents</code></strong>.</p>
<p>This simulates the events in <code>simulation_events</code> (like flipping the Simulated LED), one event at a time.</p>
<p><img src="https://lupyuen.github.io/images/wasm-stream.png" alt="GPIO Simulation Events" /></p>
<p><em>What‚Äôs inside the WebAssembly function <code>clear_simulation_events</code>?</em></p>
<p>Before running a uLisp Script, our BL602 Simulator calls <strong><code>clear_simulation_events</code></strong> to erase the buffer of Simulation Events: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L19-L22"><code>wasm.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Clear the JSON Stream of Simulation Events
void clear_simulation_events(void) {
  strcpy(events, &quot;[]&quot;);
}</code></pre></div><h1 id="flip-the-simulated-led"><a class="doc-anchor" href="#flip-the-simulated-led">¬ß</a>7 Flip the Simulated LED</h1>
<p><strong><code>simulateEvents</code></strong> is the <strong>Event Loop</strong> for our BL602 Simulator. It calls itself repeatedly to <strong>simulate each event</strong> generated by uLisp.</p>
<p>Here‚Äôs how it works: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1409-L1445"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Simulate the BL602 Simulation Events recorded in simulate_events, which contains...
///  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
function simulateEvents() {
  //  Take the first event and update the queue
  if (simulation_events.length == 0) { return; }
  const event = simulation_events.shift();
  //  event looks like:
  //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }

  //  Get the event type (gpio_output_set)
  //  and parameters ({ &quot;pin&quot;: 11, &quot;value&quot;: 1 })
  const event_type = Object.keys(event)[0];
  const args = event[event_type];</code></pre></div>
<p><strong><code>simulateEvents</code></strong> starts by fetching the <strong>next event to be simulated</strong> (from <code>simulation_events</code>).</p>
<p>It decodes the event into‚Ä¶</p>
<ol>
<li>
<p><strong>Event Type</strong>: Like‚Ä¶</p>
<p><code>gpio_output_set</code></p>
</li>
<li>
<p><strong>Event Parameters</strong>: Like‚Ä¶</p>
<p><code>{ "pin": 11, "value": 1 }</code></p>
</li>
</ol>
<p>Next it <strong>handles each Event Type</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Timeout in milliseconds to the next event
  let timeout = 1;

  //  Handle each event type
  switch (event_type) {

    //  Set GPIO output
    //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
    case &quot;gpio_output_set&quot;: 
      timeout += gpio_output_set(args.pin, args.value); 
      break;</code></pre></div>
<p>If we‚Äôre simulating a GPIO Output Event, we call the function <strong><code>gpio_output_set</code></strong> and pass the Event Parameters (<code>pin</code> and <code>value</code>).</p>
<p>(We‚Äôll talk about <code>gpio_output_set</code> and the timeout in a while)</p>
<div class="example-wrap"><pre class="language-javascript"><code>    //  Delay
    //  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
    case &quot;time_delay&quot;: 
      timeout += time_delay(args.ticks); 
      break;

    //  Unknown event type
    default: 
      throw new Error(&quot;Unknown event type: &quot; + event_type);
  }</code></pre></div>
<p>This code simulates time delays, which we‚Äôll see later.</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Simulate the next event
  if (simulation_events.length &gt; 0) {
    window.setTimeout(&quot;simulateEvents()&quot;, timeout);
  }
}</code></pre></div>
<p>Finally we <strong>simulate the next event</strong> (from <code>simulation_events</code>), by triggering <code>simulateEvents</code> with a JavaScript Timer.</p>
<p>And that‚Äôs how we simulate every event generated by uLisp!</p>
<p><em>What‚Äôs inside the function <code>gpio_output_set</code>?</em></p>
<p><strong><code>gpio_output_set</code></strong> is called by <code>simulateEvents</code> to simulate a GPIO Output Event: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1447-L1470"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Simulate setting GPIO pin output to value 0 (Low) or 1 (High):
/// { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
function gpio_output_set(pin, value) {
  //  Get the HTML Canvas Context
  const ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);</code></pre></div>
<p>First we fetch the <strong>HTML Canvas and its Context</strong>.</p>
<p>Then we <strong>set the Fill Colour</strong> to Blue or Grey, depending on GPIO Output Value‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Set the simulated LED colour depending on value
  switch (value) {
    //  Set GPIO to Low (LED on)
    case 0: ctx.fillStyle = &#39;#B0B0FF&#39;; break;  //  Blue

    //  Set GPIO to High (LED off)
    case 1: ctx.fillStyle = &#39;#CCCCCC&#39;; break;  //  Grey

    //  Unknown value
    default: throw new Error(&quot;Unknown gpio_output_set value: &quot; + args.value);
  }</code></pre></div>
<p>(Yes we‚Äôve seen this code earlier)</p>
<p>Finally we <strong>draw the Simulated LED</strong> with the Fill Colour (Blue or Grey)‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>  //  Draw the LED colour
  ctx.fillRect(315, 116, 35, 74);

  //  Simulate next event in 0 milliseconds
  return 0;
}</code></pre></div>
<p>Here‚Äôs what we see in the BL602 Simulator when we set the <strong>GPIO Output to Low</strong> (LED on)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>( digitalwrite <span class="number">11 </span>:low )</code></pre></div>
<ul>
<li>
<p><a href="https://youtu.be/KpvqCmFtPgc"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try it here</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-led.png" alt="Flip the simulated LED" /></p>
<h1 id="simulate-delays"><a class="doc-anchor" href="#simulate-delays">¬ß</a>8 Simulate Delays</h1>
<p><em>Now our BL602 Simulator flips the Simulated LED on and off. We‚Äôre ready to blink the Simulated LED right?</em></p>
<p>Not quite. We need to <strong>simulate Time Delays</strong> too!</p>
<p><em>Can‚Äôt we implement Time Delays by sleeping inside uLisp?</em></p>
<p>Not really. From what we‚Äôve seen, uLisp <strong>doesn‚Äôt run our script in real time</strong>.</p>
<p>uLisp merely generates a bunch of Simulation Events. The events need to be <strong>simulated in the correct time sequence</strong> by our BL602 Simulator.</p>
<p>Hence we also need to <strong>simulate Time Delays</strong> with a Simulation Event.</p>
<p><em>How does uLisp generate a Simulation Event for Time Delay?</em></p>
<p>When we run this uLisp Script‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( delay 1000 )</code></pre></div>
<p>Our uLisp Intepreter in WebAssembly <strong>generates a Time Delay Event</strong> like so: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L79-L93"><code>wasm.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Add a delay event. 1 tick is 1 millisecond
void time_delay(uint32_t ticks) { 
  //  How many chars in the Simulation Events buffer to keep
  int keep = 
    strlen(events)  //  Keep the existing events
    - 1;            //  Skip the trailing &quot;]&quot;

  //  Append the Time Delay Event to the buffer
  snprintf(
    events + keep,
    sizeof(events) - keep,
    &quot;, { \&quot;time_delay\&quot;: { &quot;
      &quot;\&quot;ticks\&quot;: %d &quot;
    &quot;} } ]&quot;,
    ticks
  );
}</code></pre></div>
<p>This code adds a <strong>Time Delay Event</strong> that looks like‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }</code></pre></div>
<p>(We define <strong>1 tick as 1 millisecond</strong>, so this event sleeps for 1 second)</p>
<p><em>How does our BL602 Simulator handle a Time Delay Event in JavaScript?</em></p>
<p>Earlier we‚Äôve seen <strong><code>simulateEvents</code></strong>, the Event Loop for our BL602 Simulator: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1409-L1445"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>function simulateEvents() {
  //  Take the first event
  const event = simulation_events.shift();
  ...
  //  Get the event type and parameters
  const event_type = Object.keys(event)[0];
  const args = event[event_type];
  ...
  //  Handle each event type
  switch (event_type) {
    ...
    //  Delay
    //  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
    case &quot;time_delay&quot;: 
      timeout += time_delay(args.ticks); 
      break;</code></pre></div>
<p><code>simulateEvents</code> handles the Time Delay Event by calling <strong><code>time_delay</code></strong> with the number of ticks (milliseconds) to delay: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1472-L1477"><code>ulisp.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Simulate a delay for the specified number of ticks (1 tick = 1 millisecond)
/// { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
function time_delay(ticks) {
  //  Simulate the next event in &quot;ticks&quot; milliseconds
  return ticks;
}</code></pre></div>
<p><strong><code>time_delay</code></strong> doesn‚Äôt do much‚Ä¶ It returns the <strong>number of ticks (milliseconds) to delay</strong>.</p>
<p>The magic actually happens in the calling function <code>simulateEvents</code>. From <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1409-L1445"><code>ulisp.html</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>function simulateEvents() {
  ...
  //  Get the delay in ticks / milliseconds
  timeout += time_delay(args.ticks);
  ...
  //  Simulate the next event
  if (simulation_events.length &gt; 0) {
    //  Timer expires in timeout milliseconds
    window.setTimeout(&quot;simulateEvents()&quot;, timeout);
  }
}</code></pre></div>
<p><code>simulateEvents</code> takes the returned value (number of ticks to wait) and <strong>sets the timeout of the JavaScript Timer</strong>.</p>
<p>(When the timer expires, it calls <code>simulateEvents</code> to handle the next Simulation Event)</p>
<p>Let‚Äôs watch <strong>Time Delay Events</strong> in action! Guess what happens when we run this uLisp Script with our BL602 Simulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( list
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
  ( delay 1000 )
)</code></pre></div>
<ul>
<li>
<p><a href="https://youtu.be/piRLuBYSjTw"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try it here</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-delay.png" alt="Simulating delays" /></p>
<h1 id="simulate-loops"><a class="doc-anchor" href="#simulate-loops">¬ß</a>9 Simulate Loops</h1>
<p>Let‚Äôs ponder this uLisp Script that <strong>blinks the LED in a loop</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( loop
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
  ( delay 1000 )
)</code></pre></div>
<p><em>Wait a minute‚Ä¶ Won‚Äôt this uLisp Script generate an Infinite Stream of Simulation Events? And overflow our 1024-byte event buffer?</em></p>
<p>Righto! We <strong>can‚Äôt allow uLisp Loops and Recursion to run forever</strong> in our simulator. We must stop them! (Eventually)</p>
<p>We <strong>stop runaway Loops and Recursion</strong> here: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L34-L46"><code>wasm.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Preempt the uLisp task and allow background tasks to run.
/// Called by eval() and sp_loop() in src/ulisp.c
void yield_ulisp(void) {
  //  If uLisp is running a loop or recursion,
  //  the Simulation Events buffer may overflow.
  //  We stop before the buffer overflows.
  if (strlen(events) + 100 &gt;= sizeof(events)) {  //  Assume 100 bytes of leeway

    //  Cancel the loop or recursion by jumping to loop_ulisp() in src/ulisp.c
    puts(&quot;Too many iterations, stopping the loop&quot;);
    extern jmp_buf exception;  //  Defined in src/ulisp.c
    longjmp(exception, 1);
  }
}</code></pre></div>
<p>uLisp calls <strong><code>yield_ulisp</code></strong> when it <strong>iterates through a loop</strong> or evaluates a recursive expression.</p>
<p>If <code>yield_ulisp</code> detects that the <strong>buffer for Simulation Events is about to overflow</strong>, it stops the uLisp Loop / Recursion by jumping out (<code>longjmp</code>) and reporting an exception.</p>
<p>(Which will return a <strong>truncated stream of Simulation Events</strong> to the BL602 Simulator)</p>
<p><em>Looks kinda simplistic?</em></p>
<p>Yes this solution might not work for some kinds of uLisp Loops and Recursion. But it‚Äôs sufficient to <strong>simulate a blinking LED</strong> (for a short while).</p>
<p><em>How does uLisp call <code>yield_ulisp</code>?</em></p>
<p>uLisp calls <code>yield_ulisp</code> when <strong>iterating through a loop</strong> in <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L1698-L1702"><code>ulisp.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>///  Execute uLisp Loop
object *sp_loop (object *args, object *env) {
  ...
  for (;;) {
    //  Preempt the uLisp task and allow background tasks to run
    yield_ulisp();</code></pre></div>
<p>And when it <strong>evaluates a (potentially) recursive expression</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L4658-L4664"><code>ulisp.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>///  Main uLisp Evaluator
object *eval (object *form, object *env) {
  ...
  // Preempt the uLisp task and allow background tasks to run
  yield_ulisp();</code></pre></div>
<p><em>So now we‚Äôre all set to run this uLisp loop?</em></p>
<div class="example-wrap"><pre class="language-text"><code>( loop
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
  ( delay 1000 )
)</code></pre></div>
<p>Yes! Here‚Äôs our BL602 Simulator running the <strong>LED Blinky Loop</strong>. Watch how the <strong>Simulated LED stops blinking</strong> after a while‚Ä¶</p>
<ul>
<li>
<p><a href="https://youtu.be/IUmVa3vNpRs"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try it here</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-loop.png" alt="Simulating loops" /></p>
<h1 id="add-simulator-to-blockly"><a class="doc-anchor" href="#add-simulator-to-blockly">¬ß</a>10 Add Simulator to Blockly</h1>
<p>Today we‚Äôve created two things that run in a Web Browser‚Ä¶</p>
<ol>
<li>
<p><strong>uLisp REPL</strong> (based on WebAssembly)</p>
</li>
<li>
<p><strong>BL602 Simulator</strong> (based on JavaScript)</p>
</li>
</ol>
<p>In the previous article we‚Äôve created a <strong>Blockly Web Editor</strong> that lets us <strong>drag-and-drop uLisp Programs</strong> in a Web Browser (much like Scratch). <a href="https://lupyuen.github.io/articles/lisp">(See this)</a></p>
<p><em>Can we drag-and-drop Blockly Programs in a Web Browser‚Ä¶ And run them with uLisp REPL and BL602 Simulator?</em></p>
<p><img src="https://lupyuen.github.io/images/wasm-blockly.png" alt="Blockly Web Editor for uLisp WebAssembly and BL602 Simulator" /></p>
<p>Yes we can! Just do this‚Ä¶</p>
<ol>
<li>
<p>Click this link to run the <strong>Blockly Web Editor for uLisp WebAssembly and BL602 Simulator</strong>‚Ä¶</p>
<ul>
<li><a href="https://appkaki.github.io/blockly-ulisp/demos/simulator/"><strong><code>blockly-ulisp</code> Web Editor and Simulator</strong></a></li>
</ul>
<p>(This website contains HTML, JavaScript and WebAssembly, no server-side code. We‚Äôll explain <a href="https://github.com/AppKaki/blockly-ulisp"><code>blockly-ulisp</code></a> in a while)</p>
</li>
<li>
<p>Drag-and-drop this Blockly Program‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit3.png" alt="Blockly Web Editor: Blinky" /></p>
<p>By snapping these blocks together‚Ä¶</p>
<ul>
<li>
<p><strong><code>forever</code></strong> from <strong><code>Loops</code></strong> (in the left bar)</p>
</li>
<li>
<p><strong><code>digital write</code></strong> from <strong><code>GPIO</code></strong> (in the left bar)</p>
</li>
<li>
<p><strong><code>wait</code></strong> from <strong><code>Loops</code></strong> (in the left bar)</p>
</li>
</ul>
<p>Make sure they fit snugly. (Not floaty)</p>
<p><a href="https://youtu.be/LNkmUIv7ZZc">(Stuck? Check the video)</a></p>
</li>
<li>
<p>Set the parameters for the blocks as shown above‚Ä¶</p>
<ul>
<li>
<p><strong><code>digital write</code></strong>: Set the output to <strong><code>HIGH</code></strong> for the first block, <strong><code>LOW</code></strong> for the second block</p>
</li>
<li>
<p><strong><code>wait</code></strong>: Wait 1 second for both blocks</p>
</li>
</ul>
</li>
<li>
<p>Click the <strong><code>Lisp</code></strong> tab at the top.</p>
<p>We should see this <strong>uLisp code generated by Blockly</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit4.png" alt="Blockly Web Editor: uLisp code for Blinky" /></p>
</li>
<li>
<p>Click the <strong>Run Button [ ‚ñ∂ ]</strong> at top right.</p>
<p>The <strong>Simulated LED blinks every second!</strong></p>
<p>(And stops after a while, because we don‚Äôt simulate infinite loops)</p>
<p><a href="https://youtu.be/Ag2CERd1OzQ"><strong>Watch the demo on YouTube</strong></a></p>
</li>
</ol>
<p><em>Yes indeed we can drag-and-drop Blockly Programs‚Ä¶ And run them with the uLisp REPL and BL602 Simulator!</em></p>
<p>Read on to find out how we connected Blockly to uLisp REPL (in WebAssembly) and BL602 Simulator (in JavaScript).</p>
<p><img src="https://lupyuen.github.io/images/wasm-title.png" alt="BL602 Simulator with uLisp and Blockly in WebAssembly" /></p>
<h1 id="simulate-blockly-programs"><a class="doc-anchor" href="#simulate-blockly-programs">¬ß</a>11 Simulate Blockly Programs</h1>
<p><strong>Adding the BL602 Simulator to Blockly</strong> <a href="https://lupyuen.github.io/articles/lisp">(from the previous article)</a> was surprisingly painless.</p>
<p>Here‚Äôs what we did‚Ä¶</p>
<ol>
<li>
<p>We <strong>create a Blockly folder</strong> for our new web page (based on the Blockly folder from the previous article)‚Ä¶</p>
<p>Copy the folder <a href="https://github.com/AppKaki/blockly-ulisp/tree/wasm/demos/code"><code>demos/code</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator"><code>demos/simulator</code></a></p>
</li>
<li>
<p>We <strong>copy the WebAssembly files</strong> to the Blockly folder‚Ä¶</p>
<p>Copy <code>ulisp.js</code> and <code>ulisp.wasm</code> from <a href="https://github.com/lupyuen/ulisp-bl602/tree/wasm/docs"><code>ulisp-bl602/docs</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator"><code>demos/simulator</code></a></p>
</li>
<li>
<p>Insert the <strong>HTML Canvas and the Output Box</strong> (for the uLisp log): <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L110-L120"><code>index.html</code></a></p>
<div class="example-wrap"><pre class="language-html"><code>&lt;!-- Canvas for Simulator --&gt;
&lt;tr&gt;
  &lt;td colspan=2 align=&quot;center&quot;&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;
    &lt;textarea id=&quot;output&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/textarea&gt;
    &lt;div class=&quot;spinner&quot; id=&#39;spinner&#39;&gt;&lt;/div&gt;
    &lt;div class=&quot;emscripten&quot; id=&quot;status&quot;&gt;&lt;/div&gt;    
    &lt;progress value=&quot;0&quot; max=&quot;100&quot; id=&quot;progress&quot; hidden=1&gt;&lt;/progress&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;!-- End --&gt;</code></pre></div>
<p>(<code>spinner</code>, <code>status</code> and <code>progress</code> are needed by the Emscripten JavaScript)</p>
</li>
<li>
<p>Copy the <strong>Emscripten JavaScript</strong> from <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1250-L1326"><code>ulisp.html</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L482-L562"><code>index.html</code></a></p>
<div class="example-wrap"><pre class="language-html"><code>&lt;!--  Emscripten Script: From ulisp.html  --&gt;
&lt;script type=&#39;text/javascript&#39;&gt;
  var statusElement   = ...
  var progressElement = ...
  var spinnerElement  = ...

  var Module = {
    preRun:  [],
    postRun: [],
    print:     ... ,
    printErr:  ... ,
    canvas:    ... ,
    setStatus: ... ,
    monitorRunDependencies: ...
  };
  Module.setStatus( ... );
  window.onerror = ...
&lt;/script&gt;
&lt;!--  End of Emscripten Script  --&gt;</code></pre></div></li>
<li>
<p>Copy the <strong>BL602 Simulator JavaScript</strong> from <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1328-L1480"><code>ulisp.html</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L564-L716"><code>index.html</code></a></p>
<div class="example-wrap"><pre class="language-html"><code>&lt;!--  Custom Script: TODO Sync with ulisp.html  --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

  /// JSON Stream of Simulation Events emitted by uLisp Interpreter
  let simulation_events = [];

  /// Wait for emscripten to be initialised
  Module.onRuntimeInitialized = ...

  /// Render the simulator pic
  function renderSimulator() { ... }

  /// Run the provided script
  function runScript(scr) { /* See changes below */ }

  /// Simulate the BL602 Simulation Events recorded in simulate_events
  function simulateEvents() { ... }

  /// Simulate setting GPIO pin output to value 0 (Low) or 1 (High)
  function gpio_output_set(pin, value) { ... }

  /// Simulate a delay for the specified number of ticks
  function time_delay(ticks) { ... }

&lt;/script&gt;    
&lt;!--  End of Custom Script  --&gt;</code></pre></div></li>
<li>
<p>Modify the <code>runScript</code> function above‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Run the uLisp script from Input Box
function runScript() {
  //  Get the uLisp script from Input Box
  const scr = document.getElementById(&quot;input&quot;).value;

  //  Allocate WebAssembly memory for the script
  const scr_ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);</code></pre></div>
<p>So that it runs the <strong>script from the provided parameter</strong> (instead of the REPL Input Box): <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L598-L643"><code>index.html</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>/// Run the provided uLisp script
function runScript(scr) {
  //  Allocate WebAssembly memory for the script
  const scr_ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);</code></pre></div></li>
<li>
<p>Load our <strong>Emscripten WebAssembly</strong> into Blockly: <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L718-L722"><code>index.html</code></a></p>
<div class="example-wrap"><pre class="language-html"><code>&lt;!--  Load Emscripten WebAssembly: From ulisp.html  --&gt;
&lt;script async type=&quot;text/javascript&quot; src=&quot;ulisp.js&quot;&gt;&lt;/script&gt;
&lt;!--  End of Emscripten WebAssembly  --&gt;</code></pre></div></li>
<li>
<p>Previously we ran the uLisp code on a real BL602 with the Web Serial API.</p>
<p>Now we <strong>run the uLisp code on BL602 Simulator</strong>: <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/code.js#L575-L582"><code>code.js</code></a></p>
<div class="example-wrap"><pre class="language-javascript"><code>///  Run the uLisp code on BL602 Simulator
Code.runJS = function() {
  //  Generate the uLisp code by calling the Blockly Code Generator for uLisp
  var code = Blockly.Lisp.workspaceToCode(Code.workspace);

  //  Run the uLisp code on BL602 Simulator
  runScript(code);   //  Defined in index.html
}    </code></pre></div></li>
</ol>
<p>And that‚Äôs how we <strong>added uLisp WebAssembly and BL602 Simulator to Blockly</strong>‚Ä¶</p>
<p><em>Dragging-and-dropping uLisp programs for microcontrollers‚Ä¶ And running them WITHOUT a microcontroller!</em></p>
<h1 id="can-we-simulate-any-bl602-firmware"><a class="doc-anchor" href="#can-we-simulate-any-bl602-firmware">¬ß</a>12 Can We Simulate Any BL602 Firmware?</h1>
<p><em>Our BL602 Simulator works OK for simulating a uLisp Program. Will it work for simulating BL602 Firmware coded in C?</em></p>
<p>Our BL602 Simulator <strong>might work for BL602 Firmware coded in C</strong>!</p>
<p>Let‚Äôs look at this <strong>BL602 Blinky Firmware</strong> in C: <a href="https://lupyuen.github.io/articles/rust#bl602-blinky-in-c"><code>sdk_app_blinky/demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Blink the BL602 LED
void blinky(char *buf, int len, int argc, char **argv) {
  //  Configure the LED GPIO for output (instead of input)
  int rc = bl_gpio_enable_output(
    LED_GPIO,  //  GPIO pin number (11)
    0,         //  No GPIO pullup
    0          //  No GPIO pulldown
  );
  assert(rc == 0);  //  Halt on error

  //  Blink the LED 5 times
  for (int i = 0; i &lt; 10; i++) {

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    rc = bl_gpio_output_set(  //  Set the GPIO output (from BL602 GPIO HAL)
      LED_GPIO,               //  GPIO pin number (11)
      i % 2                   //  0 for low, 1 for high
    );
    assert(rc == 0);  //  Halt on error

    //  Sleep 1 second
    time_delay(                 //  Sleep by number of ticks (from NimBLE Porting Layer)
      time_ms_to_ticks32(1000)  //  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)
    );
  }
}</code></pre></div>
<p>To get this C code running on our BL602 Simulator, we need to <strong>compile the code to WebAssembly</strong>.</p>
<p><em>Will this C code compile to WebAssembly?</em></p>
<p>Remember earlier we created these <strong>C Functions for our WebAssembly Interface</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Add a GPIO event to set output (0 for low, 1 for high)
int bl_gpio_output_set(uint8_t pin, uint8_t value) { ... }

/// Configure the GPIO pin for output
int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown) { return 0; }

/// Add a delay event. 1 tick is 1 millisecond
void time_delay(uint32_t ticks) { ... }

/// Convert milliseconds to ticks
uint32_t time_ms_to_ticks32(uint32_t millisec) { return millisec; }</code></pre></div>
<p>These <strong>C Function Signatures are 100% identical</strong> to the BL602 Functions from the BL602 IoT SDK: <code>bl_gpio_output_set</code>, <code>bl_gpio_enable_output</code>, ‚Ä¶</p>
<p>So yep, the above <strong>BL602 Firmware Code will compile to WebAssembly</strong>!</p>
<p>Similar to a uLisp Program, the BL602 Firmware Code (running in WebAssebly) will generate a <strong>JSON Stream of Simulation Events</strong>.</p>
<p>(Which we‚Äôll feed to our <strong>BL602 Simulator</strong> in JavaScript)</p>
<p><em>But can we simulate ALL functions from the BL602 IoT SDK: GPIO, I2C, SPI, ADC, DAC, LVGL, LoRa, ‚Ä¶?</em></p>
<p>This needs work of course.</p>
<p>To simulate any uLisp Program or BL602 Firmware we need to <strong>code the necessary Simulation Functions in JavaScript</strong> (like <code>gpio_output_set</code> and <code>time_delay</code>) for GPIO, I2C, SPI, ADC, DAC, LVGL, LoRa, ‚Ä¶</p>
<p>(Sounds like an interesting challenge!)</p>
<h1 id="why-simulate-a-stream-of-events"><a class="doc-anchor" href="#why-simulate-a-stream-of-events">¬ß</a>13 Why Simulate A Stream Of Events?</h1>
<p><em>Why did we choose to simulate a JSON Stream of Simulation Events? Is there a simpler way?</em></p>
<p>Let‚Äôs look at this uLisp Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( loop
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
)</code></pre></div>
<p>The obvious way to simulate this uLisp Program (with WebAssembly) would be to let <strong>uLisp control the simulator directly</strong>‚Ä¶</p>
<ol>
<li>
<p>uLisp <strong>evaluates the first expression</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( digitalwrite 11 :low )</code></pre></div></li>
<li>
<p>uLisp <strong>renders the Simulated LED</strong> flipped on.</p>
<p>(Probably with SDL, which is supported by Emscripten)</p>
</li>
<li>
<p>uLisp <strong>evaluates the next expression</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( delay 1000 )</code></pre></div></li>
<li>
<p>uLisp <strong>pauses for 1 second</strong></p>
</li>
<li>
<p>uLisp <strong>evaluates the next expression</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( digitalwrite 11 :high )</code></pre></div></li>
<li>
<p>uLisp <strong>renders the Simulated LED</strong> flipped off</p>
</li>
<li>
<p>uLisp <strong>repeats the above steps forever</strong></p>
</li>
</ol>
<p>This <strong>Synchronous Simulation</strong> of uLisp Programs is <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Disadvantages_of_tight_coupling"><strong>Tightly Coupled</strong></a>.</p>
<p>It‚Äôs heavily <strong>dependent on the implementation</strong> of the uLisp Interpreter. And the way we render the simulator (like SDL).</p>
<p>Which makes this design <strong>harder to reuse</strong> for other kinds of BL602 Firmware (like our BL602 Blinky Firmware in C) and other ways of rendering the simulator (like JavaScript).</p>
<p>To fix this, we apply <a href="https://en.wikipedia.org/wiki/Inversion_of_control"><strong>Inversion of Control</strong></a> and flip the design, so that <strong>uLisp no longer controls the simulator directly</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-simulator.jpg" alt="BL602 Simulator Design" /></p>
<p>And we get the <strong>chosen design of our BL602 Simulator</strong>.</p>
<p>Some Higher Entity (the Simulator JavaScript) takes the Simulation Events emitted by uLisp, and feeds them to the BL602 Simulator.</p>
<p>With this simulator design we get‚Ä¶</p>
<ol>
<li>
<p><strong>Loose Coupling</strong>: We can reuse this design for other kinds of BL602 Firmware, like our BL602 Blinky Firmware in C. (As explained in the previous chapter)</p>
</li>
<li>
<p><strong>Unit Testing</strong>: We might someday feed the JSON Stream of Simulation Events to a Unit Testing Engine, for running Automated Unit Tests on our uLisp Programs and BL602 Firmware. (Without actual BL602 hardware!)</p>
</li>
<li>
<p><strong>Time Compression</strong>: Time Delay Events are encoded inside the stream of Simulation Events. Which means that the simulation runs in Deferred Time, not in Real Time.</p>
<p>This gets interesting because we no longer need to wait say, 1 hour of real time to simulate a BL602 program‚Ä¶ We could <strong>speed up the simulator</strong> 10 times and see the outcome in 6 minutes!</p>
</li>
<li>
<p><strong>Time Reversal</strong>: With a stream of Simulation Events, we could reverse time too! Rewinding to a specific point in the stream could be really helpful for troubleshooting BL602 Firmware.</p>
</li>
</ol>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>14 What‚Äôs Next</h1>
<p><a href="https://lupyuen.github.io/articles/rustsim"><strong>UPDATE: We‚Äôve created a BL602 Simulator in Rust. Read about it here</strong></a></p>
<p>Creating a BL602 Simulator for uLisp and Blockly has been a fun experience.</p>
<p>But more work needs to be done‚Ä¶ Please lemme know if you‚Äôre keen to help!</p>
<p>Could this be the better way to learn Embedded Programming on modern microcontrollers?</p>
<p>Let‚Äôs build it and find out! üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sponsor">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/nm6zd1/simulate_riscv_bl602_with_webassembly_ulisp_and/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/wasm.md"><code>lupyuen.github.io/src/wasm.md</code></a></p>
<h1 id="notes"><a class="doc-anchor" href="#notes">¬ß</a>15 Notes</h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1393554618924212224">this Twitter Thread</a></li>
</ol>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>