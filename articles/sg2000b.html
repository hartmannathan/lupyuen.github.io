<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/sg2000b-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/sg2000b.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)</h1>
    <nav id="TOC"><ul>
<li><a href="#update-the-memory-map">1 Update the Memory Map</a><ul></ul></li>
<li><a href="#auipc-overflow-in-boot-code">2 <code>auipc</code> Overflow in Boot Code</a><ul></ul></li>
<li><a href="#change-auipc-to-li-in-boot-code">3 Change <code>auipc</code> to <code>li</code> in Boot Code</a><ul></ul></li>
<li><a href="#emulate-the-16550-uart-controller">4 Emulate the 16550 UART Controller</a><ul></ul></li>
<li><a href="#16550-registers-for-uart-output">5 16550 Registers for UART Output</a><ul></ul></li>
<li><a href="#16550-registers-for-uart-input">6 16550 Registers for UART Input</a><ul></ul></li>
<li><a href="#fix-the-uart-interrupt">7 Fix the UART Interrupt</a><ul></ul></li>
<li><a href="#uart-input-causes-segmentation-fault">8 UART Input causes Segmentation Fault</a><ul></ul></li>
<li><a href="#irq-isnt-initialised">9 IRQ Isn‚Äôt Initialised</a><ul></ul></li>
<li><a href="#tinyemu-supports-only-32-irqs">10 TinyEMU Supports only 32 IRQs</a><ul></ul></li>
<li><a href="#increase-tinyemu-irqs-from-32-to-64">11 Increase TinyEMU IRQs from 32 to 64</a><ul></ul></li>
<li><a href="#pending-irq-loops-forever">12 Pending IRQ Loops Forever</a><ul></ul></li>
<li><a href="#emulate-the-uart-interrupt">13 Emulate the UART Interrupt</a><ul></ul></li>
<li><a href="#clear-the-uart-interrupt">14 Clear the UART Interrupt</a><ul></ul></li>
<li><a href="#whats-next">15 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>15 Jul 2024</em></p>
<p><img src="https://lupyuen.github.io/images/sg2000b-title.jpg" alt="TODO" /></p>
<p>TODO: Read the article</p>
<p>TODO: Watch the presentation</p>
<p><a href="https://github.com/lupyuen2/sg2000-emulator">sg2000-emulator</a></p>
<p>Let‚Äôs create a Software Emulator for Sophgo SG2000 SoC and Milk-V Duo S SBC! It runs every day for our <a href="https://github.com/lupyuen/nuttx-sg2000#nuttx-automated-daily-build-for-sg2000">Daily Automated Testing</a> of Apache NuttX RTOS for SG2000.</p>
<h1 id="update-the-memory-map"><a class="doc-anchor" href="#update-the-memory-map">¬ß</a>1 Update the Memory Map</h1>
<p>We begin with the <a href="https://lupyuen.github.io/articles/tinyemu3"><strong>TinyEMU RISC-V Emulator</strong></a> for Ox64 BL808 SBC. And we tweak it for SG2000.</p>
<p>This is how we update the <strong>RISC-V Memory Map</strong> for SG2000: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/d36190c63c1db116a206a26f3bc27dfacf5c8298">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Addresss of System RAM, Core Local Interrupt Controller (unused)
// And Platform-Level Interrupt Controller
#define RAM_BASE_ADDR   0x80200000ul
#define CLINT_BASE_ADDR 0x74000000ul
#define PLIC_BASE_ADDR  0x70000000ul
</code></pre></div>
<p>Then build and run TinyEMU‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build TinyEMU for macOS
## For Linux: See https://github.com/lupyuen/nuttx-sg2000/blob/main/.github/workflows/sg2000-test.yml#L29-L45
cd $HOME/sg2000-emulator/
make clean
make \
  CFLAGS=&quot;-I$(brew --prefix)/opt/openssl/include -I$(brew --prefix)/opt/sdl2/include&quot; \
  LDFLAGS=&quot;-L$(brew --prefix)/opt/openssl/lib -L$(brew --prefix)/opt/sdl2/lib&quot; \
  CONFIG_MACOS=y

## Build NuttX for SG2000
## https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000
cd $HOME/nuttx
tools/configure.sh milkv_duos:nsh
make
## Omitted: Create the `Image` file for SG2000 NuttX

## Boot TinyEMU with NuttX for SG2000
cd $HOME/nuttx
wget https://raw.githubusercontent.com/lupyuen/nuttx-sg2000/main/nuttx.cfg
$HOME/sg2000/sg2000-emulator/temu nuttx.cfg
</code></pre></div>
<p>Our Emulator crashes at a strange address‚Ä¶</p>
<h1 id="auipc-overflow-in-boot-code"><a class="doc-anchor" href="#auipc-overflow-in-boot-code">¬ß</a>2 <code>auipc</code> Overflow in Boot Code</h1>
<p>When we <strong>Boot our Emulator</strong> with SG2000 NuttX, it crashes‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg
TinyEMU Emulator for Sophgo SG2000 SoC
raise_exception2:
  cause=1
  tval= 0xffffffff_80200000
  pc=   0xffffffff_80200000

tinyemu:
  Illegal instruction, quitting
</code></pre></div>
<p><em>What just happened?</em></p>
<p>Our Emulator tried to execute the code at MTVAL <em>0xffffffff_80200000</em>. And crashed because it‚Äôs <strong>not a valid address!</strong></p>
<p><em>0xffffffff_80200000</em> looks sus, it seems related to <strong>RAM Base Address</strong> <em>0x80200000</em>.</p>
<p><em>Our Emulator is booting the wrong address?</em></p>
<p>We check the <strong>Original TinyEMU</strong> Boot Code: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L857-L861">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the TinyEMU Boot Code
static void copy_bios(...) {
  ...
  // `q` points to the Boot Code
  q = (uint32_t *)(ram_ptr + 0x1000);

  // Load `RAM_BASE_ADDR` into Register T0:
  // `auipc t0, RAM_BASE_ADDR`
  // `RAM_BASE_ADDR` is 0x80000000
  q[0] = 0x297 + RAM_BASE_ADDR - 0x1000;

  // Later: Jump to Register T0
</code></pre></div>
<p>To load the <strong>RAM Base Address</strong> into Register T0: TinyEMU tries to assemble this RISC-V Instruction (into our Boot Code)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>auipc t0, 0x80200000
</code></pre></div>
<p><em>Maybe auipc has a problem?</em></p>
<p>We verify with the <a href="https://riscvasm.lucasteske.dev/#"><strong>RISC-V Online Assembler</strong></a>.</p>
<p>When we assemble the <strong><code>auipc</code></strong> instruction above, the Online Assembler fails with an error‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>Error: lui expression not in range 0..1048575
Error: value of 0000080200000000 too large
  for field of 4 bytes at 0000000000000000
</code></pre></div>
<p>Aha <em>0x80200000</em> is too big to assemble as an <strong><code>auipc</code> Address!</strong></p>
<p><em>But 0x80200000 is a perfectly valid address?</em></p>
<p>Remember that RISC-V is a <strong>RISC Platform</strong> after all. Some operations won‚Äôt fit into 4 bytes of Machine Code.</p>
<p>We upsize to 8 bytes of Machine Code‚Ä¶</p>
<h1 id="change-auipc-to-li-in-boot-code"><a class="doc-anchor" href="#change-auipc-to-li-in-boot-code">¬ß</a>3 Change <code>auipc</code> to <code>li</code> in Boot Code</h1>
<p>We load <em>0x80200000</em> into Register t0 in another way, with the <strong><code>li</code> Instruction</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>li  t0, 0x80200000
</code></pre></div>
<p>When we feed this above into <a href="https://riscvasm.lucasteske.dev/#"><strong>RISC-V Online Assembler</strong></a>, we see the resulting (8-byte) <strong>Machine Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>4010029b  addiw  t0, zero, 1025
01529293  slli   t0, t0,   0x15
</code></pre></div>
<p>That‚Äôs because <strong><code>li</code></strong> is a Pseudo-Instruction that expands into two RISC-V Instructions‚Ä¶</p>
<ul>
<li>
<p><strong><code>addiw</code></strong>: Add zero to <code>1025</code> and store into T0</p>
</li>
<li>
<p><strong><code>slli</code></strong>: Shift-Left T0 by <code>0x15</code> bits</p>
</li>
<li>
<p>Producing: <code>1025</code> &lt;&lt; <code>0x15</code> = <code>0x8020_0000</code></p>
</li>
</ul>
<p>Thus we copy the above Machine Code into our TinyEMU Boot Code: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/b2d5cf63c5d6d1d0d4eafa5d400216d1f76a6e21">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the TinyEMU Boot Code
static void copy_bios(...) {
  ...
  // Load `RAM_BASE_ADDR` into Register T0:
  // `li  t0, 0x80200000`
  // Which is assembled as...
  q[pc++] = 0x4010029b;  // addiw t0, zero, 1025
  q[pc++] = 0x01529293;  // slli  t0, t0,   0x15

  // TODO: Remove the hardcoding of 0x80200000
</code></pre></div>
<p>Our Emulator now boots NuttX correctly at <em>0x80200000</em>!</p>
<h1 id="emulate-the-16550-uart-controller"><a class="doc-anchor" href="#emulate-the-16550-uart-controller">¬ß</a>4 Emulate the 16550 UART Controller</h1>
<p><em>Nothing appears when we boot NuttX?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg
TinyEMU Emulator for Sophgo SG2000 SoC
(...crickets...)
</code></pre></div>
<p>That‚Äôs because we haven‚Äôt emulated the <strong>16550 UART Controller</strong> in TinyEMU!</p>
<p>To figure out what‚Äôs needed, we refer to the <strong>16550 UART Driver</strong> in NuttX: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1602-L1671">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// To send one byte to UART Output...
void u16550_send(struct uart_dev_s *dev, int ch) {
  ...
  // We write the byte to the 16550 UART Register...
  u16550_serialout(
    priv,             // UART Device
    UART_THR_OFFSET,  // UART Register: Transmit Holding Register (THR)
    ch                // Byte to be sent
  );
}

// To check if the UART Transmit FIFO is ready...
bool u16550_txready(struct uart_dev_s *dev) {
  ...
  // We read the 16550 UART Register...
  return ((
    u16550_serialin(
      priv,            // UART Device
      UART_LSR_OFFSET  // UART Register: Line Status Register (LSR)
    ) &amp; UART_LSR_THRE  // And check the THRE Bit (Transmit Holding Register Empty)
  ) != 0);
}
</code></pre></div>
<p>Which says that‚Ä¶</p>
<ul>
<li>
<p><strong>UART_THR</strong>: Transmit Holding Register</p>
<p>Will receive the byte that NuttX is transmitting</p>
</li>
<li>
<p><strong>UART_LSR</strong>: Line Status Register</p>
<p>Will be read by NuttX to check if the Transmit FIFO is Empty</p>
</li>
<li>
<p><strong>UART_LSR_THRE</strong>: Transmit Holding Register Empty</p>
<p>This is the bit in <strong>UART_LSR</strong> that will indicate whether Transmit FIFO is Empty</p>
</li>
</ul>
<p>Let‚Äôs emulate the UART Registers in TinyEMU‚Ä¶</p>
<h1 id="16550-registers-for-uart-output"><a class="doc-anchor" href="#16550-registers-for-uart-output">¬ß</a>5 16550 Registers for UART Output</h1>
<p>TODO</p>
<p>We fix the UART Output Registers: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/fd6e5333ef6f89b452901d6e580d8387e9da2573">Update UART Output Register and UART Status Register</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU calls this function to execute Memory Reads
int target_read_slow(...) {
  ...
  // If TinyEMU is reading from this address...
  switch(paddr) {

    // Address is UART Line Status Register
    case UART0_BASE_ADDR + UART_LSR_OFFSET: {

      // Always tell NuttX that
      // Transmit Holding Register is Empty
      ret = UART_LSR_THRE;

      // If UART Input is available:
      // Tell NuttX that Receive Data is Available
      if (read_input() != 0) {
        ret |= UART_LSR_DR;
      }
      break;
    }
</code></pre></div>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L395-L411">(<strong>UART Addresses</strong> are here)</a></p>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU calls this function to execute Memory Writes
int target_write_slow(...) {
  ...
  // If TinyEMU is writing to this address...
  switch(paddr) {

    // Address is UART Transmit Holding Register
    case UART0_BASE_ADDR + UART_THR_OFFSET: {

      // Print the character that&#39;s written by NuttX
      char buf[1] = { val };
      print_console(NULL, buf, 1);
      break;
    }
</code></pre></div>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L395-L411">(<strong>UART Addresses</strong> are here)</a></p>
<p>Now we see NSH Shell yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>$ $HOME/sg2000/sg2000-emulator/temu nuttx.cfg 
...
TinyEMU Emulator for Sophgo SG2000 SoC
virtio_console_init
Patched DCACHE.IALL (Invalidate all Page Table Entries in the D-Cache) at 0x80200a28
Patched SYNC.S (Ensure that all Cache Operations are completed) at 0x80200a2c
Found ECALL (Start System Timer) at 0x8020b2c6
Patched RDTIME (Read System Time) at 0x8020b2cc
elf_len=0
virtio_console_resize_event
ABC
NuttShell (NSH) NuttX-12.5.1
nsh&gt;
</code></pre></div>
<p>When we press a key, NuttX triggers an expected interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ $HOME/sg2000/sg2000-emulator/temu nuttx.cfg 
...
NuttShell (NSH) NuttX-12.5.1
nsh&gt; irq_unexpected_isr: ERROR irq: 45
_assert: Current Version: NuttX  12.5.1 218ccd843a Jun 18 2024 22:14:46 risc-v
_assert: Assertion failed panic: at file: irq/irq_unexpectedisr.c:54 task: Idle_Task process: Kernel 0x8020110c
up_dump_register: EPC: 000000008021432a
</code></pre></div><h1 id="16550-registers-for-uart-input"><a class="doc-anchor" href="#16550-registers-for-uart-input">¬ß</a>6 16550 Registers for UART Input</h1>
<p>TODO</p>
<h1 id="fix-the-uart-interrupt"><a class="doc-anchor" href="#fix-the-uart-interrupt">¬ß</a>7 Fix the UART Interrupt</h1>
<p>TODO</p>
<p>Now we fix the UART Input and UART Interrupt. Based on the NuttX Config‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_UART0_IRQ=69
</code></pre></div>
<p>Since NuttX IRQ Offset is 25, so Actual RISC-V IRQ is 69 - 25 = 44 (as confirmed by the SG2000 Reference Manual)‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/commit/643c25cada46289539e31579616e7afbf108c3ae">Set VIRTIO_IRQ to 44</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define VIRTIO_IRQ       44  // UART0 IRQ
</code></pre></div>
<p>But when we press a key: TinyEMU crashes with a Segmentation Fault‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ $HOME/sg2000/sg2000-emulator/temu nuttx.cfg    
...
NuttShell (NSH) NuttX-12.5.1
nsh&gt; [1]    94499 segmentation fault  $HOME/sg2000/sg2000-emulator/temu nuttx.cfg
</code></pre></div><h1 id="uart-input-causes-segmentation-fault"><a class="doc-anchor" href="#uart-input-causes-segmentation-fault">¬ß</a>8 UART Input causes Segmentation Fault</h1>
<p>TODO</p>
<p>We debug with <code>lldb</code> (because <code>gdb</code> is not available for macOS Arm64)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ lldb $HOME/sg2000/sg2000-emulator/temu nuttx.cfg 
(lldb) target create &quot;/Users/luppy/sg2000/sg2000-emulator/temu&quot;
Current executable set to &#39;/Users/luppy/sg2000/sg2000-emulator/temu&#39; (arm64).
(lldb) settings set -- target.run-args  &quot;nuttx.cfg&quot;
(lldb) r
Process 90245 launched: &#39;/Users/luppy/sg2000/sg2000-emulator/temu&#39; (arm64)
...
NuttShell (NSH) NuttX-12.5.1
Process 90245 stopped
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000000000000
error: memory read failed for 0x0
Target 0: (temu) stopped.
(lldb) bt
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
  * frame #0: 0x0000000000000000
    frame #1: 0x000000010000b978 temu`virt_machine_run(m=0x000000013461b2a0) at temu.c:598:17 [opt]
    frame #2: 0x000000010000be6c temu`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at temu.c:845:9 [opt]
    frame #3: 0x0000000197a4e0e0 dyld`start + 2360
(lldb) 
</code></pre></div>
<p>Which is at‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void virt_machine_run(VirtMachine *m) {
  ...    
  virtio_console_write_data(m-&gt;console_dev, buf, ret);
</code></pre></div>
<p>Why did TinyEMU crash? This doesn‚Äôt make sense, <code>m</code> is non-null!</p>
<p>Maybe it‚Äôs already optimised? Let‚Äôs disable GCC Optimisation‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/sg2000-emulator/commit/af768df81fc349562565d638e359aca6127c9267">Disable GCC Optimisation</a></li>
</ul>
<p>Now it makes more sense!</p>
<div class="example-wrap"><pre class="language-bash"><code>$ lldb $HOME/sg2000/sg2000-emulator/temu nuttx.cfg 
...
NuttShell (NSH) NuttX-12.5.1
Process 1595 stopped
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000000000000
error: memory read failed for 0x0
Target 0: (temu) stopped.
(lldb) bt
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
  * frame #0: 0x0000000000000000
    frame #1: 0x0000000100002604 temu`set_irq(irq=0x000000013a607b08, level=1) at iomem.h:145:5
    frame #2: 0x00000001000025a4 temu`virtio_console_write_data(s=0x000000013d604080, buf=&quot;a&quot;, buf_len=1) at virtio.c:1346:5
    frame #3: 0x000000010000fd2c temu`virt_machine_run(m=0x000000013a607680) at temu.c:598:17
    frame #4: 0x00000001000105cc temu`main(argc=2, argv=0x000000016fdff080) at temu.c:845:9
    frame #5: 0x0000000197a4e0e0 dyld`start + 2360
</code></pre></div>
<p>Which crashes here‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static inline void set_irq(IRQSignal *irq, int level) {
  irq-&gt;set_irq(irq-&gt;opaque, irq-&gt;irq_num, level);
}
</code></pre></div>
<p>Which means <code>irq-&gt;set_irq</code> is null! (Rightfully it should be set to <code>plic_set_irq</code>)</p>
<h1 id="irq-isnt-initialised"><a class="doc-anchor" href="#irq-isnt-initialised">¬ß</a>9 IRQ Isn‚Äôt Initialised</h1>
<p>TODO</p>
<p><em>Why is <code>irq-&gt;set_irq</code> set to null?</em></p>
<p>We verify with an Assertion Check: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/4a8652a70ff16b85ab16108686916a75505e4ef6">irq-&gt;set_irq is null!</a></p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.5.1
nsh&gt; Assertion failed: (irq-&gt;set_irq != NULL), function set_irq, file iomem.h, line 145.
Process 15262 stopped
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = hit program assert
    frame #4: 0x000000010000249c temu`set_irq(irq=0x000000014271a478, level=1) at iomem.h:145:5
   142 
   143  static inline void set_irq(IRQSignal *irq, int level)
   144  {
-&gt; 145      assert(irq-&gt;set_irq != NULL); //// TODO
   146      irq-&gt;set_irq(irq-&gt;opaque, irq-&gt;irq_num, level);
   147  }
   148 
Target 0: (temu) stopped.
(lldb) bt
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = hit program assert
    frame #0: 0x0000000197d9ea60 libsystem_kernel.dylib`__pthread_kill + 8
    frame #1: 0x0000000197dd6c20 libsystem_pthread.dylib`pthread_kill + 288
    frame #2: 0x0000000197ce3a30 libsystem_c.dylib`abort + 180
    frame #3: 0x0000000197ce2d20 libsystem_c.dylib`__assert_rtn + 284
  * frame #4: 0x000000010000249c temu`set_irq(irq=0x000000014271a478, level=1) at iomem.h:145:5
    frame #5: 0x0000000100002418 temu`virtio_console_write_data(s=0x0000000142719980, buf=&quot;a\xc0\xedE&quot;, buf_len=1) at virtio.c:1346:5
    frame #6: 0x000000010000fc30 temu`virt_machine_run(m=0x0000000142719ff0) at temu.c:598:17
    frame #7: 0x00000001000104d0 temu`main(argc=2, argv=0x000000016fdff080) at temu.c:845:9
    frame #8: 0x0000000197a4e0e0 dyld`start + 2360
</code></pre></div>
<p>We <a href="https://lldb.llvm.org/use/map.html">inspect the variables</a> in LLDB‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>frame #4: 0x000000010000249c temu`set_irq(irq=0x000000014271a478, level=1) at iomem.h:145:5
   142 
   143  static inline void set_irq(IRQSignal *irq, int level)
   144  {
-&gt; 145      assert(irq-&gt;set_irq != NULL); //// TODO
   146      irq-&gt;set_irq(irq-&gt;opaque, irq-&gt;irq_num, level);
   147  }
   148 
(lldb) frame variable
(IRQSignal *) irq = 0x000000014271a478
(int) level = 1
(lldb) p *irq
(IRQSignal) {
  set_irq = 0x0000000000000000
  opaque = 0x0000000000000000
  irq_num = 0
}
</code></pre></div>
<p><code>irq</code> is all empty! Where does <code>irq</code> come from? We step up the Call Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>(lldb) up
frame #5: 0x0000000100002418 temu`virtio_console_write_data(s=0x0000000142719980, buf=&quot;a\xc0\xedE&quot;, buf_len=1) at virtio.c:1346:5
   1343     _info(&quot;[%c]\n&quot;, buf[0]); ////
   1344     set_input(buf[0]);
   1345     s-&gt;int_status |= 1;
-&gt; 1346     set_irq(s-&gt;irq, 1);
   1347
   1348 #ifdef NOTUSED
   1349     int queue_idx = 0;
(lldb) frame variable
(VIRTIODevice *) s = 0x0000000142719980
(const uint8_t *) buf = 0x000000016fdfeae8 &quot;a\xc0\xedE&quot;
(int) buf_len = 1

(lldb) p *s
(VIRTIODevice) {
  mem_map = 0x000000014380fc00
  mem_range = 0x000000014380fe60
  pci_dev = NULL
  irq = 0x000000014271a478
  get_ram_ptr = 0x00000001000065dc (temu`virtio_mmio_get_ram_ptr at virtio.c:193)
  debug = 0
  int_status = 1
  status = 0
  device_features_sel = 0
  queue_sel = 0
  queue = {
    [0] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = YES
    }
    [1] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [2] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [3] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [4] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [5] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [6] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [7] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
  }
  device_id = 3
  vendor_id = 65535
  device_features = 1
  device_recv = 0x00000001000025cc (temu`virtio_console_recv_request at virtio.c:1278)
  config_write = 0x0000000000000000
  config_space_size = 4
  config_space = &quot;P\0\U00000019&quot;
}
</code></pre></div>
<p>This says that <code>s</code> is a <code>virtio_console</code>.</p>
<h1 id="tinyemu-supports-only-32-irqs"><a class="doc-anchor" href="#tinyemu-supports-only-32-irqs">¬ß</a>10 TinyEMU Supports only 32 IRQs</h1>
<p>TODO</p>
<p>Why is <code>s-&gt;irq</code> empty? We step up the Call Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>(lldb) up
frame #6: 0x000000010000fc30 temu`virt_machine_run(m=0x0000000142719ff0) at temu.c:598:17
   595              len = min_int(len, sizeof(buf));
   596              ret = m-&gt;console-&gt;read_data(m-&gt;console-&gt;opaque, buf, len);
   597              if (ret &gt; 0) {
-&gt; 598                  virtio_console_write_data(m-&gt;console_dev, buf, ret);
   599              }
   600          }
   601  #endif
(lldb) p *m
(VirtMachine) {
  vmc = 0x0000000100080620
  net = NULL
  console_dev = 0x0000000142719980
  console = 0x0000000142719510
  fb_dev = NULL
}
</code></pre></div>
<p><code>s-&gt;irq</code> comes from <code>m-&gt;console_dev</code>.</p>
<p><em>Why is <code>console_dev</code> not properly inited?</em></p>
<p>From earlier: UART0 is at RISC-V IRQ 44. But we discover that TinyEMU supports only 32 IRQs!</p>
<div class="example-wrap"><pre class="language-c"><code>static VirtMachine *riscv_machine_init(const VirtMachineParams *p) {
  for(i = 1; i &lt; 32; i++) {
    irq_init(&amp;s-&gt;plic_irq[i], plic_set_irq, s, i);
  }
</code></pre></div><h1 id="increase-tinyemu-irqs-from-32-to-64"><a class="doc-anchor" href="#increase-tinyemu-irqs-from-32-to-64">¬ß</a>11 Increase TinyEMU IRQs from 32 to 64</h1>
<p>TODO</p>
<p>So we increase the IRQs from 32 to 256: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/c6ce6bdbbdaf7585ce18f77b2b2f25a2317914be">Increase the IRQs from 32 to 256</a></p>
<p>(256 IRQs is too many, as we shall soon see)</p>
<p>Now we see something different when we press a key!</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.5.1
nsh&gt; irq_unexpected_isr: ERROR irq: 37
_assert: Current Version: NuttX  12.5.1 218ccd843a Jun 18 2024 22:14:46 risc-v
_assert: Assertion failed panic: at file: irq/irq_unexpectedisr.c:54 task: Idle_Task process: Kernel 0x8020110c
up_dump_register: EPC: 000000008021432a
</code></pre></div>
<p><em>What is NuttX IRQ 37? (RISC-V IRQ 12) Shouldn‚Äôt it be RISC-V IRQ 44 for UART Input?</em></p>
<p>Seems the RISC-V IRQs wrap around at 32? So RISC-V IRQ 44 becomes IRQ 12?</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.5.1
nsh&gt; plic_set_irq: irq_num=44, state=1
plic_pending_irq=0x800, plic_served_irq=0x0, mask=0x800
plic_update_mip: set_mip, pending=0x800, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x800, served=0x800
plic_read: pending irq=0xc
plic_pending_irq=0x800, plic_served_irq=0x800, mask=0x800
irq_unexpected_isr: ERROR irq: 37
</code></pre></div>
<p>So we fix the IRQ Size: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/78ac3ad75f1ec0b54f5bee10488731c7a21fb9ea">Increase the Pending IRQ Size and Served IRQ Size from 32-bit to 64-bit</a></p>
<p>Now we see the correct Pending IRQ!</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.5.1
nsh&gt; plic_set_irq: irq_num=44, state=1
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
plic_write: offset=0x201004, val=0x2c
</code></pre></div><h1 id="pending-irq-loops-forever"><a class="doc-anchor" href="#pending-irq-loops-forever">¬ß</a>12 Pending IRQ Loops Forever</h1>
<p>TODO</p>
<p><em>Why does Pending IRQ loop forever? Maybe because we haven‚Äôt cleared the UART Interrupt?</em></p>
<p>To find out why, we trace the reads and writes to UART Registers: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/1f4b79bc9d276e1ca6371e60d0c9d25a53f7fa80">Log the invalid memory accesses</a></p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.5.1
target_write_slow: invalid physical address 0x0000000004140004
User ECALL: pc=0xc0001998
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
nsh&gt; target_write_slow: invalid physical address 0x0000000004140004
User ECALL: pc=0xc0001998
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
User ECALL: pc=0xc000aa0e
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
plic_set_irq: irq_num=44, state=1
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140018
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140018
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140018
</code></pre></div>
<p><em>What are UART Registers 0x4140008 and 0x4140018? Why are they read when we press a key?</em></p>
<p>We look up the UART Registers‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// UART Registers from https://github.com/apache/nuttx/blob/master/include/nuttx/serial/uart_16550.h
#define UART0_BASE_ADDR 0x04140000
#define CONFIG_16550_REGINCR 4
#define UART_IIR_INCR          2  /* Interrupt ID Register */
#define UART_FCR_INCR          2  /* FIFO Control Register */
#define UART_MSR_INCR          6  /* Modem Status Register */

// So 0x4140008 is one of these...
#define UART_IIR_OFFSET        (CONFIG_16550_REGINCR*UART_IIR_INCR)
#define UART_FCR_OFFSET        (CONFIG_16550_REGINCR*UART_FCR_INCR)

// And 0x4140018 is...
#define UART_MSR_OFFSET        (CONFIG_16550_REGINCR*UART_MSR_INCR)
</code></pre></div>
<p>We check the NuttX 16550 UART Driver for UART_IIR_OFFSET, UART_FCR_OFFSET and UART_MSR_OFFSET. (See the next section)</p>
<p><em>What is UART Register 0x4140004? Why is it read when we print to UART?</em></p>
<p>We look up the UART Register‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// UART Registers from https://github.com/apache/nuttx/blob/master/include/nuttx/serial/uart_16550.h
#define UART0_BASE_ADDR 0x04140000
#define CONFIG_16550_REGINCR 4
#define UART_DLM_INCR          1  /* (DLAB =1) Divisor Latch MSB */
#define UART_IER_INCR          1  /* (DLAB =0) Interrupt Enable Register */

// So 0x4140004 is one of these...
#define UART_DLM_OFFSET        (CONFIG_16550_REGINCR*UART_DLM_INCR)
#define UART_DLM_OFFSET        (CONFIG_16550_REGINCR*UART_IER_INCR)
</code></pre></div>
<p>TODO: Check the NuttX 16550 UART Driver for UART_DLM_OFFSET and UART_DLM_OFFSET</p>
<h1 id="emulate-the-uart-interrupt"><a class="doc-anchor" href="#emulate-the-uart-interrupt">¬ß</a>13 Emulate the UART Interrupt</h1>
<p>TODO</p>
<p><em>How does the NuttX 16550 UART Driver use UART_IIR_OFFSET, UART_FCR_OFFSET and UART_MSR_OFFSET?</em></p>
<p>The NuttX 16550 UART Driver reads UART_IIR_OFFSET and UART_MSR_OFFSET to handle UART Interrupts: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L979-L1082">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int u16550_interrupt(int irq, FAR void *context, FAR void *arg)
{
  FAR struct uart_dev_s *dev = (struct uart_dev_s *)arg;
  FAR struct u16550_s *priv;
  uint32_t status;
  int passes;

  DEBUGASSERT(dev != NULL &amp;&amp; dev-&gt;priv != NULL);
  priv = (FAR struct u16550_s *)dev-&gt;priv;

  /* Loop until there are no characters to be transferred or,
   * until we have been looping for a long time.
   */

  for (passes = 0; passes &lt; 256; passes++)
    {
      /* Get the current UART status and check for loop
       * termination conditions
       */

      status = u16550_serialin(priv, UART_IIR_OFFSET);

      /* The UART_IIR_INTSTATUS bit should be zero if there are pending
       * interrupts
       */

      if ((status &amp; UART_IIR_INTSTATUS) != 0)
        {
          /* Break out of the loop when there is no longer a
           * pending interrupt
           */

          break;
        }

      /* Handle the interrupt by its interrupt ID field */

      switch (status &amp; UART_IIR_INTID_MASK)
        {
          /* Handle incoming, receive bytes (with or without timeout) */

          case UART_IIR_INTID_RDA:
          case UART_IIR_INTID_CTI:
            {
              uart_recvchars(dev);
              break;
            }

          /* Handle outgoing, transmit bytes */

          case UART_IIR_INTID_THRE:
            {
              uart_xmitchars(dev);
              break;
            }

          /* Just clear modem status interrupts (UART1 only) */

          case UART_IIR_INTID_MSI:
            {
              /* Read the modem status register (MSR) to clear */

              status = u16550_serialin(priv, UART_MSR_OFFSET);
              sinfo(&quot;MSR: %02&quot;PRIx32&quot;\n&quot;, status);
              break;
            }

          /* Just clear any line status interrupts */

          case UART_IIR_INTID_RLS:
            {
              /* Read the line status register (LSR) to clear */

              status = u16550_serialin(priv, UART_LSR_OFFSET);
              sinfo(&quot;LSR: %02&quot;PRIx32&quot;\n&quot;, status);
              break;
            }

          /* There should be no other values */

          default:
            {
              serr(&quot;ERROR: Unexpected IIR: %02&quot;PRIx32&quot;\n&quot;, status);
              break;
            }
        }
    }

  return OK;
}
</code></pre></div>
<p>Thus we need to emulate the UART Interrupt. To Receive Data‚Ä¶</p>
<ul>
<li>
<p>UART Register UART_IIR: Should return UART_IIR_INTID_RDA (data available)</p>
<p>Then it should return UART_IIR_INTSTATUS (no more data)</p>
</li>
<li>
<p>UART Register UART_LSR: Should return UART_LSR_DR (data available)</p>
<p>Then it should return 0 (no more data)</p>
</li>
<li>
<p>UART Register UART_RBR: Should return the input data</p>
</li>
</ul>
<p>We emulate the UART Interrupt like this: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/ce3562e4d7efe53b52a1b945850f08d93630d4d2">Emulate UART Interrupt: UART_LSR, UART_IIR, UART_RBR</a></p>
<p>Now we see‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>plic_set_irq: irq_num=44, state=1
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c

read UART_IIR_OFFSET
read UART_RBR_OFFSET
read UART_IIR_OFFSET

plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c

read UART_IIR_OFFSET
plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
read UART_IIR_OFFSET
</code></pre></div><h1 id="clear-the-uart-interrupt"><a class="doc-anchor" href="#clear-the-uart-interrupt">¬ß</a>14 Clear the UART Interrupt</h1>
<p>TODO</p>
<p><em>Why is pending IRQ looping forever?</em></p>
<p>That‚Äôs because we forgot to clear the UART Interrupt duh!</p>
<ul>
<li><a href="https://github.com/lupyuen2/sg2000-emulator/commit/2d10b7699378525a3cf4282d2eaf9da051726638">Clear the UART Interrupt</a></li>
</ul>
<p>Finally it works OK yay! <a href="https://github.com/lupyuen2/sg2000-emulator/commit/ba2e9e09df18e7feed38e67a1ca678348f0c2d2a">(We disabled logging)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg
TinyEMU Emulator for Sophgo SG2000 SoC
virtio_console_init
Patched DCACHE.IALL (Invalidate all Page Table Entries in the D-Cache) at 0x80200a28
Patched SYNC.S (Ensure that all Cache Operations are completed) at 0x80200a2c
Found ECALL (Start System Timer) at 0x8020b2c6
Patched RDTIME (Read System Time) at 0x8020b2cc
elf_len=0
virtio_console_resize_event
ABC
NuttShell (NSH) NuttX-12.5.1
nsh&gt; uname -a
NuttX 12.5.1 50fadb93f2 Jun 18 2024 09:20:31 risc-v milkv_duos
nsh&gt; 
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ac80b426f67ad38f6a59ae563b0ecb9f">OSTest works OK too!</a></p>
<p><em>SG2000 Emulator seems slower than Ox64 BL808 Emulator?</em></p>
<p>Yeah probably because SG2000 runs on <a href="https://github.com/lupyuen2/wip-nuttx/commit/bb4906c976e44a05237f91944844cd1c68ef5d5b">MTIMER_FREQ of 25000000</a>.</p>
<p>When we execute <code>sleep 10</code>, it completes in 25 seconds. We might need to adjust the TinyEMU System Timer.</p>
<p>(CPU-bound operations like <code>getprime</code> won‚Äôt have this timing delay)</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>15 What‚Äôs Next</h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000b.md"><strong>lupyuen.github.io/src/sg2000b.md</strong></a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>