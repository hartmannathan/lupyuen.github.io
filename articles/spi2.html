<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>SPI on Apache NuttX OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="SPI on Apache NuttX OS" 
    data-rh="true">
<meta property="og:description" 
    content="How we transmit and receive data over SPI on Apache NuttX OS... By coding a NuttX Device Driver"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/spi2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical" href="https://lupyuen.org/articles/spi2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">SPI on Apache NuttX OS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#spi-test-app-and-driver" title="SPI Test App and Driver">1 SPI Test App and Driver</a><ul></ul></li>
<li><a href="#inside-the-spi-test-driver" title="Inside the SPI Test Driver">2 Inside the SPI Test Driver</a><ul>
<li><a href="#file-operations" title="File Operations">2.1 File Operations</a><ul></ul></li>
<li><a href="#write-operation" title="Write Operation">2.2 Write Operation</a><ul></ul></li>
<li><a href="#read-operation" title="Read Operation">2.3 Read Operation</a><ul></ul></li>
<li><a href="#configure-spi" title="Configure SPI">2.4 Configure SPI</a><ul></ul></li></ul></li>
<li><a href="#load-the-spi-test-driver" title="Load the SPI Test Driver">3 Load the SPI Test Driver</a><ul></ul></li>
<li><a href="#inside-the-spi-test-app" title="Inside the SPI Test App">4 Inside the SPI Test App</a><ul>
<li><a href="#open-spi-test-driver" title="Open SPI Test Driver">4.1 Open SPI Test Driver</a><ul></ul></li>
<li><a href="#transmit-spi-data" title="Transmit SPI Data">4.2 Transmit SPI Data</a><ul></ul></li>
<li><a href="#receive-spi-data" title="Receive SPI Data">4.3 Receive SPI Data</a><ul></ul></li>
<li><a href="#close-spi-test-driver" title="Close SPI Test Driver">4.4 Close SPI Test Driver</a><ul></ul></li></ul></li>
<li><a href="#run-the-spi-test-app" title="Run the SPI Test App">5 Run the SPI Test App</a><ul></ul></li>
<li><a href="#test-with-logic-analyser" title="Test with Logic Analyser">6 Test with Logic Analyser</a><ul></ul></li>
<li><a href="#control-chip-select-with-gpio" title="Control Chip Select with GPIO">7 Control Chip Select with GPIO</a><ul>
<li><a href="#gpio-output-as-chip-select" title="GPIO Output as Chip Select">7.1 GPIO Output as Chip Select</a><ul></ul></li></ul></li>
<li><a href="#test-with-semtech-sx1262" title="Test with Semtech SX1262">8 Test with Semtech SX1262</a><ul>
<li><a href="#connect-sx1262" title="Connect SX1262">8.1 Connect SX1262</a><ul></ul></li>
<li><a href="#test-sx1262" title="Test SX1262">8.2 Test SX1262</a><ul></ul></li></ul></li>
<li><a href="#test-with-pinedio-stack" title="Test with PineDio Stack">9 Test with PineDio Stack</a><ul>
<li><a href="#pin-definitions" title="Pin Definitions">9.1 Pin Definitions</a><ul></ul></li>
<li><a href="#run-nuttx-on-pinedio-stack" title="Run NuttX on PineDio Stack">9.2 Run NuttX on PineDio Stack</a><ul></ul></li>
<li><a href="#chip-select" title="Chip Select">9.3 Chip Select</a><ul></ul></li></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes" title="Notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-spi-dma-on-bl602-nuttx" title="Appendix: SPI DMA on BL602 NuttX">12 Appendix: SPI DMA on BL602 NuttX</a><ul></ul></li>
<li><a href="#appendix-create-a-nuttx-device-driver" title="Appendix: Create a NuttX Device Driver">13 Appendix: Create a NuttX Device Driver</a><ul>
<li><a href="#update-makefile-and-kconfig" title="Update Makefile and Kconfig">13.1 Update Makefile and Kconfig</a><ul></ul></li>
<li><a href="#enable-spi" title="Enable SPI">13.2 Enable SPI</a><ul></ul></li>
<li><a href="#enable-logging" title="Enable Logging">13.3 Enable Logging</a><ul></ul></li>
<li><a href="#register-device-driver" title="Register Device Driver">13.4 Register Device Driver</a><ul></ul></li>
<li><a href="#verify-device-driver" title="Verify Device Driver">13.5 Verify Device Driver</a><ul></ul></li></ul></li>
<li><a href="#appendix-create-a-nuttx-app" title="Appendix: Create a NuttX App">14 Appendix: Create a NuttX App</a><ul>
<li><a href="#enable-app" title="Enable App">14.1 Enable App</a><ul></ul></li>
<li><a href="#run-the-app" title="Run the App">14.2 Run the App</a><ul></ul></li></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx" title="Appendix: Build, Flash and Run NuttX">15 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#build-nuttx" title="Build NuttX">15.1 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx" title="Flash NuttX">15.2 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx" title="Run NuttX">15.3 Run NuttX</a><ul></ul></li></ul></li>
<li><a href="#appendix-nuttx-spi-interface" title="Appendix: NuttX SPI Interface">16 Appendix: NuttX SPI Interface</a><ul>
<li><a href="#spi-device" title="SPI Device">16.1 SPI Device</a><ul></ul></li>
<li><a href="#file-descriptor" title="File Descriptor">16.2 File Descriptor</a><ul></ul></li>
<li><a href="#file-struct" title="File Struct">16.3 File Struct</a><ul></ul></li>
<li><a href="#spi-driver" title="SPI Driver">16.4 SPI Driver</a><ul></ul></li></ul></li>
<li><a href="#appendix-miso-and-mosi-are-swapped" title="Appendix: MISO And MOSI Are Swapped">17 Appendix: MISO And MOSI Are Swapped</a><ul>
<li><a href="#reproduce-the-issue" title="Reproduce the issue">17.1 Reproduce the issue</a><ul></ul></li>
<li><a href="#fix-the-issue" title="Fix the issue">17.2 Fix the issue</a><ul></ul></li>
<li><a href="#test-the-fix" title="Test the fix">17.3 Test the fix</a><ul></ul></li></ul></li>
<li><a href="#appendix-spi-mode-quirk" title="Appendix: SPI Mode Quirk">18 Appendix: SPI Mode Quirk</a><ul></ul></li></ul></nav><p>üìù <em>13 Dec 2021</em></p>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)" /></p>
<p><em>PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)</em></p>
<p>Last article we explored <strong>Apache NuttX OS</strong> and its <strong>GPIO Functions</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx"><strong>‚ÄúApache NuttX OS on RISC-V BL602 and BL604‚Äù</strong></a></li>
</ul>
<p>Today we shall venture into the <strong>SPI Functions</strong> and discover‚Ä¶</p>
<ul>
<li>
<p>How to <strong>transmit and receive</strong> data over SPI</p>
</li>
<li>
<p>By coding a simple NuttX <strong>Device Driver</strong></p>
</li>
<li>
<p>And testing with <strong>Semtech SX1262</strong> (LoRa Transceiver)</p>
</li>
<li>
<p>On Bouffalo Lab‚Äôs <strong>BL602 and BL604</strong> RISC-V SoCs</p>
</li>
</ul>
<p>We‚Äôll also study briefly the internals of the <strong>NuttX SPI Driver</strong>, to understand how it works.</p>
<p><em>What about ESP32? NuttX works the same across platforms right?</em></p>
<p>I realise that many of my readers are using ESP32 instead of BL602.</p>
<p>In this article I‚Äôll point out the tweaks needed to <strong>run the code on ESP32</strong>.</p>
<p>(Watch for the <strong>‚ÄúFor ESP32‚Äù</strong> tags)</p>
<p><img src="https://lupyuen.github.io/images/spi2-plan.jpg" alt="SPI Test App calls SPI Test Driver to access SPI Driver" /></p>
<h1 id="spi-test-app-and-driver"><a class="doc-anchor" href="#spi-test-app-and-driver">¬ß</a>1 SPI Test App and Driver</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Our plan for today (pic above)‚Ä¶</p>
<ol>
<li>
<p>We create an <strong>SPI Test App</strong> that will transfer data over SPI.</p>
<p>(A tiny program with a few lines of code)</p>
</li>
<li>
<p>We create an <strong>SPI Test Driver</strong> (called by SPI Test App) that will handle the SPI Operations.</p>
<p>(To transmit and receive data over SPI)</p>
</li>
<li>
<p>Our SPI Test Driver exposes a NuttX <a href="https://nuttx.apache.org/docs/latest/components/drivers/character/index.html"><strong>Character Device Interface</strong></a>: open(), write(), read() and close().</p>
<p>(Yep it looks like Linux, because NuttX is POSIX Compliant)</p>
</li>
<li>
<p>Our SPI Test Driver executes the SPI Operations by calling the <strong>BL602 or ESP32 SPI Driver</strong>.</p>
<p>(Which is equivalent to the Hardware Abstraction Layer in other operating systems)</p>
</li>
</ol>
<p><em>This looks complex. Is there a simpler way?</em></p>
<p>Yes we have options for doing <strong>SPI on NuttX</strong>‚Ä¶</p>
<ol>
<li>
<p>If our SPI Device is supported by an <strong>existing NuttX Device Driver</strong>, just go ahead and use the driver!</p>
<p><a href="https://github.com/apache/nuttx/tree/master/drivers">(Browse the NuttX Device Drivers)</a></p>
</li>
<li>
<p>If we‚Äôre transferring data over SPI <strong>for testing only</strong> (not for a real app), we may call the <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/spi/spi_transfer.h"><strong>SPI Transfer Interface</strong></a></p>
<p><a href="https://github.com/apache/nuttx-apps/blob/master/system/spi">(Here‚Äôs how‚Ä¶ It‚Äôs complicated)</a></p>
</li>
<li>
<p>But today we experiment with a <strong>Custom Device Driver</strong> that will talk to our own SPI Device.</p>
<p>That‚Äôs why we‚Äôre building the <strong>SPI Test Driver</strong>.</p>
<p>(Eventually we‚Äôll build a LoRaWAN Driver for Semtech SX1262)</p>
</li>
</ol>
<p><em>Can our app call the BL602 / ESP32 SPI Driver directly?</em></p>
<p>Nope that‚Äôs not supported by NuttX. (Unlike other embedded operating systems)</p>
<p>It might seemingly work on BL602 and ESP32, but it will fail on platforms with <strong>Memory Protection</strong>.</p>
<p>(Imagine a Linux App directly calling a Kernel Driver‚Ä¶ That‚Äôs no-no!)</p>
<p>Later we‚Äôll see the layers of code that abstract the BL602 / ESP32 SPI Driver from our NuttX App.</p>
<p><a href="https://www.linkedin.com/feed/update/urn:li:activity:6871062176673742848/?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A6871062176673742848%2C6871868918772846592%29&amp;replyUrn=urn%3Ali%3Acomment%3A%28activity%3A6871062176673742848%2C6871912576393986048%29">(Thanks to Alan Carvalho de Assis for the tip!)</a></p>
<p><em>Must everything be done through the read() and write() interfaces?</em></p>
<p>There‚Äôs another POSIX Interface that‚Äôs supported by NuttX: <strong>ioctl()</strong>.</p>
<p>We‚Äôll see this when we cover the NuttX Device Driver for Semtech SX1276.</p>
<p><img src="https://lupyuen.github.io/images/spi2-plan2.jpg" alt="SPI Test Driver" /></p>
<h1 id="inside-the-spi-test-driver"><a class="doc-anchor" href="#inside-the-spi-test-driver">¬ß</a>2 Inside the SPI Test Driver</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Let‚Äôs study the code in our <strong>SPI Test Driver</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c"><strong>drivers/rf/spi_test_driver.c</strong></a></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/include/nuttx/rf/spi_test_driver.h">(Header File)</a></p>
</li>
</ul>
<p>We created the SPI Test Driver by cloning another device driver, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-create-a-nuttx-device-driver"><strong>‚ÄúCreate a NuttX Device Driver‚Äù</strong></a></li>
</ul>
<p>In the following sections we explain the SPI features that we have implemented in the driver.</p>
<p><img src="https://lupyuen.github.io/images/spi2-driver2a.png" alt="File operations implemented by our driver" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L80-L89">(Source)</a></p>
<h2 id="file-operations"><a class="doc-anchor" href="#file-operations">¬ß</a>2.1 File Operations</h2>
<p>Every <a href="https://nuttx.apache.org/docs/latest/components/drivers/character/index.html"><strong>NuttX Character Device Driver</strong></a> defines a list of supported <strong>File Operations</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>open()</strong>: Open the driver</p>
</li>
<li>
<p><strong>close()</strong>: Close the driver</p>
</li>
<li>
<p><strong>read()</strong>: Read data</p>
</li>
<li>
<p><strong>write()</strong>: Write data</p>
</li>
<li>
<p><strong>ioctl()</strong>: Other operations</p>
</li>
</ul>
<p>(Plus others: seek(), poll(), ‚Ä¶)</p>
<p>Our driver defines the File Operations like so: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L88-L97">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct file_operations g_spi_test_driver_fops =
{
  spi_test_driver_open,
  spi_test_driver_close,
  spi_test_driver_read,
  spi_test_driver_write,
  NULL,  /* Seek not implemented */
  spi_test_driver_ioctl,
  NULL   /* Poll not implemented */
};

/* In spi_test_driver_register() we register the character driver */

register_driver(
  devpath, 
  &amp;g_spi_test_driver_fops, 
  0666, 
  priv);</code></pre></div>
<p><strong>spi_test_driver_register()</strong> and <strong>register_driver()</strong> are called during NuttX Startup, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#register-device-driver"><strong>‚ÄúRegister Device Driver‚Äù</strong></a></li>
</ul>
<p>Our driver implements the <strong>write()</strong> and <strong>read()</strong> operations to transfer data over SPI.</p>
<p>(They will be called by our <strong>SPI Test App</strong>, as we‚Äôll see later)</p>
<p><em>SPI is a full-duplex protocol. How will we implement read() and write()?</em></p>
<p>To simplify our SPI Test Driver, the <strong>read operation shall be buffered</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>write()</strong> transmits the provided data over SPI</p>
</li>
<li>
<p>And saves the received data into the <strong>Receive Buffer</strong></p>
</li>
<li>
<p>Then <strong>read()</strong> returns the received data from the <strong>Receive Buffer</strong></p>
</li>
</ol>
<p>The <strong>Receive Buffer</strong> is defined like so: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L99-L101">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static char recv_buffer[256];  /* Buffer for SPI response */

static int recv_buffer_len = 0;  /* Length of SPI response */</code></pre></div>
<p>Let‚Äôs dive into the write() and read() operations.</p>
<h2 id="write-operation"><a class="doc-anchor" href="#write-operation">¬ß</a>2.2 Write Operation</h2>
<p>In the write() operation for our SPI Test Driver, we‚Ä¶</p>
<ol>
<li>
<p><strong>Lock</strong> the SPI Bus</p>
</li>
<li>
<p><strong>Configure</strong> the SPI Interface</p>
</li>
<li>
<p><strong>Select</strong> the SPI Device</p>
</li>
<li>
<p><strong>Transfer</strong> SPI Data</p>
</li>
<li>
<p><strong>Deselect</strong> the device and <strong>unlock</strong> the bus</p>
</li>
</ol>
<p>Below is the implementation: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L168-L208">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Write the buffer to the SPI device */

static ssize_t spi_test_driver_write(
  FAR struct file *filep,
  FAR const char *buffer,
  size_t buflen)
{
  DEBUGASSERT(buflen &lt;= sizeof(recv_buffer));  /* TODO: Range eheck */
  DEBUGASSERT(buffer != NULL);
  DEBUGASSERT(filep  != NULL);

  /* Get the SPI interface */

  FAR struct inode *inode = filep-&gt;f_inode;
  DEBUGASSERT(inode != NULL);
  FAR struct spi_test_driver_dev_s *priv = inode-&gt;i_private;
  DEBUGASSERT(priv != NULL);</code></pre></div>
<p>We begin by fetching the <a href="https://lupyuen.github.io/articles/spi2#appendix-nuttx-spi-interface"><strong>SPI Interface</strong></a> from the File Struct.</p>
<p>Next we <strong>lock the SPI Bus</strong> and <strong>configure the SPI Interface</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Lock the SPI bus and configure the SPI interface */

  DEBUGASSERT(priv-&gt;spi != NULL);
  SPI_LOCK(priv-&gt;spi, true);
  spi_test_driver_configspi(priv-&gt;spi);</code></pre></div>
<p>(We‚Äôll see <strong>spi_test_driver_configspi</strong> in a while)</p>
<p>We <strong>select the SPI Device</strong> by pulling SPI Chip Select to Low‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Select the SPI device (unused for BL602) */

  SPI_SELECT(priv-&gt;spi, priv-&gt;spidev, true);</code></pre></div>
<p>(This has no effect on BL602. The SPI Hardware automatically sets Chip Select to Low during SPI transfer)</p>
<p>Then we <strong>transfer the data</strong> over SPI (transmit and receive)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Transmit buffer to SPI device and receive the response */

  SPI_EXCHANGE(priv-&gt;spi, buffer, recv_buffer, buflen);
  recv_buffer_len = buflen;</code></pre></div>
<p>Note that the received data goes into our <strong>Receive Buffer</strong>.</p>
<p>(Which will be returned in the read() operation)</p>
<p>Finally we <strong>deselect the device</strong> and <strong>unlock the bus</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Deselect the SPI device (unused for BL602) */

  SPI_SELECT(priv-&gt;spi, priv-&gt;spidev, false);

  /* Unlock the SPI bus */

  SPI_LOCK(priv-&gt;spi, false);

  return buflen;
}</code></pre></div>
<p>The return value is the number of bytes transferred.</p>
<p>(Deselect has no effect on BL602. The SPI Hardware automatically sets Chip Select to High after SPI transfer)</p>
<p><em>What are SPI_LOCK, SPI_SELECT and SPI_EXCHANGE?</em></p>
<p>That‚Äôs the <strong>SPI Interface</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-nuttx-spi-interface">(More about NuttX SPI Interface)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver2.png" alt="Write Operation" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L168-L208">(Source)</a></p>
<h2 id="read-operation"><a class="doc-anchor" href="#read-operation">¬ß</a>2.3 Read Operation</h2>
<p>Remember that the write() operation has saved the received SPI data into the <strong>Receive Buffer</strong>.</p>
<p>Thus for the read() operation we simply return the data in the Receive Buffer: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L210-L233">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Return the data received from the SPI device */

static ssize_t spi_test_driver_read(
  FAR struct file *filep, 
  FAR char *buffer,
  size_t buflen)
{
  DEBUGASSERT(filep  != NULL);
  DEBUGASSERT(buffer != NULL);

  /* Copy the SPI response to the buffer */

  DEBUGASSERT(recv_buffer_len &gt;= 0);
  DEBUGASSERT(recv_buffer_len &lt;= buflen);  /* TODO: Range check */
  memcpy(buffer, recv_buffer, recv_buffer_len);

  /* Return the number of bytes read */

  return recv_buffer_len;
}</code></pre></div><h2 id="configure-spi"><a class="doc-anchor" href="#configure-spi">¬ß</a>2.4 Configure SPI</h2>
<p>Earlier we called <strong>spi_test_driver_configspi</strong> to configure the SPI Interface.</p>
<p>Below is the implementation: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L107-L129">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static inline void spi_test_driver_configspi(FAR struct spi_dev_s *spi)
{
  DEBUGASSERT(spi != NULL);

  /* Set SPI Mode (Polarity and Phase) and Transfer Size (8 bits) */

  SPI_SETMODE(spi, SPI_TEST_DRIVER_SPI_MODE);
  SPI_SETBITS(spi, 8);

  /* Set SPI Hardware Features and Frequency */

  SPI_HWFEATURES(spi, 0);
  SPI_SETFREQUENCY(spi, CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-nuttx-spi-interface">(SPI_SETMODE, SPI_SETBITS, SPI_HWFEATURES and SPI_SETFREQUENCY are defined in the NuttX SPI Interface)</a></p>
<p>The code above configures the SPI Interface as follows‚Ä¶</p>
<ul>
<li>
<p><strong>SPI Mode</strong> (Polarity Phase): 0</p>
<p>(For BL602 we‚Äôre using Mode 1)</p>
</li>
<li>
<p><strong>SPI Transfer Size</strong>: 8 bits</p>
</li>
<li>
<p><strong>SPI Hardware Features</strong>: None</p>
</li>
<li>
<p><strong>SPI Frequency</strong>: 1 MHz</p>
</li>
</ul>
<p><strong>SPI Mode</strong> and <strong>SPI Frequency</strong> are defined below: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L45-L57">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* We set SPI Frequency to 1 MHz */

#ifndef CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY
#define CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY 1000000
#endif /* CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY */

/* For BL602 we use SPI Mode 1 instead of Mode 0 due to SPI quirk */

#ifdef CONFIG_BL602_SPI0
#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE1) /* SPI Mode 1: Workaround for BL602 */
#else
#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE0) /* SPI Mode 0: CPOL=0,CPHA=0 */
#endif /* CONFIG_BL602_SPI0 */</code></pre></div>
<p>BL602 uses <strong>SPI Mode 1</strong> (instead of Mode 0) because of an <strong>SPI Mode Quirk</strong> in BL602.</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-spi-mode-quirk">(More about the SPI Mode Quirk)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver4.png" alt="Register SPI Test Driver at startup" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617">(Source)</a></p>
<h1 id="load-the-spi-test-driver"><a class="doc-anchor" href="#load-the-spi-test-driver">¬ß</a>3 Load the SPI Test Driver</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p><em>How do we load our SPI Test Driver at startup?</em></p>
<p>During NuttX Startup, we <strong>load our SPI Test Driver</strong> like so: <a href="https://github.com/lupyuen/nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int bl602_bringup(void)
{
  ...
#ifdef CONFIG_RF_SPI_TEST_DRIVER

  /* Init SPI bus again */

  struct spi_dev_s *spitest = bl602_spibus_initialize(0);
  if (!spitest)
    {
      _err(&quot;ERROR: Failed to initialize SPI %d bus\n&quot;, 0);
    }

  /* Register the SPI Test Driver */

  ret = spi_test_driver_register(&quot;/dev/spitest0&quot;, spitest, 0);
  if (ret &lt; 0)
    {
      _err(&quot;ERROR: Failed to register SPI Test Driver\n&quot;);
    }

#endif /* CONFIG_RF_SPI_TEST_DRIVER */</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L367-L620"><strong>bl602_bringup</strong></a> is the NuttX Startup Function for BL602.</p>
<p>(<a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup</strong></a> for ESP32)</p>
<p>We modified the Startup Function to <strong>register our SPI Test Driver</strong>, which loads the driver into NuttX at startup.</p>
<p>Let‚Äôs run NuttX on BL602 / ESP32 and check that our <strong>SPI Test Driver loads correctly</strong>‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the modified source code‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --branch spi_test https://github.com/lupyuen/nuttx nuttx
git clone --branch spi_test https://github.com/lupyuen/nuttx-apps apps</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features">(<strong>For PineDio Stack BL604:</strong> The SPI Test Driver is already preinstalled)</a></p>
</li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Edit the Build Config
make menuconfig </code></pre></div></li>
<li>
<p>Enable the SPI Peripheral and SPI Character Driver in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-debug.jpg" alt="Enable SPI" /></p>
</li>
<li>
<p>Enable our SPI Test Driver‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver6.png" alt="Select SPI Test Driver" /></p>
</li>
<li>
<p>Enable SPI logging for easier troubleshooting‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-logging"><strong>‚ÄúEnable Logging‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver4.png" alt="Enable logging" /></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/93b553fdfcfa0221ccd6276706e72caf">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p><strong>For ESP32:</strong> Edit <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup.c</strong></a> to register our SPI Test Driver <a href="https://lupyuen.github.io/articles/spi2#register-device-driver">(See this)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>Our SPI Test Driver appears as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver10.png" alt="Our SPI Test Driver appears as ‚Äú/dev/spitest0‚Äù" /></p>
<p>Congratulations NuttX has loaded our Device Driver!</p>
<p>Let‚Äôs talk about our SPI Test App.</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-plan3.jpg" alt="SPI Test App" /></p>
<h1 id="inside-the-spi-test-app"><a class="doc-anchor" href="#inside-the-spi-test-app">¬ß</a>4 Inside the SPI Test App</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>We‚Äôve seen the write() and read() operations in our SPI Test Driver.  Now we learn how they are called by our <strong>SPI Test App</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test"><strong>examples/spi_test</strong></a></li>
</ul>
<p>We created the SPI Test App by cloning another app, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-create-a-nuttx-app"><strong>‚ÄúCreate a NuttX App‚Äù</strong></a></li>
</ul>
<p>We‚Äôll do the following in our SPI Test App‚Ä¶</p>
<ol>
<li>
<p><strong>Open</strong> our SPI Test Driver</p>
</li>
<li>
<p><strong>Transmit</strong> data over SPI</p>
</li>
<li>
<p><strong>Receive</strong> data over SPI</p>
</li>
<li>
<p><strong>Close</strong> our SPI Test Driver</p>
</li>
</ol>
<h2 id="open-spi-test-driver"><a class="doc-anchor" href="#open-spi-test-driver">¬ß</a>4.1 Open SPI Test Driver</h2>
<p>Earlier we saw that our SPI Test Driver appears in NuttX as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p>Let‚Äôs open the driver: <a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test/spi_test_main.c">spi_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int main(int argc, FAR char *argv[])
{
  /* Open SPI Test Driver */

  int fd = open(&quot;/dev/spitest0&quot;, O_RDWR);
  assert(fd &gt;= 0);  /* TODO: Handle error */</code></pre></div>
<p>(Yep this looks very Linux-like!)</p>
<p><strong>open()</strong> returns a <strong>File Descriptor</strong> that we‚Äôll use to transmit and receive data over SPI.</p>
<h2 id="transmit-spi-data"><a class="doc-anchor" href="#transmit-spi-data">¬ß</a>4.2 Transmit SPI Data</h2>
<p>Our SPI Test Driver implements a <strong>write()</strong> operation that will transmit SPI data.</p>
<p>We call it like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Write to SPI Test Driver */

  static char data[] = &quot;Hello World&quot;;
  int bytes_written = write(fd, data, sizeof(data));
  assert(bytes_written == sizeof(data));</code></pre></div>
<p>This transmits the string <strong>‚ÄúHello World‚Äù</strong> to our SPI Device.</p>
<p>(Including the terminating null character)</p>
<h2 id="receive-spi-data"><a class="doc-anchor" href="#receive-spi-data">¬ß</a>4.3 Receive SPI Data</h2>
<p>Remember that the <strong>write()</strong> operation will actually transmit and receive SPI data at the same time.</p>
<p>We read the received SPI data by calling <strong>read()</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Read response from SPI Test Driver */

  static char rx_data[256];  /* Buffer for SPI response */
  int bytes_read = read(fd, rx_data, sizeof(rx_data));
  assert(bytes_read == sizeof(get_status));</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L65-L69">(Source)</a></p>
<p>This code isn‚Äôt in our SPI Test App, we‚Äôll see this later when we test with Semtech SX1262.</p>
<h2 id="close-spi-test-driver"><a class="doc-anchor" href="#close-spi-test-driver">¬ß</a>4.4 Close SPI Test Driver</h2>
<p>Finally we close the File Descriptor for our SPI Test Driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Close SPI Test Driver */

  close(fd);
  return 0;
}</code></pre></div>
<p>Let‚Äôs run our SPI Test App!</p>
<p><img src="https://lupyuen.github.io/images/spi2-app4.png" alt="SPI Test App" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test/spi_test_main.c">(Source)</a></p>
<h1 id="run-the-spi-test-app"><a class="doc-anchor" href="#run-the-spi-test-app">¬ß</a>5 Run the SPI Test App</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Follow these steps to run our SPI Test App on BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
</li>
<li>
<p>Edit the build configuration‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make menuconfig</code></pre></div></li>
<li>
<p>Enable our SPI Test App in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-app"><strong>‚ÄúEnable App‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp4.jpg" alt="Enable SPI Test App in menuconfig" /></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/93b553fdfcfa0221ccd6276706e72caf">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>spi_test</code></pre></div></li>
<li>
<p>We should see every byte transmitted and received over SPI.</p>
<p>(Thanks to SPI Logging!)</p>
<p>The pic below shows that our app has transmitted the string <strong>‚ÄúHello World‚Äù</strong> (plus the terminating null) over SPI.</p>
<p>But because we‚Äôre not connected to any SPI Device, we don‚Äôt receive any meaningful response. (It‚Äôs all <code>0xFF</code>)</p>
<p><img src="https://lupyuen.github.io/images/spi2-app3.png" alt="SPI Test App" /></p>
</li>
</ol>
<h1 id="test-with-logic-analyser"><a class="doc-anchor" href="#test-with-logic-analyser">¬ß</a>6 Test with Logic Analyser</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p><em>How do we check if our app is transmitting SPI data correctly?</em></p>
<p>Let‚Äôs connect a <strong>Logic Analyser</strong> to BL602 / ESP32 and verify the SPI output‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Logic Analyser</th><th style="text-align: center">BL602 Pin</th><th style="text-align: center">ESP32 Pin</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>MOSI</strong></td><td style="text-align: center">GPIO 1</td><td style="text-align: center">GPIO 13</td></tr>
<tr><td style="text-align: center"><strong>MISO</strong></td><td style="text-align: center">GPIO 0</td><td style="text-align: center">GPIO 12</td></tr>
<tr><td style="text-align: center"><strong>SCK</strong></td><td style="text-align: center">GPIO 3</td><td style="text-align: center">GPIO 14</td></tr>
<tr><td style="text-align: center"><strong>CS</strong></td><td style="text-align: center">GPIO 2</td><td style="text-align: center">GPIO 15</td></tr>
<tr><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/spi2-logic4.jpg" alt="Logic Analyser connected to PineCone BL602" /></p>
<p><em>How did we get the GPIO Pin Numbers for the SPI Port?</em></p>
<p><strong>For BL602:</strong> SPI Pins are defined in <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L87-L92">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN2)
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN1)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN3)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<p><strong>For ESP32:</strong> SPI Pins are defined in <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/xtensa/src/esp32/Kconfig#L799-L817">Kconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>config ESP32_SPI2_CSPIN
	int &quot;SPI2 CS Pin&quot;
	default 15
	range 0 39

config ESP32_SPI2_CLKPIN
	int &quot;SPI2 CLK Pin&quot;
	default 14
	range 0 39

config ESP32_SPI2_MOSIPIN
	int &quot;SPI2 MOSI Pin&quot;
	default 13
	range 0 39

config ESP32_SPI2_MISOPIN
	int &quot;SPI2 MISO Pin&quot;
	default 12
	range 0 39</code></pre></div>
<p>When we run <strong>‚Äúspi_test‚Äù</strong>, we see this in our Logic Analyser‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-logic2.png" alt="Running spi_test and observing the Logic Analyser" /></p>
<p>This looks OK! Though MISO is idle because it‚Äôs not connected to an SPI Device.</p>
<p>Let‚Äôs test with a real SPI Device: Semtech SX1262.</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-miso-and-mosi-are-swapped">(BL602 has a quirk that swaps MISO and MOSI, the fix is explained here)</a></p>
<h1 id="control-chip-select-with-gpio"><a class="doc-anchor" href="#control-chip-select-with-gpio">¬ß</a>7 Control Chip Select with GPIO</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>If we zoom out the above display in the Logic Analyser, we see a problem with <strong>SPI Chip Select on BL602</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-logic3.png" alt="Chip Select goes Low after every byte" /></p>
<p>BL602 sets Chip Select to <strong>High after EVERY byte</strong>!</p>
<p>This will be a problem for <strong>Semtech SX1262</strong> (LoRa Transceiver)‚Ä¶</p>
<p>It expects Chip Select to be <strong>High after the entire multi-byte command</strong> has been transmitted! (Not after every byte)</p>
<p><a href="https://twitter.com/4ever_freedom/status/1549235596115181569">(ESP32 doesn‚Äôt have this problem, according to @4ever_freedom)</a></p>
<p><em>Can we control SPI Chip Select ourselves?</em></p>
<p>Yes, we may control Chip Select ourselves with the <strong>GPIO Output</strong> function in NuttX.</p>
<p>This means we designate a <strong>GPIO Output Pin</strong> that will be used for Chip Select.</p>
<p>And we call NuttX to flip the pin Low and High, before and after each SPI transfer.</p>
<p><em>Is there another reason for controlling Chip Select with GPIO?</em></p>
<p>On many BL602 / ESP32 boards, the SPI Bus (MISO, MOSI and SCK) is <strong>shared by multiple SPI Devices</strong>.</p>
<p>But each SPI Device has its own <strong>Chip Select Pin</strong>.</p>
<p>For such boards we‚Äôll have to control each Chip Select Pin with GPIO.</p>
<p><a href="https://lupyuen.github.io/articles/pinedio2">(PineDio Stack BL604 shares its SPI Bus with SX1262 Transceiver, ST7789 Display and SPI Flash)</a></p>
<h2 id="gpio-output-as-chip-select"><a class="doc-anchor" href="#gpio-output-as-chip-select">¬ß</a>7.1 GPIO Output as Chip Select</h2>
<p>Let‚Äôs look at the code in <strong>SPI Test App #2</strong> that controls Chip Select with GPIO: <a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L42-L74">spi_test2_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Open GPIO Output for SPI Chip Select */

int cs = open(&quot;/dev/gpout1&quot;, O_RDWR);
assert(cs &gt;= 0);  /* TODO: Handle error */</code></pre></div>
<p>(Renamed to <strong>/dev/gpio1</strong> as of Dec 2021)</p>
<p>This is new: We open the GPIO Output device <strong>‚Äú/dev/gpout1‚Äù</strong> for the SPI Chip Select Pin.</p>
<p>Next we <strong>open our SPI Test Driver</strong> as before‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Open SPI Test Driver */

int fd = open(&quot;/dev/spitest0&quot;, O_RDWR);
assert(fd &gt;= 0);</code></pre></div>
<p>Then we set our <strong>GPIO Output / Chip Select</strong> to Low by calling <strong>ioctl()</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Set SPI Chip Select to Low */

int ret = ioctl(cs, GPIOC_WRITE, 0);
assert(ret &gt;= 0);</code></pre></div>
<p>Now that the SPI Device is active, we can <strong>transmit and receive</strong> our SPI data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Get Status */

static char get_status[] = { 0xc0, 0x00 };
int bytes_written = write(fd, get_status, sizeof(get_status));
assert(bytes_written == sizeof(get_status));

/* Read response from SX1262 */

static char rx_data[256];  /* Buffer for SPI response */
int bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(get_status));</code></pre></div>
<p>(We‚Äôll explain <strong>get_status</strong> in the next section)</p>
<p>Finally we set our <strong>GPIO Output / Chip Select</strong> to High‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Set SPI Chip Select to High */

ret = ioctl(cs, GPIOC_WRITE, 1);
assert(ret &gt;= 0);

/* Close SPI Test Driver and GPIO Output */

close(fd);
close(cs);</code></pre></div>
<p>And close the SPI Test Driver and GPIO Output.</p>
<p>Let‚Äôs watch SPI Test App #2 in action with Semtech SX1262.</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#gpio-demo">(More about GPIO Output)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx5.png" alt="Control Chip Select with GPIO" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L42-L74">(Source)</a></p>
<h1 id="test-with-semtech-sx1262"><a class="doc-anchor" href="#test-with-semtech-sx1262">¬ß</a>8 Test with Semtech SX1262</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p><a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262"><strong>Semtech SX1262</strong></a> is a LoRa Transceiver (Radio Transmitter + Receiver) that‚Äôs not yet supported by NuttX.</p>
<p><a href="https://github.com/apache/nuttx/tree/master/drivers/wireless/lpwan/sx127x">(Though the older model SX1276 is supported by NuttX)</a></p>
<p>Today we shall send two short commands to SX1262 for testing‚Ä¶</p>
<ul>
<li>
<p><strong>Get Status:</strong> We transmit this sequence of bytes to SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>C0 00</code></pre></div>
<p>We expect the SPI Response to look like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>A2 22</code></pre></div>
<p>(The response might get muddled, we‚Äôll learn why in a while)</p>
</li>
<li>
<p><strong>Read Register 0x08:</strong>  We transmit this sequence of bytes to SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>1D 00 08 00 00</code></pre></div>
<p>We expect the SPI Response to end with <strong><code>0x80</code></strong> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>A2 A2 A2 A2 80</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/lorawan#troubleshoot-lorawan">(Register <code>0x08</code> is expected to have value <code>0x80</code> at startup)</a></p>
</li>
</ul>
<p>We send the <strong>‚ÄúGet Status‚Äù</strong> command with this code: <a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L59-L83">spi_test2_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Get Status */

static char get_status[] = { 0xc0, 0x00 };
int bytes_written = write(fd, get_status, sizeof(get_status));
assert(bytes_written == sizeof(get_status));

/* Read response from SX1262 */

static char rx_data[256];  /* Buffer for SPI response */
int bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(get_status));

/* Show the received status */

printf(&quot;\nSX1262 Status is %d\n&quot;, (rx_data[1] &gt;&gt; 4) &amp; 0b111);  /* Bits 6:4 */</code></pre></div>
<p>And the <strong>‚ÄúRead Register 0x08‚Äù</strong> command with this code: <a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L94-L117">spi_test2_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Read Register 8 */

static char read_reg[] = { 0x1d, 0x00, 0x08, 0x00, 0x00 };
bytes_written = write(fd, read_reg, sizeof(read_reg));
assert(bytes_written == sizeof(read_reg));

/* Read response from SX1262 */

bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(read_reg));

/* Show the received register value */

printf(&quot;\nSX1262 Register 8 is 0x%02x\n&quot;, rx_data[4]);</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c">(See the complete program)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx6.png" alt="Transmit command to SX1262: Read Register 0x08" /></p>
<h2 id="connect-sx1262"><a class="doc-anchor" href="#connect-sx1262">¬ß</a>8.1 Connect SX1262</h2>
<p>We connect SX1262 to BL602 / ESP32 as follows‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">SX1262</th><th style="text-align: center">BL602 Pin</th><th style="text-align: center">ESP32 Pin</th><th style="text-align: left">Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>MOSI</strong></td><td style="text-align: center">GPIO 1</td><td style="text-align: center">GPIO 13</td><td style="text-align: left">Yellow</td></tr>
<tr><td style="text-align: center"><strong>MISO</strong></td><td style="text-align: center">GPIO 0</td><td style="text-align: center">GPIO 12</td><td style="text-align: left">Light Green</td></tr>
<tr><td style="text-align: center"><strong>SCK</strong></td><td style="text-align: center">GPIO 3</td><td style="text-align: center">GPIO 14</td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong>CS</strong></td><td style="text-align: center">GPIO 11</td><td style="text-align: center">GPIO 15 / 16</td><td style="text-align: left">Dark Green</td></tr>
<tr><td style="text-align: center"><strong>BUSY</strong></td><td style="text-align: center">GPIO 14</td><td style="text-align: center">GPIO 18 / 17</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center"><strong>DIO1</strong></td><td style="text-align: center">GPIO 17</td><td style="text-align: center">GPIO 22</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: center"><strong>VCC</strong></td><td style="text-align: center">3V3</td><td style="text-align: center">3V3</td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center">GND</td><td style="text-align: center">GND</td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p>Here‚Äôs SX1262 connected to PineCone BL602‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="SX1262 connected to PineCone BL602" /></p>
<p>(Busy and DIO1 Pins are not connected, we‚Äôll need them for LoRa in the next artice)</p>
<p><em>Why did we connect Chip Select to GPIO 11 / 15 / 16?</em></p>
<p>Remember that we‚Äôre controlling SPI Chip Select ourselves through <strong>GPIO Output</strong>, which is defined as follows‚Ä¶</p>
<p><strong>For BL602:</strong> GPIO Output Pin is defined as <strong>GPIO 11</strong> in <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L48-L49">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_GPIO_OUT1 \
  (GPIO_OUTPUT | GPIO_FLOAT | \
  GPIO_FUNC_SWGPIO | GPIO_PIN11)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx#configure-pins">(More about this)</a></p>
<p><strong>For ESP32:</strong> GPIO Output Pin depends on our ESP32 Board (and may be customised)‚Ä¶</p>
<p>ESP32-DevKitC defines <strong>GPIO 15</strong> as the default GPIO Output Pin: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_gpio.c#L43-L67">esp32_gpio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Output pins. GPIO15 is used as an example, any other outputs could be used. */
#define GPIO_OUT1    15

/* Input pins. GPIO18 is used as an example, any other inputs could be
 * used.
 */
#define GPIO_IN1     18

/* Interrupt pins.  GPIO22 is used as an example, any other inputs could be
 * used.
 */
#define GPIO_IRQPIN1  22</code></pre></div>
<p>ESP32-WROVER-KIT uses <strong>GPIO 16</strong> for GPIO Output: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-wrover-kit/src/esp32_gpio.c#L43-L67">esp32_gpio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define GPIO_OUT1    16
#define GPIO_IN1     17
#define GPIO_IRQPIN1 22</code></pre></div>
<p>TTGO-LoRa-ESP32 uses <strong>GPIO 15</strong> for GPIO Output: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/ttgo_lora_esp32/src/esp32_gpio.c#L43-L67">esp32_gpio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define GPIO_OUT1    15
#define GPIO_IN1     18
#define GPIO_IRQPIN1 22</code></pre></div><h2 id="test-sx1262"><a class="doc-anchor" href="#test-sx1262">¬ß</a>8.2 Test SX1262</h2>
<p>Follow these steps to run our SPI Test App #2 on BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
</li>
<li>
<p>Edit the build configuration‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make menuconfig</code></pre></div></li>
<li>
<p>Enable the GPIO Driver‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#enable-gpio-driver"><strong>‚ÄúEnable GPIO Driver‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-menu7a.png" alt="Enable the GPIO Driver" /></p>
</li>
<li>
<p>Hit ‚ÄúExit‚Äù until the Top Menu appears</p>
<p>(‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable SPI Test App #2‚Ä¶</p>
<p>Select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong></p>
<p>Check the box for <strong>‚Äúspi_test2‚Äù</strong></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/93b553fdfcfa0221ccd6276706e72caf">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test2</code></pre></div>
<p>(Pic below)</p>
</li>
<li>
<p>We should see the output from the <strong>‚ÄúGet Status‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Get Status: received
  8a 8a
SX1262 Status is 0</code></pre></div>
<p>(This output is not quite correct, we‚Äôll explain why in the next section)</p>
</li>
<li>
<p>And the output from the <strong>‚ÄúRead Register 0x08‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Read Register 8: received
  a8 a8 a8 a8 80
SX1262 Register 8 is 0x80</code></pre></div>
<p>The value of Register 0x08 is correct: <strong><code>0x80</code></strong></p>
<p>Yep our NuttX App is working OK with SX1262!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-sx.png" alt="SPI Test App #2 reads the SX1262 Register correctly" /></p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-spi-mode-quirk">(BL602 has a quirk: We must use SPI Mode 1 instead of Mode 0 or the register value will be garbled)</a></p>
<p>Let‚Äôs run SPI Test App #2 on a new gagdet with onboard SX1262: PineDio Stack BL604.</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio2a.jpg" alt="PineDio Stack BL604" /></p>
<h1 id="test-with-pinedio-stack"><a class="doc-anchor" href="#test-with-pinedio-stack">¬ß</a>9 Test with PineDio Stack</h1>
<p><em>(For BL604 only)</em></p>
<p>Pine64 has just sent me a prototype of <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> (version 2, pic above) with onboard SX1262 LoRa Transceiver, ST7789 Display, SPI Flash, GPS, Compass, Touch Panel, Heart Rate Sensor, Vibrator, ‚Ä¶</p>
<p>(Yep multiple devices on the same SPI Bus)</p>
<p>Let‚Äôs test NuttX with PineDio Stack BL604 and its <strong>onboard SX1262</strong>! Here are the innards‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio1.jpg" alt="Inside PineDio Stack BL604" /></p>
<p>Before testing, remember to connect the <strong>LoRa Antenna</strong>‚Ä¶</p>
<p>(So we don‚Äôt fry the SX1262 Transceiver as we charge up the Power Amplifier)</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio10a.jpg" alt="PineDio Stack BL604 with Antenna" /></p>
<h2 id="pin-definitions"><a class="doc-anchor" href="#pin-definitions">¬ß</a>9.1 Pin Definitions</h2>
<p>Based on this schematic for PineDio Stack BL604 (version 2)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio3.png" alt="SX1262 Interface on PineDio Stack" /></p>
</blockquote>
<p>We update the following <strong>BL604 Pin Definitions</strong> in <a href="https://github.com/lupyuen/nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95">board.h</a></p>
<div><table><thead><tr><th style="text-align: center">SX1262</th><th style="text-align: center">BL604 Pin</th><th style="text-align: left">NuttX Pin</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>MOSI</strong></td><td style="text-align: center">GPIO 13</td><td style="text-align: left">BOARD_SPI_MOSI</td></tr>
<tr><td style="text-align: center"><strong>MISO</strong></td><td style="text-align: center">GPIO 0</td><td style="text-align: left">BOARD_SPI_MISO</td></tr>
<tr><td style="text-align: center"><strong>SCK</strong></td><td style="text-align: center">GPIO 11</td><td style="text-align: left">BOARD_SPI_CLK</td></tr>
<tr><td style="text-align: center"><strong>CS</strong></td><td style="text-align: center">GPIO 15</td><td style="text-align: left">BOARD_GPIO_OUT1</td></tr>
<tr><td style="text-align: center"><strong>BUSY</strong></td><td style="text-align: center">GPIO 10</td><td style="text-align: left">BOARD_GPIO_IN1</td></tr>
<tr><td style="text-align: center"><strong>DIO1</strong></td><td style="text-align: center">GPIO 19</td><td style="text-align: left">BOARD_GPIO_INT1</td></tr>
<tr><td style="text-align: center"><strong>NRESET</strong></td><td style="text-align: center">GPIO 18</td><td style="text-align: left">Not assigned yet</td></tr>
</tbody></table>
</div><div class="example-wrap"><pre class="language-c"><code>/* Busy Pin for PineDio SX1262 */

#define BOARD_GPIO_IN1    (GPIO_INPUT | GPIO_FLOAT | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN10)

/* SPI Chip Select for PineDio SX1262 */

#define BOARD_GPIO_OUT1   (GPIO_OUTPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN15)

/* GPIO Interrupt (DIO1) for PineDio SX1262 */

#define BOARD_GPIO_INT1   (GPIO_INPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN19)

/* SPI Configuration: Chip Select is unused because we control via GPIO instead */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN8)  /* Unused */
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN13)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN11)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<p>(Remember that GPIO Output <strong>BOARD_GPIO_OUT1</strong> becomes our Chip Select)</p>
<p>Today we won‚Äôt use <strong>BOARD_GPIO_IN1</strong> (Busy Pin) and <strong>BOARD_GPIO_INT1</strong> (DIO1).</p>
<p>But eventually we‚Äôll use them when we port the <strong>LoRaWAN Stack</strong> to PineDio Stack BL604!</p>
<h2 id="run-nuttx-on-pinedio-stack"><a class="doc-anchor" href="#run-nuttx-on-pinedio-stack">¬ß</a>9.2 Run NuttX on PineDio Stack</h2>
<p>Our final task for today: Run SPI Test App #2 on PineDio Stack BL604 (with onboard SX1262)‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/spi2#test-sx1262"><strong>‚ÄúTest SX1262‚Äù</strong></a></p>
</li>
<li>
<p>Edit the <strong>Pin Definitions</strong> as shown above‚Ä¶</p>
<p><a href="https://github.com/lupyuen/nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95">boards/risc-v/bl602/bl602evb/include/board.h</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test2</code></pre></div>
<p>(Pic below)</p>
</li>
<li>
<p>We should see the output from the <strong>‚ÄúGet Status‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Get Status: received
  a2 22
SX1262 Status is 2</code></pre></div>
<p>(This looks different from the BL602 output, we‚Äôll explain why in a while)</p>
</li>
<li>
<p>And the output from the <strong>‚ÄúRead Register 0x08‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Read Register 8: received
  a2 a2 a2 a2 80
SX1262 Register 8 is 0x80</code></pre></div>
<p>The value of Register 0x08 is correct: <strong><code>0x80</code></strong></p>
<p>Our SPI Test App #2 runs OK on PineDio Stack BL604 with onboard SX1262! üéâ</p>
<p><a href="https://github.com/lupyuen/lora-sx1262#read-registers">(The results are consistent with SX1262 tested on Linux with SPI Mode 0)</a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio2.png" alt="NuttX on PineDio Stack BL604" /></p>
<h2 id="chip-select"><a class="doc-anchor" href="#chip-select">¬ß</a>9.3 Chip Select</h2>
<p><em>Why did the ‚ÄúGet Status‚Äù command return different results on BL602 vs BL604?</em></p>
<p>On PineCone BL602 we configure <strong>GPIO Output (Chip Select)</strong> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_GPIO_OUT1 \
  (GPIO_OUTPUT | GPIO_FLOAT | \
  GPIO_FUNC_SWGPIO | GPIO_PIN11)</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L48-L49">(Source)</a></p>
<p>On PineDio Stack BL604 we do this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_GPIO_OUT1 \
  (GPIO_OUTPUT | GPIO_PULLUP | \
  GPIO_FUNC_SWGPIO | GPIO_PIN15)</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L47-L50">(Source)</a></p>
<p>See the difference? PineCone BL602 configures the GPIO Output (Chip Select) as <strong>GPIO_FLOAT</strong>, whereas BL604 configures it as <strong>GPIO_PULLUP</strong>.</p>
<p>With <strong>GPIO_FLOAT</strong>, Chip Select defaults to the <strong>Low State</strong> at startup.</p>
<p>Which <strong>activates SX1262</strong> on the SPI Bus at startup, possibly interpreting spurious commands and causing the ‚ÄúGet Status‚Äù command to fail.</p>
<p>PineDio Stack BL604 does it correctly: It sets Chip Select to the <strong>High State</strong> at startup (<strong>GPIO_PULLUP</strong>).  Which <strong>deactivates SX1262</strong> on the SPI Bus at startup.</p>
<p><em>Anything else we missed?</em></p>
<p>On PineDio Stack BL604 the SPI Bus is <strong>shared by multiple SPI Devices</strong>: SX1262 Transceiver, ST7789 Display, SPI Flash.</p>
<p>We ought to flip the Chip Select for other SPI Devices to High, to deactivate the other devices and <strong>prevent crosstalk</strong> on the SPI Bus.</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>10 What‚Äôs Next</h1>
<p>Now that we have NuttX talking OK to the SX1262 LoRa Transceiver‚Ä¶ We‚Äôre ready to port <strong>LoRa and LoRaWAN</strong> to NuttX!</p>
<p>Over the next couple of articles we shall <strong>migrate the LoRa + LoRaWAN code incrementally</strong> to NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262"><strong>‚ÄúLoRa SX1262 on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></p>
</li>
</ul>
<p>NuttX works great with the <strong>ST7789 SPI Display</strong> and LVGL Graphics Libary, right out of the box‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/st7789"><strong>‚ÄúST7789 Display with LVGL Graphics on Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>We‚Äôll also explore <strong>I2C on NuttX</strong>, which is super useful for IoT sensors‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280"><strong>‚ÄúApache NuttX Driver for BME280 Sensor: Ported from Zephyr OS‚Äù</strong></a></li>
</ul>
<p>I‚Äôm super excited about porting the <a href="https://lupyuen.github.io/articles/nuttx#rust-on-nuttx"><strong>Rust Embedded HAL</strong></a> to NuttX. Here‚Äôs how we integrated NuttX GPIO, SPI and I2C with Rust‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rust2"><strong>‚ÄúRust on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rusti2c"><strong>‚ÄúRust talks I2C on Apache NuttX RTOS‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://lupyuen.github.io/articles/sponsor"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sponsor">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/rf3smq/spi_on_apache_nuttx_os/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/spi2.md"><code>lupyuen.github.io/src/spi2.md</code></a></p>
<h1 id="notes"><a class="doc-anchor" href="#notes">¬ß</a>11 Notes</h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1464898624026906625">this Twitter Thread</a></p>
</li>
<li>
<p>We have already ported LoRaWAN to <strong>BL602 IoT SDK</strong> <a href="https://lupyuen.github.io/articles/lorawan">(see this)</a>, why are we porting again to NuttX?</p>
<p>Regrettably BL602 IoT SDK has been revamped (without warning) to the <strong>new ‚Äúhosal‚Äù HAL</strong> <a href="https://twitter.com/MisterTechBlog/status/1456259223323508748">(see this)</a>, and the LoRaWAN Stack will <strong>no longer work</strong> on the revamped BL602 IoT SDK.</p>
<p>For easier maintenance, we shall <strong>code our BL602 and BL604 projects with Apache NuttX OS</strong> instead.</p>
<p>(Which won‚Äôt get revamped overnight!)</p>
</li>
</ol>
<h1 id="appendix-spi-dma-on-bl602-nuttx"><a class="doc-anchor" href="#appendix-spi-dma-on-bl602-nuttx">¬ß</a>12 Appendix: SPI DMA on BL602 NuttX</h1>
<p>SPI on BL602 NuttX now supports <strong>Direct Memory Access (DMA)</strong> for speedy data transfers!</p>
<p>This is how we <strong>enable SPI DMA</strong> on BL602‚Ä¶</p>
<ol>
<li>
<p>Enter this command to configure the NuttX Build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make menuconfig</code></pre></div></li>
<li>
<p>Select <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúBL602 Peripheral Support‚Äù</strong></p>
</li>
<li>
<p>Enable <strong>‚ÄúDMA‚Äù</strong></p>
</li>
<li>
<p>Enable <strong>‚ÄúSPI DMA Support‚Äù</strong></p>
</li>
<li>
<p>Save the configuration and exit</p>
</li>
<li>
<p>Rebuild NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make</code></pre></div></li>
</ol>
<p>Many thanks to <a href="https://github.com/apache/nuttx/pull/7229"><strong>Brennan Ashton</strong></a> for the implementation of DMA on BL602!</p>
<h1 id="appendix-create-a-nuttx-device-driver"><a class="doc-anchor" href="#appendix-create-a-nuttx-device-driver">¬ß</a>13 Appendix: Create a NuttX Device Driver</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>This section explains the steps to create a <strong>NuttX Device Driver</strong> named <strong>‚Äúspi_test_driver‚Äù</strong>.</p>
<p>(Change ‚Äúspi_test_driver‚Äù to the desired name of our driver)</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/blob/newdriver/drivers/rf"><strong>‚Äúnuttx/nuttx/drivers/rf‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the file <strong>‚Äúdat-31r5-sp.c‚Äù</strong> and paste it as <strong>‚Äúspi_test_driver.c‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver.png" alt="Copy ‚Äúdat-31r5-sp.c‚Äù to ‚Äúspi_test_driver.c‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/drivers/rf/spi_test_driver.c">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test_driver.c‚Äù</strong> file, search and replace all <strong>‚Äúdat31r5sp‚Äù</strong> by <strong>‚Äúspi_test_driver‚Äù</strong></p>
<p>Be sure to <strong>Preserve Case!</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver2.png" alt="Change all ‚Äúdat31r5sp‚Äù to ‚Äúspi_test_driver‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/8fee69215163180b77dc9d5b9e7449ebe00ac1cc">(Source)</a></p>
</li>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/blob/newdriver/include/nuttx/rf"><strong>‚Äúnuttx/nuttx/include/nuttx/rf‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the file <strong>‚Äúdat-31r5-sp.h‚Äù</strong> and paste it as <strong>‚Äúspi_test_driver.h‚Äù</strong></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test_driver.h‚Äù</strong> file, search and replace all <strong>‚Äúdat31r5sp‚Äù</strong> by <strong>‚Äúspi_test_driver‚Äù</strong></p>
<p>Remember to <strong>Preserve Case!</strong></p>
<p>The Header File should look like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver3.png" alt="spi_test_driver.h" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/include/nuttx/rf/spi_test_driver.h">(Source)</a></p>
</li>
</ol>
<h2 id="update-makefile-and-kconfig"><a class="doc-anchor" href="#update-makefile-and-kconfig">¬ß</a>13.1 Update Makefile and Kconfig</h2>
<p>Now we update the Makefile so that NuttX will build our Device Driver‚Ä¶</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/blob/newdriver/drivers/rf"><strong>‚Äúnuttx/nuttx/drivers/rf‚Äù</strong></a> folder</p>
</li>
<li>
<p>Edit the file <strong>‚ÄúMake.defs‚Äù</strong></p>
<p>Insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ifeq ($(CONFIG_RF_SPI_TEST_DRIVER),y)
  CSRCS += spi_test_driver.c
  RFDEPPATH = --dep-path rf
  RFVPATH = :rf
endif</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver9.png" alt="Update ‚ÄúMake.defs‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/drivers/rf/Make.defs#L33-L37">(Source)</a></p>
</li>
<li>
<p>Edit the file <strong>‚ÄúKconfig‚Äù</strong></p>
<p>Insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config RF_SPI_TEST_DRIVER
    bool &quot;SPI Test Driver&quot;
    default n
    select SPI
    ---help---
        Enable SPI Test Driver.</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver5.png" alt="Update ‚ÄúKconfig‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/drivers/rf/Kconfig#L22-L27">(Source)</a></p>
</li>
<li>
<p>Enter the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the path of our &quot;nuttx&quot; folder
cd nuttx/nuttx

## Preserve the Build Config
cp .config ../config

## Erase the Build Config
make distclean

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Restore the Build Config
cp ../config .config

## Edit the Build Config
make menuconfig </code></pre></div></li>
</ol>
<h2 id="enable-spi"><a class="doc-anchor" href="#enable-spi">¬ß</a>13.2 Enable SPI</h2>
<p>We enable SPI and our Device Driver as follows‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúSystem Type‚Äù</strong></p>
<p><strong>For BL602:</strong> Check the box for <strong>‚ÄúBL602 Peripheral Support‚Äù</strong> ‚Üí <strong>‚ÄúSPI0‚Äù</strong></p>
<p><strong>For ESP32:</strong> Check the box for <strong>‚ÄúESP32 Peripheral Select‚Äù</strong> ‚Üí <strong>‚ÄúSPI 2‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/spi2-debug.jpg" alt="Enable SPI" /></p>
</li>
<li>
<p>At the Top Menu, select <strong>‚ÄúDevice Drivers‚Äù</strong></p>
<p>Select <strong>‚ÄúSPI Driver‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúSPI Character Driver‚Äù</strong></p>
<p>(<strong>‚ÄúSPI Exchange‚Äù</strong> should already be checked, see pic above)</p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> to return to ‚ÄúDevice Drivers‚Äù</p>
</li>
<li>
<p>Under ‚ÄúDevice Drivers‚Äù, check the box for <strong>‚ÄúRF Device Support‚Äù</strong></p>
<p>Go inside <strong>‚ÄúRF Device Support‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúSPI Test Driver‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver6.png" alt="Select SPI Test Driver" /></p>
</li>
</ol>
<h2 id="enable-logging"><a class="doc-anchor" href="#enable-logging">¬ß</a>13.3 Enable Logging</h2>
<p>Next we enable SPI logging for easier troubleshooting‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúBuild Setup‚Äù</strong> ‚Üí <strong>‚ÄúDebug Options‚Äù</strong></p>
</li>
<li>
<p>Check the boxes for the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable Debug Features
Enable Error Output
Enable Warnings Output
Enable Informational Debug Output
Enable Debug Assertions
GPIO Debug Features
GPIO Error Output
GPIO Warnings Output
GPIO Informational Output
SPI Debug Features
SPI Error Output
SPI Warnings Output
SPI Informational Output</code></pre></div>
<p><strong>For LoRaWAN:</strong> Uncheck the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable Informational Debug Output
GPIO Informational Output
SPI Informational Output</code></pre></div></li>
<li>
<p>Hit <strong>‚ÄúSave‚Äù</strong> then <strong>‚ÄúOK‚Äù</strong> to save the NuttX Configuration to <strong>‚Äú.config‚Äù</strong></p>
<p><a href="https://gist.github.com/lupyuen/93b553fdfcfa0221ccd6276706e72caf">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until <strong>menuconfig</strong> quits</p>
<p><img src="https://lupyuen.github.io/images/spi2-driver4.png" alt="Enable logging" /></p>
</li>
</ol>
<h2 id="register-device-driver"><a class="doc-anchor" href="#register-device-driver">¬ß</a>13.4 Register Device Driver</h2>
<p>During NuttX startup, we need to register our Device Driver like so‚Ä¶</p>
<ol>
<li>
<p>Browse to the <strong>Board Folder</strong>‚Ä¶</p>
<p><strong>For BL602:</strong> <a href="https://github.com/lupyuen/nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src"><strong>nuttx/nuttx/boards/ risc-v/bl602/bl602evb</strong></a></p>
<p><strong>For ESP32:</strong> <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src"><strong>nuttx/nuttx/boards/ xtensa/esp32/esp32-devkitc</strong></a></p>
<p>(Change ‚Äúesp32-devkitc‚Äù to our ESP32 board)</p>
</li>
<li>
<p>Edit the <strong>Bringup Code</strong>‚Ä¶</p>
<p><strong>For BL602:</strong> <a href="https://github.com/lupyuen/nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617"><strong>bl602_bringup.c</strong></a></p>
<p><strong>For ESP32:</strong> <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup.c</strong></a></p>
</li>
<li>
<p>Edit the function <strong>bl602_bringup()</strong> to register our Device Driver as <strong>‚Äú/dev/spitest0‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Insert this code after the #include block */

#ifdef CONFIG_RF_SPI_TEST_DRIVER
#include &lt;nuttx/rf/spi_test_driver.h&gt;
#endif /* CONFIG_RF_SPI_TEST_DRIVER */

/* End of inserted code */

...

int bl602_bringup(void)
{
  /* Omitted: Existing code in the function */

  /* Insert this code just before the &quot;return&quot; statement */

#ifdef CONFIG_RF_SPI_TEST_DRIVER

  /* Init SPI bus again */

  struct spi_dev_s *spitest = bl602_spibus_initialize(0);
  if (!spitest)
    {
      _err(&quot;ERROR: Failed to initialize SPI %d bus\n&quot;, 0);
    }

  /* Register the SPI Test Driver */

  ret = spi_test_driver_register(&quot;/dev/spitest0&quot;, spitest, 0);
  if (ret &lt; 0)
    {
      _err(&quot;ERROR: Failed to register SPI Test Driver\n&quot;);
    }

#endif /* CONFIG_RF_SPI_TEST_DRIVER */

  /* End of inserted code */

  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617">(Source)</a></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/4cae36747314bacb49ff0bba3632fbb8136f3f66#diff-387529ed7b85b38e4e96d58de6cab8a83e706c26c97e9fc71db5ea5ff20be297">(See the changes)</a></p>
<p><strong>For ESP32:</strong> Edit the function <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup()</strong></a> and insert the code above. Change <strong>‚Äúbl602_spibus_initialize(0)‚Äù</strong> to <strong>‚Äúesp32_spibus_initialize(2)‚Äù</strong>. <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/common/src/esp32_board_spidev.c#L47-L72">(Like this)</a></p>
<p><a href="https://twitter.com/4ever_freedom/status/1546857560623517699">(Thanks @4ever_freedom!)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver4.png" alt="Register our device driver at startup" /></p>
</li>
</ol>
<h2 id="verify-device-driver"><a class="doc-anchor" href="#verify-device-driver">¬ß</a>13.5 Verify Device Driver</h2>
<p>Finally we run the NuttX Firmware and check for our Device Driver‚Ä¶</p>
<ol>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32.</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>Our Device Driver appears as <strong>‚Äú/dev/spitest0‚Äù</strong>.</p>
<p>Congratulations our Device Driver is now running on NuttX!</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver10.png" alt="Our Device Driver appears as ‚Äú/dev/spitest0‚Äù" /></p>
</li>
<li>
<p>Look what happens if we forget to enable ‚ÄúSPI0‚Äù (BL602) or ‚ÄúSPI 2‚Äù (ESP32) and NuttX won‚Äôt start‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-crash2.jpg" alt="NuttX fails to start if we don‚Äôt enable SPI" /></p>
<p><a href="https://gist.github.com/lupyuen/ccfd90125f9a180b4cfb459e8a57b323">(Source)</a></p>
</li>
</ol>
<p><em>Why did we choose the ‚Äúdat-31r5-sp‚Äù driver for cloning?</em></p>
<p>We scanned the NuttX SPI Device Drivers (‚Äúgrep‚Äù and ‚Äúwc‚Äù) and picked <strong>‚Äúdat-31r5-sp‚Äù</strong> because‚Ä¶</p>
<ol>
<li>
<p>The driver code is <strong>simple</strong></p>
<p>(No dependencies on other modules)</p>
</li>
<li>
<p>It has the <strong>fewest lines of code</strong></p>
<p>(Easier to customise)</p>
</li>
<li>
<p>It‚Äôs the <strong>only driver</strong> in the RF Category</p>
<p>(Quick to modify the Makefile and Kconfig)</p>
</li>
</ol>
<p>Remember to move our driver to the correct category before releasing it!</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface7.png" alt="dat-31r5-sp is the simplest smallest SPI Device Driver" /></p>
<p><a href="https://docs.google.com/spreadsheets/d/1MDps5cPe7tIgCL1Cz98iVccJAUJq1lgctpKgg9OwztI/edit#gid=0">(Source)</a></p>
<h1 id="appendix-create-a-nuttx-app"><a class="doc-anchor" href="#appendix-create-a-nuttx-app">¬ß</a>14 Appendix: Create a NuttX App</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>This section explains the steps to create a <strong>NuttX App</strong> named <strong>‚Äúspi_test‚Äù</strong>.</p>
<p>(Change ‚Äúspi_test‚Äù to the desired name of our app)</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx-apps/tree/newapp/examples"><strong>‚Äúnuttx/apps/examples‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the <strong>‚Äúhello‚Äù</strong> subfolder and paste it as <strong>‚Äúspi_test‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp.jpg" alt="Copy the ‚Äúhello‚Äù subfolder and paste it as ‚Äúspi_test‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/commit/9af4ad6cab225d333ce0dae98c65a2a48621b3b4">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test‚Äù</strong> folder, rename <strong>‚Äúhello_main.c‚Äù</strong> to <strong>‚Äúspi_test_main.c‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp2.png" alt="Rename ‚Äúhello_main.c‚Äù to ‚Äúspi_test_main.c‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/commit/a4f884c67dc4c1042831d0554aed1d55a0e28b40">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test‚Äù</strong> folder, search and replace all <strong>‚Äúhello‚Äù</strong> by <strong>‚Äúspi_test‚Äù</strong></p>
<p>Be sure to <strong>Preserve Case!</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp3.png" alt="Change all ‚Äúhello‚Äù to ‚Äúspi_test‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/commit/0e19613b3059882f002eee948c0a79f622eccb74">(Source)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/tree/newapp/examples/spi_test">(See ‚Äúspi_test‚Äù folder)</a></p>
</li>
<li>
<p>Enter the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the path of our &quot;nuttx&quot; folder
cd nuttx/nuttx

## Preserve the Build Config
cp .config ../config

## Erase the Build Config
make distclean

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Restore the Build Config
cp ../config .config

## Edit the Build Config
make menuconfig </code></pre></div>
<p><img src="https://lupyuen.github.io/images/spi2-newapp4.jpg" alt="Select ‚Äúspi_test‚Äù in menuconfig" /></p>
</li>
</ol>
<h2 id="enable-app"><a class="doc-anchor" href="#enable-app">¬ß</a>14.1 Enable App</h2>
<p>Next we enable our app (pic above)‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong></p>
</li>
<li>
<p>Check the box for <strong>‚Äúspi_test‚Äù</strong></p>
</li>
<li>
<p>Hit <strong>‚ÄúSave‚Äù</strong> then <strong>‚ÄúOK‚Äù</strong> to save the NuttX Configuration to <strong>‚Äú.config‚Äù</strong></p>
<p><a href="https://gist.github.com/lupyuen/93b553fdfcfa0221ccd6276706e72caf">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until <strong>menuconfig</strong> quits</p>
</li>
</ol>
<h2 id="run-the-app"><a class="doc-anchor" href="#run-the-app">¬ß</a>14.2 Run the App</h2>
<p>Finally we run the NuttX Firmware and start our app‚Ä¶</p>
<ol>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32.</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>spi_test</code></pre></div></li>
<li>
<p>We should see the output below.</p>
<p>Congratulations we have created the <strong>‚Äúspi_test‚Äù</strong> app!</p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp5.png" alt="‚Äúspi_test‚Äù running on BL602" /></p>
</li>
</ol>
<h1 id="appendix-build-flash-and-run-nuttx"><a class="doc-anchor" href="#appendix-build-flash-and-run-nuttx">¬ß</a>15 Appendix: Build, Flash and Run NuttX</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="build-nuttx"><a class="doc-anchor" href="#build-nuttx">¬ß</a>15.1 Build NuttX</h2>
<p>Follow these steps to build NuttX for BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
</li>
<li>
<p>Build NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746">(See the complete log for BL602)</a></p>
</li>
<li>
<p><strong>For WSL:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>c:\blflash</strong> directory in the Windows File System‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  /mnt/c/blflash refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx"><a class="doc-anchor" href="#flash-nuttx">¬ß</a>15.2 Flash NuttX</h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux: Change &quot;/dev/ttyUSB0&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change &quot;/dev/tty.usbserial-1410&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change &quot;COM5&quot; to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx"><a class="doc-anchor" href="#run-nuttx">¬ß</a>15.3 Run NuttX</h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p><strong>macOS Tip:</strong> Here‚Äôs the script I use to build, flash and run NuttX on macOS, all in a single step: <a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">run.sh</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="Script to build, flash and run NuttX on macOS" /></p>
<p><a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">(Source)</a></p>
<h1 id="appendix-nuttx-spi-interface"><a class="doc-anchor" href="#appendix-nuttx-spi-interface">¬ß</a>16 Appendix: NuttX SPI Interface</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>In this section we dig deep into NuttX OS to understand how the <strong>SPI Functions</strong> work.</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface.png" alt="NuttX SPI Interface" /></p>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/spi/spi.h">(Source)</a></p>
<p>The <strong>NuttX SPI Interface</strong> (pic above) is defined as C Macros in <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/spi/spi.h">include/nuttx/spi/spi.h</a></p>
<ul>
<li>
<p><strong>SPI_LOCK</strong>: Lock the SPI Bus for exclusive access</p>
</li>
<li>
<p><strong>SPI_SELECT</strong>: Enable / disable the SPI Chip Select</p>
</li>
<li>
<p><strong>SPI_SETFREQUENCY</strong>: Set the SPI frequency</p>
</li>
<li>
<p><strong>SPI_SETDELAY</strong>: Set the SPI Delays in nanoseconds</p>
</li>
<li>
<p><strong>SPI_SETMODE</strong>: Set the SPI Mode</p>
</li>
<li>
<p><strong>SPI_SETBITS</strong>: Set the number of bits per word (Transfer size)</p>
</li>
<li>
<p><strong>SPI_HWFEATURES</strong>: Set hardware-specific feature flags</p>
</li>
<li>
<p><strong>SPI_STATUS</strong>: Get SPI/MMC status</p>
</li>
<li>
<p><strong>SPI_CMDDATA</strong>: Transfer 9-bit data (like for ST7789 Display)</p>
</li>
<li>
<p><strong>SPI_SEND</strong>: Exchange one word on SPI</p>
</li>
<li>
<p><strong>SPI_SNDBLOCK</strong>: Send a block of data on SPI</p>
</li>
<li>
<p><strong>SPI_RECVBLOCK</strong>: Receive a block of data from SPI</p>
</li>
<li>
<p><strong>SPI_EXCHANGE</strong>: Exchange a block of data from SPI</p>
</li>
<li>
<p><strong>SPI_REGISTERCALLBACK</strong>: Register a callback for media status change</p>
</li>
<li>
<p><strong>SPI_TRIGGER</strong>: Trigger a previously configured DMA transfer</p>
</li>
</ul>
<p><a href="https://nuttx.apache.org/docs/latest/components/drivers/special/spi.html">(More about NuttX SPI)</a></p>
<h2 id="spi-device"><a class="doc-anchor" href="#spi-device">¬ß</a>16.1 SPI Device</h2>
<p>The above SPI Interface is meant to be called by <strong>NuttX Device Drivers</strong> like so: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L168-L208">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Write the buffer to the SPI device */

static ssize_t spi_test_driver_write(
  FAR struct file *filep,
  FAR const char *buffer,
  size_t buflen)
{
  /* Get the SPI interface */

  FAR struct inode *inode = filep-&gt;f_inode;
  FAR struct spi_test_driver_dev_s *priv = inode-&gt;i_private;

  /* Omitted: Lock, configure and select the SPI interface */

  /* Transfer data to SPI interface */

  SPI_EXCHANGE(priv-&gt;spi, buffer, recv_buffer, buflen);</code></pre></div>
<p><strong>SPI_EXCHANGE</strong> is defined in the SPI Interface as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define SPI_EXCHANGE(d,t,r,l) \
  ((d)-&gt;ops-&gt;exchange(d,t,r,l))</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/include/nuttx/spi/spi.h#L372-L395">(Source)</a></p>
<p>Which maps to <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L932-L967"><strong>bl602_spi_exchange</strong></a> for BL602‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_spi_exchange(
  struct spi_dev_s *dev,
  const void *txbuffer, 
  void *rxbuffer,
  size_t nwords) {
  ...</code></pre></div>
<p>(Or <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/xtensa/src/esp32/esp32_spi.c#L1132-L1174"><strong>esp32_spi_exchange</strong></a> for ESP32)</p>
<p>Note that the SPI Interface requires an <strong>SPI Device</strong> (spi_dev_s) to be passed in.</p>
<p>Which is available to NuttX Device Drivers.</p>
<p><em>Can a NuttX App call the SPI Interface directly like this?</em></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface2.png" alt="Can a NuttX App call the SPI Interface like this?" /></p>
<p>Nope this won‚Äôt work, because NuttX Apps <strong>can‚Äôt access the SPI Device</strong> (spi_dev_s).</p>
<p>Let‚Äôs dig into NuttX OS and find out why.</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface3.png" alt="SPI Interface needs an SPI Device (spi_dev_s)" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c#L932-L967">(Source)</a></p>
<h2 id="file-descriptor"><a class="doc-anchor" href="#file-descriptor">¬ß</a>16.2 File Descriptor</h2>
<p>In a NuttX App we may open the SPI Port <strong>‚Äú/dev/spi0‚Äù</strong> to get a <strong>File Descriptor</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int fd = open(&quot;/dev/spi0&quot;, O_RDWR);</code></pre></div>
<p><em>How is the File Descriptor linked to the SPI Device (spi_dev_s)?</em></p>
<p>Well we use the File Descriptor to execute <strong>File Operations</strong>: read(), write(), ioctl(), ‚Ä¶</p>
<p>Tracing through the NuttX <strong>Virtual File System</strong>, we see that ioctl() maps the File Descriptor to a <strong>File Struct</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface4.png" alt="ioctl() maps a File Descriptor to a File Struct" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/fs/vfs/fs_ioctl.c#L118-L138">(Source)</a></p>
<h2 id="file-struct"><a class="doc-anchor" href="#file-struct">¬ß</a>16.3 File Struct</h2>
<p>The <strong>File Struct</strong> contains a Private Pointer to the <strong>SPI Driver</strong> (spi_driver_s)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface5.png" alt="File Struct contains a Private Pointer to the SPI Driver (spi_driver_s)" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/drivers/spi/spi_driver.c#L112-L147">(Source)</a></p>
<h2 id="spi-driver"><a class="doc-anchor" href="#spi-driver">¬ß</a>16.4 SPI Driver</h2>
<p>The <strong>SPI Driver</strong> (spi_driver_s) contains the <strong>SPI Device</strong> (spi_dev_s)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface6.png" alt="SPI Driver (spi_driver_s) contains the SPI Device (spi_dev_s)" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/drivers/spi/spi_driver.c#L55-L65">(Source)</a></p>
<p>Which is what we need for calling the <strong>SPI Interface</strong>!</p>
<p>But sadly the SPI Device is <strong>private to NuttX OS</strong> and we can‚Äôt access it from the NuttX App.</p>
<p>That‚Äôs why we wrote our own <strong>SPI Test Driver</strong> (which runs inside NuttX OS) to get access to the SPI Device and call the SPI Interface.</p>
<p>(By calling the SPI Test Driver from our <strong>SPI Test App</strong>)</p>
<p>In summary, NuttX maps a <strong>File Descriptor</strong> to <strong>SPI Device</strong> as follows‚Ä¶</p>
<p>File Descriptor ‚Üí File Struct ‚Üí SPI Driver (spi_driver_s) ‚Üí SPI Device (spi_dev_s)</p>
<h1 id="appendix-miso-and-mosi-are-swapped"><a class="doc-anchor" href="#appendix-miso-and-mosi-are-swapped">¬ß</a>17 Appendix: MISO And MOSI Are Swapped</h1>
<p><em>(For BL602 only)</em></p>
<p>BL602 has an SPI issue that affects both NuttX and BL602 IoT SDK: <strong>MISO and MOSI pins are swapped</strong>, contrary to the Pin Descriptions in the BL602 Reference Manual.</p>
<p>In this section we‚Ä¶</p>
<ol>
<li>
<p>Reproduce the issue on NuttX</p>
</li>
<li>
<p>Propose a fix for NuttX</p>
</li>
<li>
<p>Test the fix</p>
</li>
</ol>
<p>The fix has been merged into NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/pull/4984"><strong>‚Äúriscv/bl602: Swap SPI MISO and MOSI‚Äù</strong></a></li>
</ul>
<p>(Thank you NuttX Maintainers! üôÇ )</p>
<p>Note that the <strong>SPI Mode needs to be 1</strong> (instead of 0) for the SPI interface to operate correctly‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-spi-mode-quirk"><strong>‚ÄúSPI Mode Quirk‚Äù</strong></a></li>
</ul>
<h2 id="reproduce-the-issue"><a class="doc-anchor" href="#reproduce-the-issue">¬ß</a>17.1 Reproduce the issue</h2>
<p>The default SPI Pins for NuttX are defined in <a href="https://github.com/apache/nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L78-L83">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* SPI Configuration */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN2)
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN1)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN3)</code></pre></div>
<p>This says that <strong>MISO</strong> is GPIO 0, <strong>MOSI</strong> is GPIO 1.</p>
<p>This is consistent with the <strong>Pin Description Table</strong> from <a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en"><strong>BL602 Reference Manual</strong></a> (Version 1.2, 17 Dec 2020, page 26)</p>
<p><img src="https://lupyuen.github.io/images/spi2-driver6.png" alt="Pin Description from BL602 Reference Manual" /></p>
<p>We test the SPI Port with an <strong>SPI Test Driver</strong>: <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L168-L208">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Write the buffer to the SPI device */

static ssize_t spi_test_driver_write(
  FAR struct file *filep,
  FAR const char *buffer,
  size_t buflen)
{
  ...
  /* Transmit buffer to SPI device and receive the response */

  SPI_EXCHANGE(priv-&gt;spi, buffer, recv_buffer, buflen);
  recv_buffer_len = buflen;</code></pre></div>
<p>Which is called by an <strong>SPI Test App</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test/spi_test_main.c">spi_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int main(int argc, FAR char *argv[])
{
  /* Open SPI Test Driver */

  int fd = open(&quot;/dev/spitest0&quot;, O_RDWR);
  assert(fd &gt;= 0);

  /* Write to SPI Test Driver */

  static char data[] = &quot;Hello World&quot;;
  int bytes_written = write(fd, data, sizeof(data));
  assert(bytes_written == sizeof(data));</code></pre></div>
<p>We connect a <strong>Logic Analyser</strong> to PineCone BL602 and verify the SPI output‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Logic Analyser</th><th style="text-align: center">BL602 Pin</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>MOSI</strong></td><td style="text-align: center">GPIO 1</td></tr>
<tr><td style="text-align: center"><strong>MISO</strong></td><td style="text-align: center">GPIO 0</td></tr>
<tr><td style="text-align: center"><strong>SCK</strong></td><td style="text-align: center">GPIO 3</td></tr>
<tr><td style="text-align: center"><strong>CS</strong></td><td style="text-align: center">GPIO 2</td></tr>
<tr><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/spi2-logic4.jpg" alt="Logic Analyser connected to PineCone BL602" /></p>
<p>Logic Analyser shows that <strong>MISO and MOSI are swapped</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-logic.png" alt="Logic Analyser shows that MISO and MOSI are swapped" /></p>
<p>Let‚Äôs examine the proposed fix for the issue.</p>
<h2 id="fix-the-issue"><a class="doc-anchor" href="#fix-the-issue">¬ß</a>17.2 Fix the issue</h2>
<p>The same issue happens in <strong>BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi#spi-data-pins-are-flipped"><strong>‚ÄúSPI Data Pins Are Flipped‚Äù</strong></a></li>
</ul>
<p>On BL602 IoT SDK we fix this issue by calling <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_glb.c#L1281-L1298"><strong>GLB_Swap_SPI_0_MOSI_With_MISO()</strong></a> to swap the MISO and MOSI pins‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************//**
 * @brief  swap SPI0 MOSI with MISO
 *
 * @param  newState: ENABLE or DISABLE
 *
 * @return SUCCESS or ERROR
 *
*******************************************************************************/
BL_Err_Type GLB_Swap_SPI_0_MOSI_With_MISO(BL_Fun_Type newState)
{
    uint32_t tmpVal = 0;

    tmpVal=BL_RD_REG(GLB_BASE,GLB_PARM);
    tmpVal=BL_SET_REG_BITS_VAL(tmpVal,GLB_REG_SPI_0_SWAP,newState);
    BL_WR_REG(GLB_BASE,GLB_PARM,tmpVal);

    return SUCCESS;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_glb.c#L1281-L1298">(Source)</a></p>
<p>This function swaps MISO and MOSI by setting the GLB Hardware Register <strong>GLB_PARM</strong> at bit <strong>GLB_REG_SPI_0_SWAP</strong>.</p>
<p>For NuttX we propose to port this function as <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L1080-L1104"><strong>bl602_swap_spi_0_mosi_with_miso()</strong></a> in <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L1080-L1104">arch/risc-v/src/bl602/bl602_spi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: bl602_swap_spi_0_mosi_with_miso
 *
 * Description:
 *   Swap SPI0 MOSI with MISO
 *
 * Input Parameters:
 *   swap      - Non-zero to swap MOSI and MISO
 *
 * Returned Value:
 *   None
 *
 ****************************************************************************/

static void bl602_swap_spi_0_mosi_with_miso(uint8_t swap)
{
  if (swap)
    {
      modifyreg32(BL602_GLB_GLB_PARM, 0, GLB_PARM_REG_SPI_0_SWAP);
    }
  else
    {
      modifyreg32(BL602_GLB_GLB_PARM, GLB_PARM_REG_SPI_0_SWAP, 0);
    }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L1080-L1104">(Source)</a></p>
<p>The function above will be called by <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L1106-L1141"><strong>bl602_spi_init()</strong></a> in <a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L1106-L1141">arch/risc-v/src/bl602/bl602_spi.c</a> to swap MISO and MOSI during startup‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: bl602_spi_init
 *
 * Description:
 *   Initialize bl602 SPI hardware interface
 *
 * Input Parameters:
 *   dev      - Device-specific state data
 *
 * Returned Value:
 *   None
 *
 ****************************************************************************/

static void bl602_spi_init(struct spi_dev_s *dev)
{
  struct bl602_spi_priv_s *priv = (struct bl602_spi_priv_s *)dev;
  const struct bl602_spi_config_s *config = priv-&gt;config;

  /* Initialize the SPI semaphore that enforces mutually exclusive access */

  nxsem_init(&amp;priv-&gt;exclsem, 0, 1);

  bl602_configgpio(BOARD_SPI_CS);
  bl602_configgpio(BOARD_SPI_MOSI);
  bl602_configgpio(BOARD_SPI_MISO);
  bl602_configgpio(BOARD_SPI_CLK);

  /* set master mode */

  bl602_set_spi_0_act_mode_sel(1);

  /* swap MOSI with MISO to be consistent with BL602 Reference Manual */

  bl602_swap_spi_0_mosi_with_miso(1);</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/arch/risc-v/src/bl602/bl602_spi.c#L1106-L1141">(Source)</a></p>
<h2 id="test-the-fix"><a class="doc-anchor" href="#test-the-fix">¬ß</a>17.3 Test the fix</h2>
<p>After applying the fix, we see that the <strong>MOSI output is now correct</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-logic2.png" alt="Logic Analyser after applying the fix" /></p>
<p>As for <strong>MISO input</strong>, we tested with PineCone BL602 connected to <strong>Semtech SX1262</strong>.  We verified that the register data was read correctly over SPI‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#test-with-semtech-sx1262"><strong>‚ÄúTest with Semtech SX1262‚Äù</strong></a></li>
</ul>
<p>We have also tested the fix with <strong>PineDio Stack BL604</strong> and its onboard SX1262‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#test-with-pinedio-stack"><strong>‚ÄúTest with PineDio Stack‚Äù</strong></a></li>
</ul>
<p>The fix has been merged into NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/pull/4984"><strong>‚Äúriscv/bl602: Swap SPI MISO and MOSI‚Äù</strong></a></li>
</ul>
<p>(Thank you NuttX Maintainers! üôÇ )</p>
<p>Note that the <strong>SPI Mode needs to be 1</strong> (instead of 0) for our test to succeed‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-spi-mode-quirk"><strong>‚ÄúSPI Mode Quirk‚Äù</strong></a></li>
</ul>
<h1 id="appendix-spi-mode-quirk"><a class="doc-anchor" href="#appendix-spi-mode-quirk">¬ß</a>18 Appendix: SPI Mode Quirk</h1>
<p><em>(For BL602 only)</em></p>
<p>Due to an <strong>SPI Mode Quirk</strong> in BL602, we configure BL602 to talk to Semtech SX1262 with <strong>SPI Mode 1</strong> (instead of Mode 0).</p>
<p>(Which is quirky because SX1262 supports Mode 0, not Mode 1)</p>
<p>This is defined in <a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L45-L57">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* For BL602 we use SPI Mode 1 instead of Mode 0 due to SPI quirk */

#ifdef CONFIG_BL602_SPI0
#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE1) /* SPI Mode 1: Workaround for BL602 */
#else
#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE0) /* SPI Mode 0: CPOL=0,CPHA=0 */
#endif /* CONFIG_BL602_SPI0 */</code></pre></div>
<p>Let‚Äôs watch what happens if we use <strong>SPI Mode 0</strong> (instead of Mode 1) when BL602 talks to Semtech SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE0) /* SPI Mode 0: CPOL=0,CPHA=0 */</code></pre></div>
<p>We run <a href="https://github.com/lupyuen/nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L94-L117">spi_test2_main.c</a> to <strong>Read Register <code>0x08</code></strong> from SX1262 over SPI‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Read Register 8 */

static char read_reg[] = { 0x1d, 0x00, 0x08, 0x00, 0x00 };
bytes_written = write(fd, read_reg, sizeof(read_reg));
assert(bytes_written == sizeof(read_reg));

/* Read response from SX1262 */

bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(read_reg));

/* Show the received register value */

printf(&quot;\nSX1262 Register 8 is 0x%02x\n&quot;, rx_data[4]);</code></pre></div>
<p>We expect the value of Register <code>0x08</code> to be <strong>0x80</strong>.</p>
<p>With SPI Mode 0, the register value received over SPI is <strong>incorrect</strong> (<code>0x5A</code>)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Read Register 8: received
  a8 a8 00 43 5a
SX1262 Register 8 is 0x5a</code></pre></div>
<p><img src="https://lupyuen.github.io/images/spi2-sx2.png" alt="SPI Mode 0: Register 8 is incorrect" /></p>
<p>When we switch to SPI Mode 1, we get the correct value: <strong>0x80</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Read Register 8: received
  a8 a8 a8 a8 80
SX1262 Register 8 is 0x80</code></pre></div>
<p><img src="https://lupyuen.github.io/images/spi2-sx.png" alt="SPI Mode 1: Register 8 is correct" /></p>
<p>This SPI Mode Quirk has been observed on <strong>BL602 IoT SDK</strong> when tested with‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/spi#spi-phase-looks-sus"><strong>BME280 Sensor</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-spi-functions"><strong>SX1262 LoRa Transceiver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#spi"><strong>SX1276 LoRa Transceiver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/display#initialise-spi-port"><strong>ST7789 Display Controller</strong></a> (SPI Mode 3)</p>
</li>
</ul>
<p>This is why we always use SPI Mode 1 instead of Mode 0 on BL602.</p>
<p><strong>UPDATE:</strong> BL602 talks to SPI Devices in SPI Mode 1 or Mode 3, depending on whether the MISO / MOSI Pins are swapped. <a href="https://lupyuen.github.io/articles/pinedio2#st7789-spi-mode">(See this)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx7.png" alt="Using SPI Mode 1 instead of Mode 0 on BL602" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L51-L57">(Source)</a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>