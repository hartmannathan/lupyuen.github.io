<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Display Driver in Zig</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Display Driver in Zig" 
    data-rh="true">
<meta property="og:description" 
    content="Let's build a PinePhone Display Driver in Zig... That will run on Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's build a PinePhone Display Driver in Zig... That will run on Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/dsi2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Display Driver in Zig</h1>
    <nav id="TOC"><ul>
<li><a href="#pinephone-lcd-display">1 PinePhone LCD Display</a><ul></ul></li>
<li><a href="#long-packet-for-mipi-dsi">2 Long Packet for MIPI DSI</a><ul></ul></li>
<li><a href="#compose-long-packet">3 Compose Long Packet</a><ul>
<li><a href="#packet-header">3.1 Packet Header</a><ul></ul></li>
<li><a href="#packet-payload">3.2 Packet Payload</a><ul></ul></li>
<li><a href="#packet-footer">3.3 Packet Footer</a><ul></ul></li>
<li><a href="#combine-header-payload-and-footer">3.4 Combine Header, Payload and Footer</a><ul></ul></li></ul></li>
<li><a href="#error-correction-code">4 Error Correction Code</a><ul></ul></li>
<li><a href="#compose-short-packet">5 Compose Short Packet</a><ul></ul></li>
<li><a href="#test-mipi-dsi-driver">6 Test MIPI DSI Driver</a><ul></ul></li>
<li><a href="#run-mipi-dsi-driver-on-qemu">7 Run MIPI DSI Driver on QEMU</a><ul></ul></li>
<li><a href="#initialise-st7703-lcd-controller">8 Initialise ST7703 LCD Controller</a><ul></ul></li>
<li><a href="#send-mipi-dsi-packet">9 Send MIPI DSI Packet</a><ul></ul></li>
<li><a href="#test-mipi-dsi-driver-on-pinephone">10 Test MIPI DSI Driver on PinePhone</a><ul></ul></li>
<li><a href="#render-graphics-on-pinephone-display">11 Render Graphics on PinePhone Display</a><ul></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">13 Notes</a><ul></ul></li>
<li><a href="#appendix-cyclic-redundancy-check">14 Appendix: Cyclic Redundancy Check</a><ul></ul></li></ul></nav><p>üìù <em>18 Oct 2022</em></p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Apache NuttX RTOS rendering something on PinePhone‚Äôs LCD Display" /></p>
<p><strong>UPDATE:</strong> Apache NuttX RTOS now supports MIPI DSI! <a href="https://lupyuen.github.io/articles/dsi3">(See this)</a></p>
<p>In our last article we talked about <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> (pic above) and its <a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>LCD Display</strong></a>, connected via the (super complicated) <a href="https://lupyuen.github.io/articles/dsi#connector-for-mipi-dsi"><strong>MIPI Display Serial Interface</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></li>
</ul>
<p>Today we shall create a <strong>PinePhone Display Driver in Zig</strong>‚Ä¶ That will run on our fresh new port of <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> for PinePhone.</p>
<p>If we‚Äôre not familiar with the <a href="https://ziglang.org/"><strong>Zig Programming Language</strong></a>: No worries! This article will explain the tricky Zig parts with C.</p>
<p><em>Why build the Display Driver in Zig? Instead of C?</em></p>
<p>Sadly some parts of PinePhone‚Äôs <a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>ST7703 LCD Controller</strong></a> and <a href="https://lupyuen.github.io/articles/dsi#initialise-mipi-dsi"><strong>Allwinner A64 SoC</strong></a> are poorly documented. (Sigh)</p>
<p>Thus we‚Äôre building a <strong>Quick Prototype</strong> in Zig to be sure we‚Äôre setting the Hardware Registers correctly.</p>
<p>And while rushing through the reckless coding, it‚Äôs great to have Zig cover our backs and catch <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Common Runtime Problems</strong></a>.</p>
<p>Like Null Pointers, Underflow, Overflow, Array Out Of Bounds, ‚Ä¶</p>
<p><em>Will our final driver be in Zig or C?</em></p>
<p>Maybe Zig, maybe C?</p>
<p>It‚Äôs awfully nice to use Zig to simplify the complicated driver code. Zig‚Äôs <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Runtime Safety Checks</strong></a> are extremely helpful too.</p>
<p>But this driver goes into the <strong>NuttX RTOS Kernel</strong>. So most folks would expect the final driver to be delivered in C?</p>
<p>In any case, Zig and C look highly similar. Converting the Zig Driver to C should be straightforward.</p>
<p>(Minus the Runtime Safety Checks)</p>
<p>Zig or C? Lemme know what you think! üôè</p>
<p>Let‚Äôs continue the journey from our <strong>NuttX Porting Journal</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/dsi-title.jpg" alt="LCD Display on PinePhone Schematic (Page 2)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>LCD Display on PinePhone Schematic (Page 2)</em></a></p>
<h1 id="pinephone-lcd-display"><a href="#pinephone-lcd-display">1 PinePhone LCD Display</a></h1>
<p><em>How is the LCD Display connected inside PinePhone?</em></p>
<p>Inside PinePhone is a <strong>XBD599 LCD Panel</strong> by Xingbangda (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>‚ÄúXingbangda XBD599 LCD Panel‚Äù</strong></a></li>
</ul>
<p>The LCD Display is connected to the <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> via a <strong>MIPI Display Serial Interface (DSI)</strong>.</p>
<p><a href="https://en.wikipedia.org/wiki/MIPI_Alliance">(MIPI is the <strong>Mobile Industry Processor Interface Alliance</strong>)</a></p>
<p><em>What‚Äôs a MIPI Display Serial Interface?</em></p>
<p>Think of it as SPI, but supercharged with <strong>Multiple Data Lanes</strong>!</p>
<p>PinePhone‚Äôs MIPI Display Serial Interface runs on <strong>4 Data Lanes</strong> that will transmit 4 streams of pixel data concurrently.</p>
<p><a href="https://en.wikipedia.org/wiki/Display_Serial_Interface">(More about Display Serial Interface)</a></p>
<p><em>How do we control PinePhone‚Äôs LCD Display?</em></p>
<p>The XBD599 LCD Panel has a <strong>Sitronix ST7703 LCD Controller</strong> inside‚Ä¶</p>
<ul>
<li><a href="https://files.pine64.org/doc/datasheet/pinephone/ST7703_DS_v01_20160128.pdf"><strong>Sitronix ST7703 LCD Controller Datasheet</strong></a></li>
</ul>
<p>Which means our PinePhone Display Driver shall <strong>send commands to the ST7703 LCD Controller</strong> over the MIPI Display Serial Interface.</p>
<p><em>What commands will our Display Driver send to ST7703?</em></p>
<p>At startup, our driver shall send these 20 <strong>Initialisation Commands</strong> to the ST7703 LCD Controller‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-initialise-lcd-controller"><strong>‚ÄúInitialise LCD Controller‚Äù</strong></a></li>
</ul>
<p>ST7703 Commands can be a single byte, like for <strong>‚ÄúDisplay On‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>29</code></pre></div>
<p>Or a few bytes, like for <strong>‚ÄúEnable User Command‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>B9 F1 12 83</code></pre></div>
<p>And up to <strong>64 bytes</strong> (for ‚ÄúSet Forward GIP Timing‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>E9 82 10 06 05 A2 0A A5 
12 31 23 37 83 04 BC 27 
38 0C 00 03 00 00 00 0C 
00 03 00 00 00 75 75 31 
88 88 88 88 88 88 13 88 
64 64 20 88 88 88 88 88 
88 02 88 00 00 00 00 00 
00 00 00 00 00 00 00 00 </code></pre></div>
<p>We‚Äôll send these 20 commands to ST7703 in a specific packet format‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi-packet.png" alt="MIPI DSI Long Packet (Page 203)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Long Packet (Page 203)</em></a></p>
<h1 id="long-packet-for-mipi-dsi"><a href="#long-packet-for-mipi-dsi">2 Long Packet for MIPI DSI</a></h1>
<p>To send a command to the ST7703 LCD Controller, we‚Äôll transmit a <a href="https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi"><strong>MIPI DSI Long Packet</strong></a> in this format (pic above)‚Ä¶</p>
<p><strong>Packet Header</strong> (4 bytes):</p>
<ul>
<li>
<p><strong>Data Identifier (DI)</strong> (1 byte):</p>
<p>Virtual Channel Identifier (Bits 6 to 7)</p>
<p>Data Type (Bits 0 to 5)</p>
</li>
<li>
<p><strong>Word Count (WC)</strong> (2 bytes)Ôºö</p>
<p>Number of bytes in the Packet Payload</p>
</li>
<li>
<p><strong>Error Correction Code (ECC)</strong> (1 byte):</p>
<p>Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header</p>
</li>
</ul>
<p><strong>Packet Payload:</strong></p>
<ul>
<li>
<p><strong>Data</strong> (0 to 65,541 bytes):</p>
<p>Number of data bytes should match the Word Count (WC)</p>
</li>
</ul>
<p><strong>Packet Footer:</strong></p>
<ul>
<li>
<p><strong>Checksum (CS)</strong> (2 bytes):</p>
<p>16-bit Cyclic Redundancy Check (CCITT CRC)</p>
</li>
</ul>
<p>Let‚Äôs do this in Zig‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code1.png" alt="Compose Long Packet in Zig" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L111">(Source)</a></p>
<h1 id="compose-long-packet"><a href="#compose-long-packet">3 Compose Long Packet</a></h1>
<p>This is our <strong>Zig Function</strong> that composes a <strong>Long Packet</strong> for MIPI Display Serial Interface: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L111">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Long Packet.
// See https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi
fn composeLongPacket(
  pkt:     []u8,  // Buffer for the Returned Long Packet
  channel: u8,    // Virtual Channel ID
  cmd:     u8,    // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) []const u8 {  // Returns the Long Packet
  ...</code></pre></div>
<p>(<strong><code>u8</code></strong> in Zig is the same as <strong><code>uint8_t</code></strong> in C)</p>
<p>Our Zig Function <strong><code>composeLongPacket</code></strong> accepts the following parameters‚Ä¶</p>
<ul>
<li>
<p><strong><code>pkt</code></strong>: This is the buffer that we‚Äôll use to write the Long Packet and return it.</p>
<p>It‚Äôs declared as ‚Äú<strong><code>[]u8</code></strong>‚Äù which is a Slice of Bytes, roughly similar to ‚Äú<strong><code>uint8_t[]</code></strong>‚Äù in C.</p>
<p>(Except that the Buffer Size is also passed in the Slice)</p>
</li>
<li>
<p><strong><code>channel</code></strong>: MIPI Display Serial Interface supports multiple Virtual Channels, we‚Äôll stick to <strong>Virtual Channel 0</strong> for today</p>
</li>
<li>
<p><strong><code>cmd</code></strong>: Refers to the <a href="https://lupyuen.github.io/articles/dsi#display-command-set-for-mipi-dsi"><strong>Display Command Set (DCS)</strong></a> that we‚Äôll send over the MIPI Display Serial Interface.</p>
<p>For Long Packets, we‚Äôll send the <a href="https://lupyuen.github.io/articles/dsi#display-command-set-for-mipi-dsi"><strong>DCS Long Write Command</strong></a>. (Which has Data Type <code>0x39</code>)</p>
<p>(Later we‚Äôll see the DCS Short Write Command)</p>
</li>
<li>
<p><strong><code>buf</code></strong>: This is a C Pointer to the <strong>Transmit Buffer</strong> that will be packed inside the Long Packet. (As Packet Payload)</p>
<p>It‚Äôs declared as ‚Äú<strong><code>[*c]const u8</code></strong>‚Äù, which is the same as ‚Äú<strong><code>const uint8_t *</code></strong>‚Äù in C.</p>
<p>(‚Äú<strong><code>[*c]</code></strong>‚Äù means that Zig will handle it as a C Pointer)</p>
</li>
<li>
<p><strong><code>len</code></strong>: Number of bytes in the <strong>Transmit Buffer</strong></p>
</li>
</ul>
<p>Our Zig Function <strong><code>composeLongPacket</code></strong> returns a Slice of Bytes that will contain the Long Packet.</p>
<p>(Declared as ‚Äú<strong><code>[]const u8</code></strong>‚Äù. Yep the returned Slice will be a Sub-Slice of <strong><code>pkt</code></strong>)</p>
<p><em>Why do we mix Slices and Pointers in the Parameters?</em></p>
<p>The parameters <strong><code>buf</code></strong> and <strong><code>len</code></strong> could have been passed as a Byte Slice in Zig‚Ä¶</p>
<p>Instead we‚Äôre passing as an old-school <strong>C Pointer</strong> so that it‚Äôs compatible with the <strong>C Interface</strong> for our function‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// (Eventual) C Interface for our function
ssize_t mipi_dsi_dcs_write(
  const struct device *dev,  // MIPI DSI Device
  uint8_t     channel,  // Virtual Channel ID
  uint8_t     cmd,      // DCS Command
  const void *buf,      // Transmit Buffer
  size_t      len       // Buffer Length
);</code></pre></div>
<p>This C Interface is identical to the implementation of <strong>MIPI DSI in Zephyr OS</strong>. <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/include/zephyr/drivers/mipi_dsi.h#L325-L337">(See this)</a></p>
<p>Let‚Äôs compose the Packet Header‚Ä¶</p>
<h2 id="packet-header"><a href="#packet-header">3.1 Packet Header</a></h2>
<p>The <strong>Packet Header</strong> (4 bytes) of our Long Packet will contain‚Ä¶</p>
<ul>
<li>
<p><strong>Data Identifier (DI)</strong> (1 byte):</p>
<p>Virtual Channel Identifier (Bits 6 to 7)</p>
<p>Data Type (Bits 0 to 5)</p>
<p>(Data Type is the DCS Command)</p>
</li>
<li>
<p><strong>Word Count (WC)</strong> (2 bytes)Ôºö</p>
<p>Number of bytes in the Packet Payload</p>
</li>
<li>
<p><strong>Error Correction Code (ECC)</strong> (1 byte):</p>
<p>Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header</p>
</li>
</ul>
<p>This is how we compose the <strong>Packet Header</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L81">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  assert(channel &lt; 4);
  assert(cmd &lt; (1 &lt;&lt; 6));
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;</code></pre></div>
<p>First we populate the <strong>Data Indentifier (DI)</strong> with the Virtual Channel and DCS Command.</p>
<p>Then we convert the 16-bit <strong>Word Count (WC)</strong> to bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Word Count (WC) (2 bytes)Ôºö
  // Number of bytes in the Packet Payload
  const wc: u16 = @intCast(u16, len);
  const wcl: u8 = @intCast(u8, wc &amp; 0xff);
  const wch: u8 = @intCast(u8, wc &gt;&gt; 8);</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/#intCast"><strong><code>@intCast</code></strong></a> will halt with a Runtime Panic if <strong><code>len</code></strong> is too big to be converted into a 16-bit unsigned integer <strong><code>u16</code></strong>)</p>
<p>Next comes the <strong>Error Correction Code (ECC)</strong>. Which we compute based on the Data Identifier and Word Count‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier + Word Count (3 bytes): 
  // For computing Error Correction Code (ECC)
  const di_wc = [3]u8 { di, wcl, wch };

  // Compute Error Correction Code (ECC) for
  // Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_wc);</code></pre></div>
<p>(‚Äú<strong><code>[3]u8</code></strong>‚Äù allocates a 3-byte array from the stack)</p>
<p>We‚Äôll cover <strong><code>computeEcc</code></strong> in a while.</p>
<p>Finally we pack everything into our 4-byte <strong>Packet Header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Header (4 bytes):
  // Data Identifier + Word Count + Error Correction Code
  const header = [4]u8 { 
    di_wc[0],  // Data Identifier
    di_wc[1],  // Word Count (Low Byte)
    di_wc[2],  // Word Count (High Byte)
    ecc        // Error Correction Code
  };</code></pre></div>
<p>Moving on to the Packet Payload‚Ä¶</p>
<h2 id="packet-payload"><a href="#packet-payload">3.2 Packet Payload</a></h2>
<p>Remember that our <strong>Packet Payload</strong> is passed in as C-style <strong><code>buf</code></strong> (Buffer Pointer) and <strong><code>len</code></strong> (Buffer Length)?</p>
<p>This is how we convert the Packet Payload to a <strong>Byte Slice</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L81-L87">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Payload:
  // Data (0 to 65,541 bytes).
  // Number of data bytes should match the Word Count (WC)
  assert(len &lt;= 65_541);

  // Convert to Byte Slice
  const payload = buf[0..len];</code></pre></div>
<p>We‚Äôll concatenate the Packet Payload with the Header and Footer in a while.</p>
<p>(Packet Header and Footer are also Byte Slices)</p>
<p>From this code it‚Äôs clear that a <a href="https://ziglang.org/documentation/master/#Slices"><strong>Zig Slice</strong></a> is nothing more than a <strong>Pointer</strong> and a <strong>Length</strong>‚Ä¶ It‚Äôs the tidier and safer way to pass buffers in Zig!</p>
<h2 id="packet-footer"><a href="#packet-footer">3.3 Packet Footer</a></h2>
<p>At the end of our Long Packet is the <strong>Packet Footer</strong>: A 16-bit <strong>Cyclic Redundancy Check</strong> (CCITT CRC).</p>
<p>This is how we compute the CRC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L87-L97">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Checksum (CS) (2 bytes):
  // 16-bit Cyclic Redundancy Check (CRC) of the Payload
  // (not the entire packet)
  const cs: u16 = computeCrc(payload);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi2#appendix-cyclic-redundancy-check">(<strong><code>computeCrc</code></strong> is explained in the Appendix)</a></p>
<p>The CRC goes into the 2-byte <strong>Packet Footer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Convert CRC to 2 bytes
  const csl: u8 = @intCast(u8, cs &amp; 0xff);
  const csh: u8 = @intCast(u8, cs &gt;&gt; 8);

  // Packet Footer (2 bytes):
  // Checksum (CS)
  const footer = [2]u8 { csl, csh };</code></pre></div>
<p>Finally we‚Äôre ready to put the Header, Payload and Footer together!</p>
<h2 id="combine-header-payload-and-footer"><a href="#combine-header-payload-and-footer">3.4 Combine Header, Payload and Footer</a></h2>
<p>Our Long Packet will contain‚Ä¶</p>
<ul>
<li>
<p><strong>Packet Header</strong> (4 bytes)</p>
</li>
<li>
<p><strong>Packet Payload</strong> (<code>len</code> bytes)</p>
</li>
<li>
<p><strong>Packet Footer</strong> (2 bytes)</p>
</li>
</ul>
<p>Let‚Äôs combine the <strong>Header, Payload and Footer</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L97-L112">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Verify the Packet Buffer Length
  const pktlen = header.len + len + footer.len;
  assert(pktlen &lt;= pkt.len);  // Increase `pkt` size if this fails

  // Copy Header to Packet Buffer
  std.mem.copy(
    u8,                  // Type
    pkt[0..header.len],  // Destination
    &amp;header              // Source (4 bytes)
  );

  // Copy Payload to Packet Buffer
  // (After the Header)
  std.mem.copy(
    u8,                  // Type
    pkt[header.len..],   // Destination
    payload              // Source (`len` bytes)
  );

  // Copy Footer to Packet Buffer
  // (After the Payload)
  std.mem.copy(
    u8,                  // Type
    pkt[(header.len + len)..],  // Destination
    &amp;footer              // Source (2 bytes)
  );</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.copy"><strong><code>std.mem.copy</code></strong></a> copies one Slice to another. It works like <strong><code>memcpy</code></strong> in C)</p>
<p>And we return the Byte Slice that contains our Long Packet, sized accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>That‚Äôs how we compose a MIPI DSI Long Packet in Zig!</p>
<p><img src="https://lupyuen.github.io/images/dsi2-ecc.png" alt="MIPI DSI Error Correction Code (Page 209)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Error Correction Code (Page 209)</em></a></p>
<h1 id="error-correction-code"><a href="#error-correction-code">4 Error Correction Code</a></h1>
<p>Earlier we talked about computing the <strong>Error Correction Code (ECC)</strong> for the Packet Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2#packet-header"><strong>‚ÄúPacket Header‚Äù</strong></a></li>
</ul>
<p>The <strong>8-bit ECC</strong> shall be computed with this (magic) formula: <a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf">(Page 209)</a></p>
<div class="example-wrap"><pre class="language-text"><code>ECC[7] = 0
ECC[6] = 0
ECC[5] = D10^D11^D12^D13^D14^D15^D16^D17^D18^D19^D21^D22^D23
ECC[4] = D4^D5^D6^D7^D8^D9^D16^D17^D18^D19^D20^D22^D23
ECC[3] = D1^D2^D3^D7^D8^D9^D13^D14^D15^D19^D20^D21^D23
ECC[2] = D0^D2^D3^D5^D6^D9^D11^D12^D15^D18^D20^D21^D22
ECC[1] = D0^D1^D3^D4^D6^D8^D10^D12^D14^D17^D20^D21^D22^D23
ECC[0] = D0^D1^D2^D4^D5^D7^D10^D11^D13^D16^D20^D21^D22^D23</code></pre></div>
<p>(‚Äú<strong><code>^</code></strong>‚Äù means Exclusive OR)</p>
<p>(<strong><code>D0</code></strong> to <strong><code>D23</code></strong> refer to the pic above)</p>
<p>This is how we compute the ECC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L170-L211">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Compute the Error Correction Code (ECC) (1 byte):
/// Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header
/// See &quot;12.3.6.12: Error Correction Code&quot;, Page 208 of BL808 Reference Manual:
/// https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf
fn computeEcc(
  di_wc: [3]u8  // Data Identifier + Word Count (3 bytes)
) u8 {
  ...</code></pre></div>
<p>Our Zig Function <strong><code>computeEcc</code></strong> accepts a 3-byte array, containing the first 3 bytes of the Packet Header.</p>
<p>(‚Äú<strong><code>[3]u8</code></strong>‚Äù is equivalent to ‚Äú<strong><code>uint8_t[3]</code></strong>‚Äù in C)</p>
<p>We combine the 3 bytes into a <strong>24-bit word</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Combine DI and WC into a 24-bit word
  var di_wc_word: u32 = 
    di_wc[0] 
    | (@intCast(u32, di_wc[1]) &lt;&lt; 8)
    | (@intCast(u32, di_wc[2]) &lt;&lt; 16);</code></pre></div>
<p>Then we extract the 24 bits into <strong><code>d[0]</code></strong> to <strong><code>d[23]</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate an array of 24 bits from the stack,
  // initialised to zeros
  var d = std.mem.zeroes([24]u1);

  // Extract the 24 bits from the word
  var i: usize = 0;
  while (i &lt; 24) : (i += 1) {
    d[i] = @intCast(u1, di_wc_word &amp; 1);
    di_wc_word &gt;&gt;= 1;
  }</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.zeroes"><strong><code>std.mem.zeroes</code></strong></a> allocates an array from the stack, initialised to zeroes)</p>
<p>Note that we‚Äôre working with <strong>Bit Values</strong>‚Ä¶</p>
<ul>
<li>
<p>‚Äú<strong><code>u1</code></strong>‚Äù represents a Single Bit Value</p>
</li>
<li>
<p>‚Äú<strong><code>[24]u1</code></strong>‚Äù is an Array of 24 Bits</p>
</li>
</ul>
<p>We compute the <strong>ECC Bits</strong> according to the Magic Formula‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate an array of 8 bits from the stack,
  // initialised to zeros
  var ecc = std.mem.zeroes([8]u1);

  // Compute the ECC bits
  ecc[7] = 0;
  ecc[6] = 0;
  ecc[5] = d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[21] ^ d[22] ^ d[23];
  ecc[4] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[22] ^ d[23];
  ecc[3] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[13] ^ d[14] ^ d[15] ^ d[19] ^ d[20] ^ d[21] ^ d[23];
  ecc[2] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[11] ^ d[12] ^ d[15] ^ d[18] ^ d[20] ^ d[21] ^ d[22];
  ecc[1] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10] ^ d[12] ^ d[14] ^ d[17] ^ d[20] ^ d[21] ^ d[22] ^ d[23];
  ecc[0] = d[0]  ^ d[1]  ^ d[2]  ^ d[4]  ^ d[5]  ^ d[7]  ^ d[10] ^ d[11] ^ d[13] ^ d[16] ^ d[20] ^ d[21] ^ d[22] ^ d[23];</code></pre></div>
<p>Finally we <strong>merge the ECC Bits</strong> into a single byte and return it‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Merge the ECC bits
  return @intCast(u8, ecc[0])
    | (@intCast(u8, ecc[1]) &lt;&lt; 1)
    | (@intCast(u8, ecc[2]) &lt;&lt; 2)
    | (@intCast(u8, ecc[3]) &lt;&lt; 3)
    | (@intCast(u8, ecc[4]) &lt;&lt; 4)
    | (@intCast(u8, ecc[5]) &lt;&lt; 5)
    | (@intCast(u8, ecc[6]) &lt;&lt; 6)
    | (@intCast(u8, ecc[7]) &lt;&lt; 7);
}</code></pre></div>
<p>And we‚Äôre done with the Error Correction Code!</p>
<p><img src="https://lupyuen.github.io/images/dsi-short.png" alt="MIPI DSI Short Packet (Page 201)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Short Packet (Page 201)</em></a></p>
<h1 id="compose-short-packet"><a href="#compose-short-packet">5 Compose Short Packet</a></h1>
<p><em>We‚Äôve seen the Long Packet. Is there a Short Packet?</em></p>
<p>Yep! If we‚Äôre transmitting 1 or 2 bytes to the ST7703 LCD Controller, we may send a <strong>MIPI DSI Short Packet</strong> (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi"><strong>‚ÄúShort Packet for MIPI DSI‚Äù</strong></a></li>
</ul>
<p>A MIPI DSI Short Packet (compared with Long Packet)‚Ä¶</p>
<ul>
<li>
<p>Doesn‚Äôt have Packet Payload and Packet Footer (CRC)</p>
</li>
<li>
<p>Instead of Word Count (WC), the Packet Header now has 2 bytes of data</p>
</li>
<li>
<p>DCS Command (Data Type) is‚Ä¶</p>
<p><strong>DCS Short Write Without Parameter (<code>0x05</code>)</strong> for sending 1 byte of data</p>
<p><strong>DCS Short Write With Parameter (<code>0x15</code>)</strong> for sending 2 bytes of data</p>
</li>
<li>
<p>Everything else is the same</p>
</li>
</ul>
<p>This is how we <strong>compose a Short Packet</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L113-L168">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Short Packet. 
// See https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi
fn composeShortPacket(
  pkt:     []u8,    // Buffer for the Returned Short Packet
  channel: u8,      // Virtual Channel ID
  cmd:     u8,      // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) []const u8 {  // Returns the Short Packet
  
  // Short Packet can only have 1 or 2 data bytes
  assert(len == 1 or len == 2);</code></pre></div>
<p><strong><code>composeShortPacket</code></strong> accepts the same parameters as <strong><code>composeLongPacket</code></strong>.</p>
<p>We populate <strong>Data Indentifier (DI)</strong> the same way, with Virtual Channel and DCS Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  assert(channel &lt; 4);
  assert(cmd &lt; (1 &lt;&lt; 6));
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;</code></pre></div>
<p>Our <strong>Packet Header</strong> will include two bytes of data‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data (2 bytes), fill with 0 
  // if Second Byte is missing
  const data = [2]u8 {
    buf[0],                       // First Data Byte
    if (len == 2) buf[1] else 0,  // Second Data Byte
  };</code></pre></div>
<p>We compute the <strong>Error Correction Code (ECC)</strong> based on the Data Identifier and the two Data Bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier + Data (3 bytes): 
  // For computing Error Correction Code (ECC)
  const di_data = [3]u8 { 
    di,       // Data Identifier
    data[0],  // First Data Byte
    data[1]   // Second Data Byte
  };

  // Compute Error Correction Code (ECC) 
  // for Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_data);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi2#error-correction-code">(<strong><code>computeEcc</code></strong> is explained here)</a></p>
<p>We pack everything into our 4-byte <strong>Packet Header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Header (4 bytes):
  // Data Identifier + Data + Error Correction Code
  const header = [4]u8 { 
    di_data[0],  // Data Identifier
    di_data[1],  // First Data Byte
    di_data[2],  // Second Data Byte
    ecc          // Error Correction Code
  };</code></pre></div>
<p>We <strong>copy the Packet Header</strong> into our Packet Buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Verify the Packet Buffer Length
  const pktlen = header.len;
  assert(pktlen &lt;= pkt.len);  // Increase `pkt` size

  // Copy Header to Packet Buffer
  std.mem.copy(
    u8,                  // Type
    pkt[0..header.len],  // Destination
    &amp;header              // Source (4 bytes)
  );</code></pre></div>
<p>And we return the Byte Slice that contains our Short Packet, sized accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>We‚Äôre done with Long and Short Packets for MIPI DSI, let‚Äôs test them‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-test.png" alt="Test Case for MIPI DSI Driver" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L997-L1036">(Source)</a></p>
<h1 id="test-mipi-dsi-driver"><a href="#test-mipi-dsi-driver">6 Test MIPI DSI Driver</a></h1>
<p><em>How will we know if our Long and Short Packets are created correctly?</em></p>
<p>Let‚Äôs write a <strong>Test Case</strong> to verify that our MIPI DSI Packets are constructed correctly: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L965-L987">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Test Compose Short Packet (With Parameter)
const short_pkt_param = [_]u8 {
  0xbc, 0x4e,
};</code></pre></div>
<p>We‚Äôll compose a Short Packet that will pack the 2 bytes above.</p>
<p>(We write ‚Äú<strong><code>[_]u8</code></strong>‚Äù to declare a Byte Array in Zig)</p>
<p>First we allocate a <strong>Packet Buffer</strong> from the Stack, initialised to zeroes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Allocate Packet Buffer of 128 bytes
var pkt_buf = std.mem.zeroes([128]u8);</code></pre></div>
<p>(‚Äú<strong><code>[128]u8</code></strong>‚Äù is equivalent to ‚Äú<strong><code>uint8_t[128]</code></strong>‚Äù in C)</p>
<p>Then we call <strong><code>composeShortPacket</code></strong> to construct the Short Packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose a Short Packet (With Parameter)
const short_pkt_param_result = composeShortPacket(
  &amp;pkt_buf,  //  Packet Buffer
  0,         //  Virtual Channel
  MIPI_DSI_DCS_SHORT_WRITE_PARAM, // DCS Command: 0x15
  &amp;short_pkt_param,    // Transmit Buffer
  short_pkt_param.len  // Buffer Length
);</code></pre></div>
<p>We <strong>dump the contents</strong> of the returned packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Dump the Returned Packet
debug(&quot;Result:&quot;, .{});
dump_buffer(
  &amp;short_pkt_param_result[0],  // Pointer to Packet
  short_pkt_param_result.len   // Length of Packet
);</code></pre></div>
<p>(We‚Äôll talk about <strong><code>dump_buffer</code></strong> in a while)</p>
<p>Finally we verify that the result is ‚Äú<strong><code>15</code> <code>BC</code> <code>4E</code> <code>35</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>//  Verify the Returned Packet
assert(
  std.mem.eql(  // Compare 2 Slices...
    u8,         // Slice Type
    short_pkt_param_result,   // First Slice
    &amp;[_]u8 {                  // Second Slice
      0x15, 0xbc, 0x4e, 0x35  // Expected Data
    }
  )
);</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.eql"><strong><code>std.mem.eql</code></strong></a> returns True if the two Slices are identical)</p>
<p>The above Test Case shows this output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Testing Compose Short Packet (With Parameter)...
composeShortPacket:
  channel=0, cmd=0x15, len=2
Result:
  15 bc 4e 35 </code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-nuttx-zig-driver-for-mipi-dsi-on-qemu">(Source)</a></p>
<p>In the next chapter we‚Äôll learn to run the Test Case on the QEMU Emulator for Arm64.</p>
<p><em>What‚Äôs <code>dump_buffer</code>?</em></p>
<p><strong><code>dump_buffer</code></strong> is a C Function that dumps a packet to the console. We imported the C Function into Zig like so: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L1205-L1206">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import `dump_buffer` Function from C
extern fn dump_buffer(
  data: [*c]const u8,  // C Pointer to Packet
  len: usize           // Length of Packet
) void;                // No Return Value</code></pre></div>
<p><strong><code>dump_buffer</code></strong> is defined here: <a href="https://github.com/lupyuen/nuttx-apps/blob/de/examples/hello/hello_main.c#L197-L205">hello_main.c</a></p>
<p><em>What about testing Long Packets?</em></p>
<p>We have <strong>3 Test Cases</strong> for testing the creation of Long and Short Packets‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L931-L955"><strong>Short Packet Without Parameter</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L965-L987"><strong>Short Packet With Parameter</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L997-L1036"><strong>Long Packet</strong></a></p>
</li>
</ul>
<p><em>How did we get the Expected Result for our Test Cases?</em></p>
<p>We ran the <a href="https://gist.github.com/lupyuen/ee3adf76e76881609845d0ab0f768a95"><strong>p-boot Display Code</strong></a> (in C) on Apache NuttX RTOS and captured the Expected Packet Contents.</p>
<p>So we can be sure that our Zig Code will produce the same results as the (poorly documented) C Version.</p>
<p>Let‚Äôs find out how we ran the Test Cases on QEMU Emulator‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-qemu.png" alt="Testing MIPI DSI Driver with QEMU" /></p>
<h1 id="run-mipi-dsi-driver-on-qemu"><a href="#run-mipi-dsi-driver-on-qemu">7 Run MIPI DSI Driver on QEMU</a></h1>
<p><em>Can we test our MIPI DSI code on Apache NuttX RTOS‚Ä¶ Without a PinePhone?</em></p>
<p>Yep! Let‚Äôs test our Zig code on the <a href="https://www.qemu.org/docs/master/system/target-arm.html"><strong>QEMU Emulator for Arm64</strong></a>, running Apache NuttX RTOS.</p>
<p>Follow these steps to build <strong>NuttX RTOS for QEMU Arm64</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#test-pinephone-mipi-dsi-driver-with-qemu"><strong>‚ÄúTest PinePhone MIPI DSI Driver with QEMU‚Äù</strong></a></li>
</ul>
<p>Then we compile our <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig"><strong>Zig App (display.zig)</strong></a> and link it with NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Download the Zig App
git clone --recursive https://github.com/lupyuen/pinephone-nuttx
cd pinephone-nuttx

#  Compile the Zig App for PinePhone 
#  (armv8-a with cortex-a53)
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target aarch64-freestanding-none \
  -mcpu cortex_a53 \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  display.zig

#  Copy the compiled app to NuttX and overwrite `null.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp display.o \
  $HOME/nuttx/apps/examples/null/*null.o

#  Build NuttX to link the Zig Object from `null.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#zig-on-pinephone">(We copied the Zig Compiler Options from GCC)</a></p>
<p>We <strong>start QEMU</strong> to boot NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Run GIC v2 with QEMU
qemu-system-aarch64 \
  -smp 4 \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=2 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>(We chose <a href="https://lupyuen.github.io/articles/interrupt#allwinner-a64-gic"><strong>GIC Version 2</strong></a> to be consistent with PinePhone)</p>
<p>At the NuttX Shell, enter this command to run our <strong>Zig Test Cases</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>null</code></pre></div>
<p>Our <a href="https://lupyuen.github.io/articles/dsi2#test-mipi-dsi-driver"><strong>Test Cases for Long and Short Packets</strong></a> should complete without Assertion Failures‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-11.0.0-RC2
nsh&gt; null
HELLO ZIG ON PINEPHONE!
Testing Compose Short Packet (Without Parameter)...
composeShortPacket: channel=0, cmd=0x5, len=1
Result:
05 11 00 36 
Testing Compose Short Packet (With Parameter)...
composeShortPacket: channel=0, cmd=0x15, len=2
Result:
15 bc 4e 35 
Testing Compose Long Packet...
composeLongPacket: channel=0, cmd=0x39, len=64
Result:
39 40 00 25 e9 82 10 06 
05 a2 0a a5 12 31 23 37 
83 04 bc 27 38 0c 00 03 
00 00 00 0c 00 03 00 00 
00 75 75 31 88 88 88 88 
88 88 13 88 64 64 20 88 
88 88 88 88 88 02 88 00 
00 00 00 00 00 00 00 00 
00 00 00 00 65 03 
nsh&gt; </code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-nuttx-zig-driver-for-mipi-dsi-on-qemu">(See the Complete Log)</a></p>
<p>Yep we have successfully tested our MIPI DSI Code on NuttX RTOS and QEMU Arm64!</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code2.png" alt="Initialising ST7703 LCD Controller" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L494-L859">(Source)</a></p>
<h1 id="initialise-st7703-lcd-controller"><a href="#initialise-st7703-lcd-controller">8 Initialise ST7703 LCD Controller</a></h1>
<p><em>But our MIPI DSI Driver hasn‚Äôt talked to the PinePhone Display!</em></p>
<p>Here comes the tougher (and poorly documented) part‚Ä¶ Accessing the <strong>Hardware Registers</strong> of the Allwinner A64 SoC. So that we can <strong>send MIPI DSI Packets</strong> to PinePhone‚Äôs Display.</p>
<p>Before that, let‚Äôs prepare the MIPI DSI Packets (Long and Short) that we‚Äôll send to the display‚Ä¶</p>
<p>Earlier we talked about the <strong>20 Initialisation Commands</strong> that our Zig Driver will send to the <strong>ST7703 LCD Controller</strong> (over MIPI DSI)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2#pinephone-lcd-display"><strong>‚ÄúPinePhone LCD Display‚Äù</strong></a></li>
</ul>
<p>This is how we <strong>send the 20 commands</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L494-L859">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Initialise the ST7703 LCD Controller in Xingbangda XBD599 LCD Panel.
/// See https://lupyuen.github.io/articles/dsi#initialise-lcd-controller
pub export fn nuttx_panel_init() void {

  // Most of these commands are documented in the ST7703 Datasheet:
  // https://files.pine64.org/doc/datasheet/pinephone/ST7703_DS_v01_20160128.pdf

  // Command #1
  writeDcs(&amp;[_]u8 { 
    0xB9,  // SETEXTC (Page 131): Enable USER Command
    0xF1,  // Enable User command
    0x12,  // (Continued)
    0x83   // (Continued)
  });

  // Omitted: Commands #2 to #19
  ...

  // Wait 120 milliseconds
  _ = c.usleep(120 * 1000);

  // Command #20
  writeDcs(&amp;[_]u8 {
    0x29  // Display On (Page 97): Recover from DISPLAY OFF mode (MIPI_DCS_SET_DISPLAY_ON)
  });    
}</code></pre></div>
<p>To send a command to ST7703 Controller, <strong><code>writeDcs</code></strong> executes a <strong>DCS Short Write</strong> or <strong>DCS Long Write</strong> over MIPI DSI, depending on the length of the command: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L296-L321">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Write the DCS Command to MIPI DSI
fn writeDcs(buf: []const u8) void {

  // Do DCS Short Write or Long Write depending on command length
  assert(buf.len &gt; 0);
  const res = switch (buf.len) {

    // If Command Length is 1:
    // DCS Short Write (without parameter)
    1 =&gt; nuttx_mipi_dsi_dcs_write(null, 0, 
      MIPI_DSI_DCS_SHORT_WRITE, 
      &amp;buf[0], buf.len),

    // If Command Length is 2:
    // DCS Short Write (with parameter)
    2 =&gt; nuttx_mipi_dsi_dcs_write(null, 0, 
      MIPI_DSI_DCS_SHORT_WRITE_PARAM, 
      &amp;buf[0], buf.len),

    // If Command Length is 3 or longer:
    // DCS Long Write
    else =&gt; nuttx_mipi_dsi_dcs_write(null, 0, 
      MIPI_DSI_DCS_LONG_WRITE, 
      &amp;buf[0], buf.len),
  };
  assert(res == buf.len);
}</code></pre></div>
<p>(We write ‚Äú<strong><code>&amp;buf[0]</code></strong>‚Äù to convert a Slice into a Pointer)</p>
<p>Let‚Äôs study our Zig Function that sends Long Packets and Short Packets over MIPI DSI: <strong>nuttx_mipi_dsi_dcs_write</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code3.png" alt="Writing a DCS Command to MIPI DSI" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L296-L321">(Source)</a></p>
<h1 id="send-mipi-dsi-packet"><a href="#send-mipi-dsi-packet">9 Send MIPI DSI Packet</a></h1>
<p>Finally we‚Äôre ready to access the <strong>Hardware Registers</strong> of PinePhone‚Äôs Allwinner A64 SoC, to send MIPI DSI Packets to the display.</p>
<p>We‚Äôll call these Zig Functions to manipulate <strong>A64‚Äôs Hardware Registers</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L479-L483"><strong><code>getreg32</code></strong></a>: Read the Value of the Hardware Register at the specified Address</p>
<div class="example-wrap"><pre class="language-zig"><code>fn getreg32(addr: u64) u32</code></pre></div></li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L485-L489"><strong><code>putreg32</code></strong></a>: Set the Value of the Hardware Register at the specified Address</p>
<div class="example-wrap"><pre class="language-zig"><code>fn putreg32(val: u32, addr: u64)</code></pre></div>
<p>(Note that the Value comes <strong>before</strong> the Address)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L463-L477"><strong><code>modifyreg32</code></strong></a>: Clear and set the bits of the Hardware Register at the Address</p>
<div class="example-wrap"><pre class="language-zig"><code>fn modifyreg32(
  addr: u64,       // Address to modify
  clearbits: u32,  // Bits to clear, like (1 &lt;&lt; bit)
  setbits: u32     // Bit to set, like (1 &lt;&lt; bit)
)</code></pre></div></li>
</ul>
<p>This is how we <strong>send MIPI DSI Packets</strong> to PinePhone‚Äôs Display: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L323-L430">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Write Packet to MIPI DSI. See https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi
pub export fn nuttx_mipi_dsi_dcs_write(
  dev:     [*c]const mipi_dsi_device,  // MIPI DSI Host Device
  channel: u8,  // Virtual Channel ID
  cmd:     u8,  // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) isize {  // On Success: Return number of written bytes. On Error: Return negative error code
  ...</code></pre></div>
<p>Our function accepts a <strong>DCS Long Write</strong> or <strong>DCS Short Write</strong> command. (Depending on the packet size)</p>
<p>Based on the DCS Command received, we compose a <strong>Long Packet or Short Packet</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate Packet Buffer
  var pkt_buf = std.mem.zeroes([128]u8);

  // Compose Short or Long Packet depending on DCS Command
  const pkt = switch (cmd) {

    // For DCS Long Write: Compose Long Packet
    MIPI_DSI_DCS_LONG_WRITE =&gt;
      composeLongPacket(&amp;pkt_buf, channel, cmd, buf, len),

    // For DCS Short Write (with and without parameter):
    // Compose Short Packet
    MIPI_DSI_DCS_SHORT_WRITE,
    MIPI_DSI_DCS_SHORT_WRITE_PARAM =&gt;
      composeShortPacket(&amp;pkt_buf, channel, cmd, buf, len),

    // DCS Command not supported
    else =&gt; unreachable,
  };</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi2#compose-long-packet">(<strong>composeLongPacket</strong> is explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/dsi2#compose-short-packet">(<strong>composeShortPacket</strong> is explained here)</a></p>
<p>To prepare for Packet Transmission, we initialise the A64 Hardware Register <strong>DSI_CMD_CTL_REG</strong> (DSI Low Power Control Register)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set the following bits to 1 in DSI_CMD_CTL_REG (DSI Low Power Control Register) at Offset 0x200:
  // RX_Overflow (Bit 26): Clear flag for &quot;Receive Overflow&quot;
  // RX_Flag (Bit 25): Clear flag for &quot;Receive has started&quot;
  // TX_Flag (Bit 9): Clear flag for &quot;Transmit has started&quot;
  // All other bits must be set to 0.
  const DSI_CMD_CTL_REG = DSI_BASE_ADDRESS + 0x200;
  const RX_Overflow = 1 &lt;&lt; 26;
  const RX_Flag     = 1 &lt;&lt; 25;
  const TX_Flag     = 1 &lt;&lt; 9;
  putreg32(
    RX_Overflow | RX_Flag | TX_Flag,
    DSI_CMD_CTL_REG
  );</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi">(<strong>DSI_CMD_CTL_REG</strong> is explained here)</a></p>
<p>Next we write the Long or Short Packet to <strong>DSI_CMD_TX_REG</strong> (DSI Low Power Transmit Package Register) in 4-byte chunks‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Write the Long Packet to DSI_CMD_TX_REG 
  // (DSI Low Power Transmit Package Register) at Offset 0x300 to 0x3FC
  const DSI_CMD_TX_REG = DSI_BASE_ADDRESS + 0x300;
  var addr: u64 = DSI_CMD_TX_REG;
  var i: usize = 0;
  while (i &lt; pkt.len) : (i += 4) {
    // Fetch the next 4 bytes, fill with 0 if not available
    const b = [4]u32 {
      pkt[i],
      if (i + 1 &lt; pkt.len) pkt[i + 1] else 0,
      if (i + 2 &lt; pkt.len) pkt[i + 2] else 0,
      if (i + 3 &lt; pkt.len) pkt[i + 3] else 0,
    };

    // Merge the next 4 bytes into a 32-bit value
    const v: u32 =
      b[0]
      + (b[1] &lt;&lt; 8)
      + (b[2] &lt;&lt; 16)
      + (b[3] &lt;&lt; 24);

    // Write the 32-bit value
    assert(addr &lt;= DSI_BASE_ADDRESS + 0x3FC);
    modifyreg32(addr, 0xFFFF_FFFF, v);
    addr += 4;
  }</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi">(<strong>DSI_CMD_TX_REG</strong> is explained here)</a></p>
<p>We set the Packet Length in <strong>DSI_CMD_CTL_REG</strong> (DSI Low Power Control Register)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set Packet Length - 1 in Bits 0 to 7 (TX_Size) of
  // DSI_CMD_CTL_REG (DSI Low Power Control Register) at Offset 0x200
  modifyreg32(DSI_CMD_CTL_REG, 0xFF, @intCast(u32, pkt.len) - 1);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi">(<strong>DSI_CMD_CTL_REG</strong> is explained here)</a></p>
<p>We begin MIPI DSI Low Power Transmission by writing to <strong>DSI_INST_JUMP_SEL_REG</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set DSI_INST_JUMP_SEL_REG (Offset 0x48, undocumented) 
  // to begin the Low Power Transmission (LPTX)
  const DSI_INST_JUMP_SEL_REG = DSI_BASE_ADDRESS + 0x48;
  const DSI_INST_ID_LPDT = 4;
  const DSI_INST_ID_LP11 = 0;
  const DSI_INST_ID_END  = 15;
  putreg32(
    DSI_INST_ID_LPDT &lt;&lt; (4 * DSI_INST_ID_LP11) |
    DSI_INST_ID_END  &lt;&lt; (4 * DSI_INST_ID_LPDT),
    DSI_INST_JUMP_SEL_REG
  );</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi">(<strong>DSI_INST_JUMP_SEL_REG</strong> is explained here)</a></p>
<p>Our MIPI DSI Packet gets transmitted when we toggle the <strong>DSI Processing State</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Disable DSI Processing then Enable DSI Processing
  disableDsiProcessing();
  enableDsiProcessing();</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L451-L455">(<strong>disableDsiProcessing</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L457-L461">(<strong>enableDsiProcessing</strong> is defined here)</a></p>
<p>We must <strong>wait for the Packet Transmission</strong> to complete‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Wait for transmission to complete
  const res = waitForTransmit();
  if (res &lt; 0) {
    disableDsiProcessing();
    return res;
  }

  // Return number of written bytes
  return @intCast(isize, len);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L432-L449">(<strong>waitForTransmit</strong> is defined here)</a></p>
<p>And we‚Äôre done transmitting a MIPI DSI Packet to PinePhone‚Äôs Display!</p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Apache NuttX RTOS on PinePhone" /></p>
<h1 id="test-mipi-dsi-driver-on-pinephone"><a href="#test-mipi-dsi-driver-on-pinephone">10 Test MIPI DSI Driver on PinePhone</a></h1>
<p><em>Are we sure that our Zig Driver talks OK to PinePhone‚Äôs MIPI DSI Display?</em></p>
<p>Our Zig Driver sends <strong>20 commands over MIPI DSI</strong> to initialise PinePhone‚Äôs Display‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2#initialise-st7703-lcd-controller"><strong>‚ÄúInitialise ST7703 LCD Controller‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2#send-mipi-dsi-packet"><strong>‚ÄúSend MIPI DSI Packet‚Äù</strong></a></p>
</li>
</ul>
<p>Let‚Äôs test it with <strong>Apache NuttX RTOS</strong> on PinePhone!</p>
<p>This <strong>p-boot Display Code</strong> (in C) renders a <a href="https://gist.github.com/lupyuen/ee3adf76e76881609845d0ab0f768a95#file-test_display-c-L154-L251"><strong>‚ÄúTest Pattern‚Äù</strong></a> (pic above) on PinePhone‚Äôs Display‚Ä¶</p>
<ul>
<li><a href="https://gist.github.com/lupyuen/ee3adf76e76881609845d0ab0f768a95"><strong>‚ÄúExperimenting with PinePhone p-boot Display Code‚Äù</strong></a></li>
</ul>
<p>Inside the above code is the C Function <strong><code>panel_init</code></strong> that sends the 20 commands to initialise PinePhone‚Äôs Display‚Ä¶</p>
<ul>
<li><a href="https://megous.com/git/p-boot/tree/src/display.c#n223"><strong><code>panel_init</code> in p-boot</strong></a></li>
</ul>
<p>We modify <strong><code>panel_init</code></strong> so that it calls our <strong>Zig Driver</strong> instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// p-boot calls this to init ST7703
static void panel_init(void) {
  // We call Zig Driver to init ST7703
  nuttx_panel_init();
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi2#initialise-st7703-lcd-controller">(<strong><code>nuttx_panel_init</code></strong> is explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/pboot4">(<strong>p-boot Display Code</strong> modified for Zig)</a></p>
<p>Follow these steps to <strong>download NuttX RTOS</strong> (with our Zig Driver inside) to a microSD Card‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#test-zig-display-driver-for-pinephone"><strong>‚ÄúTest Zig Display Driver for PinePhone‚Äù</strong></a></li>
</ul>
<p>Connect our computer to PinePhone via a <a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><strong>USB Serial Debug Cable</strong></a>. (At 115.2 kbps)</p>
<p>Boot PinePhone with NuttX RTOS in the microSD Card.</p>
<p>(NuttX won‚Äôt disturb the eMMC Flash Memory)</p>
<p>At the NuttX Shell, enter this command to <strong>test our Zig Display Driver</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>hello</code></pre></div>
<p>We should see our Zig Driver composing the <strong>MIPI DSI Packets</strong> and setting the <strong>Hardware Registers</strong> of the Allwinner A64 SoC‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>HELLO NUTTX ON PINEPHONE!
...
Shell (NSH) NuttX-11.0.0-RC2
nsh&gt; hello
...
writeDcs: len=4
b9 f1 12 83 
mipi_dsi_dcs_write: channel=0, cmd=0x39, len=4
composeLongPacket: channel=0, cmd=0x39, len=4
packet: len=10
39 04 00 2c b9 f1 12 83 
84 5d 
modifyreg32: addr=0x300, val=0x2c000439
modifyreg32: addr=0x304, val=0x8312f1b9
modifyreg32: addr=0x308, val=0x00005d84
modifyreg32: addr=0x200, val=0x00000009
modifyreg32: addr=0x010, val=0x00000000
modifyreg32: addr=0x010, val=0x00000001
...</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-nuttx-zig-driver-for-mipi-dsi-on-pinephone">(See the Complete Log)</a></p>
<p>Our Zig Display Driver powers on the PinePhone Display and <strong>renders the Test Pattern</strong>‚Ä¶ Exactly like the earlier code in C! üéâ</p>
<p><em>Are we really sure that our Zig Driver works OK?</em></p>
<p>100% Yep! If our Zig Driver didn‚Äôt send the ST7703 Commands correctly, PinePhone‚Äôs Display would stay dark.</p>
<p>Our PinePhone Display Driver in Zig has successfully‚Ä¶</p>
<ul>
<li>
<p>Sent <strong>20 MIPI DSI Commands</strong> to initialise PinePhone‚Äôs ST7703 LCD Controller</p>
</li>
<li>
<p>With the correct MIPI DSI <strong>Long Packets and Short Packets</strong></p>
</li>
<li>
<p>By accessing the correct <strong>Hardware Registers</strong> in PinePhone‚Äôs Allwinner A64 SoC</p>
</li>
</ul>
<p>But we haven‚Äôt actually rendered any graphics to the display yet‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/pio-display.png" alt="Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)</em></a></p>
<h1 id="render-graphics-on-pinephone-display"><a href="#render-graphics-on-pinephone-display">11 Render Graphics on PinePhone Display</a></h1>
<p><em>Can our driver render graphics on the PinePhone Display?</em></p>
<p>Sadly our PinePhone Display Driver <strong>isn‚Äôt complete</strong>‚Ä¶ Rendering graphics on PinePhone‚Äôs Display isn‚Äôt done with MIPI DSI Packets.</p>
<p>Instead we shall program these two controllers in PinePhone‚Äôs Allwinner A64 SoC‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pio#display-engine"><strong>Display Engine (DE)</strong></a>: Execute the Rendering Pipeline to generate the pixels for display</p>
<p>(Handles image buffering, scaling, mixing, ‚Ä¶)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio#lcd-controller-tcon0"><strong>Timing Controller (TCON0)</strong></a>: Pump the generated pixels at the right clock frequency to the MIPI DSI display</p>
<p>(Pic above)</p>
</li>
</ul>
<p><em>Why won‚Äôt PinePhone‚Äôs Display accept MIPI DSI Packets for graphics?</em></p>
<p>PinePhone‚Äôs ST7703 LCD Controller <strong>doesn‚Äôt have any RAM</strong> inside‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>‚ÄúSitronix ST7703 LCD Controller‚Äù</strong></a></li>
</ul>
<p>Thus we need to <strong>pump a constant stream of pixels</strong> to the display. Which won‚Äôt work with MIPI DSI Packets. (Because it‚Äôs too inefficient)</p>
<p>A64‚Äôs <strong>Display Engine (DE)</strong> and <strong>Timing Controller (TCON0)</strong> were created to blast the pixels efficiently from PinePhone‚Äôs RAM to the ST7703 LCD Controller.</p>
<p><a href="https://gist.github.com/lupyuen/ee3adf76e76881609845d0ab0f768a95#file-test_display-c-L147-L254">(All fully automated, no interrupts needed!)</a></p>
<p>We‚Äôll talk about DE and TCON0 in the next 2 articles‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
</ul>
<p><em>The PinePhone Display Driver that we‚Äôre building‚Ä¶ What interface will it expose?</em></p>
<p>Our PinePhone Display Driver (in C or Zig) shall expose the standard <strong>Display Driver Interface</strong> that‚Äôs expected by Apache NuttX RTOS.</p>
<p>Here‚Äôs the implementation of the Display Driver Interface for the <strong>Sitronix ST7789 LCD Controller</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx/blob/master/drivers/lcd/st7789.c"><strong>nuttx/drivers/lcd/st7789.c</strong></a></li>
</ul>
<h1 id="whats-next"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>Today we‚Äôve seen the Zig Internals of our new PinePhone Display Driver for Apache NuttX RTOS. I hope that coding the driver in Zig has made it a little easier to understand what‚Äôs inside.</p>
<p>Some parts of the driver were simpler to code in Zig than in C. I‚Äôm glad I chose Zig for the driver!</p>
<p>(I took longer to write this article‚Ä¶ Than to code the Zig Driver!)</p>
<p>In the next article we shall implement the rendering features of the PinePhone Display Driver‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></li>
</ul>
<p>There‚Äôs plenty to be done for NuttX on PinePhone, please lemme know if you would like to join me üôè</p>
<p>Check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3"><strong>‚ÄúNuttX RTOS for PinePhone: MIPI Display Serial Interface‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de3"><strong>‚ÄúNuttX RTOS for PinePhone: Display Engine‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/y6s7k4/nuttx_rtos_for_pinephone_display_driver_in_zig/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/dsi2.md"><strong>lupyuen.github.io/src/dsi2.md</strong></a></p>
<h1 id="notes"><a href="#notes">13 Notes</a></h1>
<ol>
<li>
<p>All writes to MIPI DSI Hardware Registers must use <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>Data Memory Barrier (DMB)</strong></a></p>
<p><a href="https://megous.com/git/p-boot/tree/src/display.c#n756">(According to this)</a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/dsi2-checksum.png" alt="MIPI DSI Cyclic Redundancy Check (Page 210)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Cyclic Redundancy Check (Page 210)</em></a></p>
<h1 id="appendix-cyclic-redundancy-check"><a href="#appendix-cyclic-redundancy-check">14 Appendix: Cyclic Redundancy Check</a></h1>
<p>Earlier we talked about computing the 16-bit <strong>Cyclic Redundancy Check (CCITT CRC)</strong> for the MIPI DSI Packet Footer (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2#packet-footer"><strong>‚ÄúPacket Footer‚Äù</strong></a></li>
</ul>
<p>This is how our Zig Driver computes the CCITT CRC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L213-L273">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Compute 16-bit Cyclic Redundancy Check (CRC).
/// See &quot;12.3.6.13: Packet Footer&quot;, Page 210 of BL808 Reference Manual:
/// https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf
fn computeCrc(
  data: []const u8
) u16 {
  // Use CRC-16-CCITT (x^16 + x^12 + x^5 + 1)
  const crc = crc16ccitt(data, 0xffff);
  return crc;
}

/// Return a 16-bit CRC-CCITT of the contents of the `src` buffer.
/// Based on https://github.com/lupyuen/nuttx/blob/pinephone/libs/libc/misc/lib_crc16.c
fn crc16ccitt(src: []const u8, crc16val: u16) u16 {
  var i: usize = 0;
  var v = crc16val;
  while (i &lt; src.len) : (i += 1) {
    v = (v &gt;&gt; 8)
      ^ crc16ccitt_tab[(v ^ src[i]) &amp; 0xff];
  }
  return v;
}</code></pre></div>
<p><strong><code>crc16ccitt_tab</code></strong> is the standard table for computing CRC-16-CCITT based on the polynomial ‚Äú<code>x^16 + x^12 + x^5 + 1</code>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// From CRC-16-CCITT (x^16 + x^12 + x^5 + 1)
const crc16ccitt_tab = [256]u16 {
  0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
  0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
  0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
  0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
  0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
  0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
  0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
  0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
  0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
  0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
  0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
  0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
  0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
  0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
  0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
  0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
  0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
  0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
  0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
  0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
  0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
  0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
  0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
  0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
  0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
  0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
  0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
  0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
  0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
  0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
  0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
  0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78,
};</code></pre></div>
    
</body>
</html>