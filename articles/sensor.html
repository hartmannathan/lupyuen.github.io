<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Read NuttX Sensor Data with Zig</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Read NuttX Sensor Data with Zig" 
    data-rh="true">
<meta property="og:description" 
    content="Using Zig to read Sensor Data on Apache NuttX RTOS... With Bosch BME280 Temperature / Humidity / Air Pressure Sensor"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/sensor-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Read NuttX Sensor Data with Zig</h1>
    <nav id="TOC"><ul>
<li><a href="#bosch-bme280-sensor">1 Bosch BME280 Sensor</a><ul></ul></li>
<li><a href="#read-barometer-sensor">2 Read Barometer Sensor</a><ul>
<li><a href="#open-sensor-device">2.1 Open Sensor Device</a><ul></ul></li>
<li><a href="#close-sensor-device-deferred">2.2 Close Sensor Device (Deferred)</a><ul></ul></li>
<li><a href="#set-standby-interval">2.3 Set Standby Interval</a><ul></ul></li>
<li><a href="#set-batch-latency">2.4 Set Batch Latency</a><ul></ul></li>
<li><a href="#poll-sensor">2.5 Poll Sensor</a><ul></ul></li>
<li><a href="#read-sensor-data">2.6 Read Sensor Data</a><ul></ul></li>
<li><a href="#print-sensor-data">2.7 Print Sensor Data</a><ul></ul></li></ul></li>
<li><a href="#read-humidity-sensor">3 Read Humidity Sensor</a><ul></ul></li>
<li><a href="#import-nuttx-functions">4 Import NuttX Functions</a><ul></ul></li>
<li><a href="#main-function">5 Main Function</a><ul></ul></li>
<li><a href="#slice-vs-string">6 Slice vs String</a><ul></ul></li>
<li><a href="#connect-bme280-sensor">7 Connect BME280 Sensor</a><ul></ul></li>
<li><a href="#compile-zig-app">8 Compile Zig App</a><ul></ul></li>
<li><a href="#run-zig-app">9 Run Zig App</a><ul></ul></li>
<li><a href="#multiple-sensors">10 Multiple Sensors</a><ul></ul></li>
<li><a href="#lorawan-and-visual-programming">11 LoRaWAN and Visual Programming</a><ul></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">13 Notes</a><ul></ul></li>
<li><a href="#appendix-fixed-point-sensor-data">14 Appendix: Fixed-Point Sensor Data</a><ul></ul></li>
<li><a href="#appendix-updates-to-nuttx-sensor-api">15 Appendix: Updates to NuttX Sensor API</a><ul></ul></li></ul></nav><p>üìù <em>29 Jul 2022</em></p>
<p><img src="https://lupyuen.github.io/images/sensor-title.jpg" alt="Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor" /></p>
<p>With <a href="https://ziglang.org"><strong>Zig Programming Language</strong></a>, we have a fun new way to create Embedded Applications for <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>Today we shall write a Zig program that reads a NuttX Sensor: <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a> for Temperature, Humidity and Air Pressure.</p>
<p>And we‚Äôll run it on Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a>. (Pic above)</p>
<p>(The steps will be similar for other sensors and microcontrollers)</p>
<p><em>Why are we doing this in Zig?</em></p>
<p>Zig is super helpful for <strong>writing safer programs</strong> because it catches problems at runtime: Overflow, Underflow, Array Out-of-Bounds and more. <a href="https://ziglang.org/documentation/master/#Undefined-Behavior">(See the list)</a></p>
<p>The code we see today will be useful for programming <strong>IoT Gadgets</strong> with Zig. We‚Äôll use the code in upcoming projects for <strong>LoRaWAN and Visual Programming</strong>. (Details below)</p>
<p><em>What if we‚Äôre not familiar with Zig?</em></p>
<p>This article assumes that we‚Äôre familiar with C. The Zig-ish parts shall be explained with examples in C.</p>
<p><a href="https://lupyuen.github.io/articles/pinephone#appendix-learning-zig">(Tips for learning Zig)</a></p>
<p><em>But really‚Ä¶ What if we prefer to do this in C?</em></p>
<p>NuttX already provides an excellent <strong>Sensor Test App</strong> in C‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c"><strong>sensortest.c</strong></a></li>
</ul>
<p>That inspired the Zig program in this article‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/visual-zig-nuttx"><strong>lupyuen/visual-zig-nuttx</strong></a></li>
</ul>
<p>Let‚Äôs dive in and find out how we read NuttX Sensors with Zig!</p>
<p><strong>Note:</strong> The NuttX Sensor API has been updated in Jul / Aug 2022. <a href="https://lupyuen.github.io/articles/sensor#appendix-updates-to-nuttx-sensor-api">(See the changes)</a></p>
<h1 id="bosch-bme280-sensor"><a href="#bosch-bme280-sensor">1 Bosch BME280 Sensor</a></h1>
<p>For today we‚Äôll call this NuttX Driver for <strong>Bosch BME280 Sensor</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280"><strong>‚ÄúApache NuttX Driver for BME280 Sensor: Ported from Zephyr OS‚Äù</strong></a></li>
</ul>
<p>The BME280 Driver exposes two <strong>NuttX Sensor Devices</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Barometer Sensor:</strong> /dev/uorb/sensor_baro0</p>
<p>(For Temperature and Air Pressure)</p>
</li>
<li>
<p><strong>Humidity Sensor:</strong> /dev/uorb/sensor_humi0</p>
<p>(For Humidity)</p>
</li>
</ul>
<p>We shall read both Sensor Devices to fetch the Sensor Data for <strong>Temperature, Air Pressue and Humidity.</strong></p>
<p><img src="https://lupyuen.github.io/images/sensor-code2a.png" alt="Read Barometer Sensor" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L53-L145">(Source)</a></p>
<h1 id="read-barometer-sensor"><a href="#read-barometer-sensor">2 Read Barometer Sensor</a></h1>
<p>Let‚Äôs walk through the code to read the Temperature and Air Pressure from our <strong>NuttX Barometer Sensor</strong> at ‚Äú/dev/uorb/sensor_baro0‚Äù‚Ä¶</p>
<ul>
<li>
<p>Open Sensor Device</p>
</li>
<li>
<p>Set Standby Interval</p>
</li>
<li>
<p>Set Batch Latency</p>
</li>
<li>
<p>Poll Sensor</p>
</li>
<li>
<p>Read Sensor Data</p>
</li>
<li>
<p>Print Sensor Data</p>
</li>
<li>
<p>Close Sensor Device</p>
</li>
</ul>
<h2 id="open-sensor-device"><a href="#open-sensor-device">2.1 Open Sensor Device</a></h2>
<p>We begin by <strong>opening the Sensor Device</strong>: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L53-L145">sensortest.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read Pressure and Temperature from 
/// Barometer Sensor &quot;/dev/uorb/sensor_baro0&quot;
fn test_sensor() !void {

  // Open the Sensor Device
  const fd = c.open(
    &quot;/dev/uorb/sensor_baro0&quot;,  // Path of Sensor Device
    c.O_RDONLY | c.O_NONBLOCK    // Open for read-only
  );
</code></pre></div>
<p><strong><code>open()</code></strong> should look familiar‚Ä¶ On Linux we open Devices the same way.</p>
<p><em>What‚Äôs ‚Äú<code>!void</code>‚Äù?</em></p>
<p>That‚Äôs the <strong>Return Type</strong> of our function‚Ä¶</p>
<ul>
<li>
<p>Our function doesn‚Äôt return any value</p>
<p>(Hence ‚Äú<code>void</code>‚Äù)</p>
</li>
<li>
<p>But it might return an <strong>Error</strong></p>
<p>(Hence the ‚Äú<code>!</code>‚Äù)</p>
</li>
</ul>
<p><em>Why the ‚Äú<code>c.</code>‚Äù prefix?</em></p>
<p>We write ‚Äú<code>c.</code><em>something</em>‚Äù for Functions, Types and Macros <strong>imported from C</strong>.</p>
<p>(More about this in a while)</p>
<p>Next we check if the Sensor Device has been <strong>successfully opened</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Check for error
  if (fd &lt; 0) {
    std.log.err(
      &quot;Failed to open device:{s}&quot;,
      .{ c.strerror(errno()) }
    );
    return error.OpenError;
  }
</code></pre></div>
<p>If the Sensor Device doesn‚Äôt exist, we print a Formatted Message to the <strong>Error Log</strong> and return an Error.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L152-L163">(<strong>OpenError</strong> is defined here)</a></p>
<p><em>What‚Äôs ‚Äú<code>{s}</code>‚Äù?</em></p>
<p>That‚Äôs for printing a <strong>Formatted String</strong> in Zig.</p>
<p>It‚Äôs equivalent to ‚Äú<code>%s</code>‚Äù in C‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>printf(&quot;Failed to open device:%s&quot;, strerror(errno()));
</code></pre></div>
<p><em>What‚Äôs ‚Äú<code>.{ ... }</code>‚Äù?</em></p>
<p>That‚Äôs how we pass a <strong>list of Arguments</strong> when printing a Formatted Message.</p>
<p>If we have no Arguments, we write ‚Äú<code>.{}</code>‚Äù</p>
<p><a href="https://ziglang.org/documentation/master/#Anonymous-Struct-Literals">(‚Äú<code>.{ ... }</code>‚Äù creates an Anonymous Struct)</a></p>
<h2 id="close-sensor-device-deferred"><a href="#close-sensor-device-deferred">2.2 Close Sensor Device (Deferred)</a></h2>
<p>We‚Äôve just opened the Sensor Device and we must <strong>close it later</strong>‚Ä¶</p>
<p>But the Control Flow gets complicated because we might need to <strong>handle Errors</strong> and quit early. In C we‚Äôd code this with ‚Äú<code>goto</code>‚Äù.</p>
<p>For Zig we do this nifty trick‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Close the Sensor Device when 
  // this function returns
  defer {
    _ = c.close(fd);
  }
</code></pre></div>
<p>When we write <strong>‚Äú<code>defer</code>‚Äù</strong>, this chunk of code will be executed <strong>when our function returns</strong>.</p>
<p>This brilliantly solves our headache of <strong>closing the Sensor Device</strong> when we hit Errors later.</p>
<p><em>Why the ‚Äú<code>_ =</code> something‚Äù?</em></p>
<p>Zig Compiler stops us if we forget to use the <strong>Return Value</strong> of a Function.</p>
<p>We write ‚Äú<code>_ =</code> <em>something</em>‚Äù to tell Zig Compiler that we‚Äôre not using the Return Value.</p>
<h2 id="set-standby-interval"><a href="#set-standby-interval">2.3 Set Standby Interval</a></h2>
<p>Some sensors (like BME280) will automatically measure Sensor Data at <strong>Periodic Intervals</strong>. <a href="https://lupyuen.github.io/articles/bme280#standby-interval">(Like this)</a></p>
<p>Let‚Äôs assume that our sensor will measure Sensor Data <strong>every 1 second</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // TODO: Remove this definition when 
  // SNIOC_SET_INTERVAL has been been fixed: 
  // https://github.com/apache/nuttx/issues/6642
  const SNIOC_SET_INTERVAL = c._SNIOC(0x0081);

  // Set Standby Interval
  const interval: c_uint = 1_000_000;  // 1,000,000 microseconds (1 second)
  var ret = c.ioctl(
    fd,                  // Sensor Device
    SNIOC_SET_INTERVAL,  // ioctl Command
    interval             // Standby Interval
  );
</code></pre></div>
<p>(<strong>c_uint</strong> is equivalent to ‚Äúunsigned int‚Äù in C)</p>
<p>In case of error, we quit‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Check for error
  if (ret &lt; 0 and errno() != c.ENOTSUP) {
    std.log.err(&quot;Failed to set interval:{s}&quot;, .{ c.strerror(errno()) });
    return error.IntervalError;
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L152-L163">(<strong>IntervalError</strong> is defined here)</a></p>
<p>Which also closes the Sensor Device. (Due to our earlier ‚Äú<code>defer</code>‚Äù)</p>
<h2 id="set-batch-latency"><a href="#set-batch-latency">2.4 Set Batch Latency</a></h2>
<p>We set the <strong>Batch Latency</strong>, if it‚Äôs needed by our sensor‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set Batch Latency
  const latency: c_uint = 0;  // No latency
  ret = c.ioctl(
    fd,             // Sensor Device
    c.SNIOC_BATCH,  // ioctl Command
    latency         // Batch Latency
  );
</code></pre></div>
<p>And we check for error‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Check for error
  if (ret &lt; 0 and errno() != c.ENOTSUP) {
    std.log.err(&quot;Failed to batch:{s}&quot;, .{ c.strerror(errno()) });
    return error.BatchError;
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L152-L163">(<strong>BatchError</strong> is defined here)</a></p>
<h2 id="poll-sensor"><a href="#poll-sensor">2.5 Poll Sensor</a></h2>
<p>After the enabling the sensor, we <strong>poll the sensor</strong> to check if Sensor Data is available‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Prepare to poll Sensor
  var fds = std.mem.zeroes(
    c.struct_pollfd
  );
  fds.fd = fd;
  fds.events = c.POLLIN;
</code></pre></div>
<p><strong>std.mem.zeroes</strong> creates a <strong>pollfd</strong> Struct that‚Äôs initialised with nulls.</p>
<p>(The struct lives on the stack)</p>
<p>After populating the struct, we poll it‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Poll for Sensor Data
  ret = c.poll(&amp;fds, 1, -1);

  // Check if Sensor Data is available
  if (ret &lt;= 0) {
    std.log.err(&quot;Sensor data not available&quot;, .{});
    return error.DataError;
  }
</code></pre></div>
<p>We‚Äôre finally ready to read the Sensor Data!</p>
<h2 id="read-sensor-data"><a href="#read-sensor-data">2.6 Read Sensor Data</a></h2>
<p>We <strong>allocate a buffer</strong> (on the stack) to receive the Sensor Data‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Define the Sensor Data Type
  var sensor_data = std.mem.zeroes(
    c.struct_sensor_baro
  );
  // Size of the Sensor Data
  const len = @sizeOf(
    @TypeOf(sensor_data)
  );
</code></pre></div>
<p><strong>std.mem.zeroes</strong> returns a <strong>sensor_baro</strong> Struct, initialised with nulls.</p>
<p>We <strong>read the Sensor Data</strong> into the struct‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Read the Sensor Data
  const read_len = c.read(fd, &amp;sensor_data, len);

  // Check size of Sensor Data
  if (read_len &lt; len) {
    std.log.err(&quot;Sensor data incorrect size&quot;, .{});
    return error.SizeError;
  }
</code></pre></div>
<p>And convert the Pressure and Temperature from Floating-Point to <strong>Fixed-Point Numbers</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Convert the Sensor Data 
  // to Fixed-Point Numbers
  const pressure = floatToFixed(
    sensor_data.pressure
  );
  const temperature = floatToFixed(
    sensor_data.temperature
  );
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sensor#appendix-fixed-point-sensor-data">(<strong>floatToFixed</strong> is explained here)</a></p>
<p>Our Fixed-Point Numbers are similar to Floating-Point Numbers, but truncated to <strong>2 Decimal Places</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/sensor#appendix-fixed-point-sensor-data">(Why we use Fixed-Point Numbers)</a></p>
<h2 id="print-sensor-data"><a href="#print-sensor-data">2.7 Print Sensor Data</a></h2>
<p>Now we have the Pressure and Temperature as Fixed-Point Numbers, let‚Äôs <strong>print the Sensor Data</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Print the Sensor Data
  debug(&quot;pressure:{}.{:0&gt;2}&quot;, .{
    pressure.int, 
    pressure.frac 
  });
  debug(&quot;temperature:{}.{:0&gt;2}&quot;, .{
    temperature.int,
    temperature.frac 
  });

  // Will be printed as...
  // pressure:1007.66
  // temperature:27.70
</code></pre></div>
<p><em>What are ‚Äúint‚Äù and ‚Äúfrac‚Äù?</em></p>
<p>Our Fixed-Point Number has two Integer components‚Ä¶</p>
<ul>
<li>
<p><strong>int</strong>: The Integer part</p>
</li>
<li>
<p><strong>frac</strong>: The Fraction part, scaled by 100</p>
</li>
</ul>
<p>So to represent <code>123.45</code>, we break it down as‚Ä¶</p>
<ul>
<li>
<p><strong>int</strong> = <code>123</code></p>
</li>
<li>
<p><strong>frac</strong> = <code>45</code></p>
</li>
</ul>
<p><em>Why print the numbers as ‚Äú<code>{}.{:0&gt;2}</code>‚Äù?</em></p>
<p>Our Format String ‚Äú<code>{}.{:0&gt;2}</code>‚Äù says‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>{}</code></td><td style="text-align: left">Print <strong>int</strong> as a number</td></tr>
<tr><td style="text-align: center"><code>.</code></td><td style="text-align: left">Print <code>.</code></td></tr>
<tr><td style="text-align: center"><code>{:0&gt;2}</code></td><td style="text-align: left">Print <strong>frac</strong> as a 2-digit number, padded at the left by <code>0</code></td></tr>
</tbody></table>
</div>
<p>Which gives us the printed output <code>123.45</code></p>
<p><a href="https://ziglearn.org/chapter-2/#formatting-specifiers">(More about Format Strings)</a></p>
<p>And we‚Äôre done reading the Temperature and Pressure from the NuttX Barometer Sensor!</p>
<p><em>Have we forgotten to close the sensor?</em></p>
<p>Remember earlier we did this‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Close the Sensor Device when 
  // this function returns
  defer {
    _ = c.close(fd);
  }
</code></pre></div>
<p>This closes the sensor automagically when we return from the function. Super handy!</p>
<p><img src="https://lupyuen.github.io/images/sensor-code3a.png" alt="Read Barometer Sensor" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L53-L145">(Source)</a></p>
<h1 id="read-humidity-sensor"><a href="#read-humidity-sensor">3 Read Humidity Sensor</a></h1>
<p><em>What about the Humidity from our BME280 Sensor?</em></p>
<p>We read the <strong>Humidity Sensor Data</strong> the exact same way as above, with a few tweaks: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L147-L234">sensortest.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read Humidity from Humidity Sensor 
/// &quot;/dev/uorb/sensor_humi0&quot;
fn test_sensor2() !void {

  // Open the Sensor Device
  const fd = c.open(
    &quot;/dev/uorb/sensor_humi0&quot;,  // Path of Sensor Device
    c.O_RDONLY | c.O_NONBLOCK    // Open for read-only
  );
</code></pre></div>
<p>In the code above we changed the <strong>path of the Sensor Device</strong>.</p>
<p>The Sensor Data Struct becomes <strong>sensor_humi</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Define the Sensor Data Type
  var sensor_data = std.mem.zeroes(
    c.struct_sensor_humi
  );
</code></pre></div>
<p>Which contains a single value for the <strong>Humidity Sensor Data</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Read the Sensor Data
  const read_len = c.read(fd, &amp;sensor_data, len);

  // Omitted: Check size of Sensor Data
  ...

  // Convert the Sensor Data 
  // to Fixed-Point Number
  const humidity = floatToFixed(
    sensor_data.humidity
  );

  // Print the Sensor Data
  debug(&quot;humidity:{}.{:0&gt;2}&quot;, .{
    humidity.int, 
    humidity.frac 
  });

  // Will be printed as...
  // humidity:78.81
</code></pre></div>
<p>And we‚Äôre done!</p>
<p><em>Where‚Äôs the list of Sensor Data Structs?</em></p>
<p>The <strong>NuttX Sensor Data Structs</strong> are defined at‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L290-L545"><strong>include/nuttx/sensors/sensor.h</strong></a></li>
</ul>
<p><em>What about the Sensor Device Names like baro0 and humi0?</em></p>
<p>Here‚Äôs the list of <strong>NuttX Sensor Device Names</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L86-L119"><strong>testing/sensortest/sensortest.c</strong></a></li>
</ul>
<p><em>How are test_sensor and test_sensor2 called?</em></p>
<p>They are called by our <strong>Zig Main Function</strong>.</p>
<p>(More about this in a while)</p>
<p><img src="https://lupyuen.github.io/images/sensor-code5a.png" alt="Import NuttX Functions, Types and Macros" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L6-L30">(Source)</a></p>
<h1 id="import-nuttx-functions"><a href="#import-nuttx-functions">4 Import NuttX Functions</a></h1>
<p><em>How do we import into Zig the NuttX Functions? open(), ioctl(), read(), ‚Ä¶</em></p>
<p>This is how we <strong>import the NuttX Functions, Types and Macros</strong> from C into Zig: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L6-L30">sensor.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the Sensor Library from C
pub const c = @cImport({
  // NuttX Defines
  @cDefine(&quot;__NuttX__&quot;,  &quot;&quot;);
  @cDefine(&quot;NDEBUG&quot;,     &quot;&quot;);
  @cDefine(&quot;ARCH_RISCV&quot;, &quot;&quot;);

  // This is equivalent to...
  // #define __NuttX__
  // #define NDEBUG
  // #define ARCH_RISCV
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#Import-from-C-Header-File">(<strong>@cImport</strong> is documented here)</a></p>
<p>At the top we set the <strong>#define Macros</strong> that will be referenced by the NuttX Header Files coming up.</p>
<p>The settings above are specific to NuttX for BL602. <a href="https://github.com/lupyuen/visual-zig-nuttx#sensor-test-app-in-c">(Because of the GCC Options)</a></p>
<p>Next comes a workaround for a <strong>C Macro Error</strong> that appears on Zig with NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Workaround for &quot;Unable to translate macro: undefined identifier `LL`&quot;
  @cDefine(&quot;LL&quot;, &quot;&quot;);
  @cDefine(&quot;__int_c_join(a, b)&quot;, &quot;a&quot;);  //  Bypass zig/lib/include/stdint.h
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-macro-error">(More about this)</a></p>
<p>Then we import the <strong>C Header Files</strong> for NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // NuttX Header Files. This is equivalent to...
  // #include &quot;...&quot;;
  @cInclude(&quot;arch/types.h&quot;);
  @cInclude(&quot;../../nuttx/include/limits.h&quot;);
  @cInclude(&quot;nuttx/sensors/sensor.h&quot;);
  @cInclude(&quot;nuttx/config.h&quot;);
  @cInclude(&quot;sys/ioctl.h&quot;);
  @cInclude(&quot;inttypes.h&quot;);
  @cInclude(&quot;unistd.h&quot;);
  @cInclude(&quot;stdlib.h&quot;);
  @cInclude(&quot;stdio.h&quot;);
  @cInclude(&quot;fcntl.h&quot;);
  @cInclude(&quot;poll.h&quot;);
});
</code></pre></div>
<p>‚Äútypes.h‚Äù and ‚Äúlimits.h‚Äù are needed for NuttX compatibility. <a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(See this)</a></p>
<p>The other includes were copied from the <strong>NuttX Sensor Test App</strong> in C: <a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L34-L42">sensortest.c</a></p>
<p><em>What about NuttX Structs like sensor_baro and sensor_humi?</em></p>
<p><strong>NuttX Structs</strong> will be automatically imported with the code above.</p>
<p>NuttX Macros like <strong>O_RDONLY</strong> and <strong>SNIOC_BATCH</strong> will get imported too.</p>
<p><em>Why do we write ‚Äú<code>c.</code>something‚Äù when we call NuttX functions? Like ‚Äúc.open()‚Äù?</em></p>
<p>Remember that we import all NuttX Functions, Types and Macros into the <strong>‚Äú<code>c</code>‚Äù Namespace</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import Functions, Types and Macros into &quot;c&quot; Namespace
pub const c = @cImport({ ... });
</code></pre></div>
<p>That‚Äôs why we write ‚Äú<code>c.</code><em>something</em>‚Äù when we refer to NuttX Functions, Types and Macros.</p>
<p><img src="https://lupyuen.github.io/images/sensor-code4a.png" alt="Main Function" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L3-L51">(Source)</a></p>
<h1 id="main-function"><a href="#main-function">5 Main Function</a></h1>
<p>One more thing before we run our Zig program: The <strong>Main Function</strong>.</p>
<p>We begin by importing the Zig Standard Library and <strong>NuttX Sensor Definitions</strong>: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L3-L51">sensortest.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the Zig Standard Library
const std = @import(&quot;std&quot;);

/// Import the NuttX Sensor Definitions
const sen = @import(&quot;./sensor.zig&quot;);

/// Import the NuttX Sensor Library
const c = sen.c;

/// Import the Multi-Sensor Module
const multi = @import(&quot;./multisensor.zig&quot;);
</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig">(<strong>sensor.zig</strong> is located here)</a></p>
<p><strong>sen.c</strong> refers to the <a href="https://lupyuen.github.io/articles/sensor#import-nuttx-functions"><strong>C Namespace</strong></a> that contains the Functions, Types and Macros imported from NuttX.</p>
<p>(We‚Äôll talk about the Multi-Sensor Module in a while)</p>
<p>Next we declare our <strong>Main Function</strong> that will be called by NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Main Function that will be called by NuttX. 
/// We read the Sensor Data from a Sensor.
pub export fn sensortest_main(
    argc: c_int, 
    argv: [*c]const [*c]u8
) c_int {

  // Quit if no args specified
  if (argc &lt;= 1) { usage(); return -1; }
</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L236-L253">(<strong>usage</strong> is defined here)</a></p>
<p><em>Why is argv declared as ‚Äú[*c]const [*c]u8‚Äù?</em></p>
<p>That‚Äôs because‚Ä¶</p>
<ul>
<li>
<p>‚Äú<strong>[*c]u8</strong>‚Äù is a C Pointer to an Unknown Number of Unsigned Bytes</p>
<p>(Like ‚Äúuint8_t *‚Äù in C)</p>
</li>
<li>
<p>‚Äú<strong>[*c]const [*c]u8</strong>‚Äù is a C Pointer to an Unknown Number of the above C Pointers</p>
<p>(Like ‚Äúuint8_t *[]‚Äù in C)</p>
</li>
</ul>
<p>So it‚Äôs roughly equivalent to ‚Äúchar **argv‚Äù in C.</p>
<p><a href="https://ziglang.org/documentation/master/#C-Pointers">(More about C Pointers in Zig)</a></p>
<p>We check the <strong>Command-Line Argument</strong> passed to our program‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Run a command like &quot;test&quot; or &quot;test2&quot;
  if (argc == 2) {

    // Convert the command to a Slice
    const cmd = std.mem.span(argv[1]);
</code></pre></div>
<p>Assume that ‚Äú<strong>argv[1]</strong>‚Äù points to ‚Äútest‚Äù, the command-line arg for our program.</p>
<p><a href="https://ziglang.org/documentation/0.9.1/std/#root;mem.span"><strong>std.mem.span</strong></a> converts ‚Äútest‚Äù to a <strong>Zig Slice</strong>.</p>
<p>Let‚Äôs pretend a Slice works like a ‚ÄúString‚Äù, we‚Äôll explain in the next section.</p>
<p>This is how we <strong>compare our Slice</strong> with a String (that‚Äôs actually another Slice)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // If the Slice is &quot;test&quot;...
    if (std.mem.eql(u8, cmd, &quot;test&quot;)) {

      // Read the Barometer Sensor
      test_sensor()
        catch { return -1; };
      return 0;
    }
</code></pre></div>
<p>So if the command-line arg is ‚Äútest‚Äù, we call <strong>test_sensor</strong> to read the Barometer Sensor. <a href="https://lupyuen.github.io/articles/sensor#read-barometer-sensor">(As seen earlier)</a></p>
<p>If <strong>test_sensor</strong> returns an Error, the <strong>catch</strong> clause says that we quit.</p>
<p>And if the command-line arg is ‚Äútest2‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // If the Slice is &quot;test2&quot;...
    else if (std.mem.eql(u8, cmd, &quot;test2&quot;)) {

      // Read the Humidity Sensor
      test_sensor2()
        catch { return -1; };
      return 0;
    }
  }
</code></pre></div>
<p>We call <strong>test_sensor2</strong> to read the Humidity Sensor. <a href="https://lupyuen.github.io/articles/sensor#read-humidity-sensor">(As seen earlier)</a></p>
<p>For other command-line args we run a <strong>Multi-Sensor Test</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Read the Sensor specified by the Command-Line Options
  multi.test_multisensor(argc, argv)
    catch |err| {

      // Handle the error
      if (err == error.OptionError or err == error.NameError) { usage(); }
      return -1;
    };

  return 0;
}
</code></pre></div>
<p>(We‚Äôll talk about Multi-Sensor Test in a while)</p>
<p>That‚Äôs all for our Main Function!</p>
<p><em>What‚Äôs ‚Äú|err|‚Äù?</em></p>
<p>If our function <strong>test_multisensor</strong> fails with an Error‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  multi.test_multisensor(argc, argv)
    catch |err| {
      // Do something with err
    }
</code></pre></div>
<p>Then <strong>err</strong> will be set to the Error returned by <strong>test_multisensor</strong>.</p>
<h1 id="slice-vs-string"><a href="#slice-vs-string">6 Slice vs String</a></h1>
<p><em>Why do we need Slices? The usual Strings are perfectly splendid right?</em></p>
<p>Strings in C (like <strong>argv[1]</strong> from the previous section) are represented like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sensor-slice1.jpg" alt="Strings in C" /></p>
<p>That‚Äôs a Pointer to an Array of characters, <strong>terminated by Null</strong>.</p>
<p><em>What if we make a mistake and overwrite the Terminating Null?</em></p>
<p>Disaster Ensues! Our String would overrun the Array and cause <strong>Undefined Behaviour</strong> when we read the String!</p>
<p>That‚Äôs why we have <strong>Slices</strong>, a safer way to represent Strings (and other buffers with dynamic sizes)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sensor-slice2.jpg" alt="Zig Slice" /></p>
<p>A Slice has two components‚Ä¶</p>
<ul>
<li>
<p><strong>Pointer</strong> to an Array of characters (or another type)</p>
</li>
<li>
<p><strong>Length</strong> of the Array (excluding the null)</p>
</li>
</ul>
<p>Because Slices are restricted by Length, it‚Äôs a little harder to overrun our Strings by accident.</p>
<p>(If we access the bytes beyond the bounds of the Slice, our program halts with a <a href="https://ziglang.org/documentation/master/#Index-out-of-Bounds"><strong>Runtime Panic</strong></a>)</p>
<p>To convert a Null-Terminated String to a Slice, we call <a href="https://ziglang.org/documentation/0.9.1/std/#root;mem.span"><strong>std.mem.span</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Convert the command-line arg to a Slice
const slice = std.mem.span(argv[1]);
</code></pre></div>
<p>And to compare two Slices, we call <strong>std.mem.eql</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// If the Slice is &quot;test&quot;...
if (std.mem.eql(u8, slice, &quot;test&quot;)) {
  ...
}
</code></pre></div>
<p><strong>u8</strong> (unsigned byte) refers to the type of data in the Slice.</p>
<p>To convert a Slice back to a C Pointer, we write <strong>&amp;slice[0]</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Pass the Slice as a C Pointer
const fd = c.open(
  &amp;slice[0], 
  c.O_RDONLY | c.O_NONBLOCK
);
// Slice must be null-terminated.
// Triggers a runtime panic if the Slice is empty.
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#Slices">(More about Slices)</a></p>
<p><img src="https://lupyuen.github.io/images/sensor-connect.jpg" alt="Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor" /></p>
<h1 id="connect-bme280-sensor"><a href="#connect-bme280-sensor">7 Connect BME280 Sensor</a></h1>
<p>For testing the Zig Sensor App, we connect the BME280 Sensor (I2C) to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a> (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL602 Pin</th><th style="text-align: center">BME280 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 1</code></strong></td><td style="text-align: center"><code>SDA</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 2</code></strong></td><td style="text-align: center"><code>SCL</code></td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong><code>3V3</code></strong></td><td style="text-align: center"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong><code>GND</code></strong></td><td style="text-align: center"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L91-L98">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN2)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN1)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<h1 id="compile-zig-app"><a href="#compile-zig-app">8 Compile Zig App</a></h1>
<p>Below are the steps to <strong>compile our Zig Sensor App</strong> for Apache NuttX RTOS and BL602 RISC-V SoC.</p>
<p>First we download the latest version of <strong>Zig Compiler</strong> (0.10.0 or later), extract it and add to PATH‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/download/"><strong>Zig Compiler Downloads</strong></a></li>
</ul>
<p>Then we download and compile <strong>Apache NuttX RTOS</strong> for BL602‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>The downloaded version of NuttX already includes our <strong>BME280 Driver</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280"><strong>‚ÄúApache NuttX Driver for BME280 Sensor‚Äù</strong></a></li>
</ul>
<p>Check that the following have been enabled in the NuttX Build‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>I2C0 Port</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>I2C Character Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>BME280 Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>Sensor Driver Test App</strong></a></p>
</li>
</ul>
<p>Remember to set <a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>‚ÄúSensor Driver Test Stack Size‚Äù</strong></a> to <strong>4096</strong>.</p>
<p>(Because our Zig App needs additional Stack Space)</p>
<p>After building NuttX, we download and compile our <strong>Zig Sensor App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Download our Zig Sensor App for NuttX
git clone --recursive https://github.com/lupyuen/visual-zig-nuttx
cd visual-zig-nuttx

##  Compile the Zig App for BL602
##  (RV32IMACF with Hardware Floating-Point)
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  sensortest.zig
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8d7a2a360bc4d14264c77f82da58b3dc">(See the Compile Log)</a></p>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p>Also specific to BL602 is the <strong>ARCH_RISCV</strong> Macro in <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L11">visual-zig-nuttx/sensor.zig</a></p>
<p><em>How did we get the Compiler Options <code>-isystem</code> and <code>-I</code>?</em></p>
<p>Remember that we‚Äôll link our Compiled Zig App into the NuttX Firmware.</p>
<p>Hence the <strong>Zig Compiler Options must be the same</strong> as the GCC Options used to compile NuttX.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#sensor-test-app-in-c">(See the GCC Options for NuttX)</a></p>
<p>Next comes a quirk specific to BL602: We must <strong>patch the ELF Header</strong> from Software Floating-Point ABI to Hardware Floating-Point ABI‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Patch the ELF Header of `sensortest.o` from 
##  Soft-Float ABI to Hard-Float ABI
xxd -c 1 sensortest.o \
  | sed &#39;s/00000024: 01/00000024: 03/&#39; \
  | xxd -r -c 1 - sensortest2.o
cp sensortest2.o sensortest.o
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/zig#patch-elf-header">(More about this)</a></p>
<p>Finally we inject our <strong>Compiled Zig App</strong> into the NuttX Project Directory and link it into the <strong>NuttX Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Copy the compiled app to NuttX and overwrite `sensortest.o`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp sensortest.o $HOME/nuttx/apps/testing/sensortest/sensortest*.o

##  Build NuttX to link the Zig Object from `sensortest.o`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make

##  For WSL: Copy the NuttX Firmware to c:\blflash for flashing
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash
</code></pre></div>
<p>We‚Äôre ready to run our Zig App!</p>
<p><img src="https://lupyuen.github.io/images/sensor-run1a.png" alt="Zig Sensor App" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#read-barometer-sensor">(Source)</a></p>
<h1 id="run-zig-app"><a href="#run-zig-app">9 Run Zig App</a></h1>
<p>Follow these steps to <strong>flash and boot NuttX</strong> (with our Zig App inside) on BL602‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#flash-nuttx"><strong>‚ÄúFlash NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#run-nuttx"><strong>‚ÄúRun NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start our Zig App‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sensortest test
</code></pre></div>
<p>Which reads the <strong>Air Pressure and Temperature</strong> from the BME280 Barometer Sensor‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest test
Zig Sensor Test
test_sensor
pressure:1007.66
temperature:27.70
</code></pre></div>
<p>This says that the Air Pressure is <strong>1,007.66 millibars</strong> and the Temperature is <strong>27.70 ¬∞C</strong>.</p>
<p>Then enter this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sensortest test2
</code></pre></div>
<p>Which reads the <strong>Humidity</strong> from the BME280 Humidity Sensor‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest test2
Zig Sensor Test
test_sensor2
humidity:78.81
</code></pre></div>
<p>This says that the Relative Humidity is <strong>78.81 %</strong>.</p>
<p>Yep our Zig Sensor App reads the Air Pressure, Temperature and Humidity correctly from BME280 Sensor yay!</p>
<p><img src="https://lupyuen.github.io/images/sensor-run2a.png" alt="Multiple Sensors" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#clean-up">(Source)</a></p>
<h1 id="multiple-sensors"><a href="#multiple-sensors">10 Multiple Sensors</a></h1>
<p><em>To test a different sensor, do we rewrite the Zig Sensor App?</em></p>
<p><em>Is there an easier way to test any NuttX Sensor?</em></p>
<p>This is how we test <strong>any NuttX Sensor</strong>, without rewriting our app‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 1 baro0
Zig Sensor Test
test_multisensor
SensorTest: Test /dev/uorb/sensor_baro0  with interval(1000000), latency(0)
value1:1007.65
value2:27.68
SensorTest: Received message: baro0, number:1/1
</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#clean-up">(Source)</a></p>
<p>Just specify the name of the Sensor Device (‚Äúbaro0‚Äù) as the Command-Line Argument.</p>
<p>(‚Äú-n 1‚Äù means read the Sensor Data once)</p>
<p>And this is how we read ‚Äúhumi0‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 1 humi0
Zig Sensor Test
test_multisensor
SensorTest: Test /dev/uorb/sensor_humi0  with interval(1000000), latency(0)
value:78.91
SensorTest: Received message: humi0, number:1/1
</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#clean-up">(Source)</a></p>
<p>From the above output we see that Air Pressure is <strong>1,007.65 millibars</strong>, Temperature is <strong>27.68 ¬∞C</strong> and Relative Humidity is <strong>78.91 %</strong>.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L236-L253">(See the Command-Line Arguments)</a></p>
<p><em>Which sensors are supported?</em></p>
<p>Here‚Äôs the list of <strong>Sensor Devices</strong> supported by the app‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L86-L119"><strong>testing/sensortest/sensortest.c</strong></a></li>
</ul>
<p>To understand the printed values (like ‚Äúvalue1‚Äù and ‚Äúvalue2‚Äù), we refer to the <strong>Sensor Data Structs</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L290-L545"><strong>include/nuttx/sensors/sensor.h</strong></a></li>
</ul>
<p><em>How does it work?</em></p>
<p>Inside our Zig Sensor App is a <strong>Multi-Sensor Module</strong> that handles all kinds of sensors‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/multisensor.zig"><strong>multisensor.zig</strong></a></li>
</ul>
<p>The Zig code was converted from the <strong>NuttX Sensor Test App</strong> in C‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c"><strong>sensortest.c</strong></a></li>
</ul>
<p>Which is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280#sensor-test-app"><strong>‚ÄúSensor Test App‚Äù</strong></a></li>
</ul>
<p>Below are the steps for converting the Sensor Test App from C to Zig‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#auto-translate-sensor-app-to-zig"><strong>Auto-Translate Sensor App to Zig</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#sensor-app-in-zig"><strong>Sensor App in Zig</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#run-zig-sensor-app"><strong>Run Zig Sensor App</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#fix-floating-point-values"><strong>Fix Floating-Point Values</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#floating-point-link-error"><strong>Floating-Point Link Error</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#fixed-point-printing"><strong>Fixed-Point Printing</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#change-to-static-buffer"><strong>Change to Static Buffer</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#incorrect-alignment"><strong>Incorrect Alignment</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#clean-up"><strong>Clean Up</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/iot-title.jpg" alt="Pine64 PineDio Stack BL604 RISC-V Board (left) talking LoRaWAN on Zig to RAKwireless WisGate LoRaWAN Gateway (right)" /></p>
<p><em>Pine64 PineDio Stack BL604 RISC-V Board (left) talking LoRaWAN on Zig to RAKwireless WisGate LoRaWAN Gateway (right)</em></p>
<h1 id="lorawan-and-visual-programming"><a href="#lorawan-and-visual-programming">11 LoRaWAN and Visual Programming</a></h1>
<p><em>Once again‚Ä¶ Why are we doing this in Zig?</em></p>
<p>We said earlier that Zig is super helpful for <strong>writing safer programs</strong> because it catches problems at runtime: Overflow, Underflow, Array Out-of-Bounds and more. <a href="https://ziglang.org/documentation/master/#Undefined-Behavior">(See the list)</a></p>
<p>And we plan to use the Zig code in this article for upcoming <strong>LoRaWAN and Visual Programming</strong> projects.</p>
<p><em>Isn‚Äôt LoRaWAN the long-range, low-power, low-bandwidth Wireless Network for IoT Gadgets?</em></p>
<p>Yep we have previously created a Zig app for the <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN Wireless Network</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></li>
</ul>
<p>Now we can integrate the Sensor Code from this article‚Ä¶ To create the firmware for an IoT Gadget that actually <strong>transmits real Sensor Data</strong>!</p>
<p>We‚Äôll compress the Sensor Data with <strong>CBOR</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor2"><strong>‚ÄúEncode Sensor Data with CBOR on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p>And monitor the Sensor Data with <strong>Prometheus and Grafana</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/prometheus"><strong>‚ÄúMonitor IoT Devices in The Things Network with Prometheus and Grafana‚Äù</strong></a></li>
</ul>
<p><em>And this LoRaWAN App will work for all kinds of NuttX Sensors?</em></p>
<p>Righto our Zig LoRaWAN App will eventually support <strong>all types of NuttX Sensors</strong>.</p>
<p>But we‚Äôve seen today that each kind of NuttX Sensor needs a lot of <strong>boilerplate code</strong> (and error handling) to support every sensor.</p>
<p><em>Can we auto-generate the boilerplate code for each NuttX Sensor?</em></p>
<p>I‚Äôm about to experiment with <strong>Visual Programming</strong> for NuttX Sensors.</p>
<p>Perhaps we can <a href="https://github.com/lupyuen3/blockly-zig-nuttx"><strong>drag-n-drop a NuttX Sensor</strong></a> into our LoRaWAN App‚Ä¶</p>
<p>And <strong>auto-generate the Zig code</strong> for the NuttX Sensor! (Pic below)</p>
<p>That would be an awesome way to mix-n-match various NuttX Sensors for IoT Gadgets!</p>
<p><img src="https://lupyuen.github.io/images/sensor-visual.jpg" alt="Visual Programming for Zig with NuttX Sensors" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx">(Source)</a></p>
<h1 id="whats-next"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>I hope you find this article helpful for creating your own Sensor App. Lemme know what you‚Äôre building!</p>
<p>In the coming weeks I shall <a href="https://github.com/lupyuen3/blockly-zig-nuttx"><strong>customise Blockly</strong></a> to auto-generate the Zig Sensor App. Someday we‚Äôll create Sensor Apps the drag-n-drop way!</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></li>
</ul>
<p>To learn more about Zig, check out these tips‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinephone#appendix-learning-zig"><strong>‚ÄúLearning Zig‚Äù</strong></a></li>
</ul>
<p>See my earlier work on Zig, NuttX, LoRaWAN and LVGL‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/zig"><strong>‚ÄúZig on RISC-V BL602: Quick Peek with Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl"><strong>‚ÄúBuild an LVGL Touchscreen App with Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/Zig/comments/warst3/read_nuttx_sensor_data_with_zig/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sensor.md"><strong>lupyuen.github.io/src/sensor.md</strong></a></p>
<h1 id="notes"><a href="#notes">13 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1548909434440585216"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>The design of the <strong>NuttX Sensor API</strong> is discussed here‚Ä¶</p>
<p><a href="https://github.com/apache/nuttx/pull/2039"><strong>‚ÄúUnified Management for Sensor‚Äù</strong></a></p>
</li>
<li>
<p>Our Zig App includes a <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L281-L316"><strong>Custom Logger</strong></a> and <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L255-L279"><strong>Panic Handler</strong></a>. They are explained below‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-logging"><strong>‚ÄúLogging‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-panic-handler"><strong>‚ÄúPanic Handler‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sensor-code1a.png" alt="Converting to fixed-point number" /></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L39-L49">(Source)</a></p>
<h1 id="appendix-fixed-point-sensor-data"><a href="#appendix-fixed-point-sensor-data">14 Appendix: Fixed-Point Sensor Data</a></h1>
<p><em>How do we use Fixed-Point Numbers for Sensor Data?</em></p>
<p>Our Zig Sensor App reads Sensor Data as <strong>Floating-Point Numbers</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sensor#read-sensor-data"><strong>‚ÄúRead Sensor Data‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sensor#print-sensor-data"><strong>‚ÄúPrint Sensor Data‚Äù</strong></a></p>
</li>
</ul>
<p>And converts the Sensor Data to <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic"><strong>Fixed-Point Numbers</strong></a> (2 decimal places) for printing‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Convert Pressure to a Fixed-Point Number
const pressure = floatToFixed(
  sensor_data.pressure
);

// Print the Pressure as a Fixed-Point Number
debug(&quot;pressure:{}.{:0&gt;2}&quot;, .{
  pressure.int, 
  pressure.frac 
});
</code></pre></div>
<p>(More about <strong>floatToFixed</strong> in a while)</p>
<p>(Someday we might simplify the printing with <a href="https://ziglearn.org/chapter-2/#formatting"><strong>Custom Formatting</strong></a>)</p>
<p><strong>UPDATE:</strong> We no longer need to call <strong>floatToFixed</strong> when printing only one Floating-Point Number. The Debug Logger auto-converts it to Fixed-Point for us. <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L266-L294">(See this)</a></p>
<p><em>What are ‚Äúint‚Äù and ‚Äúfrac‚Äù?</em></p>
<p>Our Fixed-Point Number has two Integer components‚Ä¶</p>
<ul>
<li>
<p><strong>int</strong>: The Integer part</p>
</li>
<li>
<p><strong>frac</strong>: The Fraction part, scaled by 100</p>
</li>
</ul>
<p>So to represent <code>123.456</code>, we break it down as‚Ä¶</p>
<ul>
<li>
<p><strong>int</strong> = <code>123</code></p>
</li>
<li>
<p><strong>frac</strong> = <code>45</code></p>
</li>
</ul>
<p>We drop the final digit <code>6</code> when we convert to Fixed-Point.</p>
<p><em>Why handle Sensor Data as Fixed-Point Numbers? Why not Floating-Point?</em></p>
<p>When we tried printing the Sensor Data as Floating-Point Numbers, we hit some <strong>Linking and Runtime Issues</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#fix-floating-point-values"><strong>‚ÄúFix Floating-Point Values‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#floating-point-link-error"><strong>‚ÄúFloating-Point Link Error‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#fixed-point-printing"><strong>‚ÄúFixed-Point Printing‚Äù</strong></a></p>
</li>
</ul>
<p>Computations on Floating-Point Numbers are OK, only printing is affected. So we print the numbers as Fixed-Point instead.</p>
<p>(We observed these issues with Zig Compiler version 0.10.0, they might have been fixed in later versions of the compiler)</p>
<p><em>Isn‚Äôt our Sensor Data less precise in Fixed-Point?</em></p>
<p>Yep we lose some precision with Fixed-Point Numbers. (Like the final digit <code>6</code> from earlier)</p>
<p>But most IoT Gadgets will <strong>truncate Sensor Data</strong> before transmission anyway.</p>
<p>And for some data formats (like CBOR), we need <strong>fewer bytes</strong> to transmit Fixed-Point Numbers instead of Floating-Point‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor2#floating-point-numbers"><strong>‚ÄúFloating-Point Numbers (CBOR)‚Äù</strong></a></li>
</ul>
<p>Thus we‚Äôll probably stick to Fixed-Point Numbers for our upcoming IoT projects.</p>
<p><em>How do we convert Floating-Point to Fixed-Point?</em></p>
<p>Below is the implementation of <strong>floatToFixed</strong>, which receives a Floating-Point Number and returns the Fixed-Point Number (as a Struct): <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L39-L49">sensor.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Convert the float to a fixed-point number (`int`.`frac`) with 2 decimal places.
/// We do this because `debug` has a problem with floats.
pub fn floatToFixed(f: f32) struct { int: i32, frac: u8 } {
  const scaled = @floatToInt(i32, f * 100.0);
  const rem = @rem(scaled, 100);
  const rem_abs = if (rem &lt; 0) -rem else rem;
  return .{
    .int  = @divTrunc(scaled, 100),
    .frac = @intCast(u8, rem_abs),
  };
}
</code></pre></div>
<p>(See the docs: <a href="https://ziglang.org/documentation/master/#floatToInt"><strong>@floatToInt</strong></a>, <a href="https://ziglang.org/documentation/master/#rem"><strong>@rem</strong></a>, <a href="https://ziglang.org/documentation/master/#divTrunc"><strong>@divTrunc</strong></a>, <a href="https://ziglang.org/documentation/master/#intCast"><strong>@intCast</strong></a>)</p>
<p>This code has been tested for positive and negative numbers.</p>
<h1 id="appendix-updates-to-nuttx-sensor-api"><a href="#appendix-updates-to-nuttx-sensor-api">15 Appendix: Updates to NuttX Sensor API</a></h1>
<p>This section describes the changes in the <strong>NuttX Sensor API</strong> for Jul / Aug 2022. We have updated the code in this article for these changes‚Ä¶</p>
<ul>
<li>
<p><strong>Device Paths</strong> for NuttX Sensors have been changed from ‚Äú/dev/sensor/*‚Äù to ‚Äú/dev/uorb/sensor_*‚Äù</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/commit/ac23df5d3a4770683f82a605df9db0a3c93d5755#diff-79d9791db74e17ca2e00fa8511bf05743260815e5a7834237dbbcd0e6a5bae53">(See the changes)</a></p>
</li>
<li>
<p><strong>Sensor Structs</strong> have been renamed from <code>sensor_event_*</code> to <code>sensor_*</code></p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/commit/06e776d2e96e49c1f1b7594b2ff1d1c5617450a6">(See the changes)</a></p>
</li>
<li>
<p><strong>Activate / Deactivate Sensor (SNIOC_ACTIVATE)</strong> is no longer needed</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/commit/5064ad014d84989f6461da6720b8b53a9b29194c">(See the changes)</a></p>
</li>
<li>
<p><strong>Sensor Batch (SNIOC_BATCH)</strong> now accepts a Latency Value instead of a Pointer</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/commit/5753856d345783383fedb7a8313b9b58b5cef5d3">(See the changes)</a></p>
</li>
<li>
<p><strong>Sensor Interval (SNIOC_SET_INTERVAL)</strong> now accepts an Interval Value instead of a Pointer</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/commit/783047f74d921917b55566a85c86361bf02b46b6">(See the changes)</a></p>
</li>
<li>
<p><strong>SNIOC_SET_INTERVAL</strong> was previously defined twice with different values. This has been fixed.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/commit/62295db3a7dfdaed3fb11607c43f15a00b3e0523">(See the changes)</a></p>
</li>
</ul>
<p>Our BME280 Driver has also been updated for the new Sensor API‚Ä¶</p>
<ul>
<li>
<p><strong>Sensor Operations (sensor_ops_s)</strong> now include a Struct File parameter</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/commit/30755ca105d741b44d8889485b5f209183fffe35">(See the changes)</a></p>
</li>
<li>
<p><strong>Set Interval (bme280_set_interval)</strong> now accepts an unsigned long pointer (previously unsigned int pointer)</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/commit/3923cf436886fd5260932d880d818b8b9cc4bc31">(See the changes)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/sensor-title2.jpg" alt="Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor" /></p>

    
</body>
</html>