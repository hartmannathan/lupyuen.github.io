<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Star64 JH7110 + NuttX RTOS: RISC-V PLIC Interrupts and Serial I/O</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Star64 JH7110 + NuttX RTOS: RISC-V PLIC Interrupts and Serial I/O" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX RTOS on Pine64's Star64 JH7110 RISC-V SBC has a problem with Serial I/O Interrupts and the RISC-V Platform-Level Interrupt Controller (PLIC)... Let's fix this!"
    data-rh="true">
<meta name="description" 
    content="Apache NuttX RTOS on Pine64's Star64 JH7110 RISC-V SBC has a problem with Serial I/O Interrupts and the RISC-V Platform-Level Interrupt Controller (PLIC)... Let's fix this!">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/plic-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Star64 JH7110 + NuttX RTOS: RISC-V PLIC Interrupts and Serial I/O</h1>
    <nav id="TOC"><ul>
<li><a href="#no-console-output-from-nuttx-apps">1 No Console Output from NuttX Apps</a><ul></ul></li>
<li><a href="#serial-output-in-nuttx-qemu">2 Serial Output in NuttX QEMU</a><ul></ul></li>
<li><a href="#serial-input-in-nuttx-qemu">3 Serial Input in NuttX QEMU</a><ul></ul></li>
<li><a href="#star64-vs-qemu-serial-io">4 Star64 vs QEMU Serial I/O</a><ul></ul></li>
<li><a href="#star64-uart-interrupt">5 Star64 UART Interrupt</a><ul></ul></li>
<li><a href="#platform-level-interrupt-controller-for-star64">6 Platform-Level Interrupt Controller for Star64</a><ul>
<li><a href="#plic-memory-map">6.1 PLIC Memory Map</a><ul></ul></li>
<li><a href="#initialise-interrupts">6.2 Initialise Interrupts</a><ul></ul></li>
<li><a href="#enable-interrupts">6.3 Enable Interrupts</a><ul></ul></li>
<li><a href="#claim-and-complete-interrupts">6.4 Claim and Complete Interrupts</a><ul></ul></li></ul></li>
<li><a href="#delegate-machine-mode-interrupts-to-supervisor-mode">7 Delegate Machine-Mode Interrupts to Supervisor-Mode</a><ul></ul></li>
<li><a href="#nuttx-star64-handles-uart-interrupts">8 NuttX Star64 handles UART Interrupts</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>8 Aug 2023</em></p>
<p><img src="https://lupyuen.github.io/images/plic-title.jpg" alt="Platform-Level Interrupt Controller in JH7110 (U74) SoC" /></p>
<p>We‚Äôre almost ready with our barebones port of <a href="https://lupyuen.github.io/articles/nuttx2"><strong>Apache NuttX Real-Time Operating System</strong></a> (RTOS) to <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> 64-bit RISC-V Single-Board Computer! (Pic below)</p>
<p>(Based on <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p>In this article, we find out‚Ä¶</p>
<ul>
<li>
<p>Why there‚Äôs <strong>No Console Output</strong> from NuttX Apps</p>
</li>
<li>
<p>How <strong>Serial I/O</strong> works in NuttX QEMU</p>
</li>
<li>
<p>How UART I/O differs for <strong>Star64 vs QEMU</strong></p>
</li>
<li>
<p>What‚Äôs the RISC-V <strong>Platform-Level Interrupt Controller</strong> (PLIC)</p>
</li>
<li>
<p>Why we delegate RISC-V <strong>Machine-Mode Interrupts to Supervisor-Mode</strong></p>
</li>
<li>
<p>How NuttX Star64 handles <strong>UART Interrupts</strong></p>
</li>
<li>
<p>Which leads to a new problem: 16550 UART Controller fires too many <strong>Spurious Interrupts</strong>!</p>
<p><a href="https://youtu.be/TdSJdiQFsv8">(Watch the Demo on YouTube)</a></p>
</li>
</ul>
<p>We‚Äôll see later that <strong>NuttX Shell</strong> actually works fine! It‚Äôs just very very slooow because of the Spurious Interrupts.</p>
<p><img src="https://lupyuen.github.io/images/nuttx2-title.jpg" alt="Star64 RISC-V SBC" /></p>
<h1 id="no-console-output-from-nuttx-apps"><a href="#no-console-output-from-nuttx-apps">1 No Console Output from NuttX Apps</a></h1>
<p>At the end of <a href="https://lupyuen.github.io/articles/semihost"><strong>our previous article</strong></a>, NuttX seems to boot fine on Star64 (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
123067DFHBCI
nx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
board_late_initialize: 
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nx_start_application: ret=3
up_exit: TCB=0x404088d0 exiting
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64c-0.0.1">(See the <strong>Output Log</strong>)</a></p>
<p>But <strong>NuttX Shell</strong> doesn‚Äôt appear!</p>
<p><em>Maybe NuttX Shell wasn‚Äôt started correctly?</em></p>
<p>Let‚Äôs find out! When NuttX Apps (and NuttX Shell) print to the Serial Console (via <strong>printf</strong>), this function will be called in the NuttX Kernel: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a></p>
<p>Thus we add Debug Logs to <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a>. Something interesting happens‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>uart_write (0xc000a610):
0000  0a 4e 75 74 74 53 68 65 6c 6c 20 28 4e 53 48 29  .NuttShell (NSH)
0010  20 4e 75 74 74 58 2d 31 32 2e 30 2e 33 0a         NuttX-12.0.3.  

uart_write (0xc0015338):
0000  6e 73 68 3e 20                                   nsh&gt;            

uart_write (0xc0015310):
0000  1b 5b 4b                                         .[K             
</code></pre></div>
<p>This says that NuttX Shell is actually started!</p>
<p>Just that NuttX Shell <strong>couldn‚Äôt produce any Console Output</strong>.</p>
<p><em>But we see other messages from NuttX Kernel!</em></p>
<p>That‚Äôs because NuttX Kernel doesn‚Äôt call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a> to print messages.</p>
<p>Instead, NuttX Kernel calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1730-L1765"><strong>up_putc</strong></a>. Which calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1657-L1672"><strong>u16550_putc</strong></a> to write directly to the UART Output Register.</p>
<p><em>So uart_write is a lot more sophisticated than up_putc?</em></p>
<p>Yep NuttX Apps will (indirectly) call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a> to do Serial I/O with <strong>Buffering and Interrupts</strong>.</p>
<p>Hence <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a> is somehow broken for all NuttX Apps on Star64.</p>
<p>Let‚Äôs find out why‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/semihost-runstar64.png" alt="NuttX Star64 with Initial RAM Disk" /></p>
<h1 id="serial-output-in-nuttx-qemu"><a href="#serial-output-in-nuttx-qemu">2 Serial Output in NuttX QEMU</a></h1>
<p><em>What happens in NuttX Serial Output?</em></p>
<p>To understand how NuttX Apps print to the Serial Console (via <strong>printf</strong>), we add Debug Logs to <strong>NuttX QEMU</strong> (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ABC
nx_start: Entry
up_irq_enable: 
up_enable_irq: irq=17, RISCV_IRQ_SOFT=17

uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
up_enable_irq: irq=35, extirq=10, RISCV_IRQ_EXT=25
work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
up_exit: TCB=0x802088d0 exiting
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#uart-output-in-nuttx-qemu">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq.c#L149-L204">(<strong>up_enable_irq</strong> is defined here)</a></p>
<p>In the log above, NuttX QEMU enables UART Interrupts at <strong>NuttX IRQ 35</strong>. </p>
<p>(Equivalent to <strong>RISC-V IRQ 10</strong>, with IRQ Offset of 25)</p>
<p>Then <strong>NuttX Shell</strong> runs in QEMU‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$%&amp;riscv_doirq: irq=8
$%&amp;riscv_doirq: irq=8
$%&amp;riscv_doirq: irq=8
...
$%&amp;riscv_doirq: irq=8
$%&amp;riscv_doirq: irq=8
$%&amp;riscv_doirq: irq=8
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/common/riscv_doirq.c#L58-L131">(<strong>riscv_doirq</strong> is defined here)</a></p>
<p><strong>NuttX IRQ 8</strong> appears frequently in our log. That‚Äôs for <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/include/irq.h#L52-L74"><strong>RISCV_IRQ_ECALLU</strong></a>: ECALL from RISC-V User Mode to Supervisor Mode.</p>
<p>This happens when our NuttX App (in User Mode) makes a <strong>System Call</strong> to NuttX Kernel (in Supervisor Mode).</p>
<p>Like for printing to the <strong>Serial Console</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>uart_write (0xc000a610):
0000  0a 4e 75 74 74 53 68 65 6c 6c 20 28 4e 53 48 29  .NuttShell (NSH)
0010  20 4e 75 74 74 58 2d 31 32 2e 30 2e 33 0a         NuttX-12.0.3.  
</code></pre></div>
<p>Then this Alphabet Soup appears‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEF
FNFuFtFtFSFhFeFlFlF F(FNFSFHF)F FNFuFtFtFXF-F1F2F.F0F.F3F
</code></pre></div>
<p>This says that the NuttX Kernel calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a> (print to Serial Console), which calls‚Ä¶</p>
<p>[<code>A</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L150-L286"><strong>uart_putxmitchar</strong></a> (write to Serial Buffer), which calls‚Ä¶</p>
<p>[<code>D</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L42-L107"><strong>uart_xmitchars</strong></a> (print the Serial Buffer), which calls‚Ä¶</p>
<p>[<code>E</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L63-L68"><strong>uart_txready</strong></a> (check for UART ready) and‚Ä¶</p>
<p>[<code>F</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1572-L1587"><strong>u16550_send</strong></a> (write to UART output)</p>
<p>And that‚Äôs what happens when a NuttX App prints to the Serial Console (via <strong>printf</strong>)‚Ä¶</p>
<ol>
<li>
<p>NuttX App (in User Mode) makes a <strong>System Call</strong> to NuttX Kernel (in Supervisor Mode)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341">(<strong>uart_write</strong>)</a></p>
</li>
<li>
<p>NuttX Kernel writes the output to the <strong>Serial Buffer</strong></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L150-L286">(<strong>uart_putxmitchar</strong>)</a></p>
</li>
<li>
<p>NuttX Kernel <strong>reads the Serial Buffer</strong>, one character at a time‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L42-L107">(<strong>uart_xmitchars</strong>)</a> </p>
</li>
<li>
<p>If the <strong>UART Transmit Status</strong> is ready‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L63-L68">(<strong>uart_txready</strong>)</a></p>
</li>
<li>
<p>Write the character to <strong>UART Output</strong></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1572-L1587">(<strong>u16550_send</strong>)</a></p>
</li>
</ol>
<p><em>What if UART Transmit Status is NOT ready?</em></p>
<p>UART will trigger a <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1587-L1628"><strong>Transmit Ready Interrupt</strong></a> when it‚Äôs ready to transmit more data.</p>
<p>When this happens, our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1004-L1013"><strong>UART Interrupt Handler</strong></a> will call <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L42-L107"><strong>uart_xmitchars</strong></a> to send the Serial Buffer.</p>
<p>(Which loops back to steps above)</p>
<p>Now we do Serial Input‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic-qemu.png" alt="Serial I/O in NuttX QEMU" /></p>
<h1 id="serial-input-in-nuttx-qemu"><a href="#serial-input-in-nuttx-qemu">3 Serial Input in NuttX QEMU</a></h1>
<p><em>What happens when we type something in NuttX QEMU?</em></p>
<p>Typing something in the Serial Console will trigger a <strong>UART Interrupt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$%^&amp;
riscv_doirq: irq=35
#*
ADEFa
$%&amp;
riscv_doirq: irq=8
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#uart-output-in-nuttx-qemu">(See the <strong>Complete Log</strong>)</a></p>
<p>That triggers a call to‚Ä¶</p>
<ul>
<li>
<p>[<code>$</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ramdisk2/arch/risc-v/src/common/riscv_exception_common.S#L63-L189"><strong>exception_common</strong></a> (RISC-V Exception Handler) which calls‚Ä¶</p>
</li>
<li>
<p>[<code>%^&amp;</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c#L51-L92"><strong>riscv_dispatch_irq</strong></a> (Dispatch QEMU Interrupt), which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/common/riscv_doirq.c#L58-L131"><strong>riscv_doirq</strong></a> (Dispatch RISC-V Interrupt), which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/sched/irq/irq_dispatch.c#L112-L191"><strong>irq_dispatch</strong></a> (Dispatch NuttX Interrupt), which calls‚Ä¶</p>
</li>
<li>
<p>[<code>#</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L918-L1004"><strong>u16550_interrupt</strong></a> (UART Interrupt Handler), which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L109-L270"><strong>uart_recvchars</strong></a> (write to Serial Receive Buffer)</p>
</li>
</ul>
<p>Looks complicated, but that‚Äôs how Serial I/O works with Buffering and Interrupts in NuttX!</p>
<p><em>Why 2 Interrupts? IRQ 35 and IRQ 8?</em></p>
<ul>
<li>
<p><strong>NuttX IRQ 35</strong> (RISC-V IRQ 10) is the <strong>QEMU UART Interrupt</strong> that‚Äôs triggered when a character is received</p>
<p>(That‚Äôs us typing something)</p>
</li>
<li>
<p><strong>NuttX IRQ 8</strong> <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/include/irq.h#L52-L74">(<strong>RISCV_IRQ_ECALLU</strong>)</a> happens when a NuttX App makes a <strong>System Call</strong> to NuttX Kernel</p>
<p>(NuttX Shell calls NuttX Kernel to echo the key pressed)</p>
</li>
</ul>
<p>Now we compare the above QEMU Log with Star64‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic-star64.png" alt="NuttX Star64 Debug Log" /></p>
<h1 id="star64-vs-qemu-serial-io"><a href="#star64-vs-qemu-serial-io">4 Star64 vs QEMU Serial I/O</a></h1>
<p><em>Earlier we said that NuttX Star64 couldn‚Äôt print to Serial Console. Why?</em></p>
<p>Let‚Äôs observe the <strong>Star64 Debug Log</strong> (and compare with QEMU Log)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>up_enable_irq:
  irq=57
  extirq=32
  RISCV_IRQ_EXT=25
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#compare-uart-output-star64-vs-qemu">(See the <strong>Complete Log</strong>)</a></p>
<p>NuttX Star64 now enables <strong>UART Interrupts</strong> at NuttX IRQ 57. (RISC-V IRQ 32)</p>
<p>(More about this in the next section)</p>
<p>We see NuttX Shell making <strong>System Calls</strong> to NuttX Kernel (via NuttX IRQ 8)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$%&amp;riscv_doirq: irq=8
...
$%&amp;riscv_doirq: irq=8
</code></pre></div>
<p>Then NuttX Shell tries to <strong>print to Serial Output</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>uart_write (0xc0015338):
0000  6e 73 68 3e 20                                   nsh&gt;            

AAAAAD
</code></pre></div>
<p>From the QEMU Log, we know that <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1172-L1341"><strong>uart_write</strong></a> (print to Serial Console) calls‚Ä¶</p>
<ul>
<li>
<p>[<code>A</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L150-L286"><strong>uart_putxmitchar</strong></a> (write to Serial Buffer), which calls‚Ä¶</p>
</li>
<li>
<p>[<code>D</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L42-L107"><strong>uart_xmitchars</strong></a> (print the Serial Buffer), but wait‚Ä¶</p>
</li>
</ul>
<p><em>Something looks different from QEMU?</em></p>
<p>Yeah these are missing from the Star64 Log‚Ä¶</p>
<ul>
<li>
<p>[<code>E</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L63-L68"><strong>uart_txready</strong></a> (check for UART ready) and‚Ä¶</p>
</li>
<li>
<p>[<code>F</code>] <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1572-L1587"><strong>u16550_send</strong></a> (write to UART output)</p>
</li>
</ul>
<p>Which means that UART is <strong>NOT ready to transmit</strong>!</p>
<p><em>What happens next?</em></p>
<p>We said earlier that UART will trigger a <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1587-L1628"><strong>Transmit Ready Interrupt</strong></a> when it‚Äôs ready to transmit more data.</p>
<p>(Which triggers our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L1004-L1013"><strong>UART Interrupt Handler</strong></a> that calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial_io.c#L42-L107"><strong>uart_xmitchars</strong></a> to send more data)</p>
<p>But NuttX IRQ 57 is <strong>never triggered</strong> in the Star64 Log!</p>
<p>Thus there‚Äôs our problem: NuttX on Star64 won‚Äôt print to the Serial Output because <strong>UART Interrupts are never triggered</strong>.</p>
<p>(NuttX Star64 won‚Äôt respond to keypresses either)</p>
<p><em>There‚Äôs a problem with our Interrupt Controller?</em></p>
<p>We checked the Star64 <strong>Interrupt Settings</strong> and <strong>Memory Map</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-09f20ae7a4a374d390f5f93d478e820039f86256f7cdcce609996c9f99c71501"><strong>irq.h</strong></a>: Map RISC-V IRQ to NuttX IRQ</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-1d49cde8904f634c8963839554b7b626fd9083cf4205814b4e949630dc0a7dda"><strong>qemu_rv_memorymap.h</strong></a>: PLIC Address</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-0cb58f007c24e42ac3f868ec24239c5e1863ebbb72dfb995840bc9b80ad82723"><strong>board_memorymap.h</strong></a>: Memory Map</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-4018c37bf9b08236b37a84273281d5511d48596be9e0e4c0980d730aa95dbbe8"><strong>knsh64/defconfig</strong></a>: Memory Configuration</p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/u74_memory_map.html">(See the <strong>JH7110 U74 Memory Map</strong>)</a></p>
</li>
</ul>
<p>But everything looks OK!</p>
<p>Maybe we got the wrong UART IRQ Number? Let‚Äôs verify‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic-interrupts.jpg" alt="JH7110 Global Interrupts" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/interrupt_connections.html"><em>JH7110 Global Interrupts</em></a></p>
<h1 id="star64-uart-interrupt"><a href="#star64-uart-interrupt">5 Star64 UART Interrupt</a></h1>
<p><em>Is the UART IRQ Number correct?</em></p>
<p>According to the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html"><strong>JH7110 UART Doc</strong></a>, the UART Interrupt is at <strong>RISC-V IRQ 32</strong>‚Ä¶</p>
<p>Which becomes NuttX IRQ 57. (Offset by 25)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/include/irq.h#L75-L86">(See <strong>RISCV_IRQ_SEXT</strong>)</a></p>
<p>That‚Äôs why we configure the <strong>NuttX UART IRQ</strong> like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/boards/risc-v/qemu-rv/rv-virt/configs/knsh64/defconfig#L10-L17">knsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_UART0_IRQ=57
</code></pre></div>
<p><em>Is it the same UART IRQ as Linux?</em></p>
<p>We dumped the <strong>Linux Device Tree</strong> for JH7110‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Convert Device Tree to text format
dtc \
  -o jh7110-visionfive-v2.dts \
  -O dts \
  -I dtb \
  jh7110-visionfive-v2.dtb
</code></pre></div>
<p><a href="https://manpages.ubuntu.com/manpages/xenial/man1/dtc.1.html">(<strong>dtc</strong> decompiles a Device Tree)</a></p>
<p><strong>Linux Port UART0</strong> is indeed at RISC-V IRQ 32: <a href="https://github.com/lupyuen/nuttx-star64/blob/main/jh7110-visionfive-v2.dts#L619-L631">jh7110-visionfive-v2.dts</a></p>
<div class="example-wrap"><pre class="language-text"><code>serial@10000000 {
  compatible = &quot;snps,dw-apb-uart&quot;;
  reg = &lt;0x00 0x10000000 0x00 0x10000&gt;;
  reg-io-width = &lt;0x04&gt;;
  reg-shift = &lt;0x02&gt;;
  clocks = &lt;0x08 0x92 0x08 0x91&gt;;
  clock-names = &quot;baudclk\0apb_pclk&quot;;
  resets = &lt;0x21 0x53 0x21 0x54&gt;;
  interrupts = &lt;0x20&gt;;
  status = &quot;okay&quot;;
  pinctrl-names = &quot;default&quot;;
  pinctrl-0 = &lt;0x24&gt;;
};
</code></pre></div>
<p><em>What about the Global Interrupt Number?</em></p>
<p>According to the doc on <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/interrupt_connections.html"><strong>JH7110 Interrupt Connections</strong></a>, <strong>u0_uart</strong>	is at <strong>global_interrupts[27]</strong> (pic above).</p>
<p>Which is correct because the <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf"><strong>SiFive U74 Manual</strong></a> (Page 198) says that‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>RISC-V IRQ = Global Interrupt Number + 5
</code></pre></div>
<p><em>Maybe IRQ 32 is too high? (QEMU UART IRQ is only 10)</em></p>
<p>The doc on <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/interrupt_connections.html"><strong>JH7110 Interrupt Connections</strong></a> says that Global Interrupts are numbered <strong>0 to 126</strong>. (127 total interrupts) </p>
<p>That‚Äôs a lot more than NuttX QEMU can handle. So we patched it‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-09f20ae7a4a374d390f5f93d478e820039f86256f7cdcce609996c9f99c71501"><strong>irq.h</strong></a>: Increase to 127 IRQs</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-4d2def434fc283670f9b60826a12a9396787759b45aa156a4b6764c1a73fb0e4"><strong>qemu_rv_irq.c</strong></a>: Initialise 127 IRQs</p>
</li>
</ul>
<p>Though some parts are <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-4d2def434fc283670f9b60826a12a9396787759b45aa156a4b6764c1a73fb0e4"><strong>hardcoded to 64 IRQs</strong></a>. (Needs more fixing)</p>
<p>Let‚Äôs talk about the Interrupt Controller‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic-title.jpg" alt="Platform-Level Interrupt Controller in JH7110 (U74) SoC" /></p>
<h1 id="platform-level-interrupt-controller-for-star64"><a href="#platform-level-interrupt-controller-for-star64">6 Platform-Level Interrupt Controller for Star64</a></h1>
<p><em>What‚Äôs this PLIC?</em></p>
<p>The RISC-V <strong>Platform-Level Interrupt Controller (PLIC)</strong> inside Star64 handles <strong>Global Interrupts</strong> (External Interrupts) triggered by Peripherals. (Like the UART Controller)</p>
<ul>
<li>
<p><a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf"><strong>SiFive U74-MC Core Complex Manual</strong></a></p>
<p>‚ÄúPlatform-Level Interrupt Controller‚Äù (Page 192)</p>
</li>
<li>
<p><a href="https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc"><strong>PLIC Specification</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/interrupt#generic-interrupt-controller">(PLIC works like Arm‚Äôs <strong>Global Interrupt Controller</strong>)</a></p>
</li>
</ul>
<p>The pic above shows how we may configure Star64‚Äôs PLIC to <strong>route Interrupts</strong> to each of the 5 RISC-V Cores.</p>
<p><em>Wow there are 5 RISC-V Cores in Star64?</em></p>
<p>According to the <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf"><strong>SiFive U74 Manual</strong></a> (Page 96), these are the RISC-V Cores in JH7110‚Ä¶</p>
<ul>
<li>
<p><strong>Hart 0:</strong> S7 Monitor Core (RV64IMACB)</p>
</li>
<li>
<p><strong>Harts 1 to 4:</strong> U74 Application Cores (RV64GCB)</p>
</li>
</ul>
<p>NuttX boots on the <strong>First Application Core</strong>, which is <strong>Hart 1</strong>.</p>
<p>(Though we pass the Hart ID to NuttX as Hart 0, since NuttX expects <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L104-L110"><strong>Hart ID to start at 0</strong></a>)</p>
<p><em>So we‚Äôll route Interrupts to Hart 1?</em></p>
<p>Yep, later we might add <strong>Harts 2 to 4</strong> when we boot NuttX on the other Application Cores.</p>
<p>(But probably not Hart 0, since it‚Äôs a special limited Monitor Core)</p>
<p>Let‚Äôs check our PLIC Code in NuttX‚Ä¶</p>
<h2 id="plic-memory-map"><a href="#plic-memory-map">6.1 PLIC Memory Map</a></h2>
<p><em>How do we program the PLIC?</em></p>
<p>We write to the PLIC Registers defined in the <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf"><strong>SiFive U74 Manual</strong></a> (Page 193)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: center">R/W</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: center">0C00_0004</td><td style="text-align: center">RW</td><td style="text-align: left">Source 1 Priority</td></tr>
<tr><td style="text-align: center">0C00_0220</td><td style="text-align: center">RW</td><td style="text-align: left">Source 136 Priority</td></tr>
<tr><td style="text-align: center">0C00_1000</td><td style="text-align: center">RO</td><td style="text-align: left">Start of Pending Array</td></tr>
<tr><td style="text-align: center">0C00_1010</td><td style="text-align: center">RO</td><td style="text-align: left">Last Word of Pending Array</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>Above are the PLIC Registers for <strong>Interrupt Priorities</strong> <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf">(Page 198)</a> and <strong>Interrupt Pending Bits</strong> <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf">(Page 198)</a>.</p>
<p>(Yep PLIC supports 136 Interrupts)</p>
<p>To enable (or disable) Interrupts, we write to the <strong>Interrupt Enable Registers</strong> <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf">(Page 199)</a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: center">R/W</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: center">0C00_2100</td><td style="text-align: center">RW</td><td style="text-align: left">Start of Hart 1 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2110</td><td style="text-align: center">RW</td><td style="text-align: left">End of Hart 1 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2200</td><td style="text-align: center">RW</td><td style="text-align: left">Start of Hart 2 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2210</td><td style="text-align: center">RW</td><td style="text-align: left">End of Hart 2 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2300</td><td style="text-align: center">RW</td><td style="text-align: left">Start of Hart 3 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2310</td><td style="text-align: center">RW</td><td style="text-align: left">End of Hart 3 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2400</td><td style="text-align: center">RW</td><td style="text-align: left">Start of Hart 4 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">0C00_2410</td><td style="text-align: center">RW</td><td style="text-align: left">End of Hart 4 S-Mode Interrupt Enables</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>This says that each Hart (RISC-V Core) can be programmed individually to receive Interrupts.</p>
<p>(We‚Äôll only do <strong>Hart 1 in Supervisor Mode</strong>)</p>
<p>The <strong>Priority Threshold</strong> <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf">(Page 200)</a> works like an Interrupt Mask, it suppresses Low Priority Interrupts‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: center">R/W</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: center">0C20_2000</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 1 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: center">0C20_4000</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 2 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: center">0C20_6000</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 3 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: center">0C20_8000</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 4 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>Things can get messy when <strong>Multiple Harts</strong> service Interrupts at the same time.</p>
<p>That‚Äôs why we service Interrupts in 3 steps‚Ä¶</p>
<ol>
<li>
<p><strong>Claim</strong> the Interrupt</p>
</li>
<li>
<p><strong>Handle</strong> the Interrupt</p>
</li>
<li>
<p>Mark the Interrupt as <strong>Complete</strong></p>
</li>
</ol>
<p>(If we don‚Äôt mark the Interrupt as Complete, we won‚Äôt receive any subsequent Interrupts)</p>
<p>These are the PLIC Registers to <strong>Claim and Complete Interrupts</strong> <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf">(Page 201)</a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: center">R/W</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: center">0C20_2004</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 1 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: center">0C20_4004</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 2 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: center">0C20_6004</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 3 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: center">0C20_8004</td><td style="text-align: center">RW</td><td style="text-align: left">Hart 4 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>Based on the above Memory Map, we set the PLIC Addresses in NuttX to use <strong>Hart 1 in Supervisor Mode</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/hardware/qemu_rv_plic.h#L33-L59">qemu_rv_plic.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// PLIC Addresses for NuttX Star64
// (Hart 1 in Supervisor Mode)
// | 0x0C00_0004 | RW | Source 1 priority
// | 0x0C00_1000 | RO | Start of pending array
#define QEMU_RV_PLIC_PRIORITY (QEMU_RV_PLIC_BASE + 0x000000)
#define QEMU_RV_PLIC_PENDING1 (QEMU_RV_PLIC_BASE + 0x001000)

// NuttX Star64 runs in Supervisor Mode
#ifdef CONFIG_ARCH_USE_S_MODE

// | 0x0C00_2100 | RW | Start Hart 1 S-Mode Interrupt Enables
#define QEMU_RV_PLIC_ENABLE1 (QEMU_RV_PLIC_BASE + 0x002100)
#define QEMU_RV_PLIC_ENABLE2 (QEMU_RV_PLIC_BASE + 0x002104)

// | 0x0C20_2000 | RW | Hart 1 S-Mode Priority Threshold
// | 0x0C20_2004 | RW | Hart 1 S-Mode Claim / Complete 
#define QEMU_RV_PLIC_THRESHOLD (QEMU_RV_PLIC_BASE + 0x202000)
#define QEMU_RV_PLIC_CLAIM     (QEMU_RV_PLIC_BASE + 0x202004)

// Previously for NuttX QEMU:
// #define QEMU_RV_PLIC_ENABLE1   (QEMU_RV_PLIC_BASE + 0x002080)
// #define QEMU_RV_PLIC_ENABLE2   (QEMU_RV_PLIC_BASE + 0x002084)
// #define QEMU_RV_PLIC_THRESHOLD (QEMU_RV_PLIC_BASE + 0x201000)
// #define QEMU_RV_PLIC_CLAIM     (QEMU_RV_PLIC_BASE + 0x201004)
</code></pre></div>
<p>Let‚Äôs figure out <strong>QEMU_RV_PLIC_BASE</strong>‚Ä¶</p>
<p><em>What‚Äôs the PLIC Base Address?</em></p>
<p>According to <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/u74_memory_map.html"><strong>JH7110 U74 Memory Map</strong></a>, the Base Addresses are‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Start Address</th><th style="text-align: center">End Address</th><th style="text-align: left">Device</th></tr></thead><tbody>
<tr><td style="text-align: center">0200_0000</td><td style="text-align: center">0200_FFFF</td><td style="text-align: left">CLINT</td></tr>
<tr><td style="text-align: center">0C00_0000</td><td style="text-align: center">0FFF_FFFF</td><td style="text-align: left">PLIC</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: center"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>Which are correct in NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/hardware/qemu_rv_memorymap.h#L30-L32">qemu_rv_memorymap.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Addresses of CLINT and PLIC
#define QEMU_RV_CLINT_BASE   0x02000000
#define QEMU_RV_PLIC_BASE    0x0c000000
</code></pre></div><h2 id="initialise-interrupts"><a href="#initialise-interrupts">6.2 Initialise Interrupts</a></h2>
<p>In NuttX, this is how we <strong>initialise the PLIC</strong> Interrupt Controller: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq.c#L41-L106">qemu_rv_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Initialise Interrupts for Star64
void up_irqinitialize(void) {

  // Disable Machine interrupts 
  up_irq_save();

  // Disable all global interrupts 
  // TODO: Extend to PLIC Interrupt ID 136
  putreg32(0x0, QEMU_RV_PLIC_ENABLE1);
  putreg32(0x0, QEMU_RV_PLIC_ENABLE2);

  // Set priority for all global interrupts to 1 (lowest) 
  // TODO: Extend to PLIC Interrupt ID 136
  for (int id = 1; id &lt;= NR_IRQS; id++) {
    putreg32(
      1,  // Register Value
      (uintptr_t)(QEMU_RV_PLIC_PRIORITY + 4 * id)  // Register Address
    );
  }

  // Set irq threshold to 0 (permits all global interrupts) 
  putreg32(0, QEMU_RV_PLIC_THRESHOLD);

  // Attach the common interrupt handler 
  riscv_exception_attach();

  // And finally, enable interrupts 
  up_irq_enable();
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/include/irq.h#L660-L688">(<strong>up_irq_save</strong> is defined here)</a></p>
<p>The code above calls <strong>up_irq_enable</strong> to enable RISC-V Interrupts: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq.c#L205-L220">qemu_rv_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable Interrupts
irqstate_t up_irq_enable(void) {

  // Enable external interrupts (sie) 
  SET_CSR(CSR_IE, IE_EIE);

  // Read and enable global interrupts (sie) in sstatus 
  irqstate_t oldstat = READ_AND_SET_CSR(CSR_STATUS, STATUS_IE);
  return oldstat;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/common/riscv_internal.h#L151-L155">(<strong>SET_CSR</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/common/riscv_internal.h#L139-L145">(<strong>READ_AND_SET_CSR</strong> is defined here)</a></p>
<h2 id="enable-interrupts"><a href="#enable-interrupts">6.3 Enable Interrupts</a></h2>
<p>To enable Interrupts, we configure PLIC to forward External Interrupts to <strong>Hart 1 in Supervisor Mode</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq.c#L149-L205">qemu_rv_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable the IRQ specified by &#39;irq&#39;
void up_enable_irq(int irq) {

  // For Software Interrupt:
  // Read sstatus &amp; set software interrupt enable in sie 
  if (irq == RISCV_IRQ_SOFT) {
    SET_CSR(CSR_IE, IE_SIE);

  // For Timer Interrupt:
  // Read sstatus &amp; set timer interrupt enable in sie 
  } else if (irq == RISCV_IRQ_TIMER) {
    SET_CSR(CSR_IE, IE_TIE);

  // For Machine Timer Interrupt:
  // Read sstatus &amp; set timer interrupt enable in sie 
  } else if (irq == RISCV_IRQ_MTIMER) {
    SET_CSR(mie, MIE_MTIE);

  // For External Interrupts:
  // Set enable bit for the irq 
  // TODO: Extend to PLIC Interrupt ID 136
  } else if (irq &gt; RISCV_IRQ_EXT) {
    int extirq = irq - RISCV_IRQ_EXT;
    if (0 &lt;= extirq &amp;&amp; extirq &lt;= 63) {
      modifyreg32(
        QEMU_RV_PLIC_ENABLE1 + (4 * (extirq / 32)),  // Address
        0,  // Clear Bits
        1 &lt;&lt; (extirq % 32)  // Set Bits
      );
    } else { PANIC(); }
  }
}
</code></pre></div><h2 id="claim-and-complete-interrupts"><a href="#claim-and-complete-interrupts">6.4 Claim and Complete Interrupts</a></h2>
<p>Remember that we service Interrupts in 3 steps‚Ä¶</p>
<ol>
<li>
<p><strong>Claim</strong> the Interrupt</p>
</li>
<li>
<p><strong>Handle</strong> the Interrupt</p>
</li>
<li>
<p>Mark the Interrupt as <strong>Complete</strong></p>
</li>
</ol>
<p>This is how we do it: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c#L52-L91">qemu_rv_irq_dispatch.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Dispatch the RISC-V Interrupt
void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs) {

  // For External Interrupts:
  // Claim the Interrupt
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);
  if (RISCV_IRQ_EXT == irq) {
    // Add the value to NuttX IRQ which is offset to the mext 
    uintptr_t val = getreg32(QEMU_RV_PLIC_CLAIM);
    irq += val;
  }

  // For External Interrupts:
  // Call the Interrupt Handler
  if (RISCV_IRQ_EXT != irq) {
    regs = riscv_doirq(irq, regs);
  }

  // For External Interrupts:
  // Mark the Interrupt as Completed
  if (RISCV_IRQ_EXT &lt;= irq) {
    putreg32(
      irq - RISCV_IRQ_EXT,  // Register Value
      QEMU_RV_PLIC_CLAIM    // Register Address
    );
  }
  return regs;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/common/riscv_doirq.c#L58-L131">(<strong>riscv_doirq</strong> is defined here)</a> </p>
<p>There‚Äôs also a <strong>Core-Local Interruptor (CLINT)</strong> <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf">(Page 185)</a> that handles Software Interrupt and Timer Interrupt. But we won‚Äôt cover it today. (Pic below)</p>
<p><strong>TODO:</strong> Do we need to handle CLINT?</p>
<p>Let‚Äôs check that the RISC-V Interrupts are delegated correctly‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic-clint.jpg" alt="PLIC and CLINT in JH7110 (U74) SoC" /></p>
<h1 id="delegate-machine-mode-interrupts-to-supervisor-mode"><a href="#delegate-machine-mode-interrupts-to-supervisor-mode">7 Delegate Machine-Mode Interrupts to Supervisor-Mode</a></h1>
<p><em>Why do we delegate Interrupts?</em></p>
<p>According to the <a href="https://starfivetech.com/uploads/u74mc_core_complex_manual_21G1.pdf"><strong>SiFive U74 Manual</strong></a> (Page 176)‚Ä¶</p>
<blockquote>
<p>‚ÄúBy default, all Traps are handled in <strong>Machine Mode</strong>‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúMachine Mode Software can selectively delegate Interrupts and Exceptions to <strong>Supervisor Mode</strong> by setting the corresponding bits in <strong>mideleg</strong> and <strong>medeleg</strong> CSRs‚Äù</p>
</blockquote>
<p>NuttX runs in <strong>Supervisor Mode</strong>, so we need to be sure that the <strong>Interrupts have been delegated</strong> correctly to Supervisor Mode‚Ä¶</p>
<p>Or our UART Interrupt Handler will never be called!</p>
<p><em>What‚Äôs this ‚ÄúMachine Mode Software‚Äù? Who controls the Delegation?</em></p>
<p>On Star64, <a href="https://lupyuen.github.io/articles/linux#opensbi-supervisor-binary-interface"><strong>OpenSBI (Supervisor Binary Interface)</strong></a> boots in Machine Mode and controls the Delegation of Interrupts.</p>
<p>From the <a href="https://lupyuen.github.io/articles/linux#appendix-opensbi-log-for-star64"><strong>OpenSBI Log</strong></a>, we see the value of <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-trap-delegation-registers-medeleg-and-mideleg"><strong>mideleg</strong></a> (‚ÄúDelegate Machine Interrupt‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Boot HART MIDELEG:
  0x0222
Boot HART MEDELEG:
  0xb109
</code></pre></div>
<p><em>What does mideleg say?</em></p>
<p>(Ring-ding-ding-ding-dingeringeding!)</p>
<p><strong>mideleg</strong> is defined by the following bits: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/include/csr.h#L343-L346">csr.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Bit Definition for mideleg
#define MIP_SSIP (0x1 &lt;&lt; 1)  // Delegate Software Interrupt
#define MIP_STIP (0x1 &lt;&lt; 5)  // Delegate Timer Interrupt
#define MIP_MTIP (0x1 &lt;&lt; 7)  // Delegate Machine Timer Interrupt
#define MIP_SEIP (0x1 &lt;&lt; 9)  // Delegate External Interrupts
</code></pre></div>
<p>So <strong>mideleg <code>0x0222</code></strong> means‚Ä¶</p>
<ul>
<li>
<p>Delegate <strong>Software Interrupt</strong> to Supervisor Mode (SSIP)</p>
</li>
<li>
<p>Delegate <strong>Timer Interrupt</strong> to Supervisor Mode (STIP)</p>
</li>
<li>
<p>Delegate <strong>External Interrupts</strong> to Supervisor Mode (SEIP)</p>
<p>(But not MTIP: Delegate Machine Timer Interrupt)</p>
</li>
</ul>
<p>Thus we‚Äôre good! OpenSBI has <strong>correctly delegated External Interrupts</strong> from Machine Mode to Supervisor Mode. (For NuttX to handle)</p>
<p>We‚Äôre finally ready to test the Fixed PLIC Code on Star64!</p>
<p><img src="https://lupyuen.github.io/images/plic-nsh2.png" alt="NSH on Star64" /></p>
<h1 id="nuttx-star64-handles-uart-interrupts"><a href="#nuttx-star64-handles-uart-interrupts">8 NuttX Star64 handles UART Interrupts</a></h1>
<p><em>After fixing the PLIC Interrupts on Star64‚Ä¶</em></p>
<p><em>Are UART Interrupts OK?</em></p>
<p>We fixed the <strong>PLIC Memory Map</strong> in NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/35/files#diff-913f48beaba6a00b5a78f5965892235c858ecc51e75e3c5b1f5905b6c9830f53"><strong>qemu_rv_plic.h: Fix PLIC Memory Map</strong></a></p>
<p>(Route Interrupts to Hart 1 in Supervisor Mode)</p>
</li>
</ul>
<p>UART Interrupts at <strong>NuttX IRQ 57</strong> (RISC-V IRQ 32) are now OK yay! </p>
<div class="example-wrap"><pre class="language-text"><code>up_irq_enable: 
up_enable_irq: irq=17
up_enable_irq: RISCV_IRQ_SOFT=17
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
up_enable_irq: irq=57
up_enable_irq: extirq=32, RISCV_IRQ_EXT=25
$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
...
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;riscv_doirq: irq=57
#*$%^&amp;nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#nuttx-star64-handles-uart-interrupts">(See the <strong>Complete Log</strong>)</a></p>
<p>But we have a new problem: We are getting <strong>too many UART Interrupts</strong>!</p>
<p>TODO: Are they valid UART Interrupts?</p>
<p><em>Are we Completing the Interrupt too soon? Maybe we should slow down?</em></p>
<p>Let‚Äôs slow down the Interrupt Completion with a Logging Delay: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c#L81-L88">qemu_rv_irq_dispatch.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>if (RISCV_IRQ_EXT &lt;= irq)
  {
    _info(&quot;irq=%d, RISCV_IRQ_EXT=%d\n&quot;, irq, RISCV_IRQ_EXT);////
    // Then write PLIC_CLAIM to clear pending in PLIC 
    putreg32(irq - RISCV_IRQ_EXT, QEMU_RV_PLIC_CLAIM);
  }
</code></pre></div>
<p>Seems to work better‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>123067BCnx_start: Entry
up_irq_enable: 
up_enable_irq: irq=17
up_enable_irq: RISCV_IRQ_SOFT=17
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
up_enable_irq: irq=57
up_enable_irq: extirq=32, RISCV_IRQ_EXT=25
u16550_rxint: enable=1
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
056789riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
...
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
riscv_dispatch_irq: irq=57, RISCV_IRQ_EXT=25
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p>Also we increase the System Delay (to match PinePhone):</p>
<ul>
<li>System Type &gt; Delay loops per millisecond = 116524</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_BOARD_LOOPSPERMSEC=116524
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/boards/risc-v/qemu-rv/rv-virt/configs/knsh64/defconfig#L47">(Source)</a></p>
<p><em>UART might need some time to warm up? Maybe we enable the IRQ later?</em></p>
<p>Let‚Äôs delay the enabling of IRQ to later‚Ä¶</p>
<p>We comment out the Enable IRQ in <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L860-L871">uart_16550.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>static int u16550_attach(struct uart_dev_s *dev) {
  ...
  // Attach and enable the IRQ 
  ret = irq_attach(priv-&gt;irq, u16550_interrupt, dev);
#ifndef CONFIG_ARCH_NOINTC
  if (ret == OK)
    {
      // Enable the interrupt (RX and TX interrupts are still disabled
       * in the UART 
      ////Enable Interrupt later:
      ////up_enable_irq(priv-&gt;irq);
</code></pre></div>
<p>And add it to <code>uart_write</code>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/serial.c#L1177-L1188">serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static ssize_t uart_write(FAR struct file *filep, FAR const char *buffer,
                          size_t buflen) {
  static int count = 0;
  if (count++ == 3) { up_enable_irq(57); }////
</code></pre></div>
<p>Seems better‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>123067BCnx_start: Entry
up_irq_enable: 
up_enable_irq: irq=17
up_enable_irq: RISCV_IRQ_SOFT=17
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
u16550_rxint: enable=1
work_start_lowpri: Starting low-priority kernel worker thread(s)
board_late_initialize: 
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nx_start_application: ret=3
up_exit: TCB=0x404088d0 exiting
uart_write (0xc0200428):
0000  2a 2a 2a 6d 61 69 6e 0a                          ***main.        
up_enable_irq: irq=57
up_enable_irq: extirq=32, RISCV_IRQ_EXT=25
056789056789056789056789056789056789u05678910567896056789505678950567890056789_056789t056789x056789i056789n056789t056789:056789 056789e056789n056789a056789b056789l056789e056789=0567890056789
056789056789056789A056789056789056789056789056789056789056789056789056789056789056789056789056789AAAAA056789AAA056789u05678910567896056789505678950567890056789_056789t056789x056789i056789n056789t056789:056789 056789e056789n056789a056789b056789l056789e056789=0567891056789
056789D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-
</code></pre></div>
<p>After removing the logs, NSH works OK yay!</p>
<p>Watch what happens when we enter <code>ls</code> at the NSH Shell‚Ä¶</p>
<p><a href="https://youtu.be/TdSJdiQFsv8">(Watch the Demo on YouTube)</a></p>
<div class="example-wrap"><pre class="language-text"><code>123067BCnx_start: Entry
up_irq_enable: 
up_enable_irq: irq=17
up_enable_irq: RISCV_IRQ_SOFT=17
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
board_late_initialize: 
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nx_start_application: ret=3
up_exit: TCB=0x404088d0 exiting
up_enable_irq: irq=57
up_enable_irq: extirq=32, RISCV_IRQ_EXT=25
..***main

NuttShell (NSH) NuttX-12.0.3
nsh&gt; ......++.+.l......s......
................................................p.o.s.i.x._.s.p.a.w.n..:. .p.i.d.=...0.x.c.0.2.0.2.9.7.8. .p.a.t.h.=..l.s. .f.i.l.e._.a.c.t.i.o.n.s.=...0.x.c.0.2.0.2.9.8.0. .a.t.t.r.=...0.x.c.0.2.0.2.9.8.8. .a.r.g.v.=...0.x.c.0.2.0.2.a.2.8.
.........................................................e.x.e.c._.s.p.a.w.n.:. .E.R.R.O..R.:. .F.a.i.l.e.d. .t.o. .l.o.a.d. .p.r.o.g.r.a.m. .&#39;..l.s.&#39;.:. ..-.2.
.......n.x.p.o.s.i.x._.s.p.a.w.n._.e.x.e.c.:. .E.R.R.O.R.:. .e.x.e.c. .f.a.i.l.e.d.:. ..2.
............................................................................................................../:
............................................................... dev......../
.............. proc......../
............... system........./
.............................................................nsh&gt; ...................n.x._.s.t.a.r.t.:. .C.P.U.0.:. .B.e.g.i.n.n.i.n.g. .I.d.l.e. .L.o.o.p.
..........................
</code></pre></div>
<p>(So amazing that NuttX Apps and Context Switching are OK‚Ä¶ Even though we haven‚Äôt implemented the RISC-V Timer!)</p>
<p>But it‚Äôs super slow. Each dot is 1 Million Calls to the UART Interrupt Handler, with UART Interrupt Status <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L954-L966">UART_IIR_INTSTATUS = 0</a>! </p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L948-L967">uart_16550.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>// Get the current UART status and check for loop termination conditions 
status = u16550_serialin(priv, UART_IIR_OFFSET);

// The UART_IIR_INTSTATUS bit should be zero if there are pending interrupts 
if ((status &amp; UART_IIR_INTSTATUS) != 0)
  {
    // Break out of the loop when there is no longer a pending interrupt
      
    //// Print after every 1 million interrupts:
    static int i = 0;
    if (i++ % 1000000 == 1) {
      *(volatile uint8_t *)0x10000000 = &#39;.&#39;;
</code></pre></div>
<p>TODO: Why is UART Interrupt triggered repeatedly with <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/drivers/serial/uart_16550.c#L954-L966">UART_IIR_INTSTATUS = 0</a>?</p>
<p><em>Maybe because OpenSBI is still handling UART Interrupts in Machine Mode?</em></p>
<p>We tried to disable PLIC Interrupts for Machine Mode: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq.c#L58-L63">qemu_rv_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Disable All Global Interrupts for Hart 1 Machine-Mode
  // | 0x0C00_2080 | 4B | RW | Start Hart 1 M-Mode Interrupt Enables
  #define QEMU_RV_PLIC_ENABLE1_MMODE   (QEMU_RV_PLIC_BASE + 0x002080)
  #define QEMU_RV_PLIC_ENABLE2_MMODE   (QEMU_RV_PLIC_BASE + 0x002084)
  putreg32(0x0, QEMU_RV_PLIC_ENABLE1_MMODE);
  putreg32(0x0, QEMU_RV_PLIC_ENABLE2_MMODE);
</code></pre></div>
<p>But we still see spurious UART interrupts.</p>
<p>TODO: How does OpenSBI handle UART I/O? Are the UART Interrupts still routed to OpenSBI? Can we remove them from OpenSBI?</p>
<p>TODO: <a href="https://twitter.com/robertlipe/status/1685830584688340992?t=wTD98qn0WfhUCDho6px6gw">Robert Lipe</a> suggests that we check for floating inputs on the control signals</p>
<p>TODO: Throttle interrupts (for now) in <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c#L56-L91">riscv_dispatch_irq</a></p>
<p>TODO: Did we configure 16550 UART Interrupt Register correctly?</p>
<p>TODO: Is NuttX 16550 UART Driver any different from Linux?</p>
<p>TODO: Why are we rushing? Might get stale and out of sync with mainline</p>
<p>TODO: Check <a href="https://lupyuen.github.io/articles/privilege#other-risc-v-ports-of-nuttx">PolarFire Icicle</a></p>
<p>TODO: Check <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S">Linux Boot Code</a></p>
<p>TODO: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/sbi.c">Linux SBI Interface</a></p>
<p>TODO: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64d/arch/risc-v/src/qemu-rv/qemu_rv_exception_m.S#L64">Handle Machine Exception</a></p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Other Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/plic.md"><strong>lupyuen.github.io/src/plic.md</strong></a></p>

    
</body>
</html>