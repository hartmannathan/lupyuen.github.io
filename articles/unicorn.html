<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>(Possibly) Emulate PinePhone with Unicorn Emulator</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="(Possibly) Emulate PinePhone with Unicorn Emulator"
    data-rh="true">
<meta property="og:description" 
    content="To make PinePhone testing easier... Can we emulate Arm64 PinePhone with Unicorn Emulator? Let's find out! We'll call the Unicorn Emulator in Rust"
    data-rh="true">
<meta name="description" 
    content="To make PinePhone testing easier... Can we emulate Arm64 PinePhone with Unicorn Emulator? Let's find out! We'll call the Unicorn Emulator in Rust">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">(Possibly) Emulate PinePhone with Unicorn Emulator</h1>
    <nav id="TOC"><ul>
<li><a href="#emulate-arm64-machine-code">1 Emulate Arm64 Machine Code</a><ul></ul></li>
<li><a href="#memory-access-hook">2 Memory Access Hook</a><ul></ul></li>
<li><a href="#code-execution-hook">3 Code Execution Hook</a><ul></ul></li>
<li><a href="#block-execution-hook">4 Block Execution Hook</a><ul></ul></li>
<li><a href="#unmapped-memory">5 Unmapped Memory</a><ul></ul></li>
<li><a href="#apache-nuttx-rtos-in-unicorn">6 Apache NuttX RTOS in Unicorn</a><ul></ul></li>
<li><a href="#wait-for-uart-controller">7 Wait for UART Controller</a><ul></ul></li>
<li><a href="#emulate-uart-output">8 Emulate UART Output</a><ul></ul></li>
<li><a href="#emulator-halts-with-mmu-fault">9 Emulator Halts with MMU Fault</a><ul></ul></li>
<li><a href="#emulation-concerns">10 Emulation Concerns</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-map-address-to-function-with-elf-file">12 Appendix: Map Address to Function with ELF File</a><ul></ul></li></ul></nav><p>üìù <em>24 Feb 2023</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn-title.jpg" alt="Emulating Arm64 Machine Code in Unicorn" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/src/main.rs#L1-L55"><em>Emulating Arm64 Machine Code in Unicorn</em></a></p>
<p><a href="https://www.unicorn-engine.org/"><strong>Unicorn</strong></a> is a lightweight <strong>CPU Emulator Framework</strong> based on <a href="http://www.qemu.org/"><strong>QEMU</strong></a>.</p>
<p>(Programmable with C, Rust, Python and <a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings"><strong>many other languages</strong></a>)</p>
<p>We‚Äôre porting a new operating system <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> to <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>. And I wondered‚Ä¶</p>
<p><em>To make PinePhone testing easier‚Ä¶ Can we emulate Arm64 PinePhone with Unicorn Emulator?</em></p>
<p>Let‚Äôs find out! In this article we‚Äôll call <strong>Unicorn Emulator</strong> to‚Ä¶</p>
<ul>
<li>
<p><strong>Emulate Arm64</strong> Machine Code</p>
</li>
<li>
<p><strong>Attach Hooks</strong> to intercept Memory Access and Code Execution</p>
</li>
<li>
<p><strong>Boot Apache NuttX RTOS</strong> in the emulator</p>
</li>
<li>
<p><strong>Simulate the UART Controller</strong> for PinePhone</p>
</li>
<li>
<p><strong>Track an Exception</strong> in Arm64 Memory Management</p>
</li>
</ul>
<p>We‚Äôll do all this in <strong>basic Rust</strong>, instead of classic C.</p>
<p>(That‚Äôs because I‚Äôm too old to write meticulous C‚Ä¶ But I‚Äôm OK to get nagged by Rust Compiler if I miss something!)</p>
<p>We begin by emulating some machine code‚Ä¶</p>
<h1 id="emulate-arm64-machine-code"><a href="#emulate-arm64-machine-code">1 Emulate Arm64 Machine Code</a></h1>
<p>Suppose we wish to emulate this <strong>Arm64 Machine Code</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Start Address: 0x10000

// str  w11, [x13], #0
</span>AB <span class="number">05 00 </span>B8

<span class="comment">// ldrb w15, [x13], #0
</span>AF <span class="number">05 40 38

</span><span class="comment">// End Address: 0x10008</span></code></pre></div>
<p>With these <strong>Arm64 Register Values</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Register</th><th style="text-align: left">Value</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>X11</code></td><td style="text-align: left"><code>0x12345678</code></td></tr>
<tr><td style="text-align: center"><code>X13</code></td><td style="text-align: left"><code>0x10008</code></td></tr>
<tr><td style="text-align: center"><code>X15</code></td><td style="text-align: left"><code>0x33</code></td></tr>
</tbody></table>
</div>
<p>Which means‚Ä¶</p>
<ol>
<li>
<p><strong>Store <code>X11</code></strong> (value <strong><code>0x12345678</code></strong>)</p>
<p>Into the address referenced by <strong><code>X13</code></strong></p>
<p>(Address <strong><code>0x10008</code></strong>)</p>
</li>
<li>
<p><strong>Load <code>X15</code></strong> as a <strong>Single Byte</strong></p>
<p>From the address referenced by <strong><code>X13</code></strong></p>
<p>(Address <strong><code>0x10008</code></strong>)</p>
</li>
<li>
<p>Which sets <strong><code>X15</code></strong> to <strong><code>0x78</code></strong></p>
<p>(Because <strong><code>0x10008</code></strong> contains byte <strong><code>0x78</code></strong>)</p>
<p><a href="https://developer.arm.com/documentation/102374/0100/Registers-in-AArch64---general-purpose-registers">(<strong><code>X</code></strong> Registers are <strong>64-bit</strong>, <strong><code>W</code></strong> Registers are <strong>32-bit</strong>)</a></p>
</li>
</ol>
<p>This is how we <strong>call Unicorn Emulator</strong> to emulate the Arm64 Machine Code: <a href="https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/src/main.rs#L1-L55">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>unicorn_engine::{Unicorn, RegisterARM64};
<span class="kw">use </span>unicorn_engine::unicorn_const::{Arch, Mode, Permission};

<span class="kw">fn </span>main() {
  <span class="comment">// Arm64 Memory Address where emulation starts
  </span><span class="kw">const </span>ADDRESS: u64 = <span class="number">0x10000</span>;

  <span class="comment">// Arm64 Machine Code for the above address
  </span><span class="kw">let </span>arm64_code: Vec&lt;u8&gt; = <span class="macro">vec!</span>[
    <span class="number">0xab</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0xb8</span>,  <span class="comment">// str w11,  [x13], #0
    </span><span class="number">0xaf</span>, <span class="number">0x05</span>, <span class="number">0x40</span>, <span class="number">0x38</span>,  <span class="comment">// ldrb w15, [x13], #0
  </span>];</code></pre></div>
<p>We begin by defining the <strong>Arm64 Machine Code</strong>.</p>
<p>Then we <strong>initialise the emulator</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Init Emulator in Arm64 mode
  </span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
    Arch::ARM64,
    Mode::LITTLE_ENDIAN
  ).expect(<span class="string">"failed to init Unicorn"</span>);

  <span class="comment">// Magical horse mutates to bird
  </span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;</code></pre></div>
<p>Unicorn needs some <strong>Emulated Memory</strong> to run our code.</p>
<p>We map <strong>2MB of Executable Memory</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Map 2MB of Executable Memory at 0x10000
  // for Arm64 Machine Code
  </span>emu.mem_map(
    ADDRESS,          <span class="comment">// Address is 0x10000
    </span><span class="number">2 </span>* <span class="number">1024 </span>* <span class="number">1024</span>,  <span class="comment">// Size is 2MB
    </span>Permission::ALL   <span class="comment">// Read, Write and Execute Access
  </span>).expect(<span class="string">"failed to map code page"</span>);</code></pre></div>
<p>And we <strong>populate the Executable Memory</strong> with our Arm64 Machine Code‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Write Arm64 Machine Code to emulated Executable Memory
  </span>emu.mem_write(
    ADDRESS,     <span class="comment">// Address is 0x10000
    </span><span class="kw-2">&amp;</span>arm64_code  <span class="comment">// Arm64 Machine Code
  </span>).expect(<span class="string">"failed to write instructions"</span>);</code></pre></div>
<p>We <strong>set the Arm64 Registers</strong>: X11, X13 and X15‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Register Values
  </span><span class="kw">const </span>X11: u64 = <span class="number">0x12345678</span>;    <span class="comment">// X11 value
  </span><span class="kw">const </span>X13: u64 = ADDRESS + <span class="number">0x8</span>; <span class="comment">// X13 value
  </span><span class="kw">const </span>X15: u64 = <span class="number">0x33</span>;          <span class="comment">// X15 value
  
  // Set the Arm64 Registers
  </span>emu.reg_write(RegisterARM64::X11, X11)
    .expect(<span class="string">"failed to set X11"</span>);
  emu.reg_write(RegisterARM64::X13, X13)
    .expect(<span class="string">"failed to set X13"</span>);
  emu.reg_write(RegisterARM64::X15, X15)
    .expect(<span class="string">"failed to set X15"</span>);</code></pre></div>
<p>We <strong>start the emulator</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Emulate Arm64 Machine Code
  </span><span class="kw">let </span>err = emu.emu_start(
    ADDRESS,  <span class="comment">// Begin Address is 0x10000
    </span>ADDRESS + arm64_code.len() <span class="kw">as </span>u64,  <span class="comment">// End Address is 0x10008
    </span><span class="number">0</span>,  <span class="comment">// No Timeout
    </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
  </span>);

  <span class="comment">// Print the Emulator Error
  </span><span class="macro">println!</span>(<span class="string">"err={:?}"</span>, err);</code></pre></div>
<p>Finally we <strong>read Register X15</strong> and verify the result‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Read the X15 Register
  </span><span class="macro">assert_eq!</span>(
    emu.reg_read(RegisterARM64::X15),  <span class="comment">// Register X15
    </span><span class="prelude-val">Ok</span>(<span class="number">0x78</span>)  <span class="comment">// Expected Result
  </span>);
}</code></pre></div>
<p>And we‚Äôre done!</p>
<p>Remember to add <a href="https://crates.io/crates/unicorn-engine"><strong>unicorn-engine</strong></a> to the dependencies: <a href="https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/Cargo.toml#L8-L9">Cargo.toml</a></p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
unicorn-engine = &quot;2.0.0&quot;
</code></pre></div>
<p>When we run our <a href="https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/src/main.rs"><strong>Rust Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run --verbose

Fresh cc v1.0.79
Fresh cmake v0.1.49
Fresh pkg-config v0.3.26
Fresh bitflags v1.3.2
Fresh libc v0.2.139
Fresh unicorn-engine v2.0.1
Fresh pinephone-emulator v0.1.0
Finished dev [unoptimized + debuginfo] target(s) in 0.08s
Running `target/debug/pinephone-emulator`

err=Ok(())
</code></pre></div>
<p>Unicorn is hunky dory!</p>
<p>Let‚Äôs talk about Memory-Mapped Input / Output‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code2.png" alt="Memory Access Hook for Arm64 Emulation" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L59-L95"><em>Memory Access Hook for Arm64 Emulation</em></a></p>
<h1 id="memory-access-hook"><a href="#memory-access-hook">2 Memory Access Hook</a></h1>
<p>To emulate our gadget (like PinePhone), we need to handle <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O"><strong>Memory-Mapped Input / Output</strong></a>.</p>
<p>(Like for printing to the Serial or UART Port)</p>
<p>We do this in Unicorn Emulator with a <strong>Memory Access Hook</strong> that will be called to <strong>intercept every Memory Access</strong>.</p>
<p>Here‚Äôs a sample <strong>Hook Function</strong> that will be called to intercept every Arm64 Read / Write Access: <a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L83-L95">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Memory Access.
// Called once for every Arm64 Memory Access.
</span><span class="kw">fn </span>hook_memory(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>mem_type: MemType,    <span class="comment">// Read or Write Access
  </span>address:  u64,    <span class="comment">// Accessed Address
  </span>size:     usize,  <span class="comment">// Number of bytes accessed
  </span>value:    i64     <span class="comment">// Write Value
</span>) -&gt; bool {         <span class="comment">// Always return true

  // TODO: Emulate Memory-Mapped Input/Output (UART Controller)
  </span><span class="macro">println!</span>(<span class="string">"hook_memory: mem_type={:?}, address={:#x}, size={:?}, value={:#x}"</span>, mem_type, address, size, value);

  <span class="comment">// Always return true, value is unused by caller
  // https://github.com/unicorn-engine/unicorn/blob/dev/docs/FAQ.md#i-cant-recover-from-unmapped-readwrite-even-i-return-true-in-the-hook-why
  </span><span class="bool-val">true
</span>}</code></pre></div>
<p>Our Hook Function prints <strong>every Read / Write Access</strong> to the Emulated Arm64 Memory.</p>
<p>This is how we <strong>attach the Memory Hook Function</strong> to Unicorn Emulator: <a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L59-L74">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add Hook for Arm64 Memory Access
</span><span class="kw">let _ </span>= emu.add_mem_hook(
  HookType::MEM_ALL,  <span class="comment">// Intercept Read and Write Access
  </span><span class="number">0</span>,           <span class="comment">// Begin Address
  </span>u64::MAX,    <span class="comment">// End Address
  </span>hook_memory  <span class="comment">// Hook Function
</span>).expect(<span class="string">"failed to add memory hook"</span>);</code></pre></div>
<p>When we run this, we see the Read and Write Memory Accesses made by our <a href="https://lupyuen.github.io/articles/unicorn#emulate-arm64-machine-code"><strong>Emulated Arm64 Code</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_memory: 
  mem_type=WRITE, 
  address=0x10008, 
  size=4, 
  value=0x12345678

hook_memory: 
  mem_type=READ, 
  address=0x10008, 
  size=1, 
  value=0x0
</code></pre></div>
<p>(Value is not relevant for Memory Reads)</p>
<p>Later we‚Äôll implement UART Output with a Memory Access Hook. But first we intercept some code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code3.png" alt="Code Execution Hook for Arm64 Emulation" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L108-L117"><em>Code Execution Hook for Arm64 Emulation</em></a></p>
<h1 id="code-execution-hook"><a href="#code-execution-hook">3 Code Execution Hook</a></h1>
<p><em>Can we intercept every Arm64 Instruction that will be emulated?</em></p>
<p>Yep we can attach a <strong>Code Execution Hook</strong> to Unicorn Emulator.</p>
<p>Here‚Äôs a sample Hook Function that will be called for <strong>every Arm64 Instruction emulated</strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L108-L117">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Code Emulation.
// Called once for each Arm64 Instruction.
</span><span class="kw">fn </span>hook_code(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Instruction Address
  </span>size: u32      <span class="comment">// Instruction Size
</span>) {
  <span class="comment">// TODO: Handle special Arm64 Instructions
  </span><span class="macro">println!</span>(<span class="string">"hook_code: address={:#x}, size={:?}"</span>, address, size);
}</code></pre></div>
<p>And this is how we call Unicorn Emulator to <strong>attach the Code Hook Function</strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L52-L57">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add Hook for emulating each Arm64 Instruction
</span><span class="kw">let _ </span>= emu.add_code_hook(
  ADDRESS,  <span class="comment">// Begin Address
  </span>ADDRESS + arm64_code.len() <span class="kw">as </span>u64,  <span class="comment">// End Address
  </span>hook_code  <span class="comment">// Hook Function for Code Emulation
</span>).expect(<span class="string">"failed to add code hook"</span>);</code></pre></div>
<p>When we run this with our <a href="https://lupyuen.github.io/articles/unicorn#emulate-arm64-machine-code"><strong>Arm64 Machine Code</strong></a>, we see the Address of <strong>every Arm64 Instruction emulated</strong> (and its size)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_code:
  address=0x10000,
  size=4

hook_code:
  address=0x10004,
  size=4
</code></pre></div>
<p>We might use this to emulate <a href="https://developer.arm.com/documentation/102374/0101/Registers-in-AArch64---system-registers"><strong>Special Arm64 Instructions</strong></a>.</p>
<p>If we don‚Äôt need to intercept every single instruction, try the Block Execution Hook‚Ä¶</p>
<h1 id="block-execution-hook"><a href="#block-execution-hook">4 Block Execution Hook</a></h1>
<p><em>Is there something that works like a Code Execution Hook‚Ä¶</em></p>
<p><em>But doesn‚Äôt stop at every single Arm64 Instruction?</em></p>
<p>Yep Unicorn Emulator supports <strong>Block Execution Hooks</strong>.</p>
<p>This Hook Function will be called once when executing a <strong>Block of Arm64 Instructions</strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L97-L106">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called once for each Basic Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Block Address
  </span>size: u32      <span class="comment">// Block Size
</span>) {
  <span class="comment">// TODO: Trace the flow of emulated code
  </span><span class="macro">println!</span>(<span class="string">"hook_block: address={:#x}, size={:?}"</span>, address, size);
}</code></pre></div>
<p>This is how we <strong>attach the Block Execution Hook</strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L48-L50">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add Hook for emulating each Basic Block of Arm64 Instructions
</span><span class="kw">let _ </span>= emu.add_block_hook(hook_block)
  .expect(<span class="string">"failed to add block hook"</span>);</code></pre></div>
<p>Block Execution Hooks are <strong>less granular</strong> (called less often) than Code Execution Hooks‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block: address=0x10000, size=8
hook_code:  address=0x10000, size=4
hook_code:  address=0x10004, size=4
</code></pre></div>
<p>Which means that Unicorn Emulator calls our Hook Function only once for the <a href="https://lupyuen.github.io/articles/unicorn#emulate-arm64-machine-code"><strong>entire Block of two Arm64 Instructions</strong></a>.</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#what-is-a-block-of-arm64-instructions">(What‚Äôs a Block of Arm64 Instructions?)</a></p>
<p><em>How is this useful?</em></p>
<p>The Block Execution Hook is super helpful for monitoring the <strong>Execution Flow</strong> of our emulated code. We can‚Ä¶</p>
<ul>
<li>
<p>Read the <strong>ELF Debug Symbols</strong> (from the NuttX Image)</p>
</li>
<li>
<p>Match with the <strong>Block Execution Addresses</strong></p>
</li>
<li>
<p>And print the <strong>Name of the Function</strong> that‚Äôs being emulated</p>
</li>
</ul>
<p>This is how we do it‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn#appendix-map-address-to-function-with-elf-file"><strong>‚ÄúMap Address to Function with ELF File‚Äù</strong></a></li>
</ul>
<h1 id="unmapped-memory"><a href="#unmapped-memory">5 Unmapped Memory</a></h1>
<p><em>What happens when Unicorn Emulator tries to access memory that isn‚Äôt mapped?</em></p>
<p>Unicorn Emulator will call our Memory Access Hook with <strong>mem_type</strong> set to <strong>READ_UNMAPPED</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_memory:
  address=0x01c28014,
  size=2,
  mem_type=READ_UNMAPPED,
  value=0x0
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/b842358ba457b67ffa9f4c1a362b0386cfd97c4a/README.md#block-execution-hooks-for-arm64-emulation">(Source)</a></p>
<p>The log says that our Arm64 Machine Code attempted to read address <code>01C2</code> <code>8014</code>, which is unmapped.</p>
<p>This is how we map the memory: <a href="https://github.com/lupyuen/pinephone-emulator/blob/cd030954c2ace4cf0207872f275abc3ffb7343c6/src/main.rs#L26-L32">rust.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Map 16 MB at 0x0100 0000 for Memory-Mapped I/O by Allwinner A64 Peripherals
// https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/hardware/a64_memorymap.h#L33-L51
</span>emu.mem_map(
  <span class="number">0x0100_0000</span>,       <span class="comment">// Address
  </span><span class="number">16 </span>* <span class="number">1024 </span>* <span class="number">1024</span>,  <span class="comment">// Size
  </span>Permission::READ | Permission::WRITE  <span class="comment">// Read and Write Access
</span>).expect(<span class="string">"failed to map memory mapped I/O"</span>);</code></pre></div>
<p>We‚Äôll see this later when we handle Memory-Mapped Input / Output.</p>
<p><em>Can we map Memory Regions during emulation?</em></p>
<p>Yep we may use a Memory Access Hook to <strong>map memory regions on the fly</strong>.</p>
<p><a href="https://github.com/unicorn-engine/unicorn/blob/dev/docs/FAQ.md#i-cant-recover-from-unmapped-readwrite-even-i-return-true-in-the-hook-why">(Like this)</a></p>
<p><img src="https://lupyuen.github.io/images/unicorn-code4.png" alt="Running Apache NuttX RTOS in Unicorn" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/aa24d1c61256f38f92cf627d52c3e9a0c189bfc6/src/main.rs#L6-L78"><em>Running Apache NuttX RTOS in Unicorn</em></a></p>
<h1 id="apache-nuttx-rtos-in-unicorn"><a href="#apache-nuttx-rtos-in-unicorn">6 Apache NuttX RTOS in Unicorn</a></h1>
<p>We‚Äôre ready to run Apache NuttX RTOS in Unicorn Emulator!</p>
<p>We‚Äôve compiled <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx"><strong>Apache NuttX RTOS for PinePhone</strong></a> into an Arm64 Binary Image: <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx/nuttx.bin"><strong>nuttx.bin</strong></a></p>
<p>This is how we <strong>load the NuttX Binary Image</strong> into Unicorn: <a href="https://github.com/lupyuen/pinephone-emulator/blob/aa24d1c61256f38f92cf627d52c3e9a0c189bfc6/src/main.rs#L6-L40">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Arm64 Memory Address where emulation starts
</span><span class="kw">const </span>ADDRESS: u64 = <span class="number">0x4008_0000</span>;

<span class="comment">// Arm64 Machine Code for the above address
</span><span class="kw">let </span>arm64_code = <span class="macro">include_bytes!</span>(<span class="string">"../nuttx/nuttx.bin"</span>);</code></pre></div>
<p><a href="https://doc.rust-lang.org/std/macro.include_bytes.html"><em>(Rustle‚Ä¶ Whoosh!)</em></a></p>
<p>We <strong>initialise the emulator</strong> the same way‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init Emulator in Arm64 mode
</span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
  Arch::ARM64,
  Mode::LITTLE_ENDIAN
).expect(<span class="string">"failed to init Unicorn"</span>);

<span class="comment">// Magical horse mutates to bird
</span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;</code></pre></div>
<p>Based on the <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/include/a64/chip.h#L44-L52"><strong>NuttX Memory Map</strong></a> for PinePhone, we map two Memory Regions for NuttX‚Ä¶</p>
<ul>
<li>
<p><strong>Executable Memory</strong> (128 MB) at <strong><code>4000</code> <code>0000</code></strong></p>
<p>(For Arm64 Machine Code, Data and BSS)</p>
</li>
<li>
<p><strong>Read / Write Memory</strong> (512 MB) at <strong><code>0000</code> <code>0000</code></strong></p>
<p>(For Memory-Mapped I/O by Allwinner A64 Peripherals)</p>
</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Map 128 MB Executable Memory at 0x4000 0000 for Arm64 Machine Code
// https://github.com/apache/nuttx/blob/master/arch/arm64/include/a64/chip.h#L44-L52
</span>emu.mem_map(
  <span class="number">0x4000_0000</span>,        <span class="comment">// Address
  </span><span class="number">128 </span>* <span class="number">1024 </span>* <span class="number">1024</span>,  <span class="comment">// Size
  </span>Permission::ALL     <span class="comment">// Read, Write and Execute Access
</span>).expect(<span class="string">"failed to map code page"</span>);

<span class="comment">// Map 512 MB Read/Write Memory at 0x0000 0000 for
// Memory-Mapped I/O by Allwinner A64 Peripherals
// https://github.com/apache/nuttx/blob/master/arch/arm64/include/a64/chip.h#L44-L52
</span>emu.mem_map(
  <span class="number">0x0000_0000</span>,        <span class="comment">// Address
  </span><span class="number">512 </span>* <span class="number">1024 </span>* <span class="number">1024</span>,  <span class="comment">// Size
  </span>Permission::READ | Permission::WRITE  <span class="comment">// Read and Write Access
</span>).expect(<span class="string">"failed to map memory mapped I/O"</span>);</code></pre></div>
<p>We <strong>load the NuttX Machine Code</strong> into Emulated Memory‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Write Arm64 Machine Code to emulated Executable Memory
</span>emu.mem_write(
  ADDRESS,    <span class="comment">// Address is 4008 0000
  </span>arm64_code  <span class="comment">// NuttX Binary Image
</span>).expect(<span class="string">"failed to write instructions"</span>);</code></pre></div>
<p>And we <strong>run NuttX RTOS</strong>!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Omitted: Attach Code, Block and Memory Hooks
</span>...
<span class="comment">// Emulate Arm64 Machine Code
</span><span class="kw">let </span>err = emu.emu_start(
  ADDRESS,  <span class="comment">// Begin Address
  </span>ADDRESS + arm64_code.len() <span class="kw">as </span>u64,  <span class="comment">// End Address
  </span><span class="number">0</span>,  <span class="comment">// No Timeout
  </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
</span>);</code></pre></div>
<p>Unicorn happily <strong>boots Nuttx RTOS</strong> (yay!)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run 
hook_block:  address=0x40080000, size=8
hook_block:  address=0x40080040, size=4
hook_block:  address=0x40080044, size=12
hook_block:  address=0x40080118, size=16
...
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/a1fb82d829856d86d6845c477709c2be24373aca/nuttx/nuttx.S">(See the Arm64 Disassembly)</a></p>
<p>But our legendary creature gets stuck in mud. Let‚Äôs find out why‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code5.png" alt="Emulating the UART Controller" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/4d78876ad6f40126bf68cb2da4a43f56d9ef6e76/src/main.rs#L27-L76"><em>Emulating the UART Controller</em></a></p>
<h1 id="wait-for-uart-controller"><a href="#wait-for-uart-controller">7 Wait for UART Controller</a></h1>
<p>Unicorn gets <strong>stuck in a curious loop</strong> while booting NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4
hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4
hook_memory: address=0x01c28014, size=2, mem_type=READ, value=0x0

hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4
hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4
hook_memory: address=0x01c28014, size=2, mem_type=READ, value=0x0
...
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/045fa5da84d9e07ead5a820a075c1445661328b6/README.md#unicorn-emulator-waits-forever-for-uart-controller-ready">(Source)</a></p>
<p>See the pattern? Unicorn Emulator loops forever at address <strong><code>4008</code> <code>01F4</code></strong>‚Ä¶</p>
<p>While reading the data from address <strong><code>01C2</code> <code>8014</code></strong>.</p>
<p><em>What‚Äôs at 4008 01F4?</em></p>
<p>Here‚Äôs the <strong>NuttX Arm64 Disassembly</strong> at address <strong><code>4008</code> <code>01F4</code></strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/a1fb82d829856d86d6845c477709c2be24373aca/nuttx/nuttx.S#L3398-L3411">nuttx.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTION_FUNC(text, up_lowputc)
  ldr   x15, =UART0_BASE_ADDRESS
  400801f0:	580000cf 	ldr	x15, 40080208 &lt;up_lowputc+0x18&gt;
nuttx/arch/arm64/src/chip/a64_lowputc.S:89
  early_uart_ready x15, w2
  400801f4:	794029e2 	ldrh	w2, [x15, #20]
  400801f8:	721b005f 	tst	w2, #0x20
  400801fc:	54ffffc0 	b.eq	400801f4 &lt;up_lowputc+0x4&gt;  // b.none
nuttx/arch/arm64/src/chip/a64_lowputc.S:90
  early_uart_transmit x15, w0
  40080200:	390001e0 	strb	w0, [x15]
nuttx/arch/arm64/src/chip/a64_lowputc.S:91
  ret
  40080204:	d65f03c0 	ret
</code></pre></div>
<p>Which comes from this <strong>NuttX Source Code</strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L61-L71">a64_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Wait for A64 UART to be ready to transmit
 * xb: Register that contains the UART Base Address
 * wt: Scratch register number
 */
.macro early_uart_ready xb, wt
1:
  ldrh  \wt, [\xb, #0x14] /* UART_LSR (Line Status Register) */
  tst   \wt, #0x20        /* Check THRE (TX Holding Register Empty) */
  b.eq  1b                /* Wait for the UART to be ready (THRE=1) */
.endm
</code></pre></div>
<p><em>NuttX is printing something to the UART Port?</em></p>
<p>Yep! NuttX prints <strong>Debug Messages</strong> to the (Serial) UART Port when it boots‚Ä¶</p>
<p>And it‚Äôs waiting for the <strong>UART Controller to be ready</strong>, before printing!</p>
<p><a href="https://lupyuen.github.io/articles/uboot#wait-for-uart-ready">(As explained here)</a></p>
<p><em>What‚Äôs at 01C2 8014?</em></p>
<p><strong><code>01C2</code> <code>8014</code></strong> is the <strong>UART Line Status Register</strong> (UART_LSR) for the Allwinner A64 UART Controller inside PinePhone.</p>
<p><strong>Bit 5</strong> needs to be set to 1 to indicate that the <strong>UART Transmit FIFO</strong> is ready. Or NuttX will wait forever!</p>
<p><a href="https://lupyuen.github.io/articles/serial#wait-to-transmit">(As explained here)</a></p>
<p><em>How to fix the UART Ready Bit at 01C2 8014?</em></p>
<p>This is how we <strong>emulate the UART Ready Bit</strong> with our Input / Output Memory: <a href="https://github.com/lupyuen/pinephone-emulator/blob/4d78876ad6f40126bf68cb2da4a43f56d9ef6e76/src/main.rs#L42-L49">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Allwinner A64 UART Line Status Register (UART_LSR) at Offset 0x14.
// To indicate that the UART Transmit FIFO is ready:
// Set Bit 5 to 1.
// https://lupyuen.github.io/articles/serial#wait-to-transmit
</span>emu.mem_write(
  <span class="number">0x01c2_8014</span>,  <span class="comment">// UART Register Address
  </span><span class="kw-2">&amp;</span>[<span class="number">0b10_0000</span>]  <span class="comment">// UART Register Value
</span>).expect(<span class="string">"failed to set UART_LSR"</span>);</code></pre></div>
<p>And Unicorn Emulator stops looping!</p>
<p>Unicorn continues booting NuttX, which fills the <a href="https://en.wikipedia.org/wiki/.bss"><strong>BSS Section</strong></a> with 0‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  address=0x40089328, size=8
hook_memory: address=0x400b6a52, size=1, mem_type=WRITE, value=0x0
hook_block:  address=0x40089328, size=8
hook_memory: address=0x400b6a53, size=1, mem_type=WRITE, value=0x0
...
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/045fa5da84d9e07ead5a820a075c1445661328b6/README.md#unicorn-emulator-waits-forever-for-uart-controller-ready">(Source)</a></p>
<p>But we don‚Äôt see any NuttX Boot Messages. Let‚Äôs print the UART Output‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code6.png" alt="Emulating UART Output in Unicorn" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/aa6dd986857231a935617e8346978d7750aa51e7/src/main.rs#L89-L111"><em>Emulating UART Output in Unicorn</em></a></p>
<h1 id="emulate-uart-output"><a href="#emulate-uart-output">8 Emulate UART Output</a></h1>
<p><em>We expect to see Boot Messages from NuttX‚Ä¶</em></p>
<p><em>How do we print the UART Output?</em></p>
<p>NuttX RTOS will write the UART Output to Allwinner A64‚Äôs <strong>UART Transmit Holding Register</strong> (THR) at <strong><code>01C2</code> <code>8000</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/serial#transmit-uart"><strong>‚ÄúTransmit UART‚Äù</strong></a></li>
</ul>
<p>To emulate the UART Output, we use Unicorn‚Äôs <strong>Memory Access Hook</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn#memory-access-hook"><strong>‚ÄúMemory Access Hook‚Äù</strong></a></li>
</ul>
<p>In our Memory Access Hook, we intercept all writes to <strong><code>01C2</code> <code>8000</code></strong> and dump the bytes written: <a href="https://github.com/lupyuen/pinephone-emulator/blob/aa6dd986857231a935617e8346978d7750aa51e7/src/main.rs#L89-L111">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Memory Access.
// Called once for every Arm64 Memory Access.
</span><span class="kw">fn </span>hook_memory(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>mem_type: MemType,    <span class="comment">// Read or Write Access
  </span>address: u64,  <span class="comment">// Accessed Address
  </span>size: usize,   <span class="comment">// Number of bytes accessed
  </span>value: i64     <span class="comment">// Write Value
</span>) -&gt; bool {      <span class="comment">// Always return true

  // If writing to UART Transmit Holding Register (THR):
  // Print the output
  // https://lupyuen.github.io/articles/serial#transmit-uart
  </span><span class="kw">if </span>address == <span class="number">0x01c2_8000 </span>{
    <span class="macro">println!</span>(<span class="string">"uart output: {:?}"</span>, value <span class="kw">as </span>u8 <span class="kw">as </span>char);
  }

  <span class="comment">// Always return true, value is unused by caller
  // https://github.com/unicorn-engine/unicorn/blob/dev/docs/FAQ.md#i-cant-recover-from-unmapped-readwrite-even-i-return-true-in-the-hook-why
  </span><span class="bool-val">true
</span>}</code></pre></div>
<p>When we run this, we see a long chain of UART Output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run | grep uart
uart output: &#39;-&#39;
uart output: &#39; &#39;
uart output: &#39;R&#39;
uart output: &#39;e&#39;
uart output: &#39;a&#39;
uart output: &#39;d&#39;
uart output: &#39;y&#39;
...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/587dbeb9329d9755e4d007dd8e1246cd">(Source)</a></p>
<p>Which reads as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/uboot#pinephone-boots-nuttx">(Similar to this)</a></p>
<p>Yep NuttX RTOS is booting on Unicorn Emulator! But we have a problem‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-debug.jpg" alt="Debugging an Arm64 Exception" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#dump-the-arm64-exception"><em>Debugging an Arm64 Exception</em></a></p>
<h1 id="emulator-halts-with-mmu-fault"><a href="#emulator-halts-with-mmu-fault">9 Emulator Halts with MMU Fault</a></h1>
<p><em>NuttX RTOS boots OK on Unicorn Emulator?</em></p>
<p>Not quite. Unicorn Emulator halts with an <strong>Arm64 Exception</strong> at address <strong><code>4008</code> <code>0EF8</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  address=0x40080eec, size=16
hook_code:   address=0x40080eec, size=4
hook_code:   address=0x40080ef0, size=4
hook_code:   address=0x40080ef4, size=4
hook_code:   address=0x40080ef8, size=4
err=Err(EXCEPTION)
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/778f15875edf632ccb5a093a656084cb">(See the Complete Log)</a></p>
<p>Here‚Äôs the <strong>NuttX Arm64 Disassembly</strong> at address <strong><code>4008</code> <code>0EF8</code></strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/a1fb82d829856d86d6845c477709c2be24373aca/nuttx/nuttx.S">nuttx.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/arm64/src/common/arm64_mmu.c:544
  write_sysreg((value | SCTLR_M_BIT | SCTLR_C_BIT), sctlr_el1);
    40080ef0:	d28000a1 	mov	x1, #0x5                   	// #5
    40080ef4:	aa010000 	orr	x0, x0, x1
    40080ef8:	d5181000 	msr	sctlr_el1, x0
</code></pre></div>
<p>Which comes from this <strong>NuttX Source Code</strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L541-L544">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable the MMU and data cache:
// Read from System Control Register EL1
value = read_sysreg(sctlr_el1);

// Write to System Control Register EL1
write_sysreg(  // Write to System Register...
  value | SCTLR_M_BIT | SCTLR_C_BIT,  // Enable Address Translation and Caching
  sctlr_el1    // System Control Register EL1
);
</code></pre></div>
<p>The code above sets these flags in Arm64 <a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/SCTLR-EL1--System-Control-Register--EL1-"><strong>System Control Register EL1</strong></a> (SCTLR_EL1)‚Ä¶</p>
<ul>
<li>
<p><strong>SCTLR_M_BIT</strong> (Bit 0): Enable <strong>Address Translation</strong> for EL0 and EL1 Stage 1</p>
</li>
<li>
<p><strong>SCTLR_C_BIT</strong> (Bit 2): Enable <strong>Caching</strong> for EL0 and EL1 Stage 1</p>
<p><a href="https://lupyuen.github.io/articles/interrupt#exception-levels">(What‚Äôs EL1?)</a></p>
</li>
</ul>
<p>Thus the <strong>Address Translation</strong> (or Caching) has failed in our Emulated Arm64 Memory Management Unit, inside <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L541-L544"><strong>enable_mmu_el1</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-callgraph.jpg" alt="Call Graph for Apache NuttX RTOS" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos">(Source)</a></p>
<p>We won‚Äôt chase the Unicorn into the Rabbit Hole, but the details are covered here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#unicorn-emulator-halts-in-nuttx-mmu"><strong>‚ÄúUnicorn Emulator Halts in NuttX MMU‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#dump-the-arm64-exception"><strong>‚ÄúDump the Arm64 Exception‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#arm64-mmu-exception"><strong>‚ÄúArm64 MMU Exception‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#debug-the-unicorn-emulator"><strong>‚ÄúDebug the Unicorn Emulator‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#map-address-to-function-with-elf-file"><strong>‚ÄúMap Address to Function with ELF File‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>‚ÄúCall Graph for Apache NuttX RTOS‚Äù</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lvgl2-title.jpg" alt="Apache NuttX RTOS on PinePhone" /></p>
<p><a href="https://lupyuen.github.io/articles/what"><em>Apache NuttX RTOS on PinePhone</em></a></p>
<h1 id="emulation-concerns"><a href="#emulation-concerns">10 Emulation Concerns</a></h1>
<p><em>So are we happy with Unicorn Emulator?</em></p>
<p>Yep! Unicorn Emulator is sufficient for <strong>Automated Daily Build and Test</strong> for NuttX on PinePhone. (Via GitHub Actions)</p>
<p>Which will be similar to this BL602 setup, except that we‚Äôll boot the Daily Build on Unicorn Emulator (instead of Real Hardware)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/auto"><strong>‚ÄúAuto Flash and Test NuttX on RISC-V BL602‚Äù</strong></a></li>
</ul>
<p>Also Unicorn Emulator has produced a <strong>Call Graph</strong> for NuttX on PinePhone, which is extremely valuable for troubleshooting‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2"><strong>‚Äú(Clickable) Call Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p><em>But our PinePhone Emulator doesn‚Äôt handle Console Input‚Ä¶</em></p>
<p>Yeah we‚Äôll do that later. We have a long wishlist of features to build: Interrupts, Memory Protection, Multiple CPUs, Cortex A53, GIC v2, ‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-emulator#todo"><strong>‚ÄúWishlist for PinePhone Emulator‚Äù</strong></a></li>
</ul>
<p><em>NuttX runs graphical apps on PinePhone right?</em></p>
<p>Yep someday we‚Äôll render the <strong>NuttX Graphics Framebuffers</strong> in Unicorn.</p>
<p>(Maybe with a Rust GUI Library. Or <a href="https://alexaltea.github.io/unicorn.js/"><strong>Unicorn.js</strong></a> and WebAssembly)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/fb"><strong>‚ÄúNuttX RTOS for PinePhone: Framebuffer‚Äù</strong></a></li>
</ul>
<p><em>What about emulating other operating systems: Linux / macOS / Windows / Android?</em></p>
<p>Check out the <strong>Qiling Binary Emulation Framework</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/qilingframework/qiling"><strong>qilingframework/qiling</strong></a></li>
</ul>
<p><em>How about other hardware platforms: STM32 Blue Pill and ESP32?</em></p>
<p>Check out <strong>QEMU Emulator</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/stm32-blue-pill-unit-testing-with-qemu-blue-pill-emulator"><strong>‚ÄúUnit Testing with QEMU Blue Pill Emulator‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://medium.com/@lucassvaz/nuttx-on-an-emulated-esp32-using-qemu-8d8d93d24c63"><strong>‚ÄúNuttX on an emulated ESP32 using QEMU‚Äù</strong></a></p>
</li>
</ul>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>Check out the next article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2"><strong>‚Äú(Clickable) Call Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>This has been a fun educational exercise. Now we have a way to run <strong>Automated Daily Tests</strong> for Apache NuttX RTOS on PinePhone‚Ä¶ Kudos to the <strong>Maintainers of Unicorn Emulator</strong>!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/rust/comments/119unud/possibly_emulate_pinephone_with_unicorn_emulator/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=34908923"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/unicorn.md"><strong>lupyuen.github.io/src/unicorn.md</strong></a></p>
<h1 id="appendix-map-address-to-function-with-elf-file"><a href="#appendix-map-address-to-function-with-elf-file">12 Appendix: Map Address to Function with ELF File</a></h1>
<p>Check out the new article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2"><strong>‚Äú(Clickable) Call Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>Our <strong>Block Execution Hook</strong> now prints the <strong>Function Name</strong> and the <strong>Filename</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  
  address=0x40080eb0, 
  size=12, 
  setup_page_tables, 
  arch/arm64/src/common/arm64_mmu.c:516:25

hook_block:  
  address=0x40080eec, 
  size=16, 
  enable_mmu_el1, 
  arch/arm64/src/common/arm64_mmu.c:543:11

err=Err(EXCEPTION)
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p>Our Hook Function looks up the Address in the <a href="https://crates.io/crates/gimli"><strong>DWARF Debug Symbols</strong></a> of the <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx/nuttx"><strong>NuttX ELF File</strong></a>, like so: <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/src/main.rs#L127-L156">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Hook Function for Block Emulation.
/// Called once for each Basic Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Block Address
  </span>size: u32      <span class="comment">// Block Size
</span>) {
  <span class="macro">print!</span>(<span class="string">"hook_block:  address={:#010x}, size={:02}"</span>, address, size);

  <span class="comment">// Print the Function Name
  </span><span class="kw">let </span>function = map_address_to_function(address);
  <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref </span>name) = function {
    <span class="macro">print!</span>(<span class="string">", {}"</span>, name);
  }

  <span class="comment">// Print the Source Filename
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  <span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw-2">ref </span>file, line, col)) = loc {
    <span class="kw">let </span>file = file.clone().unwrap_or(<span class="string">""</span>.to_string());
    <span class="kw">let </span>line = line.unwrap_or(<span class="number">0</span>);
    <span class="kw">let </span>col = col.unwrap_or(<span class="number">0</span>);
    <span class="macro">print!</span>(<span class="string">", {}:{}:{}"</span>, file, line, col);
  }
  <span class="macro">println!</span>();
}</code></pre></div>
<p>We map the Block Address to Function Name and Source File in <strong>map_address_to_function</strong> and <strong>map_address_to_location</strong>:  <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/src/main.rs#L172-L219">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Function Name by looking up the ELF Context
</span><span class="kw">fn </span>map_address_to_function(
  address: u64         <span class="comment">// Code Address
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;String&gt; {  <span class="comment">// Function Name
  // Lookup the Arm64 Code Address in the ELF Context
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span><span class="kw-2">mut </span>frames = context.find_frames(address)
    .expect(<span class="string">"failed to find frames"</span>);

  <span class="comment">// Return the Function Name
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(frame) = frames.next().unwrap() {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(func) = frame.function {
      <span class="kw">if let </span><span class="prelude-val">Ok</span>(name) = func.raw_name() {
        <span class="kw">let </span>s = String::from(name);
        <span class="kw">return </span><span class="prelude-val">Some</span>(s);
      }
    }    
  }
  <span class="prelude-val">None
</span>}

<span class="doccomment">/// Map the Arm64 Code Address to the Source Filename, Line and Column
</span><span class="kw">fn </span>map_address_to_location(
  address: u64     <span class="comment">// Code Address
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;(      <span class="comment">// Returns...
  </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column
</span>)&gt; {
  <span class="comment">// Lookup the Arm64 Code Address in the ELF Context
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span>loc = context.find_location(address)
    .expect(<span class="string">"failed to find location"</span>);

  <span class="comment">// Return the Filename, Line and Column
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(loc) = loc {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(file) = loc.file {
      <span class="kw">let </span>s = String::from(file)
        .replace(<span class="string">"/private/tmp/nuttx/nuttx/"</span>, <span class="string">""</span>)
        .replace(<span class="string">"arch/arm64/src/chip"</span>, <span class="string">"arch/arm64/src/a64"</span>);  <span class="comment">// TODO: Handle other chips
      </span><span class="prelude-val">Some</span>((<span class="prelude-val">Some</span>(s), loc.line, loc.column))
    } <span class="kw">else </span>{
      <span class="prelude-val">Some</span>((<span class="prelude-val">None</span>, loc.line, loc.column))
    }
  } <span class="kw">else </span>{
    <span class="prelude-val">None
  </span>}
}</code></pre></div>
<p>To run this, we need the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a>, <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> and <a href="https://crates.io/crates/once_cell"><strong>once_cell</strong></a> crates: <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/Cargo.toml#L8-L12">Cargo.toml</a></p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
addr2line = &quot;0.19.0&quot;
gimli = &quot;0.27.2&quot;
once_cell = &quot;1.17.1&quot;
unicorn-engine = &quot;2.0.0&quot;
</code></pre></div>
<p>At startup, we load the <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx/nuttx"><strong>NuttX ELF File</strong></a> into <strong>ELF_CONTEXT</strong> as a <a href="https://docs.rs/once_cell/latest/once_cell/"><strong>Lazy Static</strong></a>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/src/main.rs#L288-L322">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::rc::Rc;
<span class="kw">use </span>std::cell::RefCell;
<span class="kw">use </span>once_cell::sync::Lazy;

<span class="doccomment">/// ELF File for mapping Addresses to Function Names and Filenames
</span><span class="kw">const </span>ELF_FILENAME: <span class="kw-2">&amp;</span>str = <span class="string">"nuttx/nuttx"</span>;

<span class="doccomment">/// ELF Context for mapping Addresses to Function Names and Filenames
</span><span class="kw">static </span>ELF_CONTEXT: Lazy&lt;ElfContext&gt; = Lazy::new(|| {
  <span class="comment">// Open the ELF File
  </span><span class="kw">let </span>path = std::path::PathBuf::from(ELF_FILENAME);
  <span class="kw">let </span>file_data = std::fs::read(path)
    .expect(<span class="string">"failed to read ELF"</span>);
  <span class="kw">let </span>slice = file_data.as_slice();

  <span class="comment">// Parse the ELF File
  </span><span class="kw">let </span>obj = addr2line::object::read::File::parse(slice)
    .expect(<span class="string">"failed to parse ELF"</span>);
  <span class="kw">let </span>context = addr2line::Context::new(<span class="kw-2">&amp;</span>obj)
    .expect(<span class="string">"failed to parse debug info"</span>);

  <span class="comment">// Set the ELF Context
  </span>ElfContext {
    context: RefCell::new(context),
  }
});

<span class="doccomment">/// Wrapper for ELF Context. Needed for `Lazy`
</span><span class="kw">struct </span>ElfContext {
  context: RefCell&lt;
    addr2line::Context&lt;
      gimli::EndianReader&lt;
        gimli::RunTimeEndian, 
        Rc&lt;[u8]&gt;  <span class="comment">// Doesn't implement Send / Sync
      </span>&gt;
    &gt;
  &gt;
}

<span class="doccomment">/// Send and Sync for ELF Context. Needed for `Lazy`
</span><span class="kw">unsafe impl </span>Send <span class="kw">for </span>ElfContext {}
<span class="kw">unsafe impl </span>Sync <span class="kw">for </span>ElfContext {}</code></pre></div>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>