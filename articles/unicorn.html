<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>(Possibly) Emulate PinePhone with Unicorn Emulator</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="(Possibly) Emulate PinePhone with Unicorn Emulator"
    data-rh="true">
<meta property="og:description" 
    content="To make PinePhone testing easier... Can we emulate Arm64 PinePhone with Unicorn Emulator? Let's find out! We'll call the Unicorn Emulator in Rust"
    data-rh="true">
<meta name="description" 
    content="To make PinePhone testing easier... Can we emulate Arm64 PinePhone with Unicorn Emulator? Let's find out! We'll call the Unicorn Emulator in Rust">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">(Possibly) Emulate PinePhone with Unicorn Emulator</h1>
    <nav id="TOC"><ul>
<li><a href="#emulate-arm64-machine-code">1 Emulate Arm64 Machine Code</a><ul></ul></li>
<li><a href="#memory-access-hook-for-arm64-emulation">2 Memory Access Hook for Arm64 Emulation</a><ul></ul></li>
<li><a href="#code-execution-hook-for-arm64-emulation">3 Code Execution Hook for Arm64 Emulation</a><ul></ul></li>
<li><a href="#block-execution-hooks-for-arm64-emulation">4 Block Execution Hooks for Arm64 Emulation</a><ul></ul></li>
<li><a href="#what-is-a-block-of-arm64-instructions">5 What is a Block of Arm64 Instructions?</a><ul></ul></li>
<li><a href="#unmapped-memory-in-unicorn-emulator">6 Unmapped Memory in Unicorn Emulator</a><ul></ul></li>
<li><a href="#run-apache-nuttx-rtos-in-unicorn-emulator">7 Run Apache NuttX RTOS in Unicorn Emulator</a><ul></ul></li>
<li><a href="#unicorn-emulator-waits-forever-for-uart-controller-ready">8 Unicorn Emulator Waits Forever for UART Controller Ready</a><ul></ul></li>
<li><a href="#emulate-uart-output-in-unicorn-emulator">9 Emulate UART Output in Unicorn Emulator</a><ul></ul></li>
<li><a href="#unicorn-emulator-halts-in-nuttx-mmu">10 Unicorn Emulator Halts in NuttX MMU</a><ul></ul></li>
<li><a href="#dump-the-arm64-exception">11 Dump the Arm64 Exception</a><ul></ul></li>
<li><a href="#arm64-mmu-exception">12 Arm64 MMU Exception</a><ul></ul></li>
<li><a href="#debug-the-unicorn-emulator">13 Debug the Unicorn Emulator</a><ul></ul></li>
<li><a href="#other-emulators">14 Other Emulators</a><ul></ul></li>
<li><a href="#todo">15 TODO</a><ul></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>1 Mar 2023</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn-title.jpg" alt="Emulating Arm64 Machine Code in Unicorn Emulator" /></p>
<p><a href="https://www.unicorn-engine.org/"><strong>Unicorn</strong></a> is a lightweight <strong>CPU Emulator Framework</strong> based on <a href="http://www.qemu.org/"><strong>QEMU</strong></a>.</p>
<p>(Programmable with C, Rust, Python and <a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings"><strong>many other languages</strong></a>)</p>
<p>We‚Äôre porting a new operating system <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> to <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>. And I wondered‚Ä¶</p>
<p><em>To make PinePhone testing easier‚Ä¶ Can we emulate Arm64 PinePhone with Unicorn Emulator?</em></p>
<p>Let‚Äôs find out! In this article we‚Äôll call <strong>Unicorn Emulator</strong> to‚Ä¶</p>
<ul>
<li>
<p><strong>Emulate Arm64</strong> Machine Code</p>
</li>
<li>
<p><strong>Attach Hooks</strong> to intercept Memory Access and Code Execution</p>
</li>
<li>
<p><strong>Boot Apache NuttX RTOS</strong> in the emulator</p>
</li>
<li>
<p><strong>Simulate the UART Controller</strong> for PinePhone</p>
</li>
<li>
<p><strong>Track an Exception</strong> in the Arm64 Memory Management Unit </p>
</li>
</ul>
<p>We‚Äôll do all this in <strong>basic Rust</strong> (instead of classic C).</p>
<p>(Because I‚Äôm too old to write meticulous C‚Ä¶ But I‚Äôm OK to get nagged by Rust Compiler if I miss something!)</p>
<p>We begin by emulating simple Arm64 Machine Code‚Ä¶</p>
<h1 id="emulate-arm64-machine-code"><a href="#emulate-arm64-machine-code">1 Emulate Arm64 Machine Code</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code.png" alt="Emulate Arm64 Machine Code" /></p>
<p>Suppose we wish to emulate some Arm64 Machine Code‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/src/main.rs#L7-L8</p>
<p>Here‚Äôs our Rust Program that calls Unicorn Emulator to emulate the Arm64 Machine Code‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/src/main.rs#L1-L55</p>
<p>We add <code>unicorn-engine</code> to <a href="Cargo.toml">Cargo.toml</a>‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/Cargo.toml#L8-L9</p>
<p>And we run our Rust Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run --verbose
  Fresh cc v1.0.79
  Fresh cmake v0.1.49
  Fresh pkg-config v0.3.26
  Fresh bitflags v1.3.2
  Fresh libc v0.2.139
  Fresh unicorn-engine v2.0.1
  Fresh pinephone-emulator v0.1.0
Finished dev [unoptimized + debuginfo] target(s) in 0.08s
  Running `target/debug/pinephone-emulator`
</code></pre></div>
<p>Our Rust Program works OK for emulating Arm64 Memory and Arm64 Registers.</p>
<p>Let‚Äôs talk about Arm64 Memory-Mapped Input / Output‚Ä¶</p>
<h1 id="memory-access-hook-for-arm64-emulation"><a href="#memory-access-hook-for-arm64-emulation">2 Memory Access Hook for Arm64 Emulation</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code2.png" alt="Memory Access Hook for Arm64 Emulation" /></p>
<p><em>How will we emulate Arm64 Memory-Mapped Input / Output?</em></p>
<p>Unicorn Emulator lets us attach hooks to Emulate Memory Access.</p>
<p>Here‚Äôs a Hook Function for Memory Access‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L83-L95</p>
<p>Our Hook Function prints all Read / Write Access to Emulated Arm64 Memory.</p>
<p><a href="https://github.com/unicorn-engine/unicorn/blob/dev/docs/FAQ.md#i-cant-recover-from-unmapped-readwrite-even-i-return-true-in-the-hook-why">(Return value is unused)</a></p>
<p>This is how we attach the Hook Function to the Unicorn Emulator‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L59-L74</p>
<p>When we run our Rust Program, we see the Read and Write Memory Accesses made by our <a href="https://github.com/lupyuen/pinephone-emulator/blob/bc5643dea66c70f57a150955a12884f695acf1a4/src/main.rs#L7-L8">Emulated Arm64 Code</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_memory: 
  mem_type=WRITE, 
  address=0x10008, 
  size=4, 
  value=0x12345678

hook_memory: 
  mem_type=READ, 
  address=0x10008, 
  size=1, 
  value=0x0
</code></pre></div>
<p>This Memory Access Hook Function will be helpful when we emulate Memory-Mapped Input/Output on PinePhone.</p>
<p>(Like for the Allwinner A64 UART Controller)</p>
<p>Unicorn Emulator allows Code Execution Hooks too‚Ä¶</p>
<h1 id="code-execution-hook-for-arm64-emulation"><a href="#code-execution-hook-for-arm64-emulation">3 Code Execution Hook for Arm64 Emulation</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code3.png" alt="Code Execution Hook for Arm64 Emulation" /></p>
<p><em>Can we intercept every Arm64 Instruction that will be emulated?</em></p>
<p>Yep we can call Unicorn Emulator to add a Code Execution Hook.</p>
<p>Here‚Äôs a sample Hook Function that will be called for every Arm64 Instruction‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L108-L117</p>
<p>And this is how we call Unicorn Emulator to add the above Hook Function‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L52-L57</p>
<p>When we run our Rust Program, we see the Address of every Arm64 Instruction emulated (and its size)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_code:
  address=0x10000,
  size=4

hook_code:
  address=0x10004,
  size=4
</code></pre></div>
<p>We might use this to emulate special Arm64 Instructions.</p>
<p>If we don‚Äôt need to intercept every single instruction, try the Block Execution Hook‚Ä¶</p>
<h1 id="block-execution-hooks-for-arm64-emulation"><a href="#block-execution-hooks-for-arm64-emulation">4 Block Execution Hooks for Arm64 Emulation</a></h1>
<p>TODO</p>
<p><em>Is there something that works like a Code Execution Hook‚Ä¶</em></p>
<p><em>But doesn‚Äôt stop at every single Arm64 Instruction?</em></p>
<p>Yep Unicorn Emulator supports Block Execution Hooks.</p>
<p>This Hook Function will be called once when executing a Block of Arm64 Instructions‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L97-L106</p>
<p>This is how we add the Block Execution Hook‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/3655ac2875664376f42ad3a3ced5cbf067790782/src/main.rs#L48-L50</p>
<p>When we run the Rust Program, we see that that the Block Size is 8‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:
  address=0x10000,
  size=8
</code></pre></div>
<p>Which means that Unicorn Emulator calls our Hook Function only once for the entire Block of 2 Arm64 Instructions.</p>
<p>This Block Execution Hook will be super helpful for monitoring the Execution Flow of our emulated code.</p>
<p>Let‚Äôs talk about the Block‚Ä¶</p>
<h1 id="what-is-a-block-of-arm64-instructions"><a href="#what-is-a-block-of-arm64-instructions">5 What is a Block of Arm64 Instructions?</a></h1>
<p>TODO</p>
<p><em>What exactly is a Block of Arm64 Instructions?</em></p>
<p>When we this code from Apache NuttX RTOS (that handles UART Output)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SECTION_FUNC(text, up_lowputc)
  ldr   x15, =UART0_BASE_ADDRESS
  400801f0:	580000cf 	ldr	x15, 40080208 &lt;up_lowputc+0x18&gt;
nuttx/arch/arm64/src/chip/a64_lowputc.S:89
  early_uart_ready x15, w2
  400801f4:	794029e2 	ldrh	w2, [x15, #20]
  400801f8:	721b005f 	tst	w2, #0x20
  400801fc:	54ffffc0 	b.eq	400801f4 &lt;up_lowputc+0x4&gt;  // b.none
nuttx/arch/arm64/src/chip/a64_lowputc.S:90
  early_uart_transmit x15, w0
  40080200:	390001e0 	strb	w0, [x15]
nuttx/arch/arm64/src/chip/a64_lowputc.S:91
  ret
  40080204:	d65f03c0 	ret
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/a1fb82d829856d86d6845c477709c2be24373aca/nuttx/nuttx.S#L3398-L3411">(Arm64 Disassembly)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L61-L71">(Source Code)</a></p>
<p>We observe that Unicorm Emulator treats <code>400801f0</code> to <code>400801fc</code> as a Block of Arm64 Instructins‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  address=0x400801f0, size=16
hook_code:   address=0x400801f0, size=4
hook_code:   address=0x400801f4, size=4
hook_code:   address=0x400801f4, size=4
hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4

hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4
hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4

hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4
hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/cd030954c2ace4cf0207872f275abc3ffb7343c6/README.md#block-execution-hooks-for-arm64-emulation">(Source)</a></p>
<p>The Block ends at <code>400801fc</code> because there‚Äôs an Arm64 Branch Instruction <code>b.eq</code>.</p>
<p>From this we deduce that Unicorn Emulator treats a sequence of Arm64 Instructions as a Block, until it sees a Branch Instruction. (Including function calls)</p>
<h1 id="unmapped-memory-in-unicorn-emulator"><a href="#unmapped-memory-in-unicorn-emulator">6 Unmapped Memory in Unicorn Emulator</a></h1>
<p>TODO</p>
<p><em>What happens when Unicorn Emulator tries to access memory that isn‚Äôt mapped?</em></p>
<p>Unicorn Emulator will call our Memory Access Hook with <code>mem_type</code> set to <code>READ_UNMAPPED</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_memory:
  address=0x01c28014,
  size=2,
  mem_type=READ_UNMAPPED,
  value=0x0
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/b842358ba457b67ffa9f4c1a362b0386cfd97c4a/README.md#block-execution-hooks-for-arm64-emulation">(Source)</a></p>
<p>The log above says that address <code>0x01c2</code> <code>8014</code> is unmapped.</p>
<p>This is how we map the memory‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/cd030954c2ace4cf0207872f275abc3ffb7343c6/src/main.rs#L26-L32</p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/include/a64/chip.h#L44-L52">(See the NuttX Memory Map)</a></p>
<p><em>Can we map Memory Regions during emulation?</em></p>
<p>Yep we may use a Memory Access Hook to map memory regions on the fly. <a href="https://github.com/unicorn-engine/unicorn/blob/dev/docs/FAQ.md#i-cant-recover-from-unmapped-readwrite-even-i-return-true-in-the-hook-why">(See this)</a></p>
<h1 id="run-apache-nuttx-rtos-in-unicorn-emulator"><a href="#run-apache-nuttx-rtos-in-unicorn-emulator">7 Run Apache NuttX RTOS in Unicorn Emulator</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code4.png" alt="Run Apache NuttX RTOS in Unicorn Emulator" /></p>
<p>Let‚Äôs run Apache NuttX RTOS in Unicorn Emulator!</p>
<p>We have compiled <a href="nuttx">Apache NuttX RTOS for PinePhone</a> into an Arm64 Binary Image <code>nuttx.bin</code>.</p>
<p>This is how we load the NuttX Binary Image into Unicorn‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/aa24d1c61256f38f92cf627d52c3e9a0c189bfc6/src/main.rs#L6-L40</p>
<p>In our Rust Program above, we mapped 2 Memory Regions for NuttX‚Ä¶</p>
<ul>
<li>
<p>Map 128 MB Executable Memory at <code>0x4000</code> <code>0000</code> for Arm64 Machine Code</p>
</li>
<li>
<p>Map 512 MB Read/Write Memory at <code>0x0000</code> <code>0000</code> for Memory-Mapped I/O by Allwinner A64 Peripherals</p>
</li>
</ul>
<p>This is based on the <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/include/a64/chip.h#L44-L52">NuttX Memory Map</a> for PinePhone.</p>
<p>When we run this, Unicorn Emulator loops forever. Let‚Äôs find out why‚Ä¶</p>
<h1 id="unicorn-emulator-waits-forever-for-uart-controller-ready"><a href="#unicorn-emulator-waits-forever-for-uart-controller-ready">8 Unicorn Emulator Waits Forever for UART Controller Ready</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code5.png" alt="Emulating the Allwinner A64 UART Controller" /></p>
<p>Here‚Äôs the output when we run NuttX RTOS in Unicorn Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_memory: address=0x01c28014, size=2, mem_type=READ, value=0x0
hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4
hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4

hook_memory: address=0x01c28014, size=2, mem_type=READ, value=0x0
hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4
hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4

hook_memory: address=0x01c28014, size=2, mem_type=READ, value=0x0
hook_code:   address=0x400801f8, size=4
hook_code:   address=0x400801fc, size=4
hook_block:  address=0x400801f4, size=12
hook_code:   address=0x400801f4, size=4
...
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/045fa5da84d9e07ead5a820a075c1445661328b6/README.md#unicorn-emulator-waits-forever-for-uart-controller-ready">(Source)</a></p>
<p>The above log shows that Unicorn Emulator loops forever at address <code>0x4008</code> <code>01f4</code>, while reading the data from address <code>0x01c2</code> <code>8014</code>.</p>
<p>Let‚Äôs check the NuttX Arm64 Code at address <code>0x4008</code> <code>01f4</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SECTION_FUNC(text, up_lowputc)
  ldr   x15, =UART0_BASE_ADDRESS
  400801f0:	580000cf 	ldr	x15, 40080208 &lt;up_lowputc+0x18&gt;
nuttx/arch/arm64/src/chip/a64_lowputc.S:89
  early_uart_ready x15, w2
  400801f4:	794029e2 	ldrh	w2, [x15, #20]
  400801f8:	721b005f 	tst	w2, #0x20
  400801fc:	54ffffc0 	b.eq	400801f4 &lt;up_lowputc+0x4&gt;  // b.none
nuttx/arch/arm64/src/chip/a64_lowputc.S:90
  early_uart_transmit x15, w0
  40080200:	390001e0 	strb	w0, [x15]
nuttx/arch/arm64/src/chip/a64_lowputc.S:91
  ret
  40080204:	d65f03c0 	ret
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/a1fb82d829856d86d6845c477709c2be24373aca/nuttx/nuttx.S#L3398-L3411">(Arm64 Disassembly)</a></p>
<p>Which comes from this NuttX Source Code‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Wait for A64 UART to be ready to transmit
 * xb: Register that contains the UART Base Address
 * wt: Scratch register number
 */
.macro early_uart_ready xb, wt
1:
  ldrh  \wt, [\xb, #0x14]      /* UART_LSR (Line Status Register) */
  tst   \wt, #0x20             /* Check THRE (TX Holding Register Empty) */
  b.eq  1b                     /* Wait for the UART to be ready (THRE=1) */
.endm
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L61-L71">(Source Code)</a></p>
<p>This code waits for the UART Controller to be ready (before printing UART Output), by checking the value at <code>0x01c2</code> <code>8014</code>. The code is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/uboot#wait-for-uart-ready">‚ÄúWait for UART Ready‚Äù</a></li>
</ul>
<p><em>What is <code>0x01c2</code> <code>8014</code>?</em></p>
<p>According to the Allwinner A64 Doc‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/serial#wait-to-transmit">‚ÄúWait To Transmit‚Äù</a></li>
</ul>
<p><code>0x01c2</code> <code>8014</code> is the UART Line Status Register (UART_LSR) at Offset 0x14.</p>
<p>Bit 5 needs to be set to 1 to indicate that the UART Transmit FIFO is ready.</p>
<p>We emulate the UART Ready Bit like so‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/4d78876ad6f40126bf68cb2da4a43f56d9ef6e76/src/main.rs#L42-L49</p>
<p>And Unicorn Emulator stops looping! It continues execution to <code>memset()</code> (to init the BSS Section to 0)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  address=0x40089328, size=8
hook_memory: address=0x400b6a52, size=1, mem_type=WRITE, value=0x0
hook_block:  address=0x40089328, size=8
hook_memory: address=0x400b6a53, size=1, mem_type=WRITE, value=0x0
hook_block:  address=0x40089328, size=8
hook_memory: address=0x400b6a54, size=1, mem_type=WRITE, value=0x0
...
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/045fa5da84d9e07ead5a820a075c1445661328b6/README.md#unicorn-emulator-waits-forever-for-uart-controller-ready">(Source)</a></p>
<p>But we don‚Äôt see any UART Output. Let‚Äôs print the UART Output‚Ä¶</p>
<h1 id="emulate-uart-output-in-unicorn-emulator"><a href="#emulate-uart-output-in-unicorn-emulator">9 Emulate UART Output in Unicorn Emulator</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code6.png" alt="Emulating UART Output in Unicorn Emulator" /></p>
<p><em>How do we print the UART Output?</em></p>
<p>According to the Allwinner A64 Doc‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/serial#transmit-uart">‚ÄúTransmit UART‚Äù</a></li>
</ul>
<p>NuttX RTOS will write the UART Output to the UART Transmit Holding Register (THR) at <code>0x01c2</code> <code>8000</code>.</p>
<p>In our Memory Access Hook, let‚Äôs intercept all writes to <code>0x01c2</code> <code>8000</code> and dump the characters written to UART Output‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/aa6dd986857231a935617e8346978d7750aa51e7/src/main.rs#L89-L111</p>
<p>When we run this, we see a long chain of UART Output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run | grep uart
uart output: &#39;-&#39;
uart output: &#39; &#39;
uart output: &#39;R&#39;
uart output: &#39;e&#39;
uart output: &#39;a&#39;
uart output: &#39;d&#39;
uart output: &#39;y&#39;
...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/587dbeb9329d9755e4d007dd8e1246cd">(Source)</a></p>
<p>Which reads as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/uboot#pinephone-boots-nuttx">(Similar to this)</a></p>
<p>Yep NuttX RTOS is booting on Unicorn Emulator! But Unicorn Emulator halts while booting NuttX‚Ä¶</p>
<h1 id="unicorn-emulator-halts-in-nuttx-mmu"><a href="#unicorn-emulator-halts-in-nuttx-mmu">10 Unicorn Emulator Halts in NuttX MMU</a></h1>
<p>TODO: Unicorn Emulator halts‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  address=0x40080cec, size=16
hook_code:   address=0x40080cec, size=4
hook_memory: address=0x400c3f90, size=8, mem_type=READ, value=0x0
hook_memory: address=0x400c3f98, size=8, mem_type=READ, value=0x0
hook_code:   address=0x40080cf0, size=4
hook_memory: address=0x400c3fa0, size=8, mem_type=READ, value=0x0
hook_code:   address=0x40080cf4, size=4
hook_memory: address=0x400c3f80, size=8, mem_type=READ, value=0x0
hook_memory: address=0x400c3f88, size=8, mem_type=READ, value=0x0
hook_code:   address=0x40080cf8, size=4
hook_block:  address=0x40080eb0, size=12
hook_code:   address=0x40080eb0, size=4
hook_code:   address=0x40080eb4, size=4
hook_code:   address=0x40080eb8, size=4
hook_block:  address=0x40080ebc, size=16
hook_code:   address=0x40080ebc, size=4
hook_code:   address=0x40080ec0, size=4
hook_code:   address=0x40080ec4, size=4
hook_code:   address=0x40080ec8, size=4
hook_block:  address=0x40080ecc, size=16
hook_code:   address=0x40080ecc, size=4
hook_code:   address=0x40080ed0, size=4
hook_code:   address=0x40080ed4, size=4
hook_code:   address=0x40080ed8, size=4
hook_block:  address=0x40080edc, size=12
hook_code:   address=0x40080edc, size=4
hook_code:   address=0x40080ee0, size=4
hook_code:   address=0x40080ee4, size=4
hook_block:  address=0x40080ee8, size=4
hook_code:   address=0x40080ee8, size=4
hook_block:  address=0x40080eec, size=16
hook_code:   address=0x40080eec, size=4
hook_code:   address=0x40080ef0, size=4
hook_code:   address=0x40080ef4, size=4
hook_code:   address=0x40080ef8, size=4
err=Err(EXCEPTION)
</code></pre></div>
<p>Unicorn Emulator halts at the NuttX MMU (EL1) code at <code>0x4008</code> <code>0ef8</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/arm64/src/common/arm64_mmu.c:544
  write_sysreg((value | SCTLR_M_BIT | SCTLR_C_BIT), sctlr_el1);
    40080ef0:	d28000a1 	mov	x1, #0x5                   	// #5
    40080ef4:	aa010000 	orr	x0, x0, x1
    40080ef8:	d5181000 	msr	sctlr_el1, x0
</code></pre></div>
<p>TODO: Why did MSR fail with an Exception?</p>
<p>Here‚Äôs the context‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>enable_mmu_el1():
nuttx/arch/arm64/src/common/arm64_mmu.c:533
  write_sysreg(MEMORY_ATTRIBUTES, mair_el1);
    40080ebc:	d2808000 	mov	x0, #0x400                 	// #1024
    40080ec0:	f2a88180 	movk	x0, #0x440c, lsl #16
    40080ec4:	f2c01fe0 	movk	x0, #0xff, lsl #32
    40080ec8:	d518a200 	msr	mair_el1, x0
nuttx/arch/arm64/src/common/arm64_mmu.c:534
  write_sysreg(get_tcr(1), tcr_el1);
    40080ecc:	d286a380 	mov	x0, #0x351c                	// #13596
    40080ed0:	f2a01000 	movk	x0, #0x80, lsl #16
    40080ed4:	f2c00020 	movk	x0, #0x1, lsl #32
    40080ed8:	d5182040 	msr	tcr_el1, x0
nuttx/arch/arm64/src/common/arm64_mmu.c:535
  write_sysreg(((uint64_t)base_xlat_table), ttbr0_el1);
    40080edc:	d00001a0 	adrp	x0, 400b6000 &lt;g_uart1port&gt;
    40080ee0:	91200000 	add	x0, x0, #0x800
    40080ee4:	d5182000 	msr	ttbr0_el1, x0
arm64_isb():
nuttx/arch/arm64/src/common/barriers.h:58
  __asm__ volatile (&quot;isb&quot; : : : &quot;memory&quot;);
    40080ee8:	d5033fdf 	isb
enable_mmu_el1():
nuttx/arch/arm64/src/common/arm64_mmu.c:543
  value = read_sysreg(sctlr_el1);
    40080eec:	d5381000 	mrs	x0, sctlr_el1
nuttx/arch/arm64/src/common/arm64_mmu.c:544
  write_sysreg((value | SCTLR_M_BIT | SCTLR_C_BIT), sctlr_el1);
    40080ef0:	d28000a1 	mov	x1, #0x5                   	// #5
    40080ef4:	aa010000 	orr	x0, x0, x1
    40080ef8:	d5181000 	msr	sctlr_el1, x0
arm64_isb():
nuttx/arch/arm64/src/common/barriers.h:58
    40080efc:	d5033fdf 	isb
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L526-L552">(NuttX MMU Source Code)</a></p>
<p>Let‚Äôs dump the Arm64 Exception‚Ä¶</p>
<h1 id="dump-the-arm64-exception"><a href="#dump-the-arm64-exception">11 Dump the Arm64 Exception</a></h1>
<p>TODO: Dump the Exception Registers ESR, FAR, ELR for EL1 <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_fatal.c#L381-L390">(Because of this)</a></p>
<p>This won‚Äôt work‚Ä¶</p>
<p>https://github.com/lupyuen/pinephone-emulator/blob/1cbfa48de10ef4735ebaf91ab85631cb48e37591/src/main.rs#L86-L91</p>
<p>Because <code>ESR_EL</code> is no longer supported and <code>CP_REG</code> can‚Äôt be read in Rust‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>err=Err(EXCEPTION)
CP_REG=Err(ARG)
ESR_EL0=Ok(0)
ESR_EL1=Ok(0)
ESR_EL2=Ok(0)
ESR_EL3=Ok(0)
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/778f15875edf632ccb5a093a656084cb">(See the Complete Log)</a></p>
<p><code>CP_REG</code> can‚Äôt be read in Rust because it needs a pointer to <code>uc_arm64_cp_reg</code> <a href="https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_arm64.py#L76-L82">(like this)</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static uc_err reg_read(CPUARMState *env, unsigned int regid, void *value) {
  ...
  case UC_ARM64_REG_CP_REG:
      ret = read_cp_reg(env, (uc_arm64_cp_reg *)value);
      break;
</code></pre></div>
<p><a href="https://github.com/unicorn-engine/unicorn/blob/master/qemu/target/arm/unicorn_aarch64.c#L225-L227">(Source)</a></p>
<p>Which isn‚Äôt supported by the Rust Bindings.</p>
<p>So instead we set a breakpoint at <code>arm64_reg_read()</code> (pic below) in‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>.cargo/registry/src/github.com-1ecc6299db9ec823/unicorn-engine-2.0.1/qemu/target/arm/unicorn_aarch64.c
</code></pre></div>
<p>(<code>arm64_reg_read()</code> calls <code>reg_read()</code> in unicorn_aarch64.c)</p>
<p>Which shows the Exception as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>env.exception = {
  syndrome: 0x8600 003f, 
  fsr: 5, 
  vaddress: 0x400c 3fff,
  target_el: 1
}
</code></pre></div>
<p>Let‚Äôs study the Arm64 Exception‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-debug.png" alt="Debug the Arm64 Exception" /></p>
<h1 id="arm64-mmu-exception"><a href="#arm64-mmu-exception">12 Arm64 MMU Exception</a></h1>
<p>TODO</p>
<p>Earlier we saw this Arm64 Exception in Unicorn Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>env.exception = {
  syndrome: 0x8600 003f, 
  fsr: 5, 
  vaddress: 0x400c 3fff,
  target_el: 1
}
</code></pre></div>
<p>TODO: What is address <code>0x400c</code> <code>3fff</code>?</p>
<p><em>What is Syndrome 0x8600 003f?</em></p>
<p>Bits 26-31 of Syndrome = 0b100001, which means‚Ä¶</p>
<blockquote>
<p>0b100001: Instruction Abort taken without a change in Exception level.</p>
</blockquote>
<blockquote>
<p>Used for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.</p>
</blockquote>
<p><a href="https://developer.arm.com/documentation/ddi0601/2022-03/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-">(Source)</a></p>
<p><em>What is FSR 5?</em></p>
<p>FSR 5 means‚Ä¶</p>
<blockquote>
<p>0b00101: Translation Fault (in) Section</p>
</blockquote>
<p><a href="https://developer.arm.com/documentation/ddi0500/d/system-control/aarch64-register-descriptions/instruction-fault-status-register--el2">(Source)</a></p>
<p><em>Why the MMU Fault?</em></p>
<p>Unicorn Emulator triggers the exception when NuttX writes to SCTLR_EL1‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Enable the MMU and data cache */
  value = read_sysreg(sctlr_el1);
  write_sysreg((value | SCTLR_M_BIT | SCTLR_C_BIT), sctlr_el1);
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L541-L544">(Source)</a></p>
<p>The above code sets these flags in SCTLR_EL1 (System Control Register EL1)‚Ä¶</p>
<ul>
<li>
<p>SCTLR_M_BIT (Bit 0): Enable Address Translation for EL0 and EL1 Stage 1</p>
</li>
<li>
<p>SCTLR_C_BIT (Bit 2): Enable Caching for EL0 and EL1 Stage 1</p>
</li>
</ul>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/SCTLR-EL1--System-Control-Register--EL1-">(More about SCTLR_EL1)</a></p>
<p>TODO: Why did the Address Translation (or Caching) fail?</p>
<p>TODO: Should we skip the MMU Update to SCTLR_EL1? Since we don‚Äôt use MMU?</p>
<h1 id="debug-the-unicorn-emulator"><a href="#debug-the-unicorn-emulator">13 Debug the Unicorn Emulator</a></h1>
<p>TODO</p>
<p><em>To troubleshoot the Arm64 MMU Exception‚Ä¶</em></p>
<p><em>Can we use a debugger to step through Unicorn Emulator?</em></p>
<p>Yes but it gets messy.</p>
<p>TODO: Trace the exception in the debugger. Look for‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$HOME/.cargo/registry/src/github.com-1ecc6299db9ec823/unicorn-engine-2.0.1/qemu/target/arm/translate-a64.c
</code></pre></div>
<p>Set a breakpoint in <code>aarch64_tr_translate_insn()</code></p>
<ul>
<li>
<p>Which calls <code>disas_b_exc_sys()</code></p>
</li>
<li>
<p>Which calls <code>disas_system()</code></p>
</li>
<li>
<p>Which calls <code>handle_sys()</code> to handle system instructions</p>
</li>
</ul>
<p>TODO: Emulate the special Arm64 Instructions </p>
<p>To inspect the Emulator Settings, set a breakpoint at <code>cpu_aarch64_init()</code> in‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$HOME/.cargo/registry/src/github.com-1ecc6299db9ec823/unicorn-engine-2.0.1/qemu/target/arm/cpu64.c
</code></pre></div><h1 id="other-emulators"><a href="#other-emulators">14 Other Emulators</a></h1>
<p>TODO</p>
<p><em>What about emulating popular operating systems: Linux / macOS / Windows / Android?</em></p>
<p>Check out the Qiling Binary Emulation Framework‚Ä¶</p>
<ul>
<li><a href="https://github.com/qilingframework/qiling">qilingframework/qiling</a></li>
</ul>
<p><em>How about other hardware platforms: STM32 Blue Pill and ESP32?</em></p>
<p>Check out QEMU‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/stm32-blue-pill-unit-testing-with-qemu-blue-pill-emulator">‚ÄúSTM32 Blue Pill ‚Äî Unit Testing with Qemu Blue Pill Emulator‚Äù</a></p>
</li>
<li>
<p><a href="https://medium.com/@lucassvaz/nuttx-on-an-emulated-esp32-using-qemu-8d8d93d24c63">‚ÄúNuttX on an emulated ESP32 using QEMU‚Äù</a></p>
</li>
</ul>
<h1 id="todo"><a href="#todo">15 TODO</a></h1>
<p>TODO: Use Unicorn Emulation Hooks to emulate PinePhone‚Äôs Allwinner A64 UART Controller</p>
<p>TODO: Emulate Apache NuttX NSH Shell on UART Controller</p>
<p>TODO: Emulate PinePhone‚Äôs Allwinner A64 Display Engine. How to render the emulated graphics: Use Web Browser + WebAssembly + Unicorn.js? Will framebuffer emulation be slow?</p>
<p>TODO: Emulate Interrupts</p>
<p>TODO: Emulate Multiple CPUs</p>
<p>TODO: Emulate Memory Protection</p>
<p>TODO: Emulate GIC v2</p>
<p>TODO: Read the Symbol Table in ELF File to get the addresses</p>
<p>TODO: Select Cortex-A53 as CPU</p>
<p>TODO: Good enough for daily build and test for NuttX on PinePhone, similar to this, but booting the daily build on Unicorn Emulator instead of Real Hardware</p>
<p><a href="https://lupyuen.github.io/articles/auto"><strong>‚ÄúAuto Flash and Test NuttX on RISC-V BL602‚Äù</strong></a></p>
<h1 id="whats-next"><a href="#whats-next">16 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/unicorn.md"><strong>lupyuen.github.io/src/unicorn.md</strong></a></p>

    
</body>
</html>