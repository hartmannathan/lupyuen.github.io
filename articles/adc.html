<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on RISC-V BL602: Is It Sunny?</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on RISC-V BL602: Is It Sunny?" 
    data-rh="true">
<meta property="og:description" 
    content="How we create Rust Firmware that reads Analog Inputs... With the Analog-to-Digital Converter on RISC-V BL602"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/adc-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on RISC-V BL602: Is It Sunny?</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-adc-in-c">1 BL602 ADC in C</a><ul>
<li><a href="#definitions">1.1 Definitions</a><ul></ul></li>
<li><a href="#initialise-the-adc-channel">1.2 Initialise the ADC Channel</a><ul></ul></li>
<li><a href="#read-the-adc-channel">1.3 Read the ADC Channel</a><ul></ul></li>
<li><a href="#run-the-c-firmware">1.4 Run the C Firmware</a><ul></ul></li>
<li><a href="#set-the-adc-gain">1.5 Set the ADC Gain</a><ul></ul></li></ul></li>
<li><a href="#create-a-bl602-rust-project">2 Create a BL602 Rust Project</a><ul></ul></li>
<li><a href="#bl602-adc-in-rust">3 BL602 ADC in Rust</a><ul>
<li><a href="#definitions-1">3.1 Definitions</a><ul></ul></li>
<li><a href="#initialise-the-adc-channel-1">3.2 Initialise the ADC Channel</a><ul></ul></li>
<li><a href="#read-the-adc-channel-1">3.3 Read the ADC Channel</a><ul></ul></li></ul></li>
<li><a href="#build-the-bl602-rust-firmware">4 Build the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#flash-the-bl602-rust-firmware">5 Flash the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#run-the-bl602-rust-firmware">6 Run the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#from-c-to-rust">7 From C To Rust</a><ul>
<li><a href="#safer-rust">7.1 Safer Rust</a><ul></ul></li>
<li><a href="#static-variables-in-rust">7.2 Static Variables in Rust</a><ul></ul></li></ul></li>
<li><a href="#rust-wrapper-for-bl602-iot-sdk">8 Rust Wrapper for BL602 IoT SDK</a><ul></ul></li>
<li><a href="#why-sunlight">9 Why Sunlight?</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-call-c-functions-from-rust">12 Appendix: Call C Functions from Rust</a><ul></ul></li>
<li><a href="#appendix-cast-c-pointers-in-rust">13 Appendix: Cast C Pointers in Rust</a><ul></ul></li>
<li><a href="#appendix-copy-memory-with-c-pointers">14 Appendix: Copy Memory with C Pointers</a><ul></ul></li>
<li><a href="#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">15 Appendix: Generating the Rust Wrapper for BL602 IoT SDK</a><ul>
<li><a href="#how-it-works">15.1 How it works</a><ul></ul></li>
<li><a href="#inject-the-docs">15.2 Inject the docs</a><ul></ul></li>
<li><a href="#rename-the-functions">15.3 Rename the functions</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>3 Aug 2021</em></p>
<p>Today we shall magically transform <a href="https://lupyuen.github.io/articles/pinecone"><strong>any RISC-V BL602 Board</strong></a> into a <strong>Light Sensor!</strong></p>
<p>We‚Äôll do this two ways‚Ä¶</p>
<ol>
<li>
<p>First we code the firmware in C</p>
<p>(By calling the BL602 IoT SDK)</p>
</li>
<li>
<p>Then we port the C firmware to Rust with‚Ä¶</p>
<p><a href="https://crates.io/crates/bl602-sdk"><strong>Rust Wrapper for BL602 IoT SDK</strong></a></p>
<p>(New to Rust? No worries we have tips for you!)</p>
</li>
</ol>
<p><em>Wait‚Ä¶ Do all BL602 Boards have an onboard Light Sensor?</em></p>
<p>Nope, all we need is a <strong>BL602 Board with an LED</strong>!</p>
<p>Reading the LED with BL602‚Äôs <strong>Analog-to-Digital Converter (ADC)</strong> will turn it into a simple, improvised Light Sensor.</p>
<p><em>Amazing! Will this work with any BL602 Board?</em></p>
<p>We have tested this with <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602</strong></a> and its onboard LED.</p>
<p>It will probably work with any BL602 / BL604 Board with an <strong>onboard or external LED:</strong> <a href="https://docs.ai-thinker.com/en/wb2"><strong>Ai-Thinker Ai-WB2</strong></a>, PineDio Stack, Pinenut, DT-BL10, MagicHome BL602, ‚Ä¶</p>
<p><em>Will our Light Sensor detect any kind of light?</em></p>
<p>Our LED-turned-Light-Sensor works best for <strong>detecting sunlight</strong>‚Ä¶ We‚Äôll learn why in a while.</p>
<p>(Yep It‚Äôs Always Sunny in Singapore ‚Ä¶ So this Sunlight Sensor won‚Äôt be so useful in Singapore üòÇ)</p>
<p><img src="https://lupyuen.github.io/images/adc-title.jpg" alt="Testing the improvised Light Sensor on PineCone BL602 RISC-V Board. BTW that‚Äôs the moon" /></p>
<p><em>Testing the improvised Light Sensor on PineCone BL602 RISC-V Board. BTW that‚Äôs the moon</em></p>
<h1 id="bl602-adc-in-c"><a href="#bl602-adc-in-c">1 BL602 ADC in C</a></h1>
<p>On PineCone BL602, there‚Äôs a <strong>Blue LED</strong> connected on <strong>GPIO Pin Number 11</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/led-rgb.png" alt="PineCone RGB LED Schematic" /></p>
<p><a href="https://github.com/pine64/bl602-docs/blob/main/mirrored/Pine64%20BL602%20EVB%20Schematic%20ver%201.1.pdf">(From PineCone BL602 Schematic)</a></p>
<p>For light sensing, we shall <strong>read the voltage</strong> from this LED GPIO with BL602‚Äôs Analog-to-Digital Converter (ADC).</p>
<p>(Because LEDs will produce a current when exposed to light. <a href="https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227">See this</a>)</p>
<p>Let‚Äôs study the <strong>C Firmware for BL602 ADC</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/"><code>sdk_app_adc2</code></a></p>
<p>By calling the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c"><strong>BL602 ADC Low Level HAL</strong></a> (Hardware Abstraction Layer), we shall‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise the ADC Channel</strong> for reading our LED GPIO</p>
</li>
<li>
<p><strong>Compute the average value</strong> of the ADC Samples that have been read</p>
</li>
</ol>
<h2 id="definitions"><a href="#definitions">1.1 Definitions</a></h2>
<p>We start by defining the <strong>GPIO Pin Number</strong> that will be read via ADC: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L13-L31"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// GPIO Pin Number that will be configured as ADC Input.
/// PineCone Blue LED is connected on BL602 GPIO 11.
/// PineCone Green LED is connected on BL602 GPIO 14.
/// Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15
/// TODO: Change the GPIO Pin Number for your BL602 board
#define ADC_GPIO 11
</code></pre></div>
<p><strong>Not all GPIOs</strong> are supported by BL602‚Äôs ADC!</p>
<p>According to the BL602 Reference Manual, only the following GPIOs are <strong>supported for ADC</strong>: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15</p>
<p><img src="https://lupyuen.github.io/images/adc-pins.png" alt="ADC GPIO Pin Numbers" /></p>
<p>Next we define the <strong>ADC Frequency</strong>. We shall read 10,000 ADC Samples every second‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// We set the ADC Frequency to 10 kHz according to &lt;https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227&gt;
/// This is 10,000 samples per second.
#define ADC_FREQUENCY 10000  //  Hz
</code></pre></div>
<p>For computing the average, we shall remember the <strong>last 1,000 ADC Samples read</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// We shall read 1,000 ADC samples, which will take 0.1 seconds
#define ADC_SAMPLES 1000
</code></pre></div>
<p>Finally we set the <strong>ADC Gain</strong> to increase the sensitivity of the ADC‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Set ADC Gain to Level 1 to increase the ADC sensitivity.
/// To disable ADC Gain, set `ADC_GAIN1` and `ADC_GAIN2` to `ADC_PGA_GAIN_NONE`.
/// See &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_adc.h#L133-L144&gt;
#define ADC_GAIN1 ADC_PGA_GAIN_1
#define ADC_GAIN2 ADC_PGA_GAIN_1
</code></pre></div>
<p>More about ADC Gain in a while.</p>
<h2 id="initialise-the-adc-channel"><a href="#initialise-the-adc-channel">1.2 Initialise the ADC Channel</a></h2>
<p>Here‚Äôs how we <strong>initialise the ADC Channel</strong> for reading our LED GPIO: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L36-L77"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to init the ADC Channel and start reading the ADC Samples.
/// Based on `hal_adc_init` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L50-L102&gt;
void init_adc(char *buf, int len, int argc, char **argv) {
  //  Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15
  assert(ADC_GPIO==4 || ADC_GPIO==5 || ADC_GPIO==6 || ADC_GPIO==9 || ADC_GPIO==10 || ADC_GPIO==11 || ADC_GPIO==12 || ADC_GPIO==13 || ADC_GPIO==14 || ADC_GPIO==15);

  //  For Single-Channel Conversion Mode, frequency must be between 500 and 16,000 Hz
  assert(ADC_FREQUENCY &gt;= 500 &amp;&amp; ADC_FREQUENCY &lt;= 16000);

  //  Init the ADC Frequency for Single-Channel Conversion Mode
  int rc = bl_adc_freq_init(1, ADC_FREQUENCY);
  assert(rc == 0);
</code></pre></div>
<p>Our <strong><code>init_adc</code> Command</strong> begins by validating the GPIO Pin Number and ADC Frequency.</p>
<p>Then it calls <strong><code>bl_adc_freq_init</code></strong> to set the <strong>ADC Frequency</strong>.</p>
<p>(Functions named <code>bl_adc_*</code> are defined in the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c">BL602 ADC Low Level HAL</a>)</p>
<p>The first parameter to <code>bl_adc_freq_init</code> selects the <strong>ADC Mode</strong>‚Ä¶</p>
<ul>
<li>
<p>ADC Mode 0: <strong>Scan Conversion Mode</strong></p>
<p>BL602 ADC Controller reads <strong>One ADC Sample</strong> from <strong>Multiple ADC Channels.</strong></p>
<p>(So it‚Äôs scanning across multiple ADC Channels, recording one sample per channel)</p>
</li>
<li>
<p>ADC Mode 1: <strong>Single-Channel Conversion Mode</strong></p>
<p>BL602 ADC Controller reads <strong>Multiple ADC Samples</strong> continuously from <strong>One ADC Channel.</strong></p>
<p>(This is the mode we‚Äôre using)</p>
</li>
</ul>
<p>Next we set the <strong>ADC GPIO Pin Number</strong> for ADC Mode 1 (Single-Channel Conversion)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init the ADC GPIO for Single-Channel Conversion Mode
  rc = bl_adc_init(1, ADC_GPIO);
  assert(rc == 0);
</code></pre></div>
<p>To increase the ADC sensitivity, we set the <strong>ADC Gain</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Enable ADC Gain to increase the ADC sensitivity
  rc = set_adc_gain(ADC_GAIN1, ADC_GAIN2);
  assert(rc == 0);
</code></pre></div>
<p>(More about this in a while)</p>
<p>BL602 ADC Controller shall transfer the ADC Samples directly into RAM, thanks to the <strong>Direct Memory Access (DMA) Controller</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init DMA for the ADC Channel for Single-Channel Conversion Mode
  rc = bl_adc_dma_init(1, ADC_SAMPLES);
  assert(rc == 0);
</code></pre></div>
<p>(First parameter of <code>bl_adc_dma_init</code> is the ADC Mode)</p>
<p>We configure the GPIO Pin for <strong>ADC Input</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the GPIO Pin as ADC Input, no pullup, no pulldown
  rc = bl_adc_gpio_init(ADC_GPIO);
  assert(rc == 0);
</code></pre></div>
<p>We set the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the ADC Channel Number for the GPIO Pin
  int channel = bl_adc_get_channel_by_gpio(ADC_GPIO);

  //  Get the DMA Context for the ADC Channel
  adc_ctx_t *ctx = bl_dma_find_ctx_by_channel(ADC_DMA_CHANNEL);
  assert(ctx != NULL);

  //  Indicate that the GPIO has been configured for ADC
  ctx-&gt;chan_init_table |= (1 &lt;&lt; channel);
</code></pre></div>
<p>(<code>bl_dma_find_ctx_by_channel</code> is defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_dma.c">BL602 DMA HAL</a>)</p>
<p>Finally we <strong>start the ADC Channel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Start reading the ADC via DMA
  bl_adc_start();
}
</code></pre></div>
<p>BL602 ADC Controller will <strong>read the ADC Samples continuously</strong> (from the GPIO Pin) into RAM (until we stop the ADC Channel).</p>
<h2 id="read-the-adc-channel"><a href="#read-the-adc-channel">1.3 Read the ADC Channel</a></h2>
<p><em>After starting the ADC Channel, how do we fetch the ADC Samples that have been read?</em></p>
<p>Let‚Äôs find out in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L79-L116"><code>demo.c</code></a> ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to compute the average value of the ADC Samples that have just been read.
/// Based on `hal_adc_get_data` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L142-L179&gt;
void read_adc(char *buf, int len, int argc, char **argv) {
  //  Get the ADC Channel Number for the GPIO Pin
  int channel = bl_adc_get_channel_by_gpio(ADC_GPIO);
    
  //  Get the DMA Context for the ADC Channel
  adc_ctx_t *ctx = bl_dma_find_ctx_by_channel(ADC_DMA_CHANNEL);
  assert(ctx != NULL);

  //  Verify that the GPIO has been configured for ADC
  assert(((1 &lt;&lt; channel) &amp; ctx-&gt;chan_init_table) != 0);
</code></pre></div>
<p>Our <strong><code>read_adc</code> Command</strong> begins by verifying the <strong>DMA Context</strong> for the ADC Channel.</p>
<p>Next we check whether the <strong>ADC Sampling</strong> has been completed for the ADC Channel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  If ADC Sampling is not finished, try again later    
  if (ctx-&gt;channel_data == NULL) {
    printf(&quot;ADC Sampling not finished\r\n&quot;);
    return;
  }
</code></pre></div>
<p>Remember that the BL602 ADC Controller will <strong>read ADC Samples continuously</strong> and write the last 1,000 samples to RAM (via DMA).</p>
<p>Let‚Äôs <strong>copy the last 1,000 ADC Samples</strong> from the DMA Context (in RAM) to a Static Array <code>adc_data</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Static array that will store 1,000 ADC Samples
  static uint32_t adc_data[ADC_SAMPLES];

  //  Copy the read ADC Samples to the static array
  memcpy(
    (uint8_t*) adc_data,             //  Destination
    (uint8_t*) (ctx-&gt;channel_data),  //  Source
    sizeof(adc_data)                 //  Size
  );  
</code></pre></div>
<p>Then we compute the <strong>average value of the ADC Samples</strong> in <code>adc_data</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Compute the average value of the ADC Samples
  uint32_t sum = 0;
  for (int i = 0; i &lt; ADC_SAMPLES; i++) {
    //  Scale up the ADC Sample to the range 0 to 3199
    uint32_t scaled = ((adc_data[i] &amp; 0xffff) * 3200) &gt;&gt; 16;
    sum += scaled;
  }
  printf(&quot;Average: %lu\r\n&quot;, (sum / ADC_SAMPLES));
}
</code></pre></div>
<p>The default ADC Configuration has roughly <strong>12 Bits of Resolution per ADC Sample</strong>.</p>
<p>Thus we scale each ADC Sample to the range <strong>0 to 3199</strong>.</p>
<p>And that‚Äôs how we code BL602 ADC Firmware in C!</p>
<p><img src="https://lupyuen.github.io/images/adc-demo.png" alt="Running the BL602 ADC Firmware in C" /></p>
<h2 id="run-the-c-firmware"><a href="#run-the-c-firmware">1.4 Run the C Firmware</a></h2>
<p>Watch what happens when we <strong>flash and run</strong> the C Firmware for BL602 ADC: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/"><code>sdk_app_adc2</code></a></p>
<ol>
<li>
<p>Enter this command to <strong>initialise the ADC Channel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>init_adc
</code></pre></div>
<p>(We‚Äôve seen this function earlier)</p>
</li>
<li>
<p>Place the BL602 Board (with LED) in a <strong>dark place</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times to get the <strong>average values</strong> of the last 1,000 ADC Samples‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_adc
  Average: 1416

read_adc
  Average: 1416

read_adc
  Average: 1416
</code></pre></div></li>
<li>
<p>Now place the BL602 Board (with LED) <strong>under sunlight</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_adc
  Average: 1408

read_adc
  Average: 1408

read_adc
  Average: 1408
</code></pre></div>
<p>Note that the average values have <strong>dropped from 1416 to 1408.</strong></p>
</li>
<li>
<p>Place the BL602 Board (with LED) <strong>back in the dark</strong> and check the average values‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_adc
  Average: 1417

read_adc
  Average: 1416

read_adc
  Average: 1416
</code></pre></div>
<p>The average values have <strong>increased from 1408 to 1416.</strong></p>
<p>Yep our improvised BL602 Light Sensor works!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/adc-gain2.png" alt="Setting the ADC Gain" /></p>
<h2 id="set-the-adc-gain"><a href="#set-the-adc-gain">1.5 Set the ADC Gain</a></h2>
<p>Let‚Äôs chat about <strong>ADC Gain</strong>, which we used when reading the LED as a Light Sensor. </p>
<p>(ADC Gain probably won‚Äôt be needed for reading most types of ADC Inputs)</p>
<p><em>Why do we need ADC Gain when reading an LED?</em></p>
<p>Our LED generates a <strong>tiny bit of current</strong> when exposed to light. To measure that tiny bit of current, we need to increase the ADC sensitivity.</p>
<p>Thus we <strong>increase the ADC Gain</strong>. (By default there‚Äôs no ADC Gain)</p>
<p><em>BL602 HAL has a function that sets the ADC Gain right?</em></p>
<p>Sadly no. We need to go really low-level and call the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_adc.c#L152-L230"><strong>BL602 Standard Driver for ADC</strong></a>.</p>
<p>(The BL602 Standard Driver directly manipulates the BL602 Hardware Registers)</p>
<p>Here‚Äôs the low-level code that <strong>sets the ADC Gain</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L118-L146"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Enable ADC Gain to increase the ADC sensitivity.
/// Based on ADC_Init in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_adc.c#L152-L230&gt;
static int set_adc_gain(uint32_t gain1, uint32_t gain2) {
  //  Read the ADC Configuration Hardware Register
  uint32_t reg = BL_RD_REG(AON_BASE, AON_GPADC_REG_CONFIG2);

  //  Set the ADC Gain
  reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_PGA1_GAIN, gain1);
  reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_PGA2_GAIN, gain2);

  //  Set the ADC Chop Mode
  if (gain1 != ADC_PGA_GAIN_NONE || gain2 != ADC_PGA_GAIN_NONE) {
    reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_CHOP_MODE, 2);
  } else {
    reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_CHOP_MODE, 1);        
  }

  //  Enable the ADC PGA
  reg = BL_CLR_REG_BIT(reg, AON_GPADC_PGA_VCMI_EN);
  if (gain1 != ADC_PGA_GAIN_NONE || gain2 != ADC_PGA_GAIN_NONE) {
    reg = BL_SET_REG_BIT(reg, AON_GPADC_PGA_EN);
  } else {
    reg = BL_CLR_REG_BIT(reg, AON_GPADC_PGA_EN);
  }

  //  Update the ADC Configuration Hardware Register
  BL_WR_REG(AON_BASE, AON_GPADC_REG_CONFIG2, reg);
  return 0;
}
</code></pre></div><h1 id="create-a-bl602-rust-project"><a href="#create-a-bl602-rust-project">2 Create a BL602 Rust Project</a></h1>
<p>Before diving into the Rust Firmware, let‚Äôs walk through the steps for <strong>creating a BL602 Rust Project</strong> (like <code>sdk_app_rust_adc</code>)‚Ä¶</p>
<ol>
<li>
<p><strong>Download the Source Code</strong> for BL602 IoT SDK‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>git clone --recursive https://github.com/lupyuen/bl_iot_sdk
</code></pre></div></li>
<li>
<p><strong>Copy the Project Folder</strong> for an existing Rust Project in <strong><code>bl_iot_sdk/customer_app</code></strong>, like <code>sdk_app_rust_gpio</code> ‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_gpio"><strong>Project Folder for <code>sdk_app_rust_gpio</code></strong></a></li>
</ul>
</li>
<li>
<p><strong>Paste the Project Folder</strong> into <strong><code>bl_iot_sdk/customer_app</code></strong> and rename it (like <code>sdk_app_rust_adc</code>)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-project.png" alt="BL602 Rust Project" /></p>
<p>Be sure to <strong>rename the Sub Folder</strong> too. (The <code>sdk_app_rust_adc</code> inside <code>sdk_app_rust_adc</code>)</p>
<p><strong>Delete the <code>build_out</code> folder</strong> if it exists.</p>
</li>
<li>
<p><strong>Edit the <code>Makefile</code></strong> in the new folder and set the Project Name: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/Makefile"><code>sdk_app_rust_adc/Makefile</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>##  Set the project name
PROJECT_NAME := sdk_app_rust_adc
</code></pre></div></li>
<li>
<p>Set the <strong>GCC Compiler Options</strong> (if any) in the Makefile <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/bouffalo.mk"><code>sdk_app_rust_adc / sdk_app_rust_adc / bouffalo.mk</code></a></p>
</li>
<li>
<p>Edit the <strong><code>run.sh</code> script</strong> in the new folder and set the Project Name: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/run.sh"><code>sdk_app_rust_adc/run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Set the project name
export APP_NAME=sdk_app_rust_adc
</code></pre></div></li>
<li>
<p>Replace the <strong>Rust Source Code</strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs"><code>sdk_app_rust_adc/ rust/src/lib.rs</code></a> </p>
</li>
<li>
<p>See the Appendix for the steps to define the <strong>Rust Commands</strong> for the Command-Line Interface in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c#L47-L55"><code>sdk_app_rust_adc / demo.c</code></a></p>
</li>
<li>
<p>Remember to edit <strong><code>README.md</code></strong> and fill in the project details</p>
</li>
</ol>
<h1 id="bl602-adc-in-rust"><a href="#bl602-adc-in-rust">3 BL602 ADC in Rust</a></h1>
<p>Now we study the <strong>Rust Firmware for BL602 ADC</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc"><code>sdk_app_rust_adc</code></a></p>
<p>We have <strong>converted the C Firmware to Rust</strong> line by line, so the Rust code will look highly similar to C.</p>
<p>Recall that our firmware implements two commands‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise the ADC Channel</strong> for reading our LED GPIO</p>
</li>
<li>
<p><strong>Compute the average value</strong> of the ADC Samples that have been read</p>
</li>
</ol>
<p>Here is the Rust implementation‚Ä¶</p>
<h2 id="definitions-1"><a href="#definitions-1">3.1 Definitions</a></h2>
<p>We start by declaring to the Rust Compiler that we‚Äôre calling the <strong>Rust Core Library</strong> (instead of Rust Standard Library): <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L1-L37"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_std]  </span><span class="comment">//  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems</span></code></pre></div>
<p>(Rust Standard Library is too heavy for embedded programs)</p>
<p>Next we <strong>import the functions</strong> from Rust Core Library that will be used in a while‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Import Libraries
</span><span class="kw">use </span>core::{          <span class="comment">//  Rust Core Library
  </span>fmt::Write,        <span class="comment">//  String Formatting    
  </span>mem::transmute,    <span class="comment">//  Pointer Casting
  </span>panic::PanicInfo,  <span class="comment">//  Panic Handler
</span>};</code></pre></div>
<p>We import the <strong>Rust Wrapper for BL602 IoT SDK</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bl602_sdk::{     <span class="comment">//  Rust Wrapper for BL602 IoT SDK
  </span>adc,               <span class="comment">//  ADC HAL
  </span>dma,               <span class="comment">//  DMA HAL
  </span>puts,              <span class="comment">//  Console Output
  </span>Ptr,               <span class="comment">//  C Pointer
  </span>String,            <span class="comment">//  Strings (limited to 64 chars)
</span>};</code></pre></div>
<p>We shall read <strong>GPIO 11</strong> (the Blue LED) as ADC Input‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// GPIO Pin Number that will be configured as ADC Input.
/// PineCone Blue LED is connected on BL602 GPIO 11.
/// PineCone Green LED is connected on BL602 GPIO 14.
/// Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15
/// TODO: Change the GPIO Pin Number for your BL602 board
</span><span class="kw">const </span>ADC_GPIO: i32 = <span class="number">11</span>;</code></pre></div>
<p>BL602 ADC Controller shall read <strong>10,000 ADC Samples per second</strong>, and remember the last <strong>100 ADC Samples</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// We set the ADC Frequency to 10 kHz according to &lt;https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227&gt;
/// This is 10,000 samples per second.
</span><span class="kw">const </span>ADC_FREQUENCY: u32 = <span class="number">10000</span>;  <span class="comment">//  Hz

</span><span class="doccomment">/// We shall read 100 ADC samples, which will take 0.01 seconds
</span><span class="kw">const </span>ADC_SAMPLES: usize = <span class="number">100</span>;</code></pre></div>
<p>(<code>usize</code> is similar to <code>size_t</code> in C, it‚Äôs used to represent the size of arrays)</p>
<p>We shall set the <strong>ADC Gain</strong> to increase the ADC sensitivity‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Set ADC Gain to Level 1 to increase the ADC sensitivity.
/// To disable ADC Gain, set `ADC_GAIN1` and `ADC_GAIN2` to `ADC_PGA_GAIN_NONE`.
/// See &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_adc.h#L133-L144&gt;
</span><span class="kw">const </span>ADC_GAIN1: u32 = ADC_PGA_GAIN_1;
<span class="kw">const </span>ADC_GAIN2: u32 = ADC_PGA_GAIN_1;</code></pre></div>
<p>But <strong><code>ADC_PGA_GAIN_1</code></strong> is missing from our Rust Wrapper.</p>
<p>Thus we copy the value from BL602 IoT SDK and define it here‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ADC_PGA_GAIN_1: u32 = <span class="number">1</span>;  <span class="comment">//  From &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_adc.h#L133-L144&gt;</span></code></pre></div>
<p><img src="https://lupyuen.github.io/images/adc-rust.png" alt="Rust Firmware for BL602 ADC" /></p>
<h2 id="initialise-the-adc-channel-1"><a href="#initialise-the-adc-channel-1">3.2 Initialise the ADC Channel</a></h2>
<p>Here‚Äôs our Rust Function <strong><code>init_adc</code></strong> that will be called by the BL602 Command-Line Interface: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L39-L100"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Command to init the ADC Channel and start reading the ADC Samples.
/// Based on `hal_adc_init` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L50-L102&gt;
</span><span class="attr">#[no_mangle]             </span><span class="comment">//  Don't mangle the function name
</span><span class="kw">extern </span><span class="string">"C" </span><span class="kw">fn </span>init_adc(  <span class="comment">//  Declare `extern "C"` because it will be called by BL602 firmware
  </span>_result: <span class="kw-2">*mut </span>u8,        <span class="comment">//  Result to be returned to command-line interface (char *)
  </span>_len:  i32,              <span class="comment">//  Size of result buffer (int)
  </span>_argc: i32,              <span class="comment">//  Number of command line args (int)
  </span>_argv: <span class="kw-2">*const *const </span>u8  <span class="comment">//  Array of command line args (char **)
</span>) {
  puts(<span class="string">"[Rust] Init ADC"</span>);</code></pre></div>
<p>(We won‚Äôt be parsing the command-line arguments, so let‚Äôs ignore the parameters passed to <code>init_adc</code>)</p>
<p>We start by validating the GPIO Pin Number and ADC Frequency‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15
  </span><span class="macro">assert!</span>(ADC_GPIO==<span class="number">4 </span>|| ADC_GPIO==<span class="number">5 </span>|| ADC_GPIO==<span class="number">6 </span>|| ADC_GPIO==<span class="number">9 </span>|| ADC_GPIO==<span class="number">10 </span>|| ADC_GPIO==<span class="number">11 </span>|| ADC_GPIO==<span class="number">12 </span>|| ADC_GPIO==<span class="number">13 </span>|| ADC_GPIO==<span class="number">14 </span>|| ADC_GPIO==<span class="number">15</span>);

  <span class="comment">//  For Single-Channel Conversion Mode, frequency must be between 500 and 16,000 Hz
  </span><span class="macro">assert!</span>(ADC_FREQUENCY &gt;= <span class="number">500 </span>&amp;&amp; ADC_FREQUENCY &lt;= <span class="number">16000</span>);</code></pre></div>
<p>(Remember: Not all GPIOs are supported for ADC!)</p>
<p>Next we select <strong>ADC Mode 1</strong> (Single-Channel Conversion) and set the <strong>ADC Frequency</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Init the ADC Frequency for Single-Channel Conversion Mode
  </span>adc::freq_init(<span class="number">1</span>, ADC_FREQUENCY)
    .expect(<span class="string">"ADC Freq failed"</span>);</code></pre></div>
<p>We set the <strong>ADC GPIO Pin Number</strong> for ADC Mode 1‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Init the ADC GPIO for Single-Channel Conversion Mode
  </span>adc::init(<span class="number">1</span>, ADC_GPIO)
    .expect(<span class="string">"ADC Init failed"</span>);</code></pre></div>
<p>To increase the ADC sensitivity, we set the <strong>ADC Gain</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Enable ADC Gain to increase the ADC sensitivity
  </span><span class="kw">let </span>rc = <span class="kw">unsafe </span>{ set_adc_gain(ADC_GAIN1, ADC_GAIN2) };  <span class="comment">//  Unsafe because we are calling C function
  </span><span class="macro">assert!</span>(rc == <span class="number">0</span>);</code></pre></div>
<p>(This calls our C function <code>set_adc_gain</code>, which shall be explained below)</p>
<p>BL602 ADC Controller shall transfer the ADC Samples directly into RAM, thanks to the <strong>Direct Memory Access (DMA) Controller</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Init DMA for the ADC Channel for Single-Channel Conversion Mode
  </span>adc::dma_init(<span class="number">1</span>, ADC_SAMPLES <span class="kw">as </span>u32)
    .expect(<span class="string">"DMA Init failed"</span>);</code></pre></div>
<p>(First parameter of <code>dma_init</code> is the ADC Mode)</p>
<p>We configure the GPIO Pin for <strong>ADC Input</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Configure the GPIO Pin as ADC Input, no pullup, no pulldown
  </span>adc::gpio_init(ADC_GPIO)
    .expect(<span class="string">"ADC GPIO failed"</span>);</code></pre></div>
<p>And we fetch the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Get the ADC Channel Number for the GPIO Pin
  </span><span class="kw">let </span>channel = adc::get_channel_by_gpio(ADC_GPIO)
    .expect(<span class="string">"ADC Channel failed"</span>);

  <span class="comment">//  Get the DMA Context for the ADC Channel
  </span><span class="kw">let </span>ptr = dma::find_ctx_by_channel(adc::ADC_DMA_CHANNEL <span class="kw">as </span>i32)
    .expect(<span class="string">"DMA Ctx failed"</span>);</code></pre></div>
<p>However the returned pointer <code>ptr</code> is actually a ‚Äú<code>void *</code>‚Äù pointer from C.</p>
<p>To use the pointer in Rust, we cast it to a <strong>DMA Context Pointer</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Cast the returned C Pointer (void *) to a DMA Context Pointer (adc_ctx *)
  </span><span class="kw">let </span>ctx = <span class="kw">unsafe </span>{     <span class="comment">//  Unsafe because we are casting a pointer
    </span>transmute::&lt;         <span class="comment">//  Cast the type...
      </span>Ptr,               <span class="comment">//  From C Pointer (void *)
      </span><span class="kw-2">*mut </span>adc::adc_ctx  <span class="comment">//  To DMA Context Pointer (adc_ctx *)
    </span>&gt;(ptr)               <span class="comment">//  For this pointer
  </span>};</code></pre></div>
<p>(More about <code>transmute</code> in the Appendix)</p>
<p>Now we may update the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Indicate that the GPIO has been configured for ADC
  </span><span class="kw">unsafe </span>{  <span class="comment">//  Unsafe because we are dereferencing a pointer
    </span>(<span class="kw-2">*</span>ctx).chan_init_table |= <span class="number">1 </span>&lt;&lt; channel;
  }</code></pre></div>
<p>(We flag this as <code>unsafe</code> because we‚Äôre dereferencing a pointer: <code>ctx</code>)</p>
<p>Finally we <strong>start the ADC Channel</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Start reading the ADC via DMA
  </span>adc::start()
    .expect(<span class="string">"ADC Start failed"</span>);
}</code></pre></div>
<p>BL602 ADC Controller will <strong>read the ADC Samples continuously</strong> (from the GPIO Pin) into RAM (until we stop the ADC Channel).</p>
<p><img src="https://lupyuen.github.io/images/adc-rust2.png" alt="Rust Firmware to read BL602 ADC" /></p>
<h2 id="read-the-adc-channel-1"><a href="#read-the-adc-channel-1">3.3 Read the ADC Channel</a></h2>
<p><em>Our ADC Channel has been started, how do we average the ADC Samples that have been read?</em></p>
<p>Let‚Äôs check out the Rust Function <strong><code>read_adc</code></strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L102-L165"><code>lib.rs</code></a> ‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Command to compute the average value of the ADC Samples that have just been read.
/// Based on `hal_adc_get_data` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L142-L179&gt;
</span><span class="attr">#[no_mangle]              </span><span class="comment">//  Don't mangle the function name
</span><span class="kw">extern </span><span class="string">"C" </span><span class="kw">fn </span>read_adc(   <span class="comment">//  Declare `extern "C"` because it will be called by BL602 firmware
  </span>_result: <span class="kw-2">*mut </span>u8,        <span class="comment">//  Result to be returned to command-line interface (char *)
  </span>_len:  i32,              <span class="comment">//  Size of result buffer (int)
  </span>_argc: i32,              <span class="comment">//  Number of command line args (int)
  </span>_argv: <span class="kw-2">*const *const </span>u8  <span class="comment">//  Array of command line args (char **)
</span>) {</code></pre></div>
<p>First we fetch the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Get the ADC Channel Number for the GPIO Pin
  </span><span class="kw">let </span>channel = adc::get_channel_by_gpio(ADC_GPIO)
    .expect(<span class="string">"ADC Channel failed"</span>);
  
  <span class="comment">//  Get the DMA Context for the ADC Channel
  </span><span class="kw">let </span>ptr = dma::find_ctx_by_channel(adc::ADC_DMA_CHANNEL <span class="kw">as </span>i32)
    .expect(<span class="string">"DMA Ctx failed"</span>);</code></pre></div>
<p>Again we cast the returned C pointer <code>ptr</code> to a <strong>DMA Context Pointer</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Cast the returned C Pointer (void *) to a DMA Context Pointer (adc_ctx *)
  </span><span class="kw">let </span>ctx = <span class="kw">unsafe </span>{     <span class="comment">//  Unsafe because we are casting a pointer
    </span>transmute::&lt;         <span class="comment">//  Cast the type...
      </span>Ptr,               <span class="comment">//  From C Pointer (void *)
      </span><span class="kw-2">*mut </span>adc::adc_ctx  <span class="comment">//  To DMA Context Pointer (adc_ctx *)
    </span>&gt;(ptr)               <span class="comment">//  For this pointer
  </span>};</code></pre></div>
<p>(More about <code>transmute</code> in the Appendix)</p>
<p>Now we may verify the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Verify that the GPIO has been configured for ADC
  </span><span class="kw">unsafe </span>{  <span class="comment">//  Unsafe because we are dereferencing a pointer
    </span><span class="macro">assert!</span>(((<span class="number">1 </span>&lt;&lt; channel) &amp; (<span class="kw-2">*</span>ctx).chan_init_table) != <span class="number">0</span>);
  }</code></pre></div>
<p>(We flag this as <code>unsafe</code> because we‚Äôre dereferencing a pointer: <code>ctx</code>)</p>
<p>And we check whether the <strong>ADC Sampling</strong> has been completed for the ADC Channel (<code>channel_data</code> shouldn‚Äôt be null)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  If ADC Sampling is not finished, try again later    
  </span><span class="kw">if unsafe </span>{ (<span class="kw-2">*</span>ctx).channel_data.is_null() } {  <span class="comment">//  Unsafe because we are dereferencing a pointer
    </span>puts(<span class="string">"ADC Sampling not finished"</span>);
    <span class="kw">return</span>;
  }</code></pre></div>
<p>(Again we flag as <code>unsafe</code> because we‚Äôre dereferencing the pointer <code>ctx</code>)</p>
<p>Remember that the BL602 ADC Controller will <strong>read ADC Samples continuously</strong> and write the last 100 samples to RAM (via DMA).</p>
<p>We define an array <code>adc_data</code> to store the last 100 samples temporarily (on the stack)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Array that will store the last 100 ADC Samples
  //  (`ADC_SAMPLES` is 100)
  </span><span class="kw">let </span><span class="kw-2">mut </span>adc_data: [u32; ADC_SAMPLES]
    = [<span class="number">0</span>; ADC_SAMPLES];  <span class="comment">//  Init array to 100 zeroes</span></code></pre></div>
<p>(Rust requires all variables to be initialised, so we set the array to 100 zeroes)</p>
<p>Let‚Äôs <strong>copy the last 100 ADC Samples</strong> from the DMA Context (in RAM) to our array <code>adc_data</code> (on the stack)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Copy the read ADC Samples to the array
  </span><span class="kw">unsafe </span>{                    <span class="comment">//  Unsafe because we are copying raw memory
    </span>core::ptr::copy(          <span class="comment">//  Copy the memory...
      </span>(<span class="kw-2">*</span>ctx).channel_data,    <span class="comment">//  From Source (ADC DMA data)
      </span>adc_data.as_mut_ptr(),  <span class="comment">//  To Destination (mutable pointer to adc_data)
      </span>adc_data.len()          <span class="comment">//  Number of Items (each item is uint32 or 4 bytes)
    </span>);    
  }</code></pre></div>
<p>(More about this in the Appendix)</p>
<p>(<code>adc_data.len()</code> returns the array length: 100)</p>
<p>Then we compute the <strong>average value of the ADC Samples</strong> in <code>adc_data</code>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Compute the average value of the ADC Samples
  </span><span class="kw">let </span><span class="kw-2">mut </span>sum = <span class="number">0</span>;
  <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..ADC_SAMPLES {  <span class="comment">//  From 0 to 99, `..` excludes 100
    //  Scale up the ADC Sample to the range 0 to 3199
    </span><span class="kw">let </span>scaled = ((adc_data[i] &amp; <span class="number">0xffff</span>) * <span class="number">3200</span>) &gt;&gt; <span class="number">16</span>;
    sum += scaled;
  }
  <span class="kw">let </span>avg = sum / ADC_SAMPLES <span class="kw">as </span>u32;</code></pre></div>
<p>We scale each ADC Sample to the range <strong>0 to 3199</strong>. (Because the default ADC Configuration produces 12-bit samples)</p>
<p>Finally we compose a <strong>formatted string with the average value</strong> and display it‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Format the output
  </span><span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();
  <span class="macro">write!</span>(buf, <span class="string">"[Rust] Average: {}"</span>, avg)
    .expect(<span class="string">"buf overflow"</span>);

  <span class="comment">//  Display the formatted output
  </span>puts(<span class="kw-2">&amp;</span>buf);
}</code></pre></div>
<p>(Yep Rust will helpfully <strong>check for buffer overflow</strong>‚Ä¶ safer than <code>sprintf</code>!)</p>
<p>Default String Size is <strong>64 characters</strong>, as defined in the BL602 Rust Wrapper.</p>
<p>(Similar to ‚Äú<code>char[64]</code>‚Äù in C)</p>
<p>The <strong>formatted output</strong> will appear like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-format.jpg" alt="Output from Rust Firmware" /></p>
<p>And we‚Äôre done‚Ä¶ That‚Äôs how we code BL602 ADC Firmware in Rust!</p>
<h1 id="build-the-bl602-rust-firmware"><a href="#build-the-bl602-rust-firmware">4 Build the BL602 Rust Firmware</a></h1>
<p>We may download the Rust Firmware Binary File <strong><code>sdk_app_rust_adc.bin</code></strong> from‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v11.0.0.0"><strong><code>sdk_app_rust_adc</code> Binary Release</strong></a></li>
</ul>
<p>Or follow these steps to build the Rust Firmware <code>sdk_app_rust_adc.bin</code>‚Ä¶</p>
<ol>
<li>
<p>Install <strong><code>rustup</code>, <code>blflash</code> and <code>xpack-riscv-none-embed-gcc</code></strong></p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/debug#install-gdb"><strong>‚ÄúInstall <code>xpack-riscv-none-embed-gcc</code>‚Äù</strong></a></p>
</li>
</ul>
</li>
<li>
<p>Download the <strong>source code</strong> for the BL602 Rust Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the master branch of lupyuen&#39;s bl_iot_sdk
git clone --recursive --branch master https://github.com/lupyuen/bl_iot_sdk
cd bl_iot_sdk/customer_app/sdk_app_rust_adc
</code></pre></div></li>
<li>
<p>Edit the script <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/run.sh"><strong><code>run.sh</code></strong></a> in the <code>sdk_app_rust_adc</code> folder.</p>
<p>This build script was created for macOS, but can be modified to run on Linux x64 and Windows WSL.</p>
</li>
<li>
<p>In <code>run.sh</code>, set the following variables to the downloaded folders for <code>blflash</code> and <code>xpack-riscv-none-embed-gcc</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Where blflash is located
export BLFLASH_PATH=$PWD/../../../blflash

##  Where GCC is located
export GCC_PATH=$PWD/../../../xpack-riscv-none-embed-gcc
</code></pre></div>
<p>Save the changes into <code>run.sh</code></p>
</li>
<li>
<p>Build the firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>./run.sh
</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Building Rust app and BL602 firmware for riscv32imacf-unknown-none-elf / sdk_app_rust_adc...

----- Build BL602 Firmware
+ make
...
LD build_out/sdk_app_rust_adc.elf
ld: undefined reference to `init_adc&#39;
ld: undefined reference to `read_adc&#39;
----- Ignore undefined references to Rust Library
</code></pre></div>
<p>This means that the <strong>C code from our BL602 Firmware</strong> has been built successfully.</p>
</li>
<li>
<p>Next the script <strong>compiles our Rust code</strong> into a static library: <code>libapp.a</code></p>
<div class="example-wrap"><pre class="language-text"><code>----- Build Rust Library
+ rustup default nightly

+ cargo build \
    --target ../riscv32imacf-unknown-none-elf.json \
    -Z build-std=core

Updating crates.io index
Compiling compiler_builtins v0.1.46
Compiling core v0.0.0
...
Compiling bl602-macros v0.0.2
Compiling bl602-sdk v0.0.6
Compiling app v0.0.1 (bl_iot_sdk/customer_app/sdk_app_rust_adc/rust)
Finished dev [unoptimized + debuginfo] target(s) in 23.55s
</code></pre></div></li>
<li>
<p>Finally the script <strong>links the Rust static library</strong> into our BL602 firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Link BL602 Firmware with Rust Library
+ make
use existing version.txt file
LD build_out/sdk_app_rust_adc.elf
Generating BIN File to build_out/sdk_app_rust_adc.bin
...
Building Finish. To flash build output.
</code></pre></div>
<p>Ignore the error from <code>blflash</code>, we‚Äôll fix this in a while.</p>
</li>
<li>
<p>Our <strong>BL602 Rust Firmware file</strong> has been generated at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>build_out/sdk_app_rust_adc.bin
</code></pre></div>
<p>Let‚Äôs flash this to BL602 and run it!</p>
</li>
</ol>
<p>Check out the complete build log here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/run.sh#L135-L497"><strong>Build Log for BL602 Rust Firmware</strong></a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/rust#appendix-build-script-for-bl602-rust-firmware">More about the build script</a></p>
<p><a href="https://lupyuen.github.io/articles/rust#rust-targets">More about the custom Rust target</a></p>
<p><img src="https://lupyuen.github.io/images/adc-build.jpg" alt="Building the BL602 Rust Firmware" /></p>
<h1 id="flash-the-bl602-rust-firmware"><a href="#flash-the-bl602-rust-firmware">5 Flash the BL602 Rust Firmware</a></h1>
<p>Here‚Äôs how we flash the Rust Firmware file <code>sdk_app_rust_adc.bin</code> to BL602‚Ä¶</p>
<ol>
<li>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ul>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ul>
<p><strong>For BL10:</strong></p>
<ul>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ul>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ul>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ul>
</li>
<li>
<p><strong>For macOS:</strong></p>
<p>Enter this at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>./run.sh
</code></pre></div>
<p>The script should automatically flash the firmware after building‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Flash BL602 Firmware

+ blflash flash build_out/sdk_app_rust_adc.bin \
    --port /dev/tty.usbserial-1410 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

Finished dev [unoptimized + debuginfo] target(s) in 0.61s
Running `target/debug/blflash flash sdk_app_rust_adc.bin --port /dev/tty.usbserial-1420 --initial-baud-rate 230400 --baud-rate 230400`
Start connection...
5ms send count 115
handshake sent elapsed 104.593¬µs
Connection Succeed
Bootrom version: 1
Boot info: BootInfo { len: 14, bootrom_version: 1, otp_info: [0, 0, 0, 0, 3, 0, 0, 0, 61, 9d, c0, 5, b9, 18, 1d, 0] }
Sending eflash_loader...
Finished 1.595620342s 17.92KB/s
5ms send count 115
handshake sent elapsed 81.908¬µs
Entered eflash_loader
Skip segment addr: 0 size: 47504 sha256 matches
Skip segment addr: e000 size: 272 sha256 matches
Skip segment addr: f000 size: 272 sha256 matches
Erase flash addr: 10000 size: 135808
Program flash... ed8a4cdacbc4c1543c74584d7297ad876b6731104856a10dff4166c123c6637d
Program done 7.40735771s 17.91KB/s
Skip segment addr: 1f8000 size: 5671 sha256 matches
Success
</code></pre></div>
<p>(We might need to edit the script to use the right serial port)</p>
</li>
<li>
<p><strong>For Linux and Windows:</strong></p>
<p>Copy <code>build_out/sdk_app_rust_adc.bin</code> to the <code>blflash</code> folder.</p>
<p>Then enter this at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the downloaded blflash folder
cd blflash

## For Linux:
blflash flash build_out/sdk_app_lora.bin \
    --port /dev/ttyUSB0

## For Windows: Change COM5 to the BL602 Serial Port
blflash flash c:\blflash\sdk_app_lora.bin --port COM5
</code></pre></div></li>
</ol>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<p><img src="https://lupyuen.github.io/images/adc-demo2.png" alt="Running the BL602 Rust Firmware" /></p>
<h1 id="run-the-bl602-rust-firmware"><a href="#run-the-bl602-rust-firmware">6 Run the BL602 Rust Firmware</a></h1>
<p>Finally we run the BL602 Rust Firmware‚Ä¶</p>
<ol>
<li>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ul>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ul>
<p><strong>For BL10:</strong></p>
<ul>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ul>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ul>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ul>
</li>
<li>
<p><strong>For macOS:</strong></p>
<p>The <code>run.sh</code> script should automatically launch CoolTerm after flashing‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Run BL602 Firmware
+ open -a CoolTerm
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More about CoolTerm</a></p>
<p><strong>For Linux:</strong></p>
<p>Connect to BL602‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div>
<p><strong>For Windows:</strong> </p>
<p>Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> </p>
<p>Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
</li>
<li>
<p>In the serial console, enter the <code>init_adc</code> command to <strong>initialise the ADC Channel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>init_adc
  [Rust] Init ADC
</code></pre></div>
<p>(We‚Äôve seen this function earlier)</p>
</li>
<li>
<p>Place the BL602 Board (with LED) in a <strong>dark place</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times to get the <strong>average values</strong> of the last 1,000 ADC Samples‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_adc
  [Rust] Average: 1417
read_adc
  [Rust] Average: 1417
read_adc
  [Rust] Average: 1417
</code></pre></div></li>
<li>
<p>Now place the BL602 Board (with LED) <strong>under sunlight</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_adc
  [Rust] Average: 1411
read_adc
  [Rust] Average: 1411
read_adc
  [Rust] Average: 1412
</code></pre></div>
<p>Note that the average values have <strong>dropped from 1417 to 1412.</strong></p>
</li>
<li>
<p>Place the BL602 Board (with LED) <strong>back in the dark</strong> and check the average values‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_adc
  [Rust] Average: 1417
read_adc
  [Rust] Average: 1417
read_adc
  [Rust] Average: 1417
</code></pre></div>
<p>The average values have <strong>increased from 1412 to 1417.</strong></p>
<p>Our improvised BL602 Light Sensor works in Rust yay!</p>
</li>
</ol>
<h1 id="from-c-to-rust"><a href="#from-c-to-rust">7 From C To Rust</a></h1>
<p><em>I‚Äôm new to Rust. Is there an easier way to jump from C to Rust?</em></p>
<p>Today we‚Äôve seen that it‚Äôs feasible to <strong>translate C Firmware into Rust</strong> line by line‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-compare.png" alt="Compare C and Rust" /></p>
<p>Which is great for embedded developers new to Rust!</p>
<p>Just be mindful of the <strong>differences between C and Rust</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>BL602 HAL Functions</strong> have been renamed for Rust.</p>
<p>(Like ‚Äú<code>bl_adc_init</code>‚Äù becomes ‚Äú<code>adc::init</code>‚Äù)</p>
<p>To see the list of BL602 HAL Functions for Rust, <a href="https://docs.rs/bl602-sdk">check out the <code>bl602-sdk</code> documentation</a>.</p>
<p>(More about this in the next chapter)</p>
</li>
<li>
<p>In Rust we check for <strong>BL602 HAL Errors</strong> by calling ‚Äú<code>expect</code>‚Äù instead of ‚Äú<code>assert</code>‚Äù.</p>
<p>(Rust Compiler will warn us if we forget to ‚Äú<code>expect</code>‚Äù)</p>
</li>
<li>
<p>Rust is <strong>super strict about Mutability</strong>‚Ä¶ Only variables and pointers declared ‚Äú<code>mut</code>‚Äù can be changed.</p>
<p>(That‚Äôs why we write ‚Äú<code>*mut i32</code>‚Äù to get a pointer to an integer whose value may be changed)</p>
</li>
<li>
<p><strong>Pointer Deferencing</strong> like ‚Äú<code>ptr-&gt;field</code>‚Äù doesn‚Äôt work in Rust.</p>
<p>We rewrite it in Rust as ‚Äú<code>(*ptr).field</code>‚Äù</p>
</li>
<li>
<p>Rust will helpfully <strong>check for Buffer Overflow</strong>.</p>
<p>(No more silent ‚Äú<code>sprintf</code>‚Äù overflow!)</p>
<p>For BL602 Rust Wrapper the default string size is <strong>64 characters</strong>.</p>
<p>(Similar to ‚Äú<code>char[64]</code>‚Äù in C)</p>
</li>
<li>
<p>All Rust variables shall be <strong>initialised</strong> before use.</p>
<p>(Even arrays and structs!)</p>
</li>
</ol>
<p>Let‚Äôs talk about ‚Äú<code>unsafe</code>‚Äù code in Rust‚Ä¶ </p>
<h2 id="safer-rust"><a href="#safer-rust">7.1 Safer Rust</a></h2>
<p>Rust reminds us to be Extra Careful when we work with <strong>C Functions and C Pointers</strong>.</p>
<p>That‚Äôs why we need to flag the following code as <strong><code>unsafe</code></strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Calling C Functions</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Call the C function `set_adc_gain`
</span><span class="kw">unsafe </span>{ set_adc_gain(ADC_GAIN1, ADC_GAIN2) };</code></pre></div>
<p>(More about this in the Appendix)</p>
</li>
<li>
<p><strong>Casting C Pointers</strong> to Rust</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Cast a C Pointer to a Rust Pointer
</span><span class="kw">let </span>ctx = <span class="kw">unsafe </span>{
  transmute::&lt;         <span class="comment">//  Cast the type...
    </span>Ptr,               <span class="comment">//  From C Pointer (void *)
    </span><span class="kw-2">*mut </span>adc::adc_ctx  <span class="comment">//  To DMA Context Pointer (adc_ctx *)
  </span>&gt;(ptr)               <span class="comment">//  For this pointer
</span>};</code></pre></div>
<p>(More about this in the Appendix)</p>
</li>
<li>
<p><strong>Dereferencing C Pointers</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Dereference a C Pointer (ctx)
</span><span class="kw">unsafe </span>{
  (<span class="kw-2">*</span>ctx).chan_init_table = ...
}</code></pre></div>
</li>
<li>
<p><strong>Copying Memory</strong> with C Pointers</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Copy memory with a C Pointer (channel_data)
</span><span class="kw">unsafe </span>{
  core::ptr::copy(          <span class="comment">//  Copy the memory...
    </span>(<span class="kw-2">*</span>ctx).channel_data,    <span class="comment">//  From Source (ADC DMA data)
    </span>adc_data.as_mut_ptr(),  <span class="comment">//  To Destination (mutable pointer to adc_data)
    </span>adc_data.len()          <span class="comment">//  Number of Items (each item is uint32 or 4 bytes)
  </span>);    
}</code></pre></div>
<p>(More about this in the Appendix)</p>
</li>
</ol>
<p>Accessing <strong>Static Variables</strong> is also ‚Äú<code>unsafe</code>‚Äù. Let‚Äôs talk about this‚Ä¶</p>
<h2 id="static-variables-in-rust"><a href="#static-variables-in-rust">7.2 Static Variables in Rust</a></h2>
<p>Earlier we saw this Rust code for <strong>averaging the ADC Samples</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  `adc_data` will store 100 ADC Samples (`ADC_SAMPLES` is 100)
</span><span class="kw">let </span><span class="kw-2">mut </span>adc_data: [u32; ADC_SAMPLES] = [<span class="number">0</span>; ADC_SAMPLES];

<span class="comment">//  Omitted: Copy data into `adc_data`
</span>...

<span class="comment">//  Compute average of `adc_data`
</span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..ADC_SAMPLES {
  <span class="comment">//  Get value from `adc_data`
  </span><span class="kw">let </span>scaled = adc_data[i] &amp; ...</code></pre></div>
<p>Note that <strong><code>adc_data</code> lives on the stack</strong>.</p>
<p>That‚Äôs a huge chunk of data on the stack‚Ä¶ <strong>400 bytes!</strong></p>
<p><em>What if we turn <code>adc_data</code> into a Static Array?</em></p>
<p>We convert <code>adc_data</code> to a Static Array like this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  `adc_data` becomes a Static Array
</span><span class="kw">static </span><span class="kw-2">mut </span>adc_data: [u32; ADC_SAMPLES] = [<span class="number">0</span>; ADC_SAMPLES];</code></pre></div>
<p><code>adc_data</code> no longer lives on the stack, it‚Äôs now in Static Memory.</p>
<p><em>What‚Äôs the catch?</em></p>
<p>Unfortunately <strong>Static Variables in Rust are <code>unsafe</code></strong>.</p>
<p>Thus all references to <code>adc_data</code> must be <strong>flagged as <code>unsafe</code></strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  `adc_data` is now unsafe because it's a Static Variable
</span><span class="kw">let </span>scaled = <span class="kw">unsafe </span>{ adc_data[i] } &amp; ...</code></pre></div>
<p>Which makes the code harder to read. That‚Äôs why we left <code>adc_data</code> on the stack for this tutorial.</p>
<p><em>Why are Static Variables <code>unsafe</code>?</em></p>
<p>Because it‚Äôs potentially possible to execute the above code in <strong>multiple tasks</strong>‚Ä¶</p>
<p>Which produces undefined behaviour when multiple tasks <strong>access the same Static Variable</strong>.</p>
<p>So it‚Äôs perfectly OK to use Static Variables in Rust. Just that we need to‚Ä¶</p>
<ol>
<li>
<p>Flag the Static Variables as <strong><code>unsafe</code></strong></p>
</li>
<li>
<p>Ensure ourselves that Static Variables are only accessed by <strong>one task at a time</strong></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/adc-crate.png" alt="Rust Wrapper for BL602 IoT SDK" /></p>
<h1 id="rust-wrapper-for-bl602-iot-sdk"><a href="#rust-wrapper-for-bl602-iot-sdk">8 Rust Wrapper for BL602 IoT SDK</a></h1>
<p><em>The BL602 Rust Wrapper Functions look mighty similar to the C Functions from the BL602 IoT SDK. How is this possible?</em></p>
<p>Because the Rust Functions were <strong>automatically generated from BL602 IoT SDK!</strong></p>
<p>We ran a script to generate the <strong>Rust Wrapper for BL602 IoT SDK</strong>.</p>
<p>And we published the Rust Wrapper on <strong><code>crates.io</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://crates.io/crates/bl602-sdk"><strong><code>bl602-sdk</code>: Rust Wrapper for BL602 IoT SDK</strong></a></li>
</ul>
<p><em>Which functions from the BL602 IoT SDK are supported?</em></p>
<p>Today our BL602 Rust Wrapper supports‚Ä¶</p>
<div><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/adc/index.html"><strong>ADC</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/i2c/index.html"><strong>I2C</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/uart/index.html"><strong>UART</strong></a></td></tr>
<tr><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/dma/index.html"><strong>DMA</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/pwm/index.html"><strong>PWM</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/wifi/index.html"><strong>WiFi</strong></a></td></tr>
<tr><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/gpio/index.html"><strong>GPIO</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/spi/index.html"><strong>SPI</strong></a></td><td></td></tr>
</tbody></table>
</div>
<p><a href="https://docs.rs/bl602-sdk">(See the complete list)</a></p>
<p><em>How do we add the BL602 Rust Wrapper to our Rust Project?</em></p>
<p>Just add <strong><code>bl602-sdk</code></strong> to the Rust project configuration: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/Cargo.toml#L9-L11"><code>rust/Cargo.toml</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>## External Rust libraries used by this module.  See crates.io.
[dependencies]
bl602-sdk = &quot;0.0.6&quot;  # Rust Wrapper for BL602 IoT SDK: https://crates.io/crates/bl602-sdk
</code></pre></div>
<p><a href="https://crates.io/crates/bl602-sdk">(Change <code>&quot;0.0.6&quot;</code> to the latest version on <code>crates.io</code>)</a></p>
<p>The BL602 Rust Wrapper will be auto-downloaded from <code>crates.io</code> when building the project.</p>
<p><img src="https://lupyuen.github.io/images/adc-doc2.png" alt="BL602 Rust Wrapper Documentation" /></p>
<p><em>Is the BL602 Rust Wrapper documented?</em></p>
<p>Yep! Every Rust Function is linked to the section in <a href="https://lupyuen.github.io/articles/book"><strong>‚ÄúThe RISC-V BL602 Book‚Äù</strong></a> that explains how we call the function‚Ä¶</p>
<ul>
<li><a href="https://docs.rs/bl602-sdk"><strong>Documentation for BL602 Rust Wrapper</strong></a></li>
</ul>
<p>(Check the Appendix to learn more about the BL602 Rust Wrapper)</p>
<p>Here‚Äôs a sample project that calls the Rust Wrapper for GPIO‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-gpio.png" alt="Rust Wrapper for GPIO" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_gpio/rust/src/lib.rs">(Source)</a></p>
<h1 id="why-sunlight"><a href="#why-sunlight">9 Why Sunlight?</a></h1>
<p><em>Why does our BL602 LED detect only sunlight? And not other kinds of light?</em></p>
<p>We‚Äôre guessing because‚Ä¶</p>
<ol>
<li>
<p>Sunlight is <strong>more intense</strong></p>
<p>(And produces more current)</p>
</li>
<li>
<p>We used the <strong>Blue LED</strong> on PineCone BL602</p>
<p>(Which is sensitive to the spectrum of Blue - Indigo - Violet - Ultra-Violet (UV) light)</p>
</li>
</ol>
<p><strong>LED Light Sensitivity</strong> is <a href="https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227">explained in this article</a>‚Ä¶</p>
<blockquote>
<p>As a photodiode, an LED is sensitive to <strong>wavelengths equal to or shorter than the predominant wavelength it emits</strong>. A green LED would be sensitive to blue light and to some green light, but not to yellow or red light. </p>
</blockquote>
<p>Also according to <a href="https://twitter.com/SravanSenthiln1/status/1418044068567797765">Sravan Senthilnathan on Twitter</a>‚Ä¶</p>
<blockquote>
<p>This is possible due to the <strong>blue LED‚Äôs semiconductor bandgap</strong> being one appropriate to absorb the UV spectrum sun light. Here is more info about it:
<a href="https://en.wikipedia.org/wiki/Aluminium_gallium_nitride">Aluminium gallium nitride on Wikipedia</a></p>
</blockquote>
<p>And according to <a href="https://www.linkedin.com/feed/update/urn:li:activity:6823802475091501056?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A6823802475091501056%2C6824139561749372928%29">Dan Lafleur on LinkedIn</a>‚Ä¶</p>
<blockquote>
<p>The technique I used to measure light level with an LED was to <strong>reverse bias the LED and then time the discharge</strong>. The light level is time based. The higher the light level the longer it takes to discharge the reversed bias junction.</p>
</blockquote>
<p><a href="https://www.sparkfun.com/news/2161">(More about measuring the Discharge Duration of an LED)</a></p>
<p>Here‚Äôs <a href="https://www.linkedin.com/feed/update/urn:li:activity:6823802475091501056?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A6823802475091501056%2C6823807829040881664%29">another comment</a>‚Ä¶</p>
<blockquote>
<p>Yes, I have used LEDs as light sensors in class projects. The point is that they are not just emitters. A selection of red, green and blue LEDs can be used to build a crude <strong>colour detector</strong>. It works.</p>
</blockquote>
<p>That sounds interesting‚Ä¶</p>
<p><em>PineCone BL602 has Red, Green and Blue LEDs. Can we use the other LEDs?</em></p>
<p><img src="https://lupyuen.github.io/images/led-rgb.png" alt="PineCone RGB LED Schematic" /></p>
<p><a href="https://github.com/pine64/bl602-docs/blob/main/mirrored/Pine64%20BL602%20EVB%20Schematic%20ver%201.1.pdf">(From PineCone BL602 Schematic)</a></p>
<p>Unfortunately <strong>PineCone‚Äôs Red LED</strong> is connected on GPIO 17, which is not supported for ADC.</p>
<p>But <strong>PineCone‚Äôs Green LED</strong> (GPIO 14) should work OK with ADC.</p>
<p><strong>Exercise For The Reader:</strong> Use PineCone‚Äôs Green LED (instead of the Blue LED) as an ADC Light Sensor. What kind of light does it detect?</p>
<p>(This article was inspired by the <strong>BBC micro:bit</strong>, which uses LED as a Light Sensor. <a href="https://learn.adafruit.com/micro-bit-lesson-4-sensing-light-and-temperature/built-in-light-sensor">See this</a>)</p>
<p><img src="https://lupyuen.github.io/images/adc-pinebook.jpg" alt="Testing the improvised Light Sensor on PineCone BL602 with Pinebook Pro" /></p>
<p><em>Testing the improvised Light Sensor on PineCone BL602 with Pinebook Pro</em></p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>Today we‚Äôve seen that it‚Äôs viable to create <strong>Rust Firmware</strong> for BL602‚Ä¶ Just call the <strong>Rust Wrapper for BL602 IoT SDK</strong>!</p>
<p>Soon we shall test the Rust Firmware on <a href="https://www.pine64.org/2021/07/15/july-update/"><strong>PineDio Stack BL604 with LoRa SX1262</strong></a>‚Ä¶ As we explore whether it‚Äôs feasible to teach <strong>Rust as a Safer Way</strong> to create firmware for BL602 and BL604.</p>
<p>Also we might <strong>Simulate BL602 Rust Firmware</strong> in a Web Browser with <strong>WebAssembly</strong>!</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rustsim"><strong>‚ÄúRust on RISC-V BL602: Simulated with WebAssembly‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator"><strong>BL602 / BL604 Simulator in WebAssembly</strong></a></p>
</li>
<li>
<p><a href="https://twitter.com/MisterTechBlog/status/1423169766080933891"><strong>Follow the updates on Twitter</strong></a></p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/owr2xp/rust_on_riscv_bl602_is_it_sunny/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/adc.md"><code>lupyuen.github.io/src/adc.md</code></a></p>
<h1 id="notes"><a href="#notes">11 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1416608940876435462">this Twitter Thread on Rust Wrapper for BL602 IoT SDK</a></p>
<p>And <a href="https://twitter.com/MisterTechBlog/status/1418025678251773954">this Twitter Thread on BL602 ADC</a></p>
</li>
<li>
<p>Are there other ways to run <strong>Rust Firmware on BL602</strong>? See this‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/rust#rust-on-bl602-two-more-ways"><strong>‚ÄúRust On BL602: Two More Ways‚Äù</strong></a></p>
</li>
<li>
<p>We may also use BL602 ADC HAL to read the <strong>BL602 Internal Temperature Sensor</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/tsen"><strong>‚ÄúInternal Temperature Sensor on BL602‚Äù</strong></a></p>
</li>
<li>
<p>Is there a <strong>simpler way to code ADC Firmware</strong> in C?</p>
<p>Yes, we could call the <strong>ADC High Level HAL</strong>.</p>
<p>(Instead of the ADC Low Level HAL that we‚Äôve seen)</p>
<p>Here‚Äôs our ADC Firmware, rewritten to call the <strong>ADC High Level HAL</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-highlevel.png" alt="BL602 ADC High Level HAL" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc/sdk_app_adc/demo.c">(Source)</a></p>
<p>But the ADC High Level HAL won‚Äôt let us set the <strong>ADC Gain</strong>.</p>
<p>We need to <strong>patch the ADC Low Level HAL</strong> like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-gain.png" alt="Setting the ADC Gain by patching the ADC High Level HAL" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c#L339-L389">(Source)</a></p>
<p>Also note that the ADC High Level HAL doesn‚Äôt allow us to compute the <strong>average of the ADC Samples</strong>.</p>
<p>It returns only one ADC Sample.</p>
</li>
<li>
<p><strong>ESP32</strong> has something similar to the BL602 Rust Wrapper‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/esp-rs/esp-idf-sys"><code>esp-idf-sys</code></a> defines the Rust Bindings for ESP32 IDF SDK (generated with <code>bindgen</code>)</p>
</li>
<li>
<p><a href="https://github.com/esp-rs/esp-idf-hal"><code>esp-idf-hal</code></a> wraps <code>esp-idf-sys</code> into a Rust Embedded HAL for ESP32</p>
</li>
<li>
<p><a href="https://mabez.dev/blog/posts/esp-rust-espressif/">More about Rust on ESP32</a></p>
</li>
</ul>
<p>(Perhaps someday we might wrap the BL602 Rust Wrapper into a Rust Embedded HAL for BL602 / BL604)</p>
</li>
</ol>
<h1 id="appendix-call-c-functions-from-rust"><a href="#appendix-call-c-functions-from-rust">12 Appendix: Call C Functions from Rust</a></h1>
<p><em>How do we call our own C Functions from Rust?</em></p>
<p>Earlier we saw this Rust code that <strong>sets the ADC Gain</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L64-L66"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  In Rust: Enable ADC Gain to increase the ADC sensitivity
</span><span class="kw">unsafe </span>{ set_adc_gain(ADC_GAIN1, ADC_GAIN2) };  <span class="comment">//  Unsafe because we are calling C function</span></code></pre></div>
<p>This calls the C Function <code>set_adc_gain</code>, which we have <strong>imported into Rust</strong> here: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L180-L184"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  In Rust: Import C Function
</span><span class="kw">extern </span><span class="string">"C" </span>{
  <span class="doccomment">/// Enable ADC Gain to increase the ADC sensitivity.
  /// Defined in customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c
  </span><span class="kw">fn </span>set_adc_gain(gain1: u32, gain2: u32) -&gt; i32;
}</code></pre></div>
<p><strong><code>set_adc_gain</code></strong> is defined in this C source file: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c#L11-L42"><code>demo.c</code></a></p>
<p><em>What about the rest of the code in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c"><code>demo.c</code></a>?</em></p>
<p>The rest of the C code in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c"><code>demo.c</code></a> is needed to set up the <strong>Command-Line Interface</strong> for our BL602 Firmware.</p>
<p>We define the <strong>Rust Commands</strong> for the Command-Line Interface like so: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c#L47-L55"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// In C: Import Rust functions from customer_app/sdk_app_rust_adc/rust/src/lib.rs
void init_adc(char *buf, int len, int argc, char **argv);
void read_adc(char *buf, int len, int argc, char **argv);

/// List of commands. STATIC_CLI_CMD_ATTRIBUTE makes these commands static
const static struct cli_command cmds_user[] STATIC_CLI_CMD_ATTRIBUTE = {
    {&quot;init_adc&quot;,        &quot;Init ADC Channel&quot;,          init_adc},
    {&quot;read_adc&quot;,        &quot;Read ADC Channel&quot;,          read_adc},
};
</code></pre></div>
<p>This defines the commands <code>init_adc</code> and <code>read_adc</code>, which are mapped to the respective Rust Functions.</p>
<h1 id="appendix-cast-c-pointers-in-rust"><a href="#appendix-cast-c-pointers-in-rust">13 Appendix: Cast C Pointers in Rust</a></h1>
<p><em>How do we cast C Pointers in Rust?</em></p>
<p>In the C version of our ADC Firmware, we implicitly cast a ‚Äú<code>void *</code>‚Äù pointer to ‚Äú<code>adc_ctx *</code>‚Äù pointer like this: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L88-L90"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  In C: Get the pointer (void *) for DMA Context
void *ptr = ...

//  Cast the returned pointer (void *) to a DMA Context Pointer (adc_ctx *)
struct adc_ctx *ctx = (struct adc_ctx *) ptr;
</code></pre></div>
<p>Here we‚Äôre <a href="https://en.wikipedia.org/wiki/Downcasting">Downcasting</a> a General Type (<code>void *</code>) to a Specific Type (<code>adc_ctx *</code>).</p>
<p>To do the same in Rust, we need to be super explicit about <strong>what we‚Äôre casting</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L119-L129"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  In Rust: Get the C Pointer (void *) for DMA Context
</span><span class="kw">let </span>ptr = ...

<span class="comment">//  Cast the returned C Pointer (void *) to a DMA Context Pointer (adc_ctx *)
</span><span class="kw">let </span>ctx = <span class="kw">unsafe </span>{     <span class="comment">//  Unsafe because we are casting a pointer
  </span>transmute::&lt;         <span class="comment">//  Cast the type...
    </span>Ptr,               <span class="comment">//  From C Pointer (void *)
    </span><span class="kw-2">*mut </span>adc::adc_ctx  <span class="comment">//  To DMA Context Pointer (adc_ctx *)
  </span>&gt;(ptr)               <span class="comment">//  For this pointer
</span>};</code></pre></div>
<p><strong><code>transmute</code></strong> is the Rust Core Library Function that will cast our value (<code>ptr</code>) from one type to another‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>transmute::&lt; FromType , ToType &gt;( ptr )</code></pre></div>
<p>Where‚Ä¶</p>
<ul>
<li>
<p>From Type is <strong><code>Ptr</code></strong></p>
<p><code>Ptr</code> is our short form for the ‚Äú<code>void *</code>‚Äù pointer in Rust.</p>
<p><a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/type.Ptr.html">(See this)</a></p>
</li>
<li>
<p>To Type is <strong><code>*mut adc::adc_ctx</code></strong></p>
<p>Which is a mutable pointer to <code>adc_ctx</code></p>
<p>(Equivalent to ‚Äú<code>adc_ctx *</code>‚Äù in C)</p>
</li>
</ul>
<p><a href="https://doc.rust-lang.org/core/mem/fn.transmute.html">(More about <code>transmute</code>)</a></p>
<p><img src="https://lupyuen.github.io/images/adc-cast.png" alt="Casting a C Pointer in Rust" /></p>
<h1 id="appendix-copy-memory-with-c-pointers"><a href="#appendix-copy-memory-with-c-pointers">14 Appendix: Copy Memory with C Pointers</a></h1>
<p><em>How do we copy memory with C Pointers?</em></p>
<p>Earlier we saw this code in our C Firmware: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L101-L106"><code>demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Array that will store ADC Samples
uint32_t adc_data[ADC_SAMPLES];

//  Copy the read ADC Samples to the array
memcpy(
  (uint8_t*) adc_data,             //  Destination
  (uint8_t*) (ctx-&gt;channel_data),  //  Source
  sizeof(adc_data)                 //  Size
);  
</code></pre></div>
<p>This code <strong>copies the ADC Samples</strong> from the DMA buffer to the array <code>adc_data</code>.</p>
<p>Here‚Äôs the equivalent code in Rust: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L142-L149"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Array that will store the last 100 ADC Samples (`ADC_SAMPLES` is 100)
</span><span class="kw">let </span><span class="kw-2">mut </span>adc_data: [u32; ADC_SAMPLES]
  = [<span class="number">0</span>; ADC_SAMPLES];  <span class="comment">//  Init array to 100 zeroes

//  Copy the read ADC Samples to the array
</span><span class="kw">unsafe </span>{                    <span class="comment">//  Unsafe because we are copying raw memory
  </span>core::ptr::copy(          <span class="comment">//  Copy the memory...
    </span>(<span class="kw-2">*</span>ctx).channel_data,    <span class="comment">//  From Source (ADC DMA data)
    </span>adc_data.as_mut_ptr(),  <span class="comment">//  To Destination (mutable pointer to adc_data)
    </span>adc_data.len()          <span class="comment">//  Number of Items (each item is uint32 or 4 bytes)
  </span>);    
}</code></pre></div>
<p>Note the differences‚Ä¶</p>
<ol>
<li>
<p>For Rust the <strong>Source Pointer</strong> is the first parameter, followed by the <strong>Destination Pointer</strong></p>
<p>(This is flipped from <code>memcpy</code> in C)</p>
</li>
<li>
<p>For Rust the third parameter is the <strong>Number of Items</strong> to be copied. (100 items)</p>
<p>(For <code>memcpy</code> the third parameter specifies the number of bytes to copy, i.e. 400 bytes)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/adc-copy.png" alt="Copy ADC data in Rust" /></p>
<h1 id="appendix-generating-the-rust-wrapper-for-bl602-iot-sdk"><a href="#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">15 Appendix: Generating the Rust Wrapper for BL602 IoT SDK</a></h1>
<p><em>How was the BL602 Rust Wrapper generated for publishing on <a href="https://crates.io/crates/bl602-sdk"><code>crates.io</code></a>?</em></p>
<p>Two tools were used to generate the <strong>Rust Wrapper for BL602 IoT SDK</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://rust-lang.github.io/rust-bindgen"><strong><code>bindgen</code></strong></a>: Command-line tool that generates the <strong>Rust Bindings</strong> for a C API.</p>
<p>(As specified by C Header Files)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs"><strong><code>safe_wrap</code></strong></a>: A Rust Procedural Macro we wrote to transform the BL602 C Types to <strong>safer Rust-Friendly Types</strong>.</p>
<p>(Including the ‚Äú<code>expect</code>‚Äù checking for return values)</p>
</li>
</ol>
<p>Here are the steps for <strong>generating the Rust Wrapper</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Install bindgen and clang: https://rust-lang.github.io/rust-bindgen/requirements.html 
cargo install bindgen
sudo apt install llvm-dev libclang-dev clang

##  Download the source code
git clone --recursive https://github.com/lupyuen/bl602-rust-wrapper
git clone --recursive https://github.com/lupyuen/bl_iot_sdk

##  Generate the Rust Bindings for BL602 IoT SDK
cd bl602-rust-wrapper
scripts/gen-bindings.sh

##  Build the docs and the test project
scripts/build.sh
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/adc-bindgen.png" alt="BL602 Rust Wrapper generated by bindgen and safe_wrap" /></p>
<h2 id="how-it-works"><a href="#how-it-works">15.1 How it works</a></h2>
<p>This script‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/scripts/gen-bindings.sh"><code>scripts/gen-bindings.sh</code></a></li>
</ul>
<p>Calls <strong><code>bindgen</code></strong> to read the BL602 IoT SDK <strong>Header Files</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Function Declarations from BL602 IoT SDK (GPIO HAL)
//  https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_gpio.h
int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown);
int bl_gpio_output_set(uint8_t pin, uint8_t value);
</code></pre></div>
<p>To produce the <strong>Rust Bindings</strong> for BL602 IoT SDK‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/src/gpio.rs"><code>bl602-sdk/src/gpio.rs</code></a></li>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/src/adc.rs"><code>bl602-sdk/src/adc.rs</code></a></li>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/src">More Bindings</a></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Rust Bindings for BL602 GPIO generated by gen-bindings.sh
</span><span class="attr">#[safe_wrap(<span class="kw">_</span>)] </span><span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>bl_gpio_enable_output(pin: u8, pullup: u8, pulldown: u8) -&gt; ::cty::c_int;
}

<span class="attr">#[safe_wrap(<span class="kw">_</span>)] </span><span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; ::cty::c_int;
}</code></pre></div>
<p>(<code>safe_wrap</code> was inserted by an <code>sed</code> script in <code>gen-bindings.sh</code>)</p>
<p>When the above Rust Bindings are compiled, they invoke the <strong><code>safe_wrap</code> Procedural Macro</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs"><code>bl602-macros/src/safe_wrap.rs</code></a></li>
</ul>
<p>To produce the <strong>Rust Wrapper</strong> for BL602 IoT SDK‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/logs/sdk-expanded.rs">Expanded <code>safe_wrap</code> macros: <code>logs/sdk-expanded.rs</code></a></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Expanded version of `safe_wrap` macros for the GPIO Rust Bindings
</span><span class="attr">#[doc = <span class="string">"Configure a GPIO Pin for Output Mode. See `bl_gpio_enable_output` in \"Enable GPIO\" &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;"</span>]
</span><span class="kw">pub fn </span>enable_output(pin: u8, pullup: u8, pulldown: u8)
    -&gt; BlResult&lt;()&gt; {
    <span class="string">"----------Extern Decl----------"</span>;
    <span class="kw">extern </span><span class="string">"C" </span>{
        <span class="kw">pub fn </span>bl_gpio_enable_output(pin: u8, pullup: u8, pulldown: u8)
        -&gt; ::cty::c_int;
    }
    <span class="string">"----------Validation----------"</span>;
    <span class="kw">unsafe </span>{
        <span class="string">"----------Call----------"</span>;
        <span class="kw">let </span>res =
            bl_gpio_enable_output(pin <span class="kw">as </span>u8, pullup <span class="kw">as </span>u8,
                                    pulldown <span class="kw">as </span>u8);
        <span class="string">"----------Result----------"</span>;
        <span class="kw">match </span>res { <span class="number">0 </span>=&gt; <span class="prelude-val">Ok</span>(()), <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(BlError::from(res)), }
    }
}

<span class="attr">#[doc = <span class="string">"Set output value of GPIO Pin. See `bl_gpio_output_set` in \"Read and Write GPIO\" &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;"</span>]
</span><span class="kw">pub fn </span>output_set(pin: u8, value: u8) -&gt; BlResult&lt;()&gt; {
    <span class="string">"----------Extern Decl----------"</span>;
    <span class="kw">extern </span><span class="string">"C" </span>{
        <span class="kw">pub fn </span>bl_gpio_output_set(pin: u8, value: u8)
        -&gt; ::cty::c_int;
    }
    <span class="string">"----------Validation----------"</span>;
    <span class="kw">unsafe </span>{
        <span class="string">"----------Call----------"</span>;
        <span class="kw">let </span>res = bl_gpio_output_set(pin <span class="kw">as </span>u8, value <span class="kw">as </span>u8);
        <span class="string">"----------Result----------"</span>;
        <span class="kw">match </span>res { <span class="number">0 </span>=&gt; <span class="prelude-val">Ok</span>(()), <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(BlError::from(res)), }
    }
}</code></pre></div>
<p>(More about <strong><code>doc</code></strong> in the next section)</p>
<p>Note that the <code>safe_wrap</code> macro converts the BL602 return values to a <strong>Rust Result Type</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">match </span>res { 
    <span class="number">0 </span>=&gt; <span class="prelude-val">Ok</span>(()), 
    <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(BlError::from(res))
}</code></pre></div>
<p>Which enables the caller to check for errors with <strong><code>expect</code></strong>.</p>
<p>We build the docs and the test project with this script‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/scripts/build.sh"><code>scripts/build.sh</code></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/README.md#build-log">See the build log</a></p>
</li>
</ul>
<p>In the previous article we attempted to code the BL602 Rust Wrapper by hand‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust"><strong>‚ÄúRun Rust RISC-V Firmware with BL602 IoT SDK‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/adc-doc2.png" alt="BL602 Rust Wrapper Documentation" /></p>
<h2 id="inject-the-docs"><a href="#inject-the-docs">15.2 Inject the docs</a></h2>
<p><em>How did we create the docs for BL602 Rust Wrapper? (Pic above)</em></p>
<ul>
<li><a href="https://docs.rs/bl602-sdk"><strong>Documentation for BL602 Rust Wrapper</strong></a></li>
</ul>
<p>Sadly BL602 IoT SDK doesn‚Äôt have much documentation‚Ä¶ But much of the SDK is already documented in <a href="https://lupyuen.github.io/articles/book"><strong>‚ÄúThe RISC-V BL602 Book‚Äù</strong></a>!</p>
<p>So we linked each Rust Wrapper Function to the relevant section in ‚ÄúThe RISC-V BL602 Book‚Äù.</p>
<p>We do this through the <strong>Rust <code>doc</code> Attribute</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Expanded version of `safe_wrap` macros for the GPIO Rust Bindings
</span><span class="attr">#[doc = <span class="string">"Configure a GPIO Pin for Output Mode. See `bl_gpio_enable_output` in \"Enable GPIO\" &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;"</span>]
</span><span class="kw">pub fn </span>enable_output(pin: u8, pullup: u8, pulldown: u8) { ...

<span class="attr">#[doc = <span class="string">"Set output value of GPIO Pin. See `bl_gpio_output_set` in \"Read and Write GPIO\" &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;"</span>]
</span><span class="kw">pub fn </span>output_set(pin: u8, value: u8) -&gt; BlResult&lt;()&gt; { ...</code></pre></div>
<p><img src="https://lupyuen.github.io/images/adc-doclink.png" alt="Documentation links to be injected" /></p>
<p><em>How did we inject the doc links into the <code>doc</code> Attribute?</em></p>
<p>For each Rust Wrapper Function, the links to <a href="https://lupyuen.github.io/articles/book">‚ÄúThe RISC-V BL602 Book‚Äù</a> are defined in this <strong>Markdown Text File</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/doclinks.md"><code>bl602-sdk/doclinks.md</code></a></li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>| Function              | Description                           | Section             | URL
| --------------------- | ------------------------------------- | ------------------- | ---
| bl_gpio_enable_output | Configure a GPIO Pin for Output Mode. | Enable GPIO         | https://lupyuen.github.io/articles/led#enable-gpio
| bl_gpio_output_set    | Set the output value of a GPIO Pin.   | Read and Write GPIO | https://lupyuen.github.io/articles/led#read-and-write-gpio
</code></pre></div>
<p>When our Rust Firmware is compiled, the <code>safe_wrap</code> macro <strong>loads the Markdown File</strong> into memory‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-doclink2.png" alt="Loading the documentation links" /></p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs#L532-L573">(Source)</a></p>
<p>And <strong>injects the doc links</strong> into the <code>doc</code> attribute‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-doclink3.png" alt="Injecting the documentation links" /></p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs#L476-L530">(Source)</a></p>
<p>And the links to ‚ÄúThe RISC-V BL602 Book‚Äù will magically appear in the Rust Docs!</p>
<ul>
<li><a href="https://docs.rs/bl602-sdk"><strong>Documentation for BL602 Rust Wrapper</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/adc-prefix.png" alt="Renaming the Rust Functions" /></p>
<h2 id="rename-the-functions"><a href="#rename-the-functions">15.3 Rename the functions</a></h2>
<p>The <code>safe_wrap</code> macro also <strong>shortens the names</strong> of the Rust Wrapper Functions.</p>
<p>Here‚Äôs the original function from the BL602 IoT SDK‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl_gpio_enable_output
</code></pre></div>
<p>And here‚Äôs the Rust Wrapper function shortened by <code>safe_wrap</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>gpio::enable_output
</code></pre></div>
<p><code>transform_function_name</code> contains the code that renames the functions: <a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs#L476-L530"><code>safe_wrap.rs</code></a></p>
<p><img src="https://lupyuen.github.io/images/adc-title2.jpg" alt="Testing the improvised Light Sensor on PineCone BL602" /></p>
<p><em>Testing the improvised Light Sensor on PineCone BL602</em></p>

    
</body>
</html>