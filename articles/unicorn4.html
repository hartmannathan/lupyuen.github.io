<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Creating the Unicorn Emulator for Avaota-A1 SBC (Apache NuttX RTOS)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Creating the Unicorn Emulator for Avaota-A1 SBC (Apache NuttX RTOS)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn4-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/unicorn4.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Creating the Unicorn Emulator for Avaota-A1 SBC (Apache NuttX RTOS)</h1>
    <nav id="rustdoc"><ul>
<li><a href="#nuttx-for-avaota-a1" title="NuttX for Avaota-A1">1 NuttX for Avaota-A1</a><ul></ul></li>
<li><a href="#unicorn-emulator-for-avaota-a1" title="Unicorn Emulator for Avaota-A1">2 Unicorn Emulator for Avaota-A1</a><ul></ul></li>
<li><a href="#emulate-16550-uart" title="Emulate 16550 UART">3 Emulate 16550 UART</a><ul></ul></li>
<li><a href="#nuttx-halts-at-syscall" title="NuttX Halts at SysCall">4 NuttX Halts at SysCall</a><ul></ul></li>
<li><a href="#syscall-for-context-switch" title="SysCall for Context Switch">5 SysCall for Context Switch</a><ul></ul></li>
<li><a href="#hook-the-unicorn-interrupt" title="Hook The Unicorn Interrupt">6 Hook The Unicorn Interrupt</a><ul></ul></li>
<li><a href="#arm64-vector-table" title="Arm64 Vector Table">7 Arm64 Vector Table</a><ul></ul></li>
<li><a href="#emulate-the-arm64-syscall" title="Emulate the Arm64 SysCall">8 Emulate the Arm64 SysCall</a><ul></ul></li>
<li><a href="#syscall-from-nuttx-app" title="SysCall from NuttX App">9 SysCall from NuttX App</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">10 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>30 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/unicorn4-title.jpg" alt="Avaota-A1 SBC: Shot on Sony NEX-7 with IKEA Ring Light, Yeelight Ring Light on Corelle Plate" /></p>
<p>TODO</p>
<p><a href="TODO"><strong>Unicorn Emulator</strong></a></p>
<ul>
<li>
<p>Unicorn doesn‚Äôt seem to emulate Arm64 SysCalls?</p>
</li>
<li>
<p>No worries we‚Äôll emulate Arm64 SysCalls ourselves!</p>
</li>
</ul>
<p><img src="https://lupyuen.org/images/avaota-title.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<p><a href="nuttx-boot-flow.pdf">NuttX Boot Flow in PDF</a> / <a href="nuttx-boot-flow.svg">SVG</a> / <a href="nuttx-boot-flow.png">PNG</a></p>
<p><a href="https://github.com/qilingframework/qiling/blob/master/qiling/core_hooks.py">qiling/core_hooks.py</a></p>
<p><a href="https://github.com/qilingframework/qiling/blob/master/qiling/os/linux/syscall.py">qiling/os/linux/syscall.py</a></p>
<p><a href="https://en.wikipedia.org/wiki/Qilin">Qilin</a></p>
<p>Emulator -&gt; Driver</p>
<p>Or driver -&gt; emulator?</p>
<p>Maybe Emulator + Device Farm</p>
<p><em>Why are we doing this?</em></p>
<ul>
<li>The Trade Tariffs are Terribly Troubling. Some of us NuttX Folks might need to hunker down and emulate Avaota SBC, for now.</li>
</ul>
<p><a href="https://docs.google.com/document/d/1qYkBu3ca3o5BXdwtUpe0EirMv9PpMOdmf7QBnqGFJkA/edit?tab=t.0">‚ÄúAttached is the Mermaid Flowchart for the Boot Flow for Apache NuttX RTOS. Please explain how NuttX boots.‚Äù</a></p>
<p>https://gist.github.com/lupyuen/b7d937c302d1926f62cea3411ca0b3c6</p>
<h1 id="nuttx-for-avaota-a1"><a class="doc-anchor" href="#nuttx-for-avaota-a1">¬ß</a>1 NuttX for Avaota-A1</h1>
<p>Weeks ago we ported NuttX to Avaota-A1 SBC‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/avaota"><strong>‚ÄúPorting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)‚Äù</strong></a></li>
</ul>
<p>To boot <strong>NuttX on Unicorn</strong>: We recompile NuttX with <a href="https://github.com/lupyuen2/wip-nuttx/pull/106"><strong>Four Tiny Tweaks</strong></a>‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/106/commits/640084e1fb1692887266716ecda52dc7ea4bf8e0"><strong>Set TCR_TG1_4K, Physical / Virtual Address to 32 Bits</strong></a></p>
<p>From the <a href="https://lupyuen.github.io/articles/unicorn3.html"><strong>Previous Article</strong></a>: Unicorn Emulator requires <strong>TCR_TG1_4K</strong>. And the <strong>Physical / Virtual Address Size</strong> should be 32 Bits.</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/106/commits/b3782b1ff989667df22b10d5c1023826e2211d88"><strong>Disable PSCI</strong></a>: We don‚Äôt emulate the <strong>PSCI Driver</strong> in Unicorn, so we disable this</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/106/commits/878e78eb40f334e6e128595dbb27ae08aed1e969"><strong>Enable Scheduler Logging</strong></a>: So we can see NuttX booting</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/106/commits/c9f38c13eb5ac6f6bbcd4d3c1de218828f9f087d"><strong>Enable SysCall Logging</strong></a>: To verify that NuttX SysCalls are OK</p>
</li>
</ol>
<p>Here are the steps to compile <strong>NuttX for Unicorn</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Modified NuttX for Avaota-A1 SBC
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch unicorn-avaota
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch unicorn-avaota
cd nuttx

## Build NuttX
make -j distclean
tools/configure.sh avaota-a1:nsh
make -j
cp .config nuttx.config

## Build Apps Filesystem
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate the Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
genromfs -f nuttx-initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad nuttx-initrd &gt;nuttx-Image

## Dump the NuttX Kernel disassembly to nuttx.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  nuttx &gt;nuttx.S 2&gt;&amp;1

## Dump the NSH Shell disassembly to nuttx-init.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  ../apps/bin/init &gt;nuttx-init.S 2&gt;&amp;1

## Dump the Hello disassembly to nuttx-hello.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  ../apps/bin/hello &gt;nuttx-hello.S 2&gt;&amp;1

## Copy NuttX Image to Unicorn Emulator
cp nuttx nuttx.S nuttx.config nuttx.hash nuttx-init.S nuttx-hello.S \
  $HOME/nuttx-arm64-emulator/nuttx
cp nuttx-Image \
  $HOME/nuttx-arm64-emulator/nuttx/Image</code></pre></div>
<p>To boot NuttX in <strong>Unicorn Emulator</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot NuttX in the Unicorn Emulator
git clone https://github.com/lupyuen/nuttx-arm64-emulator --branch avaota
cd nuttx-arm64-emulator
cargo run

## To see the Emulated UART Output
cargo run | grep &quot;uart output&quot;</code></pre></div>
<p>We inspect the code inside‚Ä¶</p>
<h1 id="unicorn-emulator-for-avaota-a1"><a class="doc-anchor" href="#unicorn-emulator-for-avaota-a1">¬ß</a>2 Unicorn Emulator for Avaota-A1</h1>
<p><em>What‚Äôs inside the Avaota-A1 Emulator?</em></p>
<p>Inside our Avaota SBC Emulator: We begin by creating the <strong>Unicorn Interface</strong>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L13-L36">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Memory Space for NuttX Kernel
</span><span class="kw">const </span>KERNEL_SIZE: usize = <span class="number">0x1000_0000</span>;
<span class="kw">static </span><span class="kw-2">mut </span>KERNEL_CODE: [u8; KERNEL_SIZE] = [<span class="number">0</span>; KERNEL_SIZE];

<span class="doccomment">/// Emulate some Arm64 Machine Code
</span><span class="kw">fn </span>main() {

  <span class="comment">// Init Emulator in Arm64 mode
  </span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
    Arch::ARM64,
    Mode::LITTLE_ENDIAN
  ).unwrap();

  <span class="comment">// Enable MMU Translation
  </span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;
  emu.ctl_tlb_type(unicorn_engine::TlbType::CPU)
    .unwrap();</code></pre></div>
<p>Based on the <a href="TODO"><strong>Allwinner A527 Memory Map</strong></a>, we reserve <strong>1 GB of I/O Memory</strong> for UART and other I/O Peripherals: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L36-L43">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Map 1 GB Read/Write Memory at 0x0000 0000 for Memory-Mapped I/O
  </span>emu.mem_map(
    <span class="number">0x0000_0000</span>,  <span class="comment">// Address
    </span><span class="number">0x4000_0000</span>,  <span class="comment">// Size
    </span>Permission::READ | Permission::WRITE  <span class="comment">// Read/Write/Execute Access
  </span>).unwrap();</code></pre></div>
<p>Next we load the <strong>NuttX Image</strong> <em>(NuttX Kernel + NuttX Apps)</em> into Unicorn Memory: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L43-L64">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Copy NuttX Image into memory
  </span><span class="kw">let </span>kernel = <span class="macro">include_bytes!</span>(<span class="string">"../nuttx/Image"</span>);
  <span class="kw">unsafe </span>{
    <span class="macro">assert!</span>(KERNEL_CODE.len() &gt;= kernel.len());
    KERNEL_CODE[<span class="number">0</span>..kernel.len()].copy_from_slice(kernel);    
  }

  <span class="comment">// Arm64 Memory Address where emulation starts.
  // Memory Space for NuttX Kernel also begins here.
  </span><span class="kw">const </span>ADDRESS: u64 = <span class="number">0x4080_0000</span>;

  <span class="comment">// Map the NuttX Kernel to 0x4080_0000
  </span><span class="kw">unsafe </span>{
    emu.mem_map_ptr(
      ADDRESS, 
      KERNEL_CODE.len(), 
      Permission::READ | Permission::EXEC,
      KERNEL_CODE.as_mut_ptr() <span class="kw">as _
    </span>).unwrap();
  }</code></pre></div>
<p>Unicorn lets us hook into its internals, for emulating nifty things. We add the <strong>Unicorn Hooks</strong> for‚Ä¶</p>
<ul>
<li>
<p><strong>Block Hook:</strong> For each block of Arm64 Code, we render the <a href="TODO"><strong>Call Graph</strong></a></p>
</li>
<li>
<p><strong>Memory Hook:</strong> To emulate the <a href="TODO"><strong>UART Hardware</strong></a>, we intercept the Memory Reads and Writes</p>
</li>
<li>
<p><strong>Interrupt Hook:</strong> We emulate <a href="TODO"><strong>Arm64 SysCalls</strong></a> as Unicorn Interrupts</p>
</li>
</ul>
<p>Like so: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L64-L88">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Add Hook for emulating each Basic Block of Arm64 Instructions
  </span>emu.add_block_hook(<span class="number">1</span>, <span class="number">0</span>, hook_block)
    .unwrap();

  <span class="comment">// Add Hook for Arm64 Memory Access
  </span>emu.add_mem_hook(
    HookType::MEM_ALL,  <span class="comment">// Intercept Read and Write Accesses
    </span><span class="number">0</span>,           <span class="comment">// Begin Address
    </span>u64::MAX,    <span class="comment">// End Address
    </span>hook_memory  <span class="comment">// Hook Function
  </span>).unwrap();

  <span class="comment">// Add Interrupt Hook
  </span>emu.add_intr_hook(hook_interrupt)
    .unwrap();

  <span class="comment">// Upcoming: Indicate that the UART Transmit FIFO is ready</span></code></pre></div>
<p><a href="TODO">(<strong>hook_block</strong> is explained here)</a></p>
<p>Finally we start the <strong>Unicorn Emulator</strong>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L88-L106">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Emulate Arm64 Machine Code
  </span><span class="kw">let </span>err = emu.emu_start(
    ADDRESS,  <span class="comment">// Begin Address
    </span>ADDRESS + KERNEL_SIZE <span class="kw">as </span>u64,  <span class="comment">// End Address
    </span><span class="number">0</span>,  <span class="comment">// No Timeout
    </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
  </span>);

  <span class="comment">// Print the Emulator Error
  </span><span class="macro">println!</span>(<span class="string">"err={:?}"</span>, err);
  <span class="macro">println!</span>(<span class="string">"PC=0x{:x}"</span>, emu.reg_read(RegisterARM64::PC).unwrap());
}</code></pre></div>
<p>That‚Äôs it for our Barebones Emulator of Avaota SBC! We fill in the hooks‚Ä¶</p>
<h1 id="emulate-16550-uart"><a class="doc-anchor" href="#emulate-16550-uart">¬ß</a>3 Emulate 16550 UART</h1>
<p><em>What about Avaota I/O? How to emulate in Unicorn?</em></p>
<p>Let‚Äôs emulate the Bare Minimum for I/O: Printing output to the <a href="TODO"><strong>16550 UART</strong></a>‚Ä¶</p>
<ol>
<li>
<p>We intercept all writes to the <a href="TODO"><strong>UART Transmit Register</strong></a>, and print them</p>
<p><em>(So we can see the Boot Log from NuttX)</em></p>
</li>
<li>
<p>We signal to NuttX that <a href="TODO"><strong>UART Transmit FIFO</strong></a> is always ready to transmit</p>
<p><em>(Otherwise NuttX will wait forever for UART)</em></p>
</li>
</ol>
<p>This will tell NuttX that our <strong>UART Transmit FIFO</strong> is forever ready: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L64-L73">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// UART Base Address
</span><span class="kw">const </span>UART0_BASE_ADDRESS: u64 = <span class="number">0x02500000</span>;

<span class="kw">fn </span>main() {
  ...
  <span class="comment">// Allwinner A527 UART Line Status Register (UART_LSR) is at Offset 0x14.
  // To indicate that the UART Transmit FIFO is ready:
  // We set Bit 5 to 1.
  </span>emu.mem_write(
    UART0_BASE_ADDRESS + <span class="number">0x14</span>,  <span class="comment">// UART Register Address
    </span><span class="kw-2">&amp;</span>[<span class="number">0b10_0000</span>]                <span class="comment">// UART Register Value
  </span>).unwrap();</code></pre></div>
<p>Our <strong>Unicorn Memory Hook</strong> will intercept all writes to the <strong>UART Transmit Register</strong>, and print them: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L152-L178">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Hook Function for Memory Access.
/// Called once for every Arm64 Memory Access.
</span><span class="kw">fn </span>hook_memory(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>mem_type: MemType,    <span class="comment">// Read or Write Access
  </span>address: u64,  <span class="comment">// Accessed Address
  </span>size: usize,   <span class="comment">// Number of bytes accessed
  </span>value: i64     <span class="comment">// Write Value
</span>) -&gt; bool {

  <span class="comment">// If writing to UART Transmit Holding Register (THR):
  // We print the UART Output
  </span><span class="kw">if </span>address == UART0_BASE_ADDRESS {
    <span class="macro">println!</span>(<span class="string">"uart output: {:?}"</span>, value <span class="kw">as </span>u8 <span class="kw">as </span>char);
  }

  <span class="comment">// Always return true, value is unused by caller
  // https://github.com/unicorn-engine/unicorn/blob/dev/docs/FAQ.md#i-cant-recover-from-unmapped-readwrite-even-i-return-true-in-the-hook-why
  </span><span class="bool-val">true
</span>}</code></pre></div>
<p>When we run this: Our Barebones Emulator will print the UART Output and show the <strong>NuttX Boot Log</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## To see the Emulated UART Output:
$ cargo run | grep &quot;uart output&quot;
TODO</code></pre></div>
<p>We‚Äôre ready to boot NuttX on Unicorn!</p>
<p><img src="https://lupyuen.org/images/unicorn3-avaota.jpg" alt="TODO" /></p>
<h1 id="nuttx-halts-at-syscall"><a class="doc-anchor" href="#nuttx-halts-at-syscall">¬ß</a>4 NuttX Halts at SysCall</h1>
<p><em>Our Barebones Emulator: What happens when we run it?</em></p>
<p>We boot NuttX on our <a href="TODO"><strong>Barebones Emulator</strong></a>. NuttX halts with an <strong>Arm64 Exception</strong> at this curious address: <em>0x4080_6D60</em>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo run
...
hook_block:  address=0x40806d4c, size=04, sched_unlock, sched/sched/sched_unlock.c:90:18
call_graph:  nxsched_merge_pending --&gt; sched_unlock
call_graph:  click nxsched_merge_pending href &quot;https://github.com/apache/nuttx/blob/master/sched/sched/sched_mergepending.c#L84&quot; &quot;sched/sched/sched_mergepending.c &quot; _blank
hook_block:  address=0x40806d50, size=08, sched_unlock, sched/sched/sched_unlock.c:92:19
hook_block:  address=0x40806d58, size=08, sys_call0, arch/arm64/include/syscall.h:152:21
call_graph:  sched_unlock --&gt; sys_call0
call_graph:  click sched_unlock href &quot;https://github.com/apache/nuttx/blob/master/sched/sched/sched_unlock.c#L89&quot; &quot;sched/sched/sched_unlock.c &quot; _blank
&gt;&gt; exception index = 2
&gt;&gt;&gt; invalid memory accessed, STOP = 21!!!
err=Err(EXCEPTION)
PC=0x40806d60</code></pre></div>
<p><em>What‚Äôs at 0x4080_6D60?</em></p>
<p>We look up the <a href="TODO"><strong>Arm64 Disassembly</strong></a> for for NuttX Kernel. We see that <em>0x4080_6D60</em> points to <strong>Arm64 SysCall <code>SVC</code> <code>0</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>nuttx/include/arch/syscall.h:152
// Execute an Arm64 SysCall SVC with SYS_ call number and no parameters
static inline uintptr_t sys_call0(unsigned int nbr) {
  register uint64_t reg0 __asm__(&quot;x0&quot;) = (uint64_t)(nbr);
    40806d58:	d2800040 	mov	x0, #0x2  // Parameter in Register X0 is 2
    40806d5c:	d4000001 	svc	#0x0      // Execute SysCall 0
    40806d60: ... //Next instruction to be executed on return from SysCall</code></pre></div>
<p><a href="TODO">(<strong>sys_call0</strong> is here)</a></p>
<p>Somehow NuttX Kernel is making an Arm64 SysCall, and failing.</p>
<p><em>Isn‚Äôt Unicorn supposed to emulate Arm64 SysCalls?</em></p>
<p>To find out: We step through Unicorn with <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb"><strong>CodeLLDB Debugger</strong></a> (pic above). Unicorn triggers the Arm64 Exception here: <a href="TODO">unicorn-engine-2.1.3/qemu/accel/tcg/cpu-exec.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// When Unicorn handles a CPU Exception...
static inline bool cpu_handle_exception(CPUState *cpu, int *ret) {
  ...
  // Unicorn: call registered interrupt callbacks
  catched = false;
  HOOK_FOREACH_VAR_DECLARE;
  HOOK_FOREACH(uc, hook, UC_HOOK_INTR) {
    if (hook-&gt;to_delete) { continue; }
    JIT_CALLBACK_GUARD(((uc_cb_hookintr_t)hook-&gt;callback)(uc, cpu-&gt;exception_index, hook-&gt;user_data));
    catched = true;
  }

  // Unicorn: If interrupt is uncaught, stop the execution
  if (!catched) {
    if (uc-&gt;invalid_error == UC_ERR_OK) {
      // OOPS! EXCEPTION HAPPENS HERE
      uc-&gt;invalid_error = UC_ERR_EXCEPTION;
    }
    cpu-&gt;halted = 1;
    *ret = EXCP_HLT;
    return true;
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/.vscode/bookmarks.json">(Set these <strong>Debug Breakpoints</strong>)</a></p>
<p><a href="https://github.com/qemu/qemu/blob/master/accel/tcg/cpu-exec.c#L704-L769">(Compare with <strong>Original QEMU</strong>)</a></p>
<p>Aha! Unicorn is expecting us to <strong>Hook This Interrupt</strong> and emulate the Arm64 SysCall, inside our Interrupt Callback.</p>
<p>Before hooking the interrupt, we track down the origin of the SysCall‚Ä¶</p>
<h1 id="syscall-for-context-switch"><a class="doc-anchor" href="#syscall-for-context-switch">¬ß</a>5 SysCall for Context Switch</h1>
<p><em>Why is NuttX Kernel making an Arm64 SysCall? Aren‚Äôt SysCalls used by NuttX Apps?</em></p>
<p>Let‚Äôs find out! NuttX passes a <strong>Parameter to SysCall</strong> in Register X0. The Parameter Value is <strong><code>2</code></strong>: TODO</p>
<div class="example-wrap"><pre class="language-c"><code>nuttx/sched/sched/sched_unlock.c:92
TODO: Function
TODO {
  up_switch_context(this_task(), rtcb);
    40807230:	d538d080 	mrs	x0, tpidr_el1
    40807234:	37000060 	tbnz	w0, #0, 40807240 &lt;sched_unlock+0x80&gt;

nuttx/include/arch/syscall.h:152
// Execute an Arm64 SysCall SVC with SYS_ call number and no parameters
static inline uintptr_t sys_call0(unsigned int nbr) {
  register uint64_t reg0 __asm__(&quot;x0&quot;) = (uint64_t)(nbr);
    40807238:	d2800040 	mov	x0, #0x2  // Parameter in Register X0 is 2
    4080723c:	d4000001 	svc	#0x0      // Execute SysCall 0</code></pre></div>
<p>What‚Äôs the NuttX SysCall with Parameter 2? It‚Äôs for <strong>Switching The Context</strong> between NuttX Tasks: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/include/syscall.h#L78-L83">syscall.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX SysCall 2 will Switch Context:
// void arm64_switchcontext(void **saveregs, void *restoreregs)
#define SYS_switch_context (2)</code></pre></div>
<p>Which is implemented here: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_syscall.c#L201-L216">arm64_syscall.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX executes the Arm64 SysCall...
uint64_t *arm64_syscall(uint64_t *regs) {
  ...
  // If SysCall is for Switch Context...
  case SYS_switch_context:

    // Update the Scheduler Parameters
    nxsched_suspend_scheduler(*running_task);
    nxsched_resume_scheduler(tcb);
    *running_task = tcb;

    // Restore the CPU Lock
    restore_critical_section(tcb, cpu);
    addrenv_switch(tcb);
    break;</code></pre></div>
<p>Ah we see the light‚Ä¶</p>
<ol>
<li>
<p>NuttX Kernel makes an <strong>Arm64 SysCall</strong> during Startup</p>
</li>
<li>
<p>To trigger the <strong>Very First Context Switch</strong></p>
</li>
<li>
<p>Which will start the <strong>NuttX Tasks</strong> and boot successfully</p>
</li>
<li>
<p>This means we must emulate the <strong>Arm64 SysCall</strong>!</p>
</li>
</ol>
<p>FYI <strong>NuttX SysCalls</strong> are defined here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/include/sys/syscall_lookup.h">SysCall Defines: syscall_lookup.h</a></p>
</li>
<li>
<p><a href="TODO">SysCall CSV: TODO</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-c"><code>SYSCALL_LOOKUP(getpid,                     0)
SYSCALL_LOOKUP(gettid,                     0)
SYSCALL_LOOKUP(sched_getcpu,               0)
SYSCALL_LOOKUP(sched_lock,                 0)
SYSCALL_LOOKUP(sched_lockcount,            0)
SYSCALL_LOOKUP(sched_unlock,               0)
SYSCALL_LOOKUP(sched_yield,                0)</code></pre></div><h1 id="hook-the-unicorn-interrupt"><a class="doc-anchor" href="#hook-the-unicorn-interrupt">¬ß</a>6 Hook The Unicorn Interrupt</h1>
<p><em>To Boot NuttX: We need to Emulate the Arm64 SysCall. How?</em></p>
<p>We saw earlier that Unicorn expects us to‚Ä¶</p>
<ol>
<li>
<p><a href="TODO"><strong>Hook the Unicorn Interrupt</strong></a></p>
</li>
<li>
<p>Then <strong>Emulate the Arm64 SysCall</strong></p>
</li>
</ol>
<p>This is how we <strong>Hook the Interrupt</strong>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L85-L152">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Main Function of Avaota Emulator
</span><span class="kw">fn </span>main() {
  ...
  <span class="comment">// Add the Interrupt Hook
  </span>emu.add_intr_hook(hook_interrupt)
    .unwrap();

  <span class="comment">// Emulate Arm64 Machine Code
  </span><span class="kw">let </span>err = emu.emu_start(
    ADDRESS,  <span class="comment">// Begin Address
    </span>ADDRESS + KERNEL_SIZE <span class="kw">as </span>u64,  <span class="comment">// End Address
    </span><span class="number">0</span>,  <span class="comment">// No Timeout
    </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
  </span>);
  ...
}

<span class="doccomment">/// Hook Function to handle the Unicorn Interrupt
</span><span class="kw">fn </span>hook_interrupt(
  emu: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>intno: u32,             <span class="comment">// Interrupt Number
</span>) {
  <span class="kw">let </span>pc = emu.reg_read(RegisterARM64::PC).unwrap();
  <span class="kw">let </span>x0 = emu.reg_read(RegisterARM64::X0).unwrap();
  <span class="macro">println!</span>(<span class="string">"hook_interrupt: intno={intno}"</span>);
  <span class="macro">println!</span>(<span class="string">"PC=0x{pc:08x}"</span>);
  <span class="macro">println!</span>(<span class="string">"X0=0x{x0:08x}"</span>);
  <span class="macro">println!</span>(<span class="string">"ESR_EL0={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL0));
  <span class="macro">println!</span>(<span class="string">"ESR_EL1={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL1));
  <span class="macro">println!</span>(<span class="string">"ESR_EL2={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL2));
  <span class="macro">println!</span>(<span class="string">"ESR_EL3={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL3));

  <span class="comment">// Upcoming: Handle the SysCall
  </span>...
}</code></pre></div>
<p>Our Interrupt Hook is super barebones, barely sufficient for making it past the Arm64 SysCall‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo run
...
## NuttX Scheduler calls Arm64 SysCall...
call_graph:  sched_unlock --&gt; sys_call0
call_graph:  click sched_unlock href &quot;https://github.com/apache/nuttx/blob/master/sched/sched/sched_unlock.c#L89&quot; &quot;sched/sched/sched_unlock.c &quot; _blank

## Unicorn calls our Interrupt Hook!
&gt;&gt; exception index = 2
hook_interrupt: intno=2
PC=0x40806d60

## Our Interrupt Hook returns to Unicorn,
## without handling the Arm64 SysCall...
call_graph:  sys_call0 --&gt; sched_unlock
call_graph:  up_irq_restore --&gt; sched_unlock
call_graph:  click up_irq_restore href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/include/irq.h#L382&quot; &quot;arch/arm64/include/irq.h &quot; _blank

## NuttX tries to continue booting, but fails...
call_graph:  nx_start --&gt; up_idle
call_graph:  click nx_start href &quot;https://github.com/apache/nuttx/blob/master/sched/init/nx_start.c#L781&quot; &quot;sched/init/nx_start.c &quot; _blank

## Unicorn says that NuttX has halted at WFI
&gt;&gt; exception index = 65537
&gt;&gt;&gt; stop with r = 10001, HLT=10001
&gt;&gt;&gt; got HLT!!!
err=Ok(())
PC=0x408169d0</code></pre></div>
<p><a href="TODO">(<strong>0x4081_69D0</strong> points to WFI)</a></p>
<p>But we‚Äôre not done yet! Unicorn halts because we haven‚Äôt emulated the Arm64 SysCall. Let‚Äôs do it‚Ä¶</p>
<h1 id="arm64-vector-table"><a class="doc-anchor" href="#arm64-vector-table">¬ß</a>7 Arm64 Vector Table</h1>
<p><em>How to emulate the Arm64 SysCall?</em></p>
<p>Here‚Äôs our plan‚Ä¶</p>
<ol>
<li>
<p>System Register <a href="TODO"><strong>VBAR_EL1</strong></a> points to the <strong>Arm64 Vector Table</strong></p>
<p><em>(Exception Level 1, for NuttX Kernel)</em></p>
</li>
<li>
<p>We read <strong>VBAR_EL1</strong> to fetch the <strong>Arm64 Vector Table</strong></p>
</li>
<li>
<p>We <strong>jump into</strong> the Vector Table, at the right spot</p>
</li>
<li>
<p>Which will execute the <strong>NuttX Exception Handler</strong> for Arm64 SysCall</p>
</li>
</ol>
<p><em>Where exactly in the Arm64 Vector Table?</em></p>
<p><strong>VBAR_EL1</strong> points to this Vector Table: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_vector_table.S#L103-L145">arm64_vector_table.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Four types of exceptions:
 * - synchronous: aborts from MMU, SP/CP alignment checking, unallocated
 *   instructions, SVCs/SMCs/HVCs, ...)
 * - IRQ: group 1 (normal) interrupts
 * - FIQ: group 0 or secure interrupts
 * - SError: fatal system errors
 *
 * Four different contexts:
 * - from same exception level, when using the SP_EL0 stack pointer
 * - from same exception level, when using the SP_ELx stack pointer
 * - from lower exception level, when this is AArch64
 * - from lower exception level, when this is AArch32
 *
 * +------------------+------------------+-------------------------+
 * |     Address      |  Exception type  |       Description       |
 * +------------------+------------------+-------------------------+
 * | VBAR_ELn + 0x000 | Synchronous      | Current EL with SP0     |
 * |          + 0x080 | IRQ / vIRQ       |                         |
 * |          + 0x100 | FIQ / vFIQ       |                         |
 * |          + 0x180 | SError / vSError |                         |
 * +------------------+------------------+-------------------------+
 * |          + 0x200 | Synchronous      | Current EL with SPx     |
 * |          + 0x280 | IRQ / vIRQ       |                         |
 * |          + 0x300 | FIQ / vFIQ       |                         |
 * |          + 0x380 | SError / vSError |                         |
 * +------------------+------------------+-------------------------+
 * |          + 0x400 | Synchronous      | Lower EL using AArch64  |
 * |          + 0x480 | IRQ / vIRQ       |                         |
 * |          + 0x500 | FIQ / vFIQ       |                         |
 * |          + 0x580 | SError / vSError |                         |
 * +------------------+------------------+-------------------------+
 * |          + 0x600 | Synchronous      | Lower EL using AArch32  |
 * |          + 0x680 | IRQ / vIRQ       |                         |
 * |          + 0x700 | FIQ / vFIQ       |                         |
 * |          + 0x780 | SError / vSError |                         |
 * +------------------+------------------+-------------------------+</code></pre></div>
<p>We‚Äôre doing <strong>SVC SysCall</strong> <em>(Synchronous Exception)</em> at Exception Level 1‚Ä¶</p>
<p>Which means Unicorn Emulator should jump to <strong>VBAR_EL1 + 0x200</strong>. Here‚Äôs how‚Ä¶</p>
<h1 id="emulate-the-arm64-syscall"><a class="doc-anchor" href="#emulate-the-arm64-syscall">¬ß</a>8 Emulate the Arm64 SysCall</h1>
<p>Inside our <strong>Interrupt Hook</strong>: This is how we jump to <strong>VBAR_EL1 + 0x200</strong>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/src/main.rs#L115-L152">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Hook Function to Handle Unicorn Interrupt
</span><span class="kw">fn </span>hook_interrupt(
    emu: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
    </span>intno: u32,             <span class="comment">// Interrupt Number
</span>) {
  <span class="kw">let </span>pc = emu.reg_read(RegisterARM64::PC).unwrap();
  <span class="kw">let </span>x0 = emu.reg_read(RegisterARM64::X0).unwrap();
  <span class="macro">println!</span>(<span class="string">"hook_interrupt: intno={intno}"</span>);
  <span class="macro">println!</span>(<span class="string">"PC=0x{pc:08x}"</span>);
  <span class="macro">println!</span>(<span class="string">"X0=0x{x0:08x}"</span>);
  <span class="macro">println!</span>(<span class="string">"ESR_EL0={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL0));
  <span class="macro">println!</span>(<span class="string">"ESR_EL1={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL1));
  <span class="macro">println!</span>(<span class="string">"ESR_EL2={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL2));
  <span class="macro">println!</span>(<span class="string">"ESR_EL3={:?}"</span>, emu.reg_read(RegisterARM64::ESR_EL3));

  <span class="comment">// SysCall from NuttX Apps: We don't handle it yet
  </span><span class="kw">if </span>pc &gt;= <span class="number">0xC000_0000 </span>{ <span class="macro">println!</span>(<span class="string">"TODO: Handle SysCall from NuttX Apps"</span>); finish(); }

  <span class="comment">// SysCall from NuttX Kernel: Handle it here...
  </span><span class="kw">if </span>intno == <span class="number">2 </span>{

    <span class="comment">// We are doing SVC (Synchronous Exception) at EL1.
    // Which means Unicorn Emulator should jump to VBAR_EL1 + 0x200.
    </span><span class="kw">let </span>esr_el1 = <span class="number">0x15 </span>&lt;&lt; <span class="number">26</span>;  <span class="comment">// Exception is SVC
    </span><span class="kw">let </span>vbar_el1 = emu.reg_read(RegisterARM64::VBAR_EL1).unwrap();
    <span class="kw">let </span>svc = vbar_el1 + <span class="number">0x200</span>;

    <span class="comment">// Update the ESR_EL1 and Program Counter
    </span>emu.reg_write(RegisterARM64::ESR_EL1, esr_el1).unwrap();
    emu.reg_write(RegisterARM64::PC, svc).unwrap();

    <span class="comment">// Print the values
    </span><span class="macro">println!</span>(<span class="string">"esr_el1=0x{esr_el1:08x}"</span>);
    <span class="macro">println!</span>(<span class="string">"vbar_el1=0x{vbar_el1:08x}"</span>);
    <span class="macro">println!</span>(<span class="string">"jump to svc=0x{svc:08x}"</span>);
  }
}</code></pre></div>
<p>TODO: Why ESR_EL1?</p>
<p>And it works: NuttX on Unicorn boots <em>(almost)</em> to <strong>NSH Shell</strong>. Yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo run | grep &quot;uart output&quot;
...
## NuttX begins booting...
- Ready to Boot Primary CPU
- Boot from EL1
- Boot to C runtime for OS Initialize
nx_start: Entry
up_allocate_kheap: heap_start=0x0x40849000, heap_size=0x77b7000
gic_validate_dist_version: No GIC version detect
arm64_gic_initialize: no distributor detected, giving up ret=-19
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_highpri: Starting high-priority kernel worker thread(s)
nxtask_activate: hpwork pid=1,TCB=0x40849e78
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=2,TCB=0x4084c008
nxtask_activate: AppBringUp pid=3,TCB=0x4084c190

## Unicorn calls our Interrupt Hook...
&gt;&gt; exception index = 2
hook_interrupt: intno=2
PC=0x40807300
X0=0x00000002

## We jump to VBAR_EL1 + 0x200
## Which points to NuttX Exception Handler for Arm64 SysCall
esr_el1=0x54000000
vbar_el1=0x40827000
jump to svc=0x40827200

## Unicorn executes the NuttX Exception Handler for Arm64 SysCall
&gt;&gt; exception index = 65536
&gt;&gt;&gt; stop with r = 10000, HLT=10001
&gt;&gt; exception index = 4294967295

## NuttX dumps the Arm64 SysCall
arm64_dump_syscall: SYSCALL arm64_syscall: regs: 0x408483c0 cmd: 2
arm64_dump_syscall: x0:  0x2                 x1:  0x0
arm64_dump_syscall: x2:  0x4084c008          x3:  0x408432b8
arm64_dump_syscall: x4:  0x40849e78          x5:  0x2
arm64_dump_syscall: x6:  0x40843000          x7:  0x3

## NuttX continues booting yay!
nx_start_application: Starting init task: /system/bin/init
nxtask_activate: /system/bin/init pid=4,TCB=0x4084c9f0
nxtask_exit: AppBringUp pid=3,TCB=0x4084c190
...
## More Arm64 SysCalls, handled correctly...
arm64_dump_syscall: SYSCALL arm64_syscall: regs: 0x40853c70 cmd: 1
arm64_dump_syscall: x0:  0x1                 x1:  0x40843000
arm64_dump_syscall: x2:  0x0                 x3:  0x1
arm64_dump_syscall: x4:  0x3                 x5:  0x40844000
arm64_dump_syscall: x6:  0x4                 x7:  0x0
...
arm64_dump_syscall: SYSCALL arm64_syscall: regs: 0x4084bc20 cmd: 2
arm64_dump_syscall: x0:  0x2                 x1:  0xc0
arm64_dump_syscall: x2:  0x4084c008          x3:  0x0
arm64_dump_syscall: x4:  0x408432d0          x5:  0x0
arm64_dump_syscall: x6:  0x0                 x7:  0x0
...
arm64_dump_syscall: SYSCALL arm64_syscall: regs: 0x4084fc20 cmd: 2
arm64_dump_syscall: x0:  0x2                 x1:  0x64
arm64_dump_syscall: x2:  0x4084c9f0          x3:  0x0
arm64_dump_syscall: x4:  0x408432d0          x5:  0x0
arm64_dump_syscall: x6:  0x0                 x7:  0x0</code></pre></div>
<p><a href="TODO">(See the <strong>Unicorn Log</strong>)</a></p>
<p>But NSH Shell won‚Äôt start correctly, here‚Äôs why‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Our Emulator stops at SysCall Command 9
&gt;&gt; exception index = 2
hook_interrupt: intno=2
PC=0xc0003f00
X0=0x00000009
ESR_EL1=Ok(1409286144)
TODO: Handle SysCall from NuttX Apps</code></pre></div><h1 id="syscall-from-nuttx-app"><a class="doc-anchor" href="#syscall-from-nuttx-app">¬ß</a>9 SysCall from NuttX App</h1>
<p><em>What‚Äôs SysCall Command 9? Where in NSH Shell is 0xC000_3F00?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo run
...
## Our Emulator stops at SysCall Command 9
hook_interrupt: intno=2
PC=0xc0003f00
X0=0x00000009
ESR_EL0=Ok(0)
ESR_EL1=Ok(1409286144)</code></pre></div>
<p>According to Arm64 Disassembly of NSH Shell, <strong>SysCall Command 9</strong> happens inside the <code>gettid</code> function: <a href="TODO">nuttx-init.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NSH Shell calls gettid() to fetch Thread ID.
// Exception Level 0 (NuttX App) calls Exception Level 1 (NuttX Kernel).
gettid():
  2ef4:	d2800120 	mov	x0,  #0x9  // SysCall Command 9 (Register X0)
  2ef8:	f81f0ffe 	str	x30, [sp, #-16]!
  2efc:	d4000001 	svc	#0x0       // Execute the SysCall
  2f00:	f84107fe 	ldr	x30, [sp], #16
  2f04:	d65f03c0 	ret</code></pre></div>
<p>This says that‚Ä¶</p>
<ol>
<li>
<p><strong>NSH Shell</strong> is starting as a NuttX App</p>
<p><em>(Exception Level 0)</em></p>
</li>
<li>
<p>NSH Shall calls <code>gettid()</code> to fetch the <strong>Current Thread ID</strong></p>
</li>
<li>
<p>Which triggers an Arm64 SysCall from <strong>NuttX App</strong> into <strong>NuttX Kernel</strong></p>
<p><em>(Exception Level 0 calls Exception Level 1)</em></p>
</li>
<li>
<p>Which we haven‚Äôt implemented yet</p>
<p><em>(Nope, no SysCalls across Exception Levels)</em></p>
</li>
</ol>
<p>We‚Äôll implement this SysCall soon!</p>
<p>TODO: GIC</p>
<p>TODO: Timer</p>
<p>TODO: Other Peripherals</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>10 What‚Äôs Next</h1>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-starpro64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for StarPro64 EIC7700X‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Other Project: ‚ÄúNuttX for Oz64 SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>Older Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/unicorn4.md"><strong>lupyuen.org/src/unicorn4.md</strong></a></p>
<p><img src="https://lupyuen.org/images/unicorn4-title.jpg" alt="TODO" /></p>
<span style="font-size:80%">
<p><em>Shot on Sony NEX-7 with IKEA Ring Light, Yeelight Ring Light on Corelle Plate</em></p>
</span>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>