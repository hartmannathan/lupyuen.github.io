<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Booting RISC-V Linux on Star64 JH7110 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Booting RISC-V Linux on Star64 JH7110 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="Watch what happens when we boot Yocto and Armbian Linux on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC"
    data-rh="true">
<meta name="description" 
    content="Watch what happens when we boot Yocto and Armbian Linux on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/linux-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Booting RISC-V Linux on Star64 JH7110 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#serial-console-on-star64">1 Serial Console on Star64</a><ul></ul></li>
<li><a href="#boot-yocto-linux-on-star64">2 Boot Yocto Linux on Star64</a><ul></ul></li>
<li><a href="#yocto-linux-with-kde-plasma">3 Yocto Linux with KDE Plasma</a><ul></ul></li>
<li><a href="#boot-armbian-linux-on-star64">4 Boot Armbian Linux on Star64</a><ul></ul></li>
<li><a href="#nuttx-prints-to-qemu-console">5 NuttX prints to QEMU Console</a><ul></ul></li>
<li><a href="#uart-base-address-for-star64">6 UART Base Address for Star64</a><ul></ul></li>
<li><a href="#risc-v-linux-kernel-header">7 RISC-V Linux Kernel Header</a><ul></ul></li>
<li><a href="#set-start-address-of-nuttx-kernel">8 Set Start Address of NuttX Kernel</a><ul></ul></li>
<li><a href="#boot-nuttx-on-star64">9 Boot NuttX on Star64</a><ul></ul></li>
<li><a href="#nuttx-fails-to-get-hart-id">10 NuttX Fails To Get Hart ID</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-star64-u-boot-bootloader-log">12 Appendix: Star64 U-Boot Bootloader Log</a><ul>
<li><a href="#u-boot-commands-for-star64">12.1 U-Boot Commands for Star64</a><ul></ul></li>
<li><a href="#u-boot-settings-for-star64">12.2 U-Boot Settings for Star64</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>9 Jul 2023</em></p>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Star64 JH7110 RISC-V SBC with Woodpecker USB Serial Adapter" /></p>
<p><a href="https://wiki.pine64.org/wiki/STAR64"><em>Star64 JH7110 RISC-V SBC with Woodpecker USB Serial Adapter</em></a></p>
<p>Previously we talked about the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> 64-bit RISC-V Single-Board Computer. (Based on <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p>And we inspected the Linux Images for Star64‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64"><strong>‚ÄúInspecting the RISC-V Linux Images for Star64 JH7110 SBC‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs boot them on Star64! We‚Äôll soon see‚Ä¶</p>
<ul>
<li>
<p><strong>Yocto Linux</strong> boots OK on Star64</p>
<p>(Even KDE Plasma)</p>
</li>
<li>
<p><strong>Armbian Linux</strong> is not quite ready</p>
<p>(Missing Device Tree)</p>
</li>
<li>
<p><strong>Apache NuttX RTOS</strong> boots a bit</p>
<p>(Thanks to Armbian)</p>
</li>
<li>
<p>Helped by <strong>OpenSBI</strong> and <strong>U-Boot Bootloader</strong></p>
<p>(We‚Äôll explain why)</p>
</li>
</ul>
<p>Read on for the details‚Ä¶</p>
<p><em>What‚Äôs NuttX?</em></p>
<p><a href="https://lupyuen.github.io/articles/riscv"><strong>Apache NuttX</strong></a> is a <strong>Real-Time Operating System (RTOS)</strong> that runs on many kinds of devices, from 8-bit to 64-bit.</p>
<p>The analysis that we do today will be super helpful for <a href="https://lupyuen.github.io/articles/riscv#jump-to-start"><strong>porting NuttX to Star64</strong></a>.</p>
<p><img src="https://lupyuen.github.io/images/star64-uart1.jpg" alt="UART0 TX and RX on GPIO Header Pins 8 and 10" /></p>
<h1 id="serial-console-on-star64"><a href="#serial-console-on-star64">1 Serial Console on Star64</a></h1>
<p>Before we begin, let‚Äôs connect a <strong>USB Serial Adapter</strong> to Star64. (So we can see the Boot Log)</p>
<p>We‚Äôll use the <a href="https://pine64.com/product/serial-console-woodpecker-edition/"><strong>Pine64 Woodpecker Serial Adapter</strong></a>. (Any CH340 or similar adapter should work)</p>
<p>According to <a href="https://files.pine64.org/doc/star64/Star64_Schematic_V1.1_20230504.pdf"><strong>Star64 Schematic</strong></a> (Page 18), <strong>UART0 TX and RX</strong> (GPIO 5 and 6) are connected to the <strong>GPIO Header</strong> (Pins 8 and 10). (Pic above)</p>
<p>Thus we connect these pins‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Star64 GPIO Header</th><th style="text-align: center"><a href="https://pine64.com/product/serial-console-woodpecker-edition/">USB Serial Adapter</a></th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center">Pin 6 (GND)</td><td style="text-align: center">GND</td><td style="text-align: left">Brown</td></tr>
<tr><td style="text-align: center">Pin 8 (TX)</td><td style="text-align: center">RX</td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center">Pin 10 (RX)</td><td style="text-align: center">TX</td><td style="text-align: left">Orange</td></tr>
</tbody></table>
</div>
<p>On our USB Serial Adapter, set the Voltage Jumper to <strong>3V3</strong>. (Instead of 5V, pic below)</p>
<p><img src="https://lupyuen.github.io/images/star64-uart3.jpg" alt="Pine64 Woodpecker Serial Adapter" /></p>
<p>On our computer, connect to the USB Serial Port at <strong>115.2 kbps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 115200
</code></pre></div>
<p>Insert the <strong>microSD Card</strong> (from next section) and power up Star64.</p>
<p>Verify that the <strong>DIP Switches</strong> for GPIO 0 and 1 are set to <strong>Low and Low</strong>. (Default setting, pic below)</p>
<p>So Star64 should start the U-Boot Bootloader from <strong>Internal Flash Memory</strong>.</p>
<p><a href="https://wiki.pine64.org/wiki/STAR64#Prototype_Bringup_Notes">(DIP Switch Labels are inverted: <strong>‚ÄúON‚Äù</strong> actually means <strong>‚ÄúLow‚Äù</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/star64-uart2.jpg" alt="DIP Switches for GPIO 0 and 1 are set to Low and Low" /></p>
<h1 id="boot-yocto-linux-on-star64"><a href="#boot-yocto-linux-on-star64">2 Boot Yocto Linux on Star64</a></h1>
<p><em>What‚Äôs Yocto Linux?</em></p>
<p><a href="https://www.yoctoproject.org/"><strong>Yocto</strong></a> provides tools for creating a Custom Linux Image. (Like for Star64)</p>
<p>Yocto is like baking <a href="https://lupyuen.github.io/articles/sourdough"><strong>Sourdough Bread</strong></a>‚Ä¶</p>
<p>We start with the base (Sourdough Starter + Flour), then we add fruits, nuts, seeds, chocolate, ‚Ä¶ Baked into a delicious loaf that‚Äôs uniquely ours!</p>
<p>(Compare with Linux Distros, which is like buying a loaf of bread)</p>
<p><em>Ahem enough with the bread‚Ä¶</em></p>
<p>Righto! We download the <a href="https://github.com/Fishwaldo/meta-pine64"><strong>Yocto Minimal Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://pine64.my-ho.st:8443/star64-image-minimal-star64-1.2.wic.bz2"><strong>star64-image-minimal 1.2</strong></a></li>
</ul>
<p>Uncompress the <strong>.bz2</strong> file, rename as <strong>.img</strong>.</p>
<p>(Balena Etcher won‚Äôt work with <strong>.bz2</strong> files!)</p>
<p>Write the <strong>.img</strong> file to a microSD Card with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a> or <a href="https://wiki.gnome.org/Apps/Disks"><strong>GNOME Disks</strong></a>.</p>
<p>When we boot the microSD Card on Star64, the <strong>OpenSBI (Supervisor Binary Interface)</strong> appears (running from Internal Flash Memory)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>OpenSBI v1.2
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|
Platform Name: StarFive VisionFive V2
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b23edf50cecbee13e5aab3c0bae6c528">(See the <strong>Complete Log</strong>)</a></p>
<p>(We‚Äôll explain OpenSBI in a while)</p>
<p>OpenSBI starts the <a href="https://u-boot.readthedocs.io/en/latest/board/starfive/visionfive2.html#flashing"><strong>U-Boot Bootloader</strong></a> (also from Internal Flash Memory)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2021.10 (Jan 19 2023 - 04:09:41 +0800), Build: jenkins-github_visionfive2-6
CPU:   rv64imacu
Model: StarFive VisionFive V2
DRAM:  8 GiB
</code></pre></div>
<p>U-Boot Bootloader loads the <a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64"><strong>Yocto Linux Kernel</strong></a>, <a href="https://docs.kernel.org/admin-guide/initrd.html"><strong>Initial RAM Disk</strong></a> and <a href="https://u-boot.readthedocs.io/en/latest/develop/devicetree/index.html"><strong>Flattened Device Tree (FDT)</strong></a> from the microSD Card‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Loading kernel from FIT Image at a0000000 ...
  Load Address: 0x40200000
  Entry Point:  0x40200000
Loading ramdisk from FIT Image at a0000000 ...
  Load Address: 0x46100000
Loading fdt from FIT Image at a0000000 ...
  Load Address: 0x46000000
  Loading fdt from 0xa094e97c to 0x46000000
  Booting using the fdt blob at 0x46000000
  Uncompressing Kernel Image
Booting kernel in
  Flattened Device Tree blob at 46000000
  Booting using the fdt blob at 0x46000000
  Using Device Tree in place at 0000000046000000, end 000000004600efff
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64">(Packed into a <strong>FIT: Flat Image Tree</strong>)</a></p>
<p>And boots the <a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64"><strong>Yocto Linux Kernel</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
Linux version 5.15.107 (oe-user@oe-host) 
  (riscv64-pine64-linux-gcc (GCC) 11.3.0, GNU ld (GNU Binutils) 2.38.20220708) 
  #1 SMP Mon May 15 17:57:25 UTC 2023
</code></pre></div>
<p>We log in with <strong>root</strong> or <strong>pine64</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Username</th><th style="text-align: left">Password</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>root</code></td><td style="text-align: left"><code>pine64</code></td></tr>
<tr><td style="text-align: left"><code>pine64</code></td><td style="text-align: left"><code>pine64</code></td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/Fishwaldo/meta-pine64#usernames">(Source)</a></p>
<div class="example-wrap"><pre class="language-text"><code>PinIx 1.2 star64 hvc0
star64 login: root
Password: pine64

root@star64:~# uname -a
Linux star64 5.15.107 #1 SMP Mon May 15 17:57:25 UTC 2023
  riscv64 riscv64 riscv64 GNU/Linux
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b23edf50cecbee13e5aab3c0bae6c528">(See the <strong>Complete Log</strong>)</a></p>
<p>Yep the Yocto Minimal Image boots OK on Star64!</p>
<p><img src="https://lupyuen.github.io/images/star64-plasma.jpg" alt="Yocto Linux with KDE Plasma on Star64" /></p>
<h1 id="yocto-linux-with-kde-plasma"><a href="#yocto-linux-with-kde-plasma">3 Yocto Linux with KDE Plasma</a></h1>
<p><em>Yocto Minimal looks so dull. Is there anything graphical?</em></p>
<p>Yep! Let‚Äôs download the <a href="https://github.com/Fishwaldo/meta-pine64"><strong>Yocto Plasma Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://pine64.my-ho.st:8443/star64-image-plasma-star64-1.2.wic.bz2"><strong>star64-image-plasma</strong></a></li>
</ul>
<p>Uncompress the <strong>.bz2</strong> file, rename as <strong>.img</strong>.</p>
<p>Write it to a microSD Card with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a> or <a href="https://wiki.gnome.org/Apps/Disks"><strong>GNOME Disks</strong></a>.</p>
<p>When we boot the microSD Card on Star64, the KDE Plasma Desktop Environment runs OK on a HDMI Display! (Pic above)</p>
<p>Remember to log in as <strong>root</strong> or <strong>pine64</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Username</th><th style="text-align: left">Password</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>root</code></td><td style="text-align: left"><code>pine64</code></td></tr>
<tr><td style="text-align: left"><code>pine64</code></td><td style="text-align: left"><code>pine64</code></td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/Fishwaldo/meta-pine64#usernames">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/star64-armbian.png" alt="Armbian Image for Star64" /></p>
<h1 id="boot-armbian-linux-on-star64"><a href="#boot-armbian-linux-on-star64">4 Boot Armbian Linux on Star64</a></h1>
<p><em>What about other Linux Distros for Star64?</em></p>
<p>Let‚Äôs boot Armbian Linux on Star64! We download the <a href="https://www.armbian.com/star64/"><strong>Armbian Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/armbianro/os/releases/download/23.8.0-trunk.56/Armbian_23.8.0-trunk.56_Star64_lunar_edge_5.15.0_minimal.img.xz"><strong>Armbian 23.8 Lunar for Star64 (Minimal)</strong></a></li>
</ul>
<p>Uncompress the <strong>.xz</strong> file. Write the <strong>.img</strong> file to a microSD Card with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a> or <a href="https://wiki.gnome.org/Apps/Disks"><strong>GNOME Disks</strong></a>.</p>
<p><em>What happens when we boot the microSD on Star64?</em></p>
<p>Armbian fails to boot on Star64!</p>
<div class="example-wrap"><pre class="language-text"><code>Retrieving file: /boot/uInitrd
10911538 bytes read in 466 ms (22.3 MiB/s)
Retrieving file: /boot/Image
22040576 bytes read in 936 ms (22.5 MiB/s)
Retrieving file: /boot/dtb/starfive/jh7110-star64-pine64.dtb
Failed to load &#39;/boot/dtb/starfive/jh7110-star64-pine64.dtb&#39;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/d73ace627318375fe20e90e4950f9c50">(See the <strong>Complete Log</strong>)</a></p>
<p>That‚Äôs because the <a href="https://u-boot.readthedocs.io/en/latest/develop/devicetree/index.html"><strong>Flattened Device Tree (FDT)</strong></a> is missing‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64"><strong>Armbian Image fails to boot</strong></a></li>
</ul>
<p>So Armbian is not quite ready for Star64. But no worries! Armbian will be super helpful for booting NuttX RTOS, we we‚Äôll soon see‚Ä¶</p>
<h1 id="nuttx-prints-to-qemu-console"><a href="#nuttx-prints-to-qemu-console">5 NuttX prints to QEMU Console</a></h1>
<p>TODO</p>
<p>Our NuttX Kernel will print to Star64 Serial Console for debugging. Before that, let‚Äôs write some RISC-V Assembly Code to print to the QEMU Console!</p>
<p>Earlier we ran NuttX on QEMU Emulator for 64-bit RISC-V‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv">‚Äú64-bit RISC-V with Apache NuttX Real-Time Operating System‚Äù</a></li>
</ul>
<p>QEMU emulates a 16550 UART Port. (Similar to Star64 / JH7110)</p>
<p><em>What‚Äôs the Base Address of QEMU‚Äôs UART Port?</em></p>
<p>According to the NuttX Configuration for QEMU: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>Base Address of QEMU‚Äôs UART Port is <code>0x1000</code> <code>0000</code>. (Same as Star64 / JH7110 yay!)</p>
<p><em>How to print to the 16550 UART Port?</em></p>
<p>Let‚Äôs check the 16550 UART Driver in NuttX. From <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1539-L1553">uart_16550.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: u16550_send
 *
 * Description:
 *   This method will send one byte on the UART
 *
 ****************************************************************************/

static void u16550_send(struct uart_dev_s *dev, int ch)
{
  FAR struct u16550_s *priv = (FAR struct u16550_s *)dev-&gt;priv;
  u16550_serialout(priv, UART_THR_OFFSET, (uart_datawidth_t)ch);
}
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L610-L624">(u16550_serialout is defined here)</a></p>
<p>To print a character, the driver writes to the UART Base Address (<code>0x1000</code> <code>0000</code>) at Offset UART_THR_OFFSET.</p>
<p>And we discover that <a href="https://github.com/apache/nuttx/blob/dc69b108b8e0547ecf6990207526c27aceaf1e2e/include/nuttx/serial/uart_16550.h#L172-L200">UART_THR_OFFSET</a> is 0:</p>
<div class="example-wrap"><pre class="language-c"><code>#define UART_THR_INCR          0 /* (DLAB =0) Transmit Holding Register */
#define UART_THR_OFFSET        (CONFIG_16550_REGINCR*UART_THR_INCR)
</code></pre></div>
<p>So we can transmit to UART Port by simply writing to <code>0x1000</code> <code>0000</code>. How convenient!</p>
<p><em>How to print to the QEMU Console?</em></p>
<p>Let‚Äôs do the printing in RISC-V Assembly Code, so that we can debug the NuttX Boot Code.</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L71-L93">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>  /* Load UART Base Address to Register t0 */
  li  t0, 0x10000000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)
</code></pre></div>
<p>This prints ‚Äú123‚Äù to the QEMU Console. Here‚Äôs the output:</p>
<div class="example-wrap"><pre class="language-text"><code>+ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic

123123123123123123112323
NuttShell (NSH) NuttX-12.0.3
nsh&gt; 
</code></pre></div>
<p>Which is correct because QEMU is running with 8 CPUs. Yay!</p>
<p><img src="https://lupyuen.github.io/images/riscv-print.png" alt="NuttX prints to QEMU Console" /></p>
<p><a href="https://about.sourcegraph.com/cody">Cody AI Assistant</a> explains our RISC-V Assembly Code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/riscv-cody1.png" alt="Cody AI Assistant explains our RISC-V Assembly Code" /></p>
<p>And offers to optimise our RISC-V Assembly Code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/riscv-cody2.png" alt="Cody AI Assistant optimises our RISC-V Assembly Code" /></p>
<p>But the output is incorrect ;-)</p>
<div class="example-wrap"><pre class="language-text"><code>+ qemu-system-riscv64 -semihosting -M virt,aclint=on -cpu rv64 -smp 8 -bios none -kernel nuttx -nographic
11111111
NuttShell (NSH) NuttX-12.0.3
nsh&gt; 
</code></pre></div>
<p>The correct output is <code>123123123123123123112323</code>. (Because of the 8 CPUs)</p>
<h1 id="uart-base-address-for-star64"><a href="#uart-base-address-for-star64">6 UART Base Address for Star64</a></h1>
<p>TODO</p>
<p>We‚Äôll take the UART Assembly Code from the previous section and run on Star64 / JH7110. (So we can troubleshoot the NuttX Boot Code)</p>
<p><em>Does Star64 / JH7110 use a 16550 UART Controller like QEMU?</em></p>
<p>According to the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/function_layer.html">JH7110 UART Developing Guide</a>, Star64 / JH7110 uses the 8250 UART Controller‚Ä¶</p>
<p>Which is <a href="https://en.wikipedia.org/wiki/16550_UART">compatible with QEMU‚Äôs 16550 UART Controller</a>. So our UART Assembly Code for QEMU will run on Star64!</p>
<p><em>What‚Äôs the UART Base Address for Star64 / JH7110?</em></p>
<p>Based on <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/system_memory_map.html">JH7110 System Memory Map</a>, UART0 is at <code>0x1000</code> <code>0000</code>.</p>
<p>Also from the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html">JH7110 UART Device Tree</a>: UART Register Base Address is <code>0x1000</code> <code>0000</code> with range <code>0x10000</code>.</p>
<p><a href="https://doc-en.rvspace.org/JH7110/Datasheet/JH7110_DS/uart.html">(JH7110 UART Datasheet)</a></p>
<p><em>Isn‚Äôt that the same UART Base Address as QEMU?</em></p>
<p>Let‚Äôs check the UART Base Address in NuttX for QEMU. From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>NuttX UART Base Address is <code>0x1000</code> <code>0000</code>. The exact same UART Base Address for QEMU AND Star64!</p>
<p>So no changes needed, our UART Assembly Code will run on QEMU AND Star64 yay!</p>
<h1 id="risc-v-linux-kernel-header"><a href="#risc-v-linux-kernel-header">7 RISC-V Linux Kernel Header</a></h1>
<p>TODO</p>
<p>For U-Boot Bootloader to boot NuttX, we need to embed the RISC-V Linux Kernel Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#inside-the-kernel-image"><strong>‚ÄúInside the Kernel Image‚Äù</strong></a></li>
</ul>
<p>This is how we decode the RISC-V Linux Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#appendix-decode-the-risc-v-linux-header"><strong>‚ÄúDecode the RISC-V Linux Header‚Äù</strong></a></li>
</ul>
<p>We copy the Arm64 Linux Header from <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/arm64/src/common/arm64_head.S#L79-L118">arm64_head.S</a>‚Ä¶</p>
<p>And tweak for RISC-V Linux Header, like this: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L42-L75">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>__start:
  /* Begin Test */

  /* DO NOT MODIFY. Image Header expected by Linux bootloaders.
   *
   * This `li` instruction has no meaningful effect except that
   * its opcode forms the magic &quot;MZ&quot; signature of a PE/COFF file
   * that is required for UEFI applications.
   *
   * Some bootloaders check the magic &quot;MZ&quot; to see if the image is a valid
   * Linux image. But modifying the bootLoader is unnecessary unless we
   * need to do a customized secure boot. So we just put &quot;MZ&quot; in the
   * header to make the bootloader happy.
   */

  c.li    s4, -13              /* Magic Signature &quot;MZ&quot; (2 bytes) */
  j       real_start           /* Jump to Kernel Start (2 bytes) */
  .long   0                    /* Executable Code padded to 8 bytes */
  .quad   0x200000             /* Image load offset from start of RAM */
  /* TODO: _e_initstack - __start */
  .quad   171644               /* Effective size of kernel image, little-endian */
  .quad   0x0                  /* Kernel flags, little-endian */
  .long   0x2                  /* Version of this header */
  .long   0                    /* Reserved */
  .quad   0                    /* Reserved */
  .ascii  &quot;RISCV\x00\x00\x00&quot;  /* Magic number, &quot;RISCV&quot; (8 bytes) */
  .ascii  &quot;RSC\x05&quot;            /* Magic number 2, &quot;RSC\x05&quot; (4 bytes) */
  .long   0                    /* Reserved for PE COFF offset */

real_start:

  /* Load UART Base Address to Register t0 */
  li  t0, 0x10000000
</code></pre></div>
<p>Note that Image Load Offset must be <code>0x20</code> <code>0000</code>!</p>
<div class="example-wrap"><pre class="language-text"><code>  .quad   0x200000             /* Image load offset from start of RAM */
</code></pre></div>
<p>That‚Äôs because our kernel starts at <code>0x4020</code> <code>0000</code></p>
<p>Here‚Äôs the assembled output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>0000000040200000 &lt;__start&gt;:
  li      s4, -0xd             /* Magic Signature &quot;MZ&quot; (2 bytes) */
    40200000:	5a4d                	li	s4,-13
  j       real_start           /* Jump to Kernel Start (2 bytes) */
    40200002:	a83d                	j	40200040 &lt;real_start&gt;
    40200004:	0000                	unimp
    40200006:	0000                	unimp
    40200008:	0000                	unimp
    4020000a:	0020                	addi	s0,sp,8
    4020000c:	0000                	unimp
    4020000e:	0000                	unimp
    40200010:	9e7c                	0x9e7c
    40200012:	0002                	c.slli64	zero
	...
    40200020:	0002                	c.slli64	zero
	...
    4020002e:	0000                	unimp
    40200030:	4952                	lw	s2,20(sp)
    40200032:	00564353          	fadd.s	ft6,fa2,ft5,rmm
    40200036:	0000                	unimp
    40200038:	5352                	lw	t1,52(sp)
    4020003a:	00000543          	fmadd.s	fa0,ft0,ft0,ft0,rne
	...

0000000040200040 &lt;real_start&gt;:
</code></pre></div>
<p>Check that the lengths and offsets match the RISC-V Linux Header Format‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#appendix-decode-the-risc-v-linux-header"><strong>‚ÄúDecode the RISC-V Linux Header‚Äù</strong></a></li>
</ul>
<p>And our RISC-V Boot Code tested OK with QEMU.</p>
<h1 id="set-start-address-of-nuttx-kernel"><a href="#set-start-address-of-nuttx-kernel">8 Set Start Address of NuttX Kernel</a></h1>
<p>TODO</p>
<p>Earlier we saw that Star64‚Äôs U-Boot Bootloader will load Linux Kernels into RAM at Address <code>0x4020</code> <code>0000</code>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64">‚ÄúArmbian Image for Star64‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64">‚ÄúYocto Image for Star64‚Äù</a></p>
</li>
</ul>
<p>To boot NuttX on Star64, let‚Äôs set the Start Address of the NuttX Kernel to <code>0x4020</code> <code>0000</code>.</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L56-L57">nsh64/defconfig</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_SIZE=33554432
CONFIG_RAM_START=0x80000000
</code></pre></div>
<p>We changed the above NuttX Build Config to <code>0x40200000</code></p>
<p>We also updated the Linker Script: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script#L21-L26">ld.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p>Remember to change this if building for NuttX Kernel Mode: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld-kernel64.script#L21-L51">ld-kernel64.script</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>MEMORY
{
    /* Previously 0x80000000 */
    kflash (rx) : ORIGIN = 0x40200000, LENGTH = 2048K   /* w/ cache */
    /* Previously 0x80200000 */
    ksram (rwx) : ORIGIN = 0x40400000, LENGTH = 2048K   /* w/ cache */
    /* Previously 0x80400000 */
    pgram (rwx) : ORIGIN = 0x40600000, LENGTH = 4096K   /* w/ cache */
}
...
SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p>RISC-V Disassembly of NuttX Kernel shows that the Start Address is correct‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>0000000040200000 &lt;__start&gt;:
  li      s4, -0xd             /* Magic Signature &quot;MZ&quot; (2 bytes) */
    40200000:	5a4d                	li	s4,-13
  j       real_start           /* Jump to Kernel Start (2 bytes) */
    40200002:	a83d                	j	40200040 &lt;real_start&gt;
</code></pre></div>
<p>We‚Äôre ready to boot NuttX on Star64!</p>
<h1 id="boot-nuttx-on-star64"><a href="#boot-nuttx-on-star64">9 Boot NuttX on Star64</a></h1>
<p>TODO</p>
<p>Let‚Äôs boot NuttX on Star64! We compile <a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu">NuttX for 64-bit RISC-V QEMU</a> with these tweaks‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#nuttx-prints-to-qemu-console">‚ÄúNuttX prints to QEMU Console‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#uart-base-address-for-star64">‚ÄúUART Base Address for Star64‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#risc-v-linux-kernel-header">‚ÄúRISC-V Linux Kernel Header‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#set-start-address-of-nuttx-kernel">‚ÄúSet Start Address of NuttX Kernel‚Äù</a></p>
</li>
</ul>
<p>For the microSD Image, we pick this <a href="https://www.armbian.com/star64/"><strong>Armbian Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/armbianro/os/releases/download/23.8.0-trunk.56/Armbian_23.8.0-trunk.56_Star64_lunar_edge_5.15.0_minimal.img.xz"><strong>Armbian 23.8 Lunar for Star64 (Minimal)</strong></a></li>
</ul>
<p>Write the Armbian Image to a microSD Card with Balena Etcher.</p>
<p>We fix the <a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64">Missing Device Tree</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sudo chmod go+w /run/media/luppy/armbi_root/boot
sudo chmod go+w /run/media/luppy/armbi_root/boot/dtb/starfive
cp \
  /boot/dtb/starfive/jh7110-visionfive-v2.dtb \
  /boot/dtb/starfive/jh7110-star64-pine64.dtb
</code></pre></div>
<p>Then we delete the sym-link <code>/boot/Image</code> and copy the NuttX Binary Image <code>nuttx.bin</code> to <code>/boot/Image</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Export the NuttX Binary Image to nuttx.bin
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Delete /boot/Image
rm /run/media/luppy/armbi_root/boot/Image

## Copy nuttx.bin to /boot/Image
cp nuttx.bin /run/media/luppy/armbi_root/boot/Image
</code></pre></div>
<p>Insert the microSD Card into Star64 and power up.</p>
<p>NuttX boots with <code>123</code> yay! <a href="https://github.com/lupyuen/nuttx-star64#nuttx-prints-to-qemu-console">(Which is printed by our Boot Code)</a></p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123
Unhandled exception: Illegal instruction
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/star64-nuttx.png" alt="Boot NuttX on Star64" /></p>
<p>Here‚Äôs the complete log‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Retrieving file: /boot/extlinux/extlinux.conf
383 bytes read in 7 ms (52.7 KiB/s)
1:[6CArmbian
Retrieving file: /boot/uInitrd
10911538 bytes read in 466 ms (22.3 MiB/s)
Retrieving file: /boot/Image
163201 bytes read in 14 ms (11.1 MiB/s)
append: root=UUID=99f62df4-be35-475c-99ef-2ba3f74fe6b5 console=ttyS0,115200n8 console=tty0 earlycon=sbi rootflags=data=writeback stmmaceth=chain_mode:1 rw rw no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 splash plymouth.ignore-serial-consoles
Retrieving file: /boot/dtb/starfive/jh7110-star64-pine64.dtb
50235 bytes read in 14 ms (3.4 MiB/s)
## Loading init Ramdisk from Legacy Image at 46100000 ...
   Image Name:   uInitrd
   Image Type:   RISC-V Linux RAMDisk Image (gzip compressed)
   Data Size:    10911474 Bytes = 10.4 MiB
   Load Address: 00000000
   Entry Point:  00000000
   Verifying Checksum ... OK
## Flattened Device Tree blob at 46000000
   Booting using the fdt blob at 0x46000000
   Using Device Tree in place at 0000000046000000, end 000000004600f43a

Starting kernel ...

clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
EPC: ffffffff804ba05c RA: 00000000402011c6 reloc adjusted

SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
A4:  0000000000000000 A5:  0000000040200000 A6:  00000000fffd5708
A7:  0000000000000000 S2:  00000000fff47194 S3:  0000000000000003
S4:  fffffffffffffff3 S5:  00000000fffdbb50 S6:  0000000000000000
S7:  0000000000000000 S8:  00000000fff47194 S9:  0000000000000002
S10: 0000000000000000 S11: 0000000000000000 T3:  0000000000000023
T4:  000000004600b5cc T5:  000000000000ff00 T6:  000000004600b5cc

Code: 0313 0320 8023 0062 0313 0330 8023 0062 (2573 f140)


resetting ...
reset not supported yet
### ERROR ### Please RESET the board ###
</code></pre></div>
<p>Why does NuttX crash at <code>4020005c</code>? See the next section‚Ä¶</p>
<h1 id="nuttx-fails-to-get-hart-id"><a href="#nuttx-fails-to-get-hart-id">10 NuttX Fails To Get Hart ID</a></h1>
<p>TODO</p>
<p>Earlier we saw NuttX crashing when booting on Star64‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123
Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
</code></pre></div>
<p><em>Why did NuttX crash at <code>4020005c</code>?</em></p>
<p>Here‚Äôs our RISC-V Boot Code‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L103">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/qemu_rv_head.S:95
  /* Load mhartid (cpuid) */
  csrr a0, mhartid
    4020005c:	f1402573  csrr a0, mhartid
</code></pre></div>
<p>NuttX tries loads the CPU ID or Hardware Thread ‚ÄúHart‚Äù ID from the RISC-V Control and Status Register (CSR). <a href="https://lupyuen.github.io/articles/riscv#get-cpu-id">(Explained here)</a></p>
<p>But it fails! Because we don‚Äôt have sufficient privilege to access the Hart ID.</p>
<p>RISC-V runs at 3 Privilege Levels‚Ä¶</p>
<ul>
<li>
<p>M: Machine Level (Most powerful)</p>
</li>
<li>
<p>S: Supervisor Level (Less powerful)</p>
</li>
<li>
<p>U: User Level (Least powerful)</p>
</li>
</ul>
<p>NuttX runs at Supervisor Level, which <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html">doesn‚Äôt allow access to Machine-Level CSR Registers</a>.  (Including <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid">Hart ID</a>)</p>
<p>(The <code>m</code> in <code>mhartid</code> signifies that it‚Äôs a Machine-Level Register)</p>
<p><em>What runs at Machine Level?</em></p>
<p><a href="https://www.thegoodpenguin.co.uk/blog/an-overview-of-opensbi/">OpenSBI</a> (Supervisor Binary Interface) is the first thing that boots on Star64. It runs at Machine Level and starts the U-Boot Bootloader.</p>
<p><a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.pdf">(See the RISC-V SBI Spec)</a></p>
<p><em>What about U-Boot Bootloader?</em></p>
<p>U-Boot Bootloader runs at Supervisor Level. And starts NuttX, also at Supervisor Level.</p>
<p>So OpenSBI is the only thing that runs at Machine Level. And can access the Machine-Level Registers.</p>
<p><em>How to get the Hart ID from OpenSBI?</em></p>
<p>Let‚Äôs refer to the Linux Boot Code: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S">linux/arch/riscv/kernel/head.S</a></p>
<p>(Tip: <code>CONFIG_RISCV_M_MODE</code> is False and <code>CONFIG_EFI</code> is True)</p>
<p>From <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L292-L295">linux/blob/master/arch/riscv/kernel/head.S</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>/* Save hart ID and DTB physical address */
mv s0, a0
mv s1, a1
</code></pre></div>
<p>Here we see that U-Boot <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.adoc#function-hart-start-fid-0">(or OpenSBI)</a> will pass 2 arguments when it starts our kernel‚Ä¶</p>
<ul>
<li>
<p>Register A0: Hart ID</p>
</li>
<li>
<p>Register A1: RAM Address of Device Tree</p>
</li>
</ul>
<p>So we‚Äôll simply read the Hart ID from Register A0. (And ignore A1)</p>
<p>TODO: Remove <code>csrr a0, mhartid</code></p>
<p><em>What are the actual values of Registers A0 and A1?</em></p>
<p>Thanks to our <a href="https://github.com/lupyuen/nuttx-star64#boot-nuttx-on-star64">earlier Crash Dump</a>, we know the actual values of A0 and A1!</p>
<div class="example-wrap"><pre class="language-text"><code>SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
</code></pre></div>
<p>This says that‚Ä¶</p>
<ul>
<li>
<p>Hart ID is 1 (Register A0)</p>
</li>
<li>
<p>RAM Address of Device Tree is <code>0x4600</code> <code>0000</code> (Register A1)</p>
</li>
</ul>
<p>Yep looks correct!</p>
<p><em>What about other CSR Instructions in our NuttX Boot Code?</em></p>
<p>We change the Machine-Level <code>m</code> Registers to Supervisor-Level <code>s</code> Registers.</p>
<p>TODO: To Disable Interrupts: Change <code>mie</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><code>sie</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Disable all interrupts (i.e. timer, external) in mie */
csrw  mie, zero
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#disable-interrupts">(Source)</a></p>
<p>TODO: To Load Interrupt Vector Table: Change <code>mtvec</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><code>stvec</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Load address of Interrupt Vector Table */
csrw  mtvec, t0
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#load-interrupt-vector">(Source)</a></p>
<p><em>The Linux Boot Code looks confusing. What are CSR_IE and CSR_IP?</em></p>
<div class="example-wrap"><pre class="language-text"><code>/* Mask all interrupts */
csrw CSR_IE, zero
csrw CSR_IP, zero
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L195-L200">(Source)</a></p>
<p>That‚Äôs because the Linux Boot Code will work for Machine Level AND Supervisor Level! Here‚Äôs how <code>CSR_IE</code> and <code>CSR_IP</code> are mapped to the <code>m</code> and <code>s</code> CSR Registers‚Ä¶</p>
<p>(Remember: <code>CONFIG_RISCV_M_MODE</code> is false for NuttX)</p>
<div class="example-wrap"><pre class="language-text"><code>#ifdef CONFIG_RISCV_M_MODE
  /* Use Machine-Level CSR Registers */
  # define CSR_IE		CSR_MIE
  # define CSR_IP		CSR_MIP
  ...
#else
  /* Use Supervisor-Level CSR Registers */
  # define CSR_IE		CSR_SIE
  # define CSR_IP		CSR_SIP
  ...
#endif /* !CONFIG_RISCV_M_MODE */
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/csr.h#L391-L444">(Source)</a></p>
<p>TODO: See <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/mpfs/mpfs_opensbi_utils.S#L62-L107">mpfs_opensbi_prepare_hart</a></p>
<p>TODO: Set CLINT and PLIC Addresses</p>
<p>From <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/u74_memory_map.html">U74 Memory Map</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>0x00_0200_0000	0x00_0200_FFFF		RW A	CLINT
0x00_0C00_0000	0x00_0FFF_FFFF		RW A	PLIC
</code></pre></div>
<p>TODO: We update <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/hardware/qemu_rv_memorymap.h#L27-L33">qemu_rv_memorymap.h</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>#define QEMU_RV_CLINT_BASE   0x02000000
#define QEMU_RV_ACLINT_BASE  0x02f00000
#define QEMU_RV_PLIC_BASE    0x0c000000
</code></pre></div><h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/linux.md"><strong>lupyuen.github.io/src/linux.md</strong></a></p>
<h1 id="appendix-star64-u-boot-bootloader-log"><a href="#appendix-star64-u-boot-bootloader-log">12 Appendix: Star64 U-Boot Bootloader Log</a></h1>
<p>TODO</p>
<p>Here‚Äôs the log for U-Boot Bootloader on Star64 (without microSD Card)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-opensbi.jpg" alt="U-Boot Bootloader Log" /></p>
<div class="example-wrap"><pre class="language-text"><code>U-Boot SPL 2021.10 (Jan 19 2023 - 04:09:41 +0800)
DDR version: dc2e84f0.
Trying to boot from SPI

OpenSBI v1.2
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name             : StarFive VisionFive V2
Platform Features         : medeleg
Platform HART Count       : 5
Platform IPI Device       : aclint-mswi
Platform Timer Device     : aclint-mtimer @ 4000000Hz
Platform Console Device   : uart8250
Platform HSM Device       : jh7110-hsm
Platform PMU Device       : ---
Platform Reboot Device    : pm-reset
Platform Shutdown Device  : pm-reset
Firmware Base             : 0x40000000
Firmware Size             : 288 KB
Runtime SBI Version       : 1.0

Domain0 Name              : root
Domain0 Boot HART         : 1
Domain0 HARTs             : 0*,1*,2*,3*,4*
Domain0 Region00          : 0x0000000002000000-0x000000000200ffff (I)
Domain0 Region01          : 0x0000000040000000-0x000000004007ffff ()
Domain0 Region02          : 0x0000000000000000-0xffffffffffffffff (R,W,X)
Domain0 Next Address      : 0x0000000040200000
Domain0 Next Arg1         : 0x0000000042200000
Domain0 Next Mode         : S-mode
Domain0 SysReset          : yes

Boot HART ID              : 1
Boot HART Domain          : root
Boot HART Priv Version    : v1.11
Boot HART Base ISA        : rv64imafdcbx
Boot HART ISA Extensions  : none
Boot HART PMP Count       : 8
Boot HART PMP Granularity : 4096
Boot HART PMP Address Bits: 34
Boot HART MHPM Count      : 2
Boot HART MIDELEG         : 0x0000000000000222
Boot HART MEDELEG         : 0x000000000000b109


U-Boot 2021.10 (Jan 19 2023 - 04:09:41 +0800), Build: jenkins-github_visionfive2-6

CPU:   rv64imacu
Model: StarFive VisionFive V2
DRAM:  8 GiB
MMC:   sdio0@16010000: 0, sdio1@16020000: 1
Loading Environment from SPIFlash... SF: Detected gd25lq128 with page size 256 Bytes, erase size 4 KiB, total 16 MiB
*** Warning - bad CRC, using default environment

StarFive EEPROM format v2

--------EEPROM INFO--------
Vendor : PINE64
Product full SN: STAR64V1-2310-D008E000-00000003
data version: 0x2
PCB revision: 0xc1
BOM revision: A
Ethernet MAC0 address: 6c:cf:39:00:75:5d
Ethernet MAC1 address: 6c:cf:39:00:75:5e
--------EEPROM INFO--------

In:    serial@10000000
Out:   serial@10000000
Err:   serial@10000000
Model: StarFive VisionFive V2
Net:   eth0: ethernet@16030000, eth1: ethernet@16040000
Card did not respond to voltage select! : -110
Card did not respond to voltage select! : -110
bootmode flash device 0
Card did not respond to voltage select! : -110
Hit any key to stop autoboot:  2  1  0 
Card did not respond to voltage select! : -110
Couldn&#39;t find partition mmc 0:3
Can&#39;t set block device
Importing environment from mmc0 ...
## Warning: Input data exceeds 1048576 bytes - truncated
## Info: input data size = 1048578 = 0x100002
Card did not respond to voltage select! : -110
Couldn&#39;t find partition mmc 1:2
Can&#39;t set block device
## Warning: defaulting to text format
## Error: &quot;boot2&quot; not defined
Card did not respond to voltage select! : -110
ethernet@16030000 Waiting for PHY auto negotiation to complete......... TIMEOUT !
phy_startup() failed: -110FAILED: -110ethernet@16040000 Waiting for PHY auto negotiation to complete......... TIMEOUT !
phy_startup() failed: -110FAILED: -110ethernet@16030000 Waiting for PHY auto negotiation to complete......... TIMEOUT !
phy_startup() failed: -110FAILED: -110ethernet@16040000 Waiting for PHY auto negotiation to complete......... TIMEOUT !
phy_startup() failed: -110FAILED: -110StarFive # 
StarFive # 
</code></pre></div>
<p>Which is OK because we haven‚Äôt inserted a microSD Card.</p>
<h2 id="u-boot-commands-for-star64"><a href="#u-boot-commands-for-star64">12.1 U-Boot Commands for Star64</a></h2>
<p>TODO</p>
<p>Here are the U-Boot Commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>StarFive # help
?         - alias for &#39;help&#39;
base      - print or set address offset
bdinfo    - print Board Info structure
blkcache  - block cache diagnostics and control
boot      - boot default, i.e., run &#39;bootcmd&#39;
bootd     - boot default, i.e., run &#39;bootcmd&#39;
bootefi   - Boots an EFI payload from memory
bootelf   - Boot from an ELF image in memory
booti     - boot Linux kernel &#39;Image&#39; format from memory
bootm     - boot application image from memory
bootp     - boot image via network using BOOTP/TFTP protocol
bootvx    - Boot vxWorks from an ELF image
cmp       - memory compare
config    - print .config
coninfo   - print console devices and information
cp        - memory copy
cpu       - display information about CPUs
crc32     - checksum calculation
dhcp      - boot image via network using DHCP/TFTP protocol
dm        - Driver model low level access
echo      - echo args to console
editenv   - edit environment variable
eeprom    - EEPROM sub-system
efidebug  - Configure UEFI environment
env       - environment handling commands
erase     - erase FLASH memory
eraseenv  - erase environment variables from persistent storage
exit      - exit script
ext2load  - load binary file from a Ext2 filesystem
ext2ls    - list files in a directory (default /)
ext4load  - load binary file from a Ext4 filesystem
ext4ls    - list files in a directory (default /)
ext4size  - determine a file&#39;s size
ext4write - create a file in the root directory
false     - do nothing, unsuccessfully
fatinfo   - print information about filesystem
fatload   - load binary file from a dos filesystem
fatls     - list files in a directory (default /)
fatmkdir  - create a directory
fatrm     - delete a file
fatsize   - determine a file&#39;s size
fatwrite  - write file into a dos filesystem
fdt       - flattened device tree utility commands
flinfo    - print FLASH memory information
fstype    - Look up a filesystem type
fstypes   - List supported filesystem types
fsuuid    - Look up a filesystem UUID
go        - start application at address &#39;addr&#39;
gpio      - query and control gpio pins
gpt       - GUID Partition Table
gzwrite   - unzip and write memory to block device
help      - print command description/usage
i2c       - I2C sub-system
iminfo    - print header information for application image
imxtract  - extract a part of a multi-image
itest     - return true/false on integer compare
ln        - Create a symbolic link
load      - load binary file from a filesystem
loadb     - load binary file over serial line (kermit mode)
loads     - load S-Record file over serial line
loadx     - load binary file over serial line (xmodem mode)
loady     - load binary file over serial line (ymodem mode)
log       - log system
loop      - infinite loop on address range
ls        - list files in a directory (default /)
lzmadec   - lzma uncompress a memory region
mac       - display and program the system ID and MAC addresses in EEPROM
md        - memory display
misc      - Access miscellaneous devices with MISC uclass driver APIs
mm        - memory modify (auto-incrementing address)
mmc       - MMC sub system
mmcinfo   - display MMC info
mw        - memory write (fill)
net       - NET sub-system
nfs       - boot image via network using NFS protocol
nm        - memory modify (constant address)
panic     - Panic with optional message
part      - disk partition related commands
ping      - send ICMP ECHO_REQUEST to network host
pinmux    - show pin-controller muxing
printenv  - print environment variables
protect   - enable or disable FLASH write protection
random    - fill memory with random pattern
reset     - Perform RESET of the CPU
run       - run commands in an environment variable
save      - save file to a filesystem
saveenv   - save environment variables to persistent storage
setenv    - set environment variables
setexpr   - set environment variable as the result of eval expression
sf        - SPI flash sub-system
showvar   - print local hushshell variables
size      - determine a file&#39;s size
sleep     - delay execution for some time
source    - run script from memory
sysboot   - command to get and boot from syslinux files
test      - minimal test like /bin/sh
tftpboot  - boot image via network using TFTP protocol
tftpput   - TFTP put command, for uploading files to a server
true      - do nothing, successfully
unlz4     - lz4 uncompress a memory region
unzip     - unzip a memory region
version   - print monitor, compiler and linker version
</code></pre></div><h2 id="u-boot-settings-for-star64"><a href="#u-boot-settings-for-star64">12.2 U-Boot Settings for Star64</a></h2>
<p>TODO</p>
<p>Here are the U-Boot Settings‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>StarFive # printenv
baudrate=115200
boot_a_script=load ${devtype} ${devnum}:${distro_bootpart} ${scriptaddr} ${prefix}${script}; source ${scriptaddr}
boot_efi_binary=load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_r} efi/boot/bootriscv64.efi; if fdt addr ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r};else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi
boot_efi_bootmgr=if fdt addr ${fdt_addr_r}; then bootefi bootmgr ${fdt_addr_r};else bootefi bootmgr;fi
boot_extlinux=sysboot ${devtype} ${devnum}:${distro_bootpart} any ${scriptaddr} ${prefix}${boot_syslinux_conf}
boot_prefixes=/ /boot/
boot_script_dhcp=boot.scr.uimg
boot_scripts=boot.scr.uimg boot.scr
boot_syslinux_conf=extlinux/extlinux.conf
boot_targets=mmc0 dhcp 
bootargs=console=ttyS0,115200  debug rootwait  earlycon=sbi
bootcmd=run load_vf2_env;run importbootenv;run load_distro_uenv;run boot2;run distro_bootcmd
bootcmd_dhcp=devtype=dhcp; if dhcp ${scriptaddr} ${boot_script_dhcp}; then source ${scriptaddr}; fi;setenv efi_fdtfile ${fdtfile}; setenv efi_old_vci ${bootp_vci};setenv efi_old_arch ${bootp_arch};setenv bootp_vci PXEClient:Arch:00027:UNDI:003000;setenv bootp_arch 0x1b;if dhcp ${kernel_addr_r}; then tftpboot ${fdt_addr_r} dtb/${efi_fdtfile};if fdt addr ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r}; else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi;fi;setenv bootp_vci ${efi_old_vci};setenv bootp_arch ${efi_old_arch};setenv efi_fdtfile;setenv efi_old_arch;setenv efi_old_vci;
bootcmd_distro=run fdt_loaddtb; run fdt_sizecheck; run set_fdt_distro; sysboot mmc ${fatbootpart} fat c0000000 ${bootdir}/${boot_syslinux_conf}; 
bootcmd_mmc0=devnum=0; run mmc_boot
bootdelay=2
bootdir=/boot
bootenv=uEnv.txt
bootmode=flash
bootpart=0:3
chip_vision=UNKOWN
chipa_gmac_set=fdt set /soc/ethernet@16030000/ethernet-phy@0 tx_inverted_10 &lt;0x0&gt;;fdt set /soc/ethernet@16030000/ethernet-phy@0 tx_inverted_100 &lt;0x0&gt;;fdt set /soc/ethernet@16030000/ethernet-phy@0 tx_inverted_1000 &lt;0x0&gt;;fdt set /soc/ethernet@16030000/ethernet-phy@0 tx_delay_sel &lt;0x9&gt;;fdt set /soc/ethernet@16040000/ethernet-phy@1 tx_inverted_10 &lt;0x0&gt;;fdt set /soc/ethernet@16040000/ethernet-phy@1 tx_inverted_100 &lt;0x0&gt;;fdt set /soc/ethernet@16040000/ethernet-phy@1 tx_inverted_1000 &lt;0x0&gt;;fdt set /soc/ethernet@16040000/ethernet-phy@1 tx_delay_sel &lt;0x9&gt; 
chipa_set=if test ${chip_vision} = A; then run chipa_gmac_set;fi; 
chipa_set_linux=fdt addr ${fdt_addr_r};run visionfive2_mem_set;run chipa_set;
chipa_set_linux_force=fdt addr ${fdt_addr_r};run visionfive2_mem_set;run chipa_gmac_set; 
chipa_set_uboot=fdt addr ${uboot_fdt_addr};run chipa_set;
chipa_set_uboot_force=fdt addr ${uboot_fdt_addr};run chipa_gmac_set; 
devnum=0
distro_bootcmd=for target in ${boot_targets}; do run bootcmd_${target}; done
distroloadaddr=0xb0000000
efi_dtb_prefixes=/ /dtb/ /dtb/current/
eth0addr=6c:cf:39:00:75:5d
eth1addr=6c:cf:39:00:75:5e
ethact=ethernet@16030000
ethaddr=6c:cf:39:00:75:5d
ext4bootenv=ext4load mmc ${bootpart} ${loadaddr} ${bootdir}/${bootenv}
fatbootpart=1:2
fdt_addr_r=0x46000000
fdt_high=0xffffffffffffffff
fdt_loaddtb=fatload mmc ${fatbootpart} ${fdt_addr_r} ${bootdir}/dtbs/${fdtfile}; fdt addr ${fdt_addr_r}; 
fdt_sizecheck=fatsize mmc ${fatbootpart} ${bootdir}/dtbs/${fdtfile}; 
fdtaddr=fffc6aa0
fdtcontroladdr=fffc6aa0
fdtfile=starfive/starfive_visionfive2.dtb
importbootenv=echo Importing environment from mmc${devnum} ...; env import -t ${loadaddr} ${filesize}
initrd_high=0xffffffffffffffff
ipaddr=192.168.120.230
kernel_addr_r=0x40200000
load_distro_uenv=fatload mmc ${fatbootpart} ${distroloadaddr} ${bootdir}/${bootenv}; env import ${distroloadaddr} 17c; 
load_efi_dtb=load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} ${prefix}${efi_fdtfile}
load_vf2_env=fatload mmc ${bootpart} ${loadaddr} ${testenv}
loadaddr=0xa0000000
loadbootenv=fatload mmc ${bootpart} ${loadaddr} ${bootenv}
memory_addr=40000000
memory_size=200000000
mmc_boot=if mmc dev ${devnum}; then devtype=mmc; run scan_dev_for_boot_part; fi
mmcbootenv=run scan_mmc_dev; setenv bootpart ${devnum}:${mmcpart}; if mmc rescan; then run loadbootenv &amp;&amp; run importbootenv; run ext4bootenv &amp;&amp; run importbootenv; if test -n $uenvcmd; then echo Running uenvcmd ...; run uenvcmd; fi; fi
mmcpart=3
netmask=255.255.255.0
partitions=name=loader1,start=17K,size=1M,type=${type_guid_gpt_loader1};name=loader2,size=4MB,type=${type_guid_gpt_loader2};name=system,size=-,bootable,type=${type_guid_gpt_system};
preboot=run chipa_set_uboot;run mmcbootenv
pxefile_addr_r=0x45900000
ramdisk_addr_r=0x46100000
scan_dev_for_boot=echo Scanning ${devtype} ${devnum}:${distro_bootpart}...; for prefix in ${boot_prefixes}; do run scan_dev_for_extlinux; run scan_dev_for_scripts; done;run scan_dev_for_efi;
scan_dev_for_boot_part=part list ${devtype} ${devnum} -bootable devplist; env exists devplist || setenv devplist 1; for distro_bootpart in ${devplist}; do if fstype ${devtype} ${devnum}:${distro_bootpart} bootfstype; then run scan_dev_for_boot; fi; done; setenv devplist
scan_dev_for_efi=setenv efi_fdtfile ${fdtfile}; for prefix in ${efi_dtb_prefixes}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${efi_fdtfile}; then run load_efi_dtb; fi;done;run boot_efi_bootmgr;if test -e ${devtype} ${devnum}:${distro_bootpart} efi/boot/bootriscv64.efi; then echo Found EFI removable media binary efi/boot/bootriscv64.efi; run boot_efi_binary; echo EFI LOAD FAILED: continuing...; fi; setenv efi_fdtfile
scan_dev_for_extlinux=if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${boot_syslinux_conf}; then echo Found ${prefix}${boot_syslinux_conf}; run boot_extlinux; echo SCRIPT FAILED: continuing...; fi
scan_dev_for_scripts=for script in ${boot_scripts}; do if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${script}; then echo Found U-Boot script ${prefix}${script}; run boot_a_script; echo SCRIPT FAILED: continuing...; fi; done
scan_mmc_dev=if test ${bootmode} = flash; then if mmc dev ${devnum}; then echo found device ${devnum};else setenv devnum 0;mmc dev 0;fi; fi; echo bootmode ${bootmode} device ${devnum};
scan_sf_for_scripts=${devtype} read ${scriptaddr} ${script_offset_f} ${script_size_f}; source ${scriptaddr}; echo SCRIPT FAILED: continuing...
script_offset_f=0x1fff000
script_size_f=0x1000
scriptaddr=0x43900000
serial#=STAR64V1-2310-D008E000-00000003
set_fdt_distro=if test ${chip_vision} = A; then if test ${memory_size} = 200000000; then run chipa_gmac_set;run visionfive2_mem_set;fatwrite mmc ${fatbootpart} ${fdt_addr_r} ${bootdir}/dtbs/${fdtfile} ${filesize};else run chipa_gmac_set;run visionfive2_mem_set;fatwrite mmc ${fatbootpart} ${fdt_addr_r} ${bootdir}/dtbs/${fdtfile} ${filesize};fi;else run visionfive2_mem_set;fatwrite mmc ${fatbootpart} ${fdt_addr_r} ${bootdir}/dtbs/${fdtfile} ${filesize};fi; 
sf_boot=if sf probe ${busnum}; then devtype=sf; run scan_sf_for_scripts; fi
stderr=serial@10000000
stdin=serial@10000000
stdout=serial@10000000
testenv=vf2_uEnv.txt
type_guid_gpt_loader1=5B193300-FC78-40CD-8002-E86C45580B47
type_guid_gpt_loader2=2E54B353-1271-4842-806F-E436D6AF6985
type_guid_gpt_system=0FC63DAF-8483-4772-8E79-3D69D8477DE4
uboot_fdt_addr=0xfffc6aa0
ver=U-Boot 2021.10 (Jan 19 2023 - 04:09:41 +0800)
visionfive2_mem_set=fdt memory ${memory_addr} ${memory_size};

Environment size: 7246/65532 bytes
StarFive # 
</code></pre></div>
    
</body>
</html>