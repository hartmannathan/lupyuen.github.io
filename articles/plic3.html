<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Fixed the UART Interrupt and Platform-Level Interrupt Controller (Ox64 BL808)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Fixed the UART Interrupt and Platform-Level Interrupt Controller (Ox64 BL808)" 
    data-rh="true">
<meta property="og:description" 
    content="Weak Ordering in the Ox64 BL808 Memory Management Unit (T-Head C906)... Causes problems with UART Interrupts and the Platform-Level Interrupt Controller"
    data-rh="true">
<meta name="description" 
    content="Weak Ordering in the Ox64 BL808 Memory Management Unit (T-Head C906)... Causes problems with UART Interrupts and the Platform-Level Interrupt Controller">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/plic3-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/plic3.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Fixed the UART Interrupt and Platform-Level Interrupt Controller (Ox64 BL808)</h1>
    <nav id="TOC"><ul>
<li><a href="#uart-interrupt">1 UART Interrupt</a><ul></ul></li>
<li><a href="#uart-and-plic-troubles">2 UART and PLIC Troubles</a><ul></ul></li>
<li><a href="#leaky-reads-in-uart">3 Leaky Reads in UART</a><ul></ul></li>
<li><a href="#t-head-errata">4 T-Head Errata</a><ul></ul></li>
<li><a href="#memory-management-unit">5 Memory Management Unit</a><ul></ul></li>
<li><a href="#enable-strong-order">6 Enable Strong Order</a><ul></ul></li>
<li><a href="#it-works">7 It Works!</a><ul></ul></li>
<li><a href="#lessons-learnt">8 Lessons Learnt</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-and-run-nuttx">10 Appendix: Build and Run NuttX</a><ul></ul></li></ul></nav><p>üìù <em>10 Dec 2023</em></p>
<p><img src="https://lupyuen.github.io/images/plic3-title.png" alt="UART Input and Platform-Level Interrupt Controller are finally OK on Apache NuttX RTOS and Ox64 BL808 RISC-V SBC!" /></p>
<p>Last week we walked through the <strong>Serial Console</strong> for <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> 64-bit RISC-V Single-Board Computer (pic below)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/plic2"><strong>‚ÄúUART Interrupt and Platform-Level Interrupt Controller‚Äù</strong></a></li>
</ul>
<p>And we hit some illogical impossible problems on <a href="https://lupyuen.github.io/articles/ox2"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#backup-plan"><strong>Console Input</strong></a> is always empty</p>
<p>(Can‚Äôt enter any Console Commands)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#more-trouble-with-interrupt-claim"><strong>Interrupt Claim</strong></a> is forever 0</p>
<p>(Ox64 won‚Äôt tell us which Interrupt was fired!)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#trouble-with-interrupt-priority"><strong>Leaky Writes</strong></a> are mushing up adjacent Interrupt Registers</p>
<p>(Or maybe Leaky Reads?)</p>
</li>
</ul>
<p>Today we discover the <strong>One Single Culprit</strong> behind all this rowdy mischief‚Ä¶</p>
<p><strong>Weak Ordering in the MMU</strong>! (Memory Management Unit)</p>
<p>Here‚Äôs how we solved the baffling mystery‚Ä¶</p>
<p><a href="https://youtu.be/l7Y36nTkr8c">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)" /></p>
<h1 id="uart-interrupt"><a class="doc-anchor" href="#uart-interrupt">¬ß</a>1 UART Interrupt</h1>
<p><em>Sorry TLDR: What‚Äôs this PLIC? What‚Äôs Serial Console gotta do with it?</em></p>
<p><a href="https://lupyuen.github.io/articles/plic2#platform-level-interrupt-controller"><strong>Platform-Level Interrupt Controller</strong></a> (PLIC) is the hardware inside our SBC that controls the forwarding of <strong>Peripheral Interrupts</strong> to our 64-bit RISC-V CPU.</p>
<p>(Like Interrupts for <strong>UART</strong>, <strong>I2C</strong>, <strong>SPI</strong>, ‚Ä¶)</p>
<p><img src="https://lupyuen.github.io/images/plic2-bl808a.jpg" alt="BL808 Platform-Level Interrupt Controller" /></p>
<p><em>Why should we bother with PLIC?</em></p>
<p>Suppose we‚Äôre typing something in the <strong>Serial Console</strong> on Ox64 SBC‚Ä¶</p>
<ul>
<li>
<p>Every single <strong>key that we press</strong>‚Ä¶</p>
<p>(Pic above)</p>
</li>
<li>
<p>Is received by the <strong>UART Controller</strong> in our RISC-V SoC‚Ä¶</p>
<p>(Bouffalo Lab BL808 SoC)</p>
</li>
<li>
<p>Which fires an <strong>Interrupt through the PLIC</strong> to our RISC-V CPU </p>
<p>(T-Head C906 RISC-V Core)</p>
</li>
</ul>
<p>Without the PLIC, it‚Äôs <strong>impossible to enter commands</strong> in the Serial Console!</p>
<p><em>Tell me more‚Ä¶</em></p>
<p>Let‚Äôs run through the steps to <strong>handle a UART Interrupt</strong> on a RISC-V SBC‚Ä¶ </p>
<p><img src="https://lupyuen.github.io/images/plic2-registers.jpg" alt="Platform-Level Interrupt Controller for Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<ol>
<li>
<p>At Startup: We set <a href="https://lupyuen.github.io/articles/plic2#set-the-interrupt-priority"><strong>Interrupt Priority</strong></a> to 1.</p>
<p>(Lowest Priority)</p>
</li>
<li>
<p>And <a href="https://lupyuen.github.io/articles/plic2#set-the-interrupt-threshold"><strong>Interrupt Threshold</strong></a> to 0.</p>
<p>(Allow all Interrupts to fire later)</p>
</li>
<li>
<p>We flip Bit 20 of <a href="https://lupyuen.github.io/articles/plic2#enable-the-interrupt"><strong>Interrupt Enable</strong></a> Register to 1.</p>
<p>(To enable <strong>RISC-V IRQ 20</strong> for UART3)</p>
</li>
<li>
<p>Suppose we <strong>press a key</strong> on the Serial Console‚Ä¶</p>
<p>Our UART Controller will <strong>fire an Interrupt</strong> for IRQ 20.</p>
<p>(IRQ means <strong>Interrupt Request Number</strong>)</p>
</li>
<li>
<p>Our Interrupt Handler will read the Interrupt Number (20) from the <a href="https://lupyuen.github.io/articles/plic2#claim-the-interrupt"><strong>Interrupt Claim</strong></a> Register‚Ä¶</p>
<p>Call the <a href="https://lupyuen.github.io/articles/plic2#dispatch-the-interrupt"><strong>UART Driver</strong></a> to read the keypress‚Ä¶</p>
<p>Then write the Interrupt Number (20) back into the same old <a href="https://lupyuen.github.io/articles/plic2#complete-the-interrupt"><strong>Interrupt Claim</strong></a> Register‚Ä¶</p>
<p>Which will <a href="https://lupyuen.github.io/articles/plic2#complete-the-interrupt"><strong>Complete the Interrupt</strong></a>.</p>
</li>
<li>
<p>Non-Essential But Useful: <a href="https://lupyuen.github.io/articles/plic2#pending-interrupts"><strong>Interrupt Pending</strong></a> Register says which Interrupts are awaiting Claiming and Completion.</p>
<p>(We‚Äôll use it for troubleshooting)</p>
</li>
</ol>
<p>That‚Äôs the Textbook Recipe for PLIC, according to the <a href="https://five-embeddev.com/riscv-isa-manual/latest/plic.html#plic"><strong>Official RISC-V PLIC Spec</strong></a>. (If Julia Child wrote a PLIC Textbook)</p>
<p>But it doesn‚Äôt work on Ox64 BL808 SBC and T-Head C906 Core‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic3-trouble.jpg" alt="UART and PLIC Troubles on Ox64" /></p>
<h1 id="uart-and-plic-troubles"><a class="doc-anchor" href="#uart-and-plic-troubles">¬ß</a>2 UART and PLIC Troubles</h1>
<p><em>What happens when we run the PLIC Recipe on Ox64?</em></p>
<p>Absolute Disaster! (Pic above)</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#trouble-with-interrupt-priority"><strong>Interrupt Priorities</strong></a> get mushed into 0</p>
<p>(Instead of 1)</p>
</li>
<li>
<p>When we set the <a href="https://lupyuen.github.io/articles/plic2#trouble-with-interrupt-priority"><strong>Interrupt Enable</strong></a> Register‚Ä¶</p>
<p>The value <strong>leaks over</strong> into the next 32-bit word</p>
<p>(Hence the <strong>‚ÄúLeaky Write‚Äù</strong>)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2#more-trouble-with-interrupt-claim"><strong>Interrupt Claim</strong></a> Register is always 0</p>
<p>(Can‚Äôt read the <strong>Actual Interrupt Number</strong>!)</p>
</li>
<li>
<p>Our <a href="https://lupyuen.github.io/articles/plic2#backup-plan"><strong>UART Driver</strong></a> says that the UART Input is Empty</p>
<p>(We verified the <a href="https://github.com/lupyuen/nuttx-ox64#compare-ox64-bl808-uart-registers"><strong>UART Registers</strong></a>)</p>
</li>
</ul>
<p>Our troubles are all Seemingly Unrelated. However there‚Äôs actually only One Sinister Culprit causing all these headaches‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic3-rx.png" alt="BL808 UART Receive Status (Page 405)" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><em>BL808 UART Receive Status (Page 405)</em></a></p>
<h1 id="leaky-reads-in-uart"><a class="doc-anchor" href="#leaky-reads-in-uart">¬ß</a>3 Leaky Reads in UART</h1>
<p><em>How to track down the culprit?</em></p>
<p>We begin with the simplest bug: <a href="https://lupyuen.github.io/articles/plic2#backup-plan"><strong>UART Input</strong></a> is always Empty.</p>
<p>In our <a href="https://lupyuen.github.io/articles/plic2#appendix-uart-driver-for-ox64"><strong>UART Driver</strong></a>, this is how we read the <strong>UART Input</strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_serial.c#L502-L540">bl808_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Receive one character from the UART Port.
// Called (indirectly) by the UART Interrupt Handler: __uart_interrupt
int bl808_receive(...) {
  ...
  // If there&#39;s Pending UART Input...
  // (FIFO_CONFIG_1 is 0x30002084)
  if (getreg32(BL808_UART_FIFO_CONFIG_1(uart_idx)) &amp; UART_FIFO_CONFIG_1_RX_CNT_MASK) {

    // Then read the Actual UART Input
    // (FIFO_RDATA is 0x3000208c)
    rxdata = getreg32(BL808_UART_FIFO_RDATA(uart_idx)) &amp; UART_FIFO_RDATA_MASK;
</code></pre></div>
<p>Which says that we‚Ä¶</p>
<ul>
<li>
<p>Check if there‚Äôs any <strong>Pending UART Input</strong>‚Ä¶</p>
<p>(At address <code>0x3000_2084</code>)</p>
</li>
<li>
<p>Before reading the <strong>Actual UART Input</strong></p>
<p>(At address <code>0x3000_208C</code>)</p>
</li>
</ul>
<p>Or simply‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Check for Pending UART Input
uintptr_t pending = getreg32(0x30002084);

// Read the Actual UART Input
uintptr_t rx = getreg32(0x3000208c);

// Dump the values
_info(&quot;pending=%p, rx=%p\n&quot;, pending, rx);
</code></pre></div>
<p><em>What happens when we run this?</em></p>
<p>Something strange happens‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// Yep there&#39;s Pending UART Input...
pending=0x7070120

// But Actual UART Input is empty!
rx=0
</code></pre></div>
<p>UART Controller says there‚Äôs <strong>UART Input to be read</strong>‚Ä¶ And it‚Äôs <strong>totally empty</strong>!</p>
<p><em>How is that possible?</em></p>
<p>The only logical explanation: Someone has <strong>already read</strong> the UART Input!</p>
<p>UART Input gets <strong>Auto-Reset to 0</strong>, right after it‚Äôs read. Someone must have read it, unintentionally.</p>
<p><em>Hmmm this sounds like a Leaky Read‚Ä¶</em></p>
<p>Exactly! (Pic below)</p>
<ul>
<li>
<p>When we check if there‚Äôs any <strong>Pending UART Input</strong>‚Ä¶</p>
<p>(At address <code>0x3000_2084</code>)</p>
</li>
<li>
<p>It causes the neighbouring <strong>Actual UART Input</strong> to be read unintentionally‚Ä¶</p>
<p>(At address <code>0x3000_208C</code>)</p>
</li>
<li>
<p>Which auto-erases the <strong>Actual UART Input</strong>‚Ä¶</p>
<p>Before we actually read it!</p>
</li>
</ul>
<p>Yep indeed we have Leaky Read + Leaky Write that are causing all our UART + PLIC woes.</p>
<p>Things are looking mighty illogical and <em>incoherent</em>. Why oh why?</p>
<p><img src="https://lupyuen.github.io/images/plic3-uart.jpg" alt="Leaky Reads in UART" /></p>
<h1 id="t-head-errata"><a class="doc-anchor" href="#t-head-errata">¬ß</a>4 T-Head Errata</h1>
<p><em>But Linux runs OK on Ox64 BL808‚Ä¶</em></p>
<p><em>Something special about Linux on T-Head C906?</em></p>
<p>We search for <strong>‚ÄúT-Head‚Äù</strong> in the <a href="https://github.com/torvalds/linux"><strong>Linux Kernel Repo</strong></a>. And we see this vital clue: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/errata_list.h#L69-L164">errata_list.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// T-Head Errata for Linux
#ifdef CONFIG_ERRATA_THEAD_PBMT
  // IO/NOCACHE memory types are handled together with svpbmt,
  // so on T-Head chips, check if no other memory type is set,
  // and set the non-0 PMA type if applicable.
  ...
  asm volatile(... _PAGE_MTMASK_THEAD ...)
</code></pre></div>
<p><a href="https://github.com/riscv/riscv-isa-manual/blob/main/src/supervisor.adoc#svpbmt">(<strong>Svpbmt Extension</strong> defines <strong>Page-Based Memory Types</strong>)</a></p>
<p><em>Aha! A Linux Errata for T-Head CPU!</em></p>
<p>We track down <strong>PAGE_MTMASK_THEAD</strong>: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/pgtable-64.h#L126-L142">pgtable-64.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// T-Head Memory Type Definitions in Linux
#define _PAGE_PMA_THEAD     ((1UL &lt;&lt; 62) | (1UL &lt;&lt; 61) | (1UL &lt;&lt; 60))
#define _PAGE_NOCACHE_THEAD ((1UL &lt; 61) | (1UL &lt;&lt; 60))
#define _PAGE_IO_THEAD      ((1UL &lt;&lt; 63) | (1UL &lt;&lt; 60))
#define _PAGE_MTMASK_THEAD  (_PAGE_PMA_THEAD | _PAGE_IO_THEAD | (1UL &lt;&lt; 59))
</code></pre></div>
<p><a href="https://qoto.org/@lupyuen/111544462454486393">(Spot the Typo!)</a></p>
<p>Which is annotated with‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>[63:59] T-Head Memory Type definitions:
Bit[63] SO  - Strong Order
Bit[62] C   - Cacheable
Bit[61] B   - Bufferable
Bit[60] SH  - Shareable
Bit[59] Sec - Trustable

00110 - NC:  Weakly-Ordered, Non-Cacheable, Bufferable, Shareable, Non-Trustable
01110 - PMA: Weakly-Ordered, Cacheable, Bufferable, Shareable, Non-Trustable
10010 - IO:  Strongly-Ordered, Non-Cacheable, Non-Bufferable, Shareable, Non-Trustable
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/pgtable-64.h#L126-L142">(Source)</a></p>
<p><em>Something sus about I/O Memory?</em></p>
<p>The last line suggests we should configure the <strong>T-Head Memory Type</strong> specifically to support <strong>I/O Memory</strong>: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/pgtable-64.h#L126-L142"><strong>PAGE_IO_THEAD</strong></a></p>
<div><table><thead><tr><th style="text-align: left">Memory Attribute</th><th style="text-align: left">Page Table Entry</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Strongly-Ordered</strong></td><td style="text-align: left">Bit 63 is 1</td></tr>
<tr><td style="text-align: left"><strong>Non-Cacheable</strong></td><td style="text-align: left">Bit 62 is 0 <em>(Default)</em></td></tr>
<tr><td style="text-align: left"><strong>Non-Bufferable</strong></td><td style="text-align: left">Bit 61 is 0 <em>(Default)</em></td></tr>
<tr><td style="text-align: left"><strong>Shareable</strong></td><td style="text-align: left">Bit 60 is 1</td></tr>
<tr><td style="text-align: left"><strong>Non-Trustable</strong></td><td style="text-align: left">Bit 59 is 0 <em>(Default)</em></td></tr>
</tbody></table>
</div>
<p>With the above evidence, we deduce that <strong>‚ÄúStrong Order‚Äù</strong> is the Magical Bit that we need for UART and PLIC!</p>
<p><em>What‚Äôs ‚ÄúStrong Order‚Äù?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Memory_ordering#Runtime_memory_ordering"><strong>‚ÄúStrong Order‚Äù</strong></a> means ‚ÄúAll Reads and All Writes are In-Order‚Äù.</p>
<p>Apparently T-Head C906 will (by default) <strong>Disable Strong Order</strong> and read / write memory <strong>Out-of-Sequence</strong>. (So that it performs better)</p>
<p>Which will surely mess up our UART and PLIC Registers!</p>
<p><em>They should‚Äôve warned us about Strong Order and I/O Memory!</em></p>
<p>Ahem <a href="https://github.com/riscv/riscv-isa-manual/blob/main/src/supervisor.adoc#svpbmt"><strong>they did</strong></a>‚Ä¶</p>
<blockquote>
<p>‚ÄúA Device Driver written to rely on <strong>I/O Strong Ordering</strong> rules <strong>will not operate correctly</strong> if the Address Range is mapped with PBMT=NC <em>[Weakly Ordered]</em>‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúAs such, this <strong>configuration is discouraged</strong>‚Äù</p>
</blockquote>
<p>Though that warning comes from the <a href="https://github.com/riscv/riscv-isa-manual/blob/main/src/supervisor.adoc#svpbmt"><strong>New Svpbmt Extension</strong></a>. Which <a href="https://patchwork.kernel.org/project/linux-riscv/patch/20210911092139.79607-3-guoren@kernel.org/#24450685"><strong>isn‚Äôt supported</strong></a> by T-Head C906.</p>
<p>(Svpbmt Bits 61~62 will conflict with T-Head Bits 59~63. Oh boy)</p>
<p><em>How to enable Strong Order?</em></p>
<p>We do it in the T-Head C906 MMU‚Ä¶</p>
<p><a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">(<strong>Strong Order</strong> appears briefly in <strong>C906 User Manual</strong>, Pages 24 &amp; 53)</a></p>
<p><a href="https://github.com/T-head-Semi/openc906/blob/main/C906_RTL_FACTORY/gen_rtl/mmu/rtl/aq_mmu_regs.v#L341-L342">(What‚Äôs <strong>‚ÄúShareable‚Äù</strong>? It‚Äôs not documented)</a></p>
<p><strong>UPDATE:</strong> Shareable might support <a href="https://news.ycombinator.com/item?id=38587092#38591801"><strong>Strong Ordering across Multiple Cores</strong></a></p>
<p><img src="https://lupyuen.github.io/images/mmu-l1kernel2b.jpg" alt="Level 1 Page Table for Ox64 MMU" /></p>
<p><a href="https://lupyuen.github.io/articles/mmu#huge-chunks-level-1"><em>Level 1 Page Table for Ox64 MMU</em></a></p>
<h1 id="memory-management-unit"><a class="doc-anchor" href="#memory-management-unit">¬ß</a>5 Memory Management Unit</h1>
<p><em>Wow the soup gets too salty. What‚Äôs MMU?</em></p>
<p><a href="https://lupyuen.github.io/articles/mmu"><strong>Memory Management Unit (MMU)</strong></a> is the hardware inside our SBC that does‚Ä¶</p>
<ul>
<li>
<p><strong>Memory Protection</strong>: Prevent Applications (and Kernel) from meddling with things (in System Memory) that they‚Äôre not supposed to</p>
</li>
<li>
<p><strong>Virtual Memory</strong>: Allow Applications to access chunks of ‚ÄúImaginary Memory‚Äù at Exotic Addresses (<strong><code>0x8000_0000</code></strong>!)</p>
<p>But in reality: They‚Äôre System RAM recycled from boring old addresses (like <strong><code>0x5060_4000</code></strong>)</p>
<p>(Kinda like ‚ÄúThe Matrix‚Äù)</p>
</li>
</ul>
<p><strong>For Ox64:</strong> We switched on the MMU to protect the Kernel Memory from the Apps. And to protect the Apps from each other.</p>
<p><em>How does it work?</em></p>
<p>The pic above shows the <strong>Level 1 Page Table</strong> that we configured for our MMU. The Page Table has a <strong>Page Table Entry</strong> that says‚Ä¶</p>
<ul>
<li>
<p><strong>V:</strong> It‚Äôs a <strong>Valid</strong> Page Table Entry</p>
</li>
<li>
<p><strong>G:</strong> It‚Äôs a <a href="https://lupyuen.github.io/articles/mmu#swap-the-satp-register"><strong>Global Mapping</strong></a></p>
</li>
<li>
<p><strong>R:</strong> Allow <strong>Kernel Reads</strong> for <strong><code>0x0</code></strong> to <strong><code>0x3FFF_FFFF</code></strong></p>
</li>
<li>
<p><strong>W:</strong> Allow <strong>Kernel Writes</strong> for <strong><code>0x0</code></strong> to <strong><code>0x3FFF_FFFF</code></strong></p>
<p>(Including the UART Registers at <code>0x3000_2000</code>)</p>
</li>
</ul>
<p><em>What about PAGE_IO_THEAD and Strong Order?</em></p>
<div><table><thead><tr><th style="text-align: left">Memory Attribute</th><th style="text-align: left">Page Table Entry</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>SO: Strongly-Ordered</strong></td><td style="text-align: left">Bit 63 is 1</td></tr>
<tr><td style="text-align: left"><strong>SH: Shareable</strong></td><td style="text-align: left">Bit 60 is 1</td></tr>
</tbody></table>
</div>
<p>We‚Äôll set the <strong>SO and SH Bits</strong> in our Page Table Entries. Hopefully UART and PLIC won‚Äôt get mushed up no more‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic3-mmu.jpg" alt="Enable Strong Order in Ox64 MMU" /></p>
<h1 id="enable-strong-order"><a class="doc-anchor" href="#enable-strong-order">¬ß</a>6 Enable Strong Order</h1>
<p><em>We need to set the Strong Order Bit‚Ä¶</em></p>
<p><em>How will we enable it in our Page Table Entry?</em></p>
<div><table><thead><tr><th style="text-align: left">Memory Attribute</th><th style="text-align: left">Page Table Entry</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>SO: Strongly-Ordered</strong></td><td style="text-align: left">Bit 63 is 1</td></tr>
<tr><td style="text-align: left"><strong>SH: Shareable</strong></td><td style="text-align: left">Bit 60 is 1</td></tr>
</tbody></table>
</div>
<p>For testing, we patched our MMU Code to set the <strong>Strong Order Bit</strong> in our Page Table Entries (pic above): <a href="https://github.com/lupyuen2/wip-nuttx/blob/ox64c/arch/risc-v/src/common/riscv_mmu.c#L100-L127">riscv_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Set a Page Table Entry in a Page Table for the MMU
void mmu_ln_setentry(
  uint32_t ptlevel,   // Level of Page Table: 1, 2 or 3 
  uintptr_t lntable,  // Page Table Address
  uintptr_t paddr,    // Physical Address
  uintptr_t vaddr,    // Virtual Address (For Kernel: Same as Physical Address)
  uint32_t mmuflags   // MMU Flags (V / G / R / W)
) {
  ...
  // Set the Page Table Entry:
  // Physical Page Number and MMU Flags (V / G / R / W)
  lntable[index] = (paddr | mmuflags);

  // Now we set the T-Head Memory Type in Bits 59 to 63.
  // For I/O and PLIC Memory, we set...
  // SO (Bit 63): Strong Order
  // SH (Bit 60): Shareable
  #define _PAGE_IO_THEAD ((1UL &lt;&lt; 63) | (1UL &lt;&lt; 60))

  // If this is a Leaf Page Table Entry
  // for I/O Memory or PLIC Memory...
  if ((mmuflags &amp; PTE_R) &amp;&amp;    // Leaf Page Table Entry
    (vaddr &lt; 0x40000000UL ||   // I/O Memory
    vaddr &gt;= 0xe0000000UL)) {  // PLIC Memory

    // Then set the Strong Order
    // and Shareable Bits
    lntable[index] = lntable[index]
      | _PAGE_IO_THEAD;
  }
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_mm_init.c#L42-L49">(Moved here)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_mm_init.c#L241-L253">(And here)</a></p>
<p>The code above will set the <strong>Strong Order and Shareable Bits</strong> for‚Ä¶</p>
<ul>
<li>
<p><strong>I/O Memory</strong>: <strong><code>0x0</code></strong> to <strong><code>0x3FFF_FFFF</code></strong></p>
<p>(Including the UART Registers at <code>0x3000_2000</code>)</p>
</li>
<li>
<p><strong>PLIC Memory</strong>: <strong><code>0xE000_0000</code></strong> to <strong><code>0xEFFF_FFFF</code></strong></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>map I/O regions
  vaddr=0, lntable[index]=0x90000000000000e7
  // &quot;0x9000...&quot; means Strong Order (Bit 63) and Shareable (Bit 60) are set

map PLIC as Interrupt L2
  vaddr=0xe0000000, lntable[index]=0x90000000380000e7
  vaddr=0xe0200000, lntable[index]=0x90000000380800e7
  vaddr=0xe0400000, lntable[index]=0x90000000381000e7
  vaddr=0xe0600000, lntable[index]=0x90000000381800e7
  ...
  vaddr=0xefc00000, lntable[index]=0x900000003bf000e7
  vaddr=0xefe00000, lntable[index]=0x900000003bf800e7
  // &quot;0x9000...&quot; means Strong Order (Bit 63) and Shareable (Bit 60) are set
</code></pre></div>
<p>We test our patched code‚Ä¶</p>
<p><strong>NOTE:</strong> T-Head MMU Flags (Strong Order / Shareable) are available only if OpenSBI has set the <a href="https://github.com/lupyuen/nuttx-ox64#strangeness-in-ox64-bl808-plic"><strong>MAEE Bit in the MXSTATUS Register to 1</strong></a>. Otherwise the MMU will crash when we set the flags!</p>
<p><strong>UPDATE:</strong> NuttX Mainline now supports <a href="https://github.com/apache/nuttx/pull/11365"><strong>T-Head C906 Memory Types</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/3761d9e73ca2c5b97b2f33dc1fc63946#file-ox64-nuttx-uart-ok-log-L25-L160">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/4e343153d996f7f7a9b2d8a79edf42cd3900d42e">(<strong>Shareable Bit</strong> doesn‚Äôt effect anything. We‚Äôre keeping it to be consistent with Linux)</a></p>
<p><img src="https://lupyuen.github.io/images/plic3-title.png" alt="UART Input and Platform-Level Interrupt Controller are finally OK on Apache NuttX RTOS and Ox64 BL808 RISC-V SBC!" /></p>
<h1 id="it-works"><a class="doc-anchor" href="#it-works">¬ß</a>7 It Works!</h1>
<p><em>What happens when we run our patched MMU code?</em></p>
<p>Our UART and PLIC Troubles are finally over!</p>
<ul>
<li>
<p><strong>Interrupt Priorities</strong> are <a href="https://gist.github.com/lupyuen/3761d9e73ca2c5b97b2f33dc1fc63946/4b137b2f6a20289bbaab8d79ed0f2f9ea2a87ef5#file-ox64-nuttx-uart-ok-log-L188-L208"><strong>set correctly to 1</strong></a></p>
<div class="example-wrap"><pre class="language-text"><code>PLIC Interrupt Priority: After (0xe0000004):
0000  01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00  ................
0010  01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00  ................
0020  01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00  ................
</code></pre></div></li>
<li>
<p><strong>Interrupt Enable</strong> <a href="https://gist.github.com/lupyuen/3761d9e73ca2c5b97b2f33dc1fc63946/4b137b2f6a20289bbaab8d79ed0f2f9ea2a87ef5#file-ox64-nuttx-uart-ok-log-L280-L281"><strong>doesn‚Äôt leak</strong></a> to the next word</p>
<div class="example-wrap"><pre class="language-text"><code>PLIC Hart 0 S-Mode Interrupt Enable (0xe0002080):
0000  00 00 10 00 00 00 00 00                          ........   
</code></pre></div></li>
<li>
<p><strong>Interrupt Claim</strong> returns the <a href="https://gist.github.com/lupyuen/365d9d6d162a60a5f8514d1040eec495#file-ox64-nuttx-claim-ok-log-L33-L44"><strong>correct Interrupt Number</strong></a></p>
<div class="example-wrap"><pre class="language-text"><code>riscv_dispatch_irq: claim=0x14
</code></pre></div></li>
<li>
<p>Our <strong>UART Driver</strong> returns the <a href="https://gist.github.com/lupyuen/6f3e24278c4700f73da72b9efd703167#file-ox64-nuttx-mmu-uncache-log-L344"><strong>correct UART Input</strong></a></p>
<div class="example-wrap"><pre class="language-text"><code>bl808_receive: rxdata=0x31
</code></pre></div></li>
</ul>
<p><em>Is NuttX usable on Ox64?</em></p>
<p>Yep! <a href="https://lupyuen.github.io/articles/plic3#appendix-build-and-run-nuttx"><strong>NuttX RTOS on Ox64</strong></a> now boots OK to the NuttX Shell (NSH).</p>
<p>And happily accepts commands through the <strong>Serial Console</strong> yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.0.3
nsh&gt; uname -a
NuttX 12.0.3 fd05b07 Nov 24 2023 07:42:54 risc-v star64

nsh&gt; ls /dev
/dev:
 console
 null
 ram0
 zero

nsh&gt; hello
Hello, World!!
</code></pre></div>
<p><a href="https://youtu.be/l7Y36nTkr8c">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/eda07e8fb1791e18451f0b4e99868324#file-ox64-nuttx-uart-ok2-log-L127-L146">(See the <strong>Complete Log</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic3-ox64.jpg" alt="We are hunky dory with Ox64 BL808 and T-Head C906 üëç" /></p>
<h1 id="lessons-learnt"><a class="doc-anchor" href="#lessons-learnt">¬ß</a>8 Lessons Learnt</h1>
<p><em>Phew that was some quick intense debugging‚Ä¶</em></p>
<p>Yeah we‚Äôre really fortunate to get NuttX RTOS running OK on Ox64. Couple of things that might have helped‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/plic2"><strong>Write up Everything</strong></a> about our troubles</p>
<p>(And share them publicly)</p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=38502979"><strong>Read the Comments</strong></a></p>
<p>(They might inspire the solution!)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64#fix-the-uart-interrupt-for-ox64-bl808"><strong>Re-Read and Re-Think</strong></a> everything we wrote</p>
<p>(Challenge all our Assumptions)</p>
</li>
<li>
<p><a href="https://qoto.org/@lupyuen/111528215670914785"><strong>Head to the Beach</strong></a>. Have a Picnic.</p>
<p>(Never know when the solution might pop up!)</p>
</li>
<li>
<p>Sounds like an Agatha Christie Mystery‚Ä¶</p>
<p>But sometimes it‚Äôs indeed <a href="https://lupyuen.github.io/articles/plic3#t-head-errata"><strong>One Single Culprit</strong></a> (Weak Ordering) behind all the Seemingly Unrelated Problems!</p>
</li>
</ol>
<p><em>Will NuttX officially support Ox64?</em></p>
<p>We plan to‚Ä¶</p>
<ul>
<li>
<p>Take a <strong>brief break</strong> from writing</p>
<p>(No new article next week)</p>
</li>
<li>
<p><strong>Clean up</strong> our code</p>
<p>(Rename the JH7110 things to BL808)</p>
</li>
<li>
<p>Upstream our code to <a href="https://lupyuen.github.io/articles/pr"><strong>NuttX Mainline</strong></a></p>
<p>(Delicate Regression Operation because we‚Äôre adding <a href="https://lupyuen.github.io/articles/plic3#t-head-errata"><strong>MMU Flags</strong></a>)</p>
</li>
</ul>
<p>And Apache NuttX RTOS shall <strong>officially support Ox64 BL808 SBC</strong> real soon!</p>
<p><strong>UPDATE:</strong> NuttX officially <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>supports Ox64 BL808 SBC</strong></a>!</p>
<p><em>Are we hunky dory with Ox64 BL808 and T-Head C906?</em></p>
<p>We said this <a href="https://lupyuen.github.io/articles/plic2#all-things-considered"><strong>last time</strong></a>‚Ä¶</p>
<blockquote>
<p><em>‚ÄúIf RISC-V ain‚Äôt RISC-V on SiFive vs T-Head: We‚Äôll find out!‚Äù</em></p>
</blockquote>
<p>As of Today: Yep <strong>RISC-V is indeed RISC-V</strong> on SiFive vs T-Head‚Ä¶ Just beware of <a href="https://lupyuen.codeberg.page/articles/plic2.html#all-things-considered"><strong>C906 MMU</strong></a>, <a href="https://lupyuen.github.io/articles/plic2#all-things-considered"><strong>C906 PLIC</strong></a> and <a href="https://lupyuen.github.io/articles/plic3#t-head-errata"><strong>T-Head Errata</strong></a>!</p>
<p><a href="https://github.com/riscv/riscv-isa-manual/blob/main/src/supervisor.adoc#svpbmt">(<strong>New T-Head Cores</strong> will probably migrate to <strong>Svpbmt Extension</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic3-beach2.jpg" alt="Quick dip in the sea + Picnic on the beach ‚Ä¶ Really helps with NuttX + Ox64 troubleshooting! üëç" /></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>9 What‚Äôs Next</h1>
<p>Thank you so much for reading my adventures of NuttX on Ox64‚Ä¶ You‚Äôre my inspiration for solving this sticky mystery! üôè</p>
<ul>
<li>
<p>Previously the <strong>Console Input</strong> was always empty</p>
<p>(Couldn‚Äôt enter any Console Commands)</p>
</li>
<li>
<p>And <strong>Interrupt Claim</strong> wasn‚Äôt working correctly</p>
<p>(Ox64 wouldn‚Äôt say which Interrupt was fired)</p>
</li>
<li>
<p>Because <strong>Leaky Reads and Writes</strong> were contaminating our UART and PLIC Registers</p>
<p>(Something was doing phantom reads and writes)</p>
</li>
<li>
<p>But when we <strong>Enabled Strong Ordering</strong> in the T-Head C906 MMU‚Ä¶</p>
<p>(Memory Management Unit)</p>
</li>
<li>
<p>Everything becomes OK</p>
<p>(No more worries!)</p>
</li>
</ul>
<p><strong>Apache NuttX RTOS for Ox64 BL808</strong> shall be Upstreamed to Mainline real soon. Stay tuned for updates!</p>
<p><strong>UPDATE:</strong> NuttX officially <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>supports Ox64 BL808 SBC</strong></a>!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=38587092"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://forum.pine64.org/showthread.php?tid=18935"><strong>Discuss this article on Pine64 Forum</strong></a></p>
</li>
<li>
<p><a href="https://bbs.bouffalolab.com/d/269-article-fixed-the-uart-interrupt-and-platform-level-interrupt-controller"><strong>Discuss this article on Bouffalo Lab Forum</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/plic3.md"><strong>lupyuen.github.io/src/plic3.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/plic3-title.png" alt="UART Input and Platform-Level Interrupt Controller are finally OK on Apache NuttX RTOS and Ox64 BL808 RISC-V SBC!" /></p>
<h1 id="appendix-build-and-run-nuttx"><a class="doc-anchor" href="#appendix-build-and-run-nuttx">¬ß</a>10 Appendix: Build and Run NuttX</h1>
<p>In this article, we ran a Work-In-Progress Version of <strong>Apache NuttX RTOS for Ox64</strong>, with PLIC and Console Input working OK.</p>
<p>This is how we download and build NuttX for Ox64 BL808 SBC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch ox64c \
  https://github.com/lupyuen2/wip-nuttx \
  nuttx
git clone \
  --branch ox64c \
  https://github.com/lupyuen2/wip-nuttx-apps \
  apps

## Build NuttX
cd nuttx
tools/configure.sh star64:nsh
make

## Export the NuttX Kernel
## to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p>Then we build the <strong>Initial RAM Disk</strong> that contains NuttX Shell and NuttX Apps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build the Apps Filesystem
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd

## Generate the Initial RAM Disk `initrd`
## in ROMFS Filesystem Format
## from the Apps Filesystem `../apps/bin`
## and label it `NuttXBootVol`
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &quot;NuttXBootVol&quot;

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/ox64c-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/ox64c-1">(See the <strong>Build Outputs</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/app#pad-the-initial-ram-disk">(Why the <strong>64 KB Padding</strong>)</a></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot">(Remember to flash <strong>OpenSBI and U-Boot Bootloader</strong>)</a></p>
<p>Then we do the <a href="https://lupyuen.github.io/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Overwrite the microSD Linux Image by the <strong>NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Overwrite the Linux Image
## on Ox64 microSD
cp Image \
  &quot;/Volumes/NO NAME/Image&quot;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <a href="https://lupyuen.github.io/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
<p>Ox64 boots <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI</strong></a>, which starts <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>, which starts <strong>NuttX Kernel</strong> and the NuttX Shell (NSH).</p>
<p>NuttX Commands will run OK in NuttX Shell. (Pic above)</p>
<p><a href="https://gist.github.com/lupyuen/eda07e8fb1791e18451f0b4e99868324">(See the <strong>NuttX Log</strong>)</a></p>
<p><a href="https://youtu.be/l7Y36nTkr8c">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/ox64c-1">(See the <strong>Build Outputs</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/plic3-beach.jpg" alt="Quick dip in the sea + Picnic on the beach ‚Ä¶ Really helps with NuttX + Ox64 troubleshooting! üëç" /></p>
<p><em>Quick dip in the sea + Picnic on the beach‚Ä¶ Really helps with NuttX + Ox64 troubleshooting!</em> üëç</p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>