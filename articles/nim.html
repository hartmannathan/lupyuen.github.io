<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="Let's blink an LED on Pine64 Ox64 BL808 64-bit RISC-V Single-Board Computer... With Nim Programming Language and Apache NuttX Real-Time Operating System"
    data-rh="true">
<meta name="description" 
    content="Let's blink an LED on Pine64 Ox64 BL808 64-bit RISC-V Single-Board Computer... With Nim Programming Language and Apache NuttX Real-Time Operating System">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/nim-ox64.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/nim.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a><ul></ul></li>
<li><a href="#blink-an-led">2 Blink an LED</a><ul></ul></li>
<li><a href="#import-nuttx-functions">3 Import NuttX Functions</a><ul></ul></li>
<li><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a><ul></ul></li>
<li><a href="#nim-blinks-the-led-on-ox64">5 Nim blinks the LED on Ox64</a><ul></ul></li>
<li><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a><ul></ul></li>
<li><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a><ul></ul></li>
<li><a href="#documentation">8 Documentation</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-risc-v-timer-with-opensbi">10 Appendix: RISC-V Timer with OpenSBI</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-qemu">11 Appendix: Build NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-ox64">12 Appendix: Build NuttX for Ox64</a><ul></ul></li></ul></nav><p>üìù <em>7 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!" /></p>
<p>Happy New Year! 2024 is here and we‚Äôre running <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) on Single-Board Computers with <strong>plenty of RAM</strong>‚Ä¶</p>
<p>Like <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> RISC-V SBC with 64 MB RAM! (Pic below)</p>
<p><em>How will we use the Plentiful RAM?</em></p>
<p>In this article, we create a <strong>Blinky LED</strong> app with a Modern, <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage-Collected</strong></a> Language: <a href="https://nim-lang.org"><strong>Nim Programming Language</strong></a>.</p>
<p>Garbage-Collected Languages (like Nim) require <strong>a bit more RAM</strong> than Low-Level Languages (like C). Perfect for our roomy SBC!</p>
<p><em>But we need a RISC-V SBC?</em></p>
<p>No worries! We‚Äôll run Nim + NuttX on the <strong>QEMU Emulator</strong> for 64-bit RISC-V. Which works great on Linux, macOS and Windows machines.</p>
<p>Everything that happens on Ox64 SBC, we‚Äôll see the <strong>exact same thing</strong> in QEMU!</p>
<p>(Well everything except the blinkenlight)</p>
<p><em>Hmmm Garbage Collection‚Ä¶ Won‚Äôt it run-pause-run-pause?</em></p>
<p>Awesome folks Wilderness Labs are running .NET on NuttX with Garbage Collection. Maybe it‚Äôs not so bad!</p>
<p>Also TinyGo</p>
<p>TODO: how different from Zig and Rust?</p>
<p>Memory Safe (like Rust)
Garbage Collected
Compiles to C (instead of LLVM)
Syntax is Python like but static compiled </p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)" /></p>
<h1 id="basic-nim-from-scratch"><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a></h1>
<p><em>(3 languages in a title heh heh)</em></p>
<p>This is the <strong>simplest Nim Program</strong> (that will run on NuttX): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L65">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim.
## Will be called by NuttX, so we export to C.
proc hello_nim() {.exportc, cdecl.} =

  ## Print something
  echo &quot;Hello Nim!&quot;

  ## Force the Garbage Collection
  GC_runOrc()
</code></pre></div>
<p>Which looks a lot like Python!</p>
<p><em>What‚Äôs GC_runOrc?</em></p>
<p>Our Nim Program will be <strong>called by C</strong>. (Remember NuttX?)</p>
<p>And Nim works with <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage Collection</strong></a>. Thus we call <strong>GC_runOrc</strong> to force the Garbage Collection to complete, clean up all remaining Nim Objects, before returning to C and NuttX.</p>
<p><em>What if we forget to call GC_runOrc?</em></p>
<p>Erm don‚Äôt! To make it unforgettable, we <strong><code>defer</code></strong> the Garbage Collection: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L65">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Print something
  echo &quot;Hello Nim!&quot;
</code></pre></div>
<p><strong><code>defer</code></strong> ensures that the Garbage Collection <strong>will always happen</strong>, as soon as we return from the Main Function.</p>
<p>Now we do something cool and enlightening‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nim-code.png" alt="Blink an LED with Nim" /></p>
<h1 id="blink-an-led"><a href="#blink-an-led">2 Blink an LED</a></h1>
<p>This is how we <strong>blink an LED</strong> with Nim on NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L21-L56">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Blink the LED
proc blink_led() =

  ## Open the LED Driver
  echo &quot;Opening /dev/userleds&quot;
  let fd = c_open(&quot;/dev/userleds&quot;, O_WRONLY)

  ## Check the File Descriptor for errors
  if fd &lt; 0:
    echo &quot;Failed to open /dev/userleds&quot;
    return
</code></pre></div>
<p>First we call the NuttX Function <strong><code>open</code></strong> to access the <strong>LED Driver</strong>.</p>
<p>We might forget to <strong><code>close</code></strong> the LED Driver (in case of errors), so we <strong><code>defer</code></strong> the closing‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## On Return: Close the LED Driver
  defer: c_close(fd)
</code></pre></div>
<p>Next we call the NuttX Function <strong><code>ioctl</code></strong> to flip <strong>LED 0 to On</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Turn on LED
  echo &quot;Set LED 0 to 1&quot;
  var ret = c_ioctl(fd, ULEDIOC_SETALL, 1)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return
</code></pre></div>
<p><strong>ULEDIOC_SETALL</strong> accepts a Bit Mask of LED States. The value <strong><code>1</code></strong> says LED 0 (Bit 0) will be flipped On. (Other LEDs will be flipped Off)</p>
<p>We <strong>pause a while</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Wait a second (literally)
  ## Because 1 million microseconds = 1 second
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)
</code></pre></div>
<p>Finally we flip <strong>LED 0 to Off</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Turn off LED
  echo &quot;Set LED 0 to 0&quot;
  ret = c_ioctl(fd, ULEDIOC_SETALL, 0)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return

  ## Wait again
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)
</code></pre></div>
<p>In our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L69"><strong>Main Function</strong></a>: We call the above function <strong>20 times</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Blink the LED 20 times
  for loop in 0..19:
    blink_led()
</code></pre></div>
<p>TODO: Looks very similar to C</p>
<p>And we‚Äôre almost done! Nim needs to discover our NuttX Functions‚Ä¶</p>
<h1 id="import-nuttx-functions"><a href="#import-nuttx-functions">3 Import NuttX Functions</a></h1>
<p><em>How will Nim know about open / close / ioctl / usleep?</em></p>
<p>We <strong>import the NuttX Functions</strong> from C into Nim: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L1-L21">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Import NuttX Functions from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

proc c_open(filename: cstring, mode: cint): cint {.
  importc: &quot;open&quot;,
  header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl.}

proc c_close(fd: cint): cint {.
  importc: &quot;close&quot;,
  header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl, discardable.}

proc c_ioctl(fd: cint, request: cint): cint {.
  importc: &quot;ioctl&quot;,
  header: &quot;&lt;sys/ioctl.h&gt;&quot;,
  nodecl, varargs.}

proc c_usleep(usec: cuint): cint {.
  importc: &quot;usleep&quot;,
  header: &quot;&lt;unistd.h&gt;&quot;,
  nodecl, discardable.}
</code></pre></div>
<p>(<strong>discardable</strong> tells Nim Compiler that the Return Value is optional)</p>
<p>(<strong>nodecl</strong> means don‚Äôt emit the C Declaration in the Generated Code)</p>
<p>We do the same for <strong>NuttX Macros</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Import NuttX Macros from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

var O_WRONLY {.
  importc: &quot;O_WRONLY&quot;, 
  header: &quot;&lt;fcntl.h&gt;&quot;.}: cint

var ULEDIOC_SETALL {.
  importc: &quot;ULEDIOC_SETALL&quot;, 
  header: &quot;&lt;nuttx/leds/userled.h&gt;&quot;.}: cint
</code></pre></div>
<p>We‚Äôre ready to run this!</p>
<h1 id="run-nim-on-qemu"><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a></h1>
<p>TODO: We begin by <strong>booting NuttX RTOS</strong> on RISC-V QEMU Emulator (64-bit)‚Ä¶</p>
<ol>
<li>
<p>Install <a href="https://www.qemu.org/download/"><strong>QEMU Emulator for RISC-V (64-bit)</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For macOS:
brew install qemu

## For Debian and Ubuntu:
sudo apt install qemu-system-riscv64
</code></pre></div></li>
<li>
<p>TODO: Download <strong><code>nuttx</code></strong> from the <a href="https://github.com/lupyuen/lupyuen.github.io/releases/tag/nuttx-riscv64"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p>TODO: <a href="https://github.com/lupyuen/lupyuen.github.io/releases/download/nuttx-riscv64/nuttx"><strong>nuttx: NuttX Image for 64-bit RISC-V QEMU</strong></a></p>
<p>TODO: If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Start the <strong>QEMU RISC-V Emulator</strong> (64-bit) with NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div></li>
<li>
<p>NuttX is now running in the QEMU Emulator! (Pic below)</p>
<div class="example-wrap"><pre class="language-text"><code>uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
nx_start_application: Starting init thread

NuttShell (NSH) NuttX-12.1.0-RC0
nsh&gt; nx_start: CPU0: Beginning Idle Loop
nsh&gt;
</code></pre></div>
<p>TODO: <a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8">(See the Complete Log)</a></p>
</li>
<li>
<p>TODO: hello_nim</p>
</li>
<li>
<p>TODO: Enter ‚Äú<strong>help</strong>‚Äù to see the available commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]

    .         break     dd        exit      ls        ps        source    umount
    [         cat       df        false     mkdir     pwd       test      unset
    ?         cd        dmesg     free      mkrd      rm        time      uptime
    alias     cp        echo      help      mount     rmdir     true      usleep
    unalias   cmp       env       hexdump   mv        set       truncate  xd
    basename  dirname   exec      kill      printf    sleep     uname

Builtin Apps:
    nsh     ostest  sh
</code></pre></div></li>
<li>
<p>TODO: NuttX works like a tiny version of Linux, so the commands will look familiar‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 12.1.0-RC0 275db39 Jun 16 2023 20:22:08 risc-v rv-virt

nsh&gt; ls /dev
/dev:
console
null
ttyS0
zero

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK           STACK   USED  FILLED COMMAND
    0     0   0 FIFO     Kthread N-- Ready              0000000000000000 002000 001224  61.2%  Idle Task
    1     1 100 RR       Task    --- Running            0000000000000000 002992 002024  67.6%  nsh_main
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8">(See the Complete Log)</a></p>
</li>
<li>
<p>To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>
</li>
</ol>
<h1 id="nim-blinks-the-led-on-ox64"><a href="#nim-blinks-the-led-on-ox64">5 Nim blinks the LED on Ox64</a></h1>
<p>TODO
We assume LED is connected to GPIO 29, Pin 21. <a href="https://wiki.pine64.org/wiki/File:Ox64_pinout.png">(See the Pinout)</a></p>
<p>(With a 47 Ohm Resistor, yellow-purple-black-gold)</p>
<h1 id="inside-nim-on-nuttx"><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a></h1>
<p><em>Nim runs incredibly well on NuttX. How is that possible?</em></p>
<p>That‚Äôs because <strong>Nim compiles to C</strong>. As far as NuttX is concerned‚Ä¶</p>
<p>Nim looks like <strong>another C Program!</strong></p>
<p><em>Whoa! How is Nim compiled to C?</em></p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L37-L41"><strong>NuttX Makefile</strong></a> calls the Nim Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Nim to C
export TOPDIR=$PWD/nuttx
cd apps/examples/hello_nim
nim c --header hello_nim_async.nim 
</code></pre></div>
<p>Nim Compiler compiles our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L63"><strong>Nim Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Nim Program that prints something
proc hello_nim() {.exportc, cdecl.} =
  echo &quot;Hello Nim!&quot;
</code></pre></div>
<p>Into this <a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L130-L146"><strong>C Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Main Function compiled from Nim to C:
// echo &quot;Hello Nim!&quot;
N_LIB_PRIVATE N_CDECL(void, hello_nim)(void) {
  ...
  // `echo` comes from the Nim System Library
  // https://github.com/nim-lang/Nim/blob/devel/lib/system.nim#L2849-L2902
  echoBinSafe(TM__1vqzGCGyH8jPEpAwiaNwvg_2, 1);
  ...
}

// String &quot;Hello Nim!&quot; compiled from Nim to C
static NIM_CONST tyArray__nHXaesL0DJZHyVS07ARPRA TM__1vqzGCGyH8jPEpAwiaNwvg_2 
  = {{10, (NimStrPayload*)&amp;TM__1vqzGCGyH8jPEpAwiaNwvg_3}};

// Actual String for &quot;Hello Nim!&quot;
static const struct { NI cap; NIM_CHAR data[10+1]; } TM__1vqzGCGyH8jPEpAwiaNwvg_3 
  = { 10 | NIM_STRLIT_FLAG, &quot;Hello Nim!&quot; };
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L130-L146">(From .nimcache/@mhello_nim_async.nim.c)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar">(See the nimcache)</a></p>
<p>Yep Nim Compiler has produced a perfectly valid C Program. That will compile with any C Compiler!</p>
<p><em>How will NuttX compile this?</em></p>
<p>Nim Compiler generates the code above into the <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> folder.</p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L31-L35"><strong>NuttX Makefile</strong></a> compiles everything inside <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> with the GCC Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Compile everything in the .nimcache folder
NIMPATH = $(shell choosenim show path)
CFLAGS += -I $(NIMPATH)/lib -I ../../.nimcache
CSRCS  += $(wildcard ../../.nimcache/*.c)
</code></pre></div>
<p>And links the Nim Modules (compiled by GCC) into NuttX.</p>
<p><em>So Nim Compiler is aware of NuttX?</em></p>
<p>Yep! Nim Compiler is internally wired to <strong>produce NuttX Code</strong> (that GCC will compile correctly)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21372/files"><strong>Nim Support for NuttX</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/config.nims"><strong>Nim Configuration for NuttX: config.nims</strong></a></p>
</li>
</ul>
<p>Kudos to <a href="https://github.com/centurysys"><strong>centurysys</strong></a> and the Nim Community for making this possible!</p>
<p><em>Everything is hunky dory with Nim on NuttX?</em></p>
<p>We made some <strong>Minor Fixes</strong>, we‚Äôll upstream to NuttX shortly‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>Here we see the Nim Compiler working perfectly, compiling our program for NuttX (by parsing the NuttX Build Config)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ export TOPDIR=/workspaces/bookworm/nuttx
$ cd /workspaces/bookworm/apps/examples/hello_nim
$ nim c --header hello_nim_async.nim

read_config: /workspaces/bookworm/nuttx/.config
line=CONFIG_DEBUG_SYMBOLS=y
line=CONFIG_DEBUG_FULLOPT=y
line=CONFIG_ARCH=&quot;risc-v&quot;
@[&quot;keyval=&quot;, &quot;ARCH&quot;, &quot;\&quot;risc-v\&quot;&quot;]
keyval[1]=&quot;risc-v&quot;
line=CONFIG_RAM_SIZE=33554432
* arch:    riscv64
* opt:     oSize
* debug:   true
* ramSize: 33554432
* isSim:   false
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/nim.cfg&#39; [Conf]
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/config.nims&#39; [Conf]
Hint: used config file &#39;/workspaces/bookworm/apps/config.nims&#39; [Conf]
....................................................................................................................................
Hint: mm: orc; opt: size; options: -d:danger
92931 lines; 1.214s; 137.633MiB peakmem; proj: /workspaces/bookworm/apps/examples/hello_nim/hello_nim_async.nim; out: /workspaces/bookworm/apps/.nimcache/hello_nim_async.json [SuccessX]
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/nim-gpio.jpg" alt="GPIO 29 in BL808 Reference Manual (Page 119)" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><em>GPIO 29 in BL808 Reference Manual (Page 119)</em></a></p>
<h1 id="led-driver-for-ox64"><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a></h1>
<p><em>Our Nim Experiment needs an LED Driver for Ox64‚Ä¶</em></p>
<p><em>What‚Äôs the Quickest Way to create a NuttX LED Driver?</em></p>
<p><strong>U-Boot Bootloader</strong> can help! Power up Ox64 and press Enter a few times to reveal the <strong>U-Boot Command Prompt</strong>.</p>
<p>We enter these <strong>U-Boot Commands</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the GPIO 29 Register at 0x20000938 (gpio_cfg29)
$ md 0x20000938 1
20000938: 00400803                             ..@.

## Set GPIO 29 Output to 1:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
## = 0x1000b40
$ mw 0x20000938 0x1000b40 1

## Dump the GPIO 29 Register to verify
$ md 020000938 1
20000938: 01000b40                             @...

## Set GPIO 29 Output to 0:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
## = 0xb40
$ mw 0x20000938 0xb40 1

## Dump the GPIO 29 Register to verify
$ md 0x20000938 1
20000938: 00000b40                             @...
</code></pre></div>
<p>And our LED (GPIO 29) will <strong>flip On and Off</strong>!</p>
<p>Thus we have verified the <strong>Magic Bits</strong> for flipping our LED‚Ä¶</p>
<ul>
<li>
<p>Write to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
</li>
<li>
<p>Register Value <strong><code>0x100</code> <code>0B40</code></strong> will flip the LED On</p>
</li>
<li>
<p>Register Value <strong><code>0xB40</code></strong> will flip the LED Off</p>
</li>
</ul>
<p><em>How did we figure out the Magic Bits for GPIO 29?</em></p>
<p>From <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>BL808 Reference Manual</strong></a> Page 56, ‚ÄúNormal GPIO Output Mode‚Äù‚Ä¶</p>
<ul>
<li>
<p>Set <strong>reg_gpio_29_oe</strong> (Bit 6) to <strong><code>1</code></strong> to enable GPIO Output Mode <br>
= (1 &lt;&lt; 6)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_func_sel</strong> (Bits 8 to 12) to <strong><code>11</code></strong> to enter SWGPIO Mode <br>
= (11 &lt;&lt; 8)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_mode</strong> (Bits 30 to 31) to <strong><code>0</code></strong> to enable Normal Output Function of I/O <br>
= (0 &lt;&lt; 30)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_pu</strong> (Bit 4) and <strong>reg_gpio_29_pd</strong> (Bit 5) to <strong><code>0</code></strong> to disable Internal Pull-Up and Pull-Down functions <br>
= (0 &lt;&lt; 4)</p>
</li>
<li>
<p>Set the Pin Level (<strong><code>0</code></strong> or <strong><code>1</code></strong>) through <strong>reg_gpio_29_o</strong> (Bit 24) <br>
= Either (0 &lt;&lt; 24) Or (1 &lt;&lt; 24)</p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/images/nim-gpio.jpg">(<strong>GPIO Bits</strong> are listed in the pic above)</a></p>
<p>Which means‚Ä¶</p>
<ul>
<li>
<p><strong>Set GPIO Output to 0</strong> <br>
= (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24) <br>
= <strong><code>0xB40</code></strong></p>
</li>
<li>
<p><strong>Set GPIO Output to 1</strong> <br>
= (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24) <br>
= <strong><code>0x100</code> <code>0B40</code></strong></p>
</li>
</ul>
<p>And we write the above values to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
<p><em>How to flip the GPIO in our LED Driver?</em></p>
<p>We do this in our <strong>NuttX LED Driver</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_userleds.c#L176-L209">bl808_userleds.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Flip the LEDs On and Off according to the LED Set
// (Bit 0 = LED 0)
void board_userled_all(uint32_t ledset) {

  // For LED 0 to 2...
  for (int i = 0; i &lt; BOARD_LEDS; i++) {

    // Get the desired state of the LED
    bool val = ((ledset &amp; g_led_setmap[i]) != 0);

    // If this is LED 0...
    if (i == 0) {

      // Flip it On or Off?
      if (val) {

        // Flip LED 0 (GPIO 29) to On:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
        // mw 0x20000938 0x1000b40 1
        *(volatile uint32_t *) 0x20000938 = 0x1000b40;
      } else {

        // Flip LED 0 (GPIO 29) to Off:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
        // mw 0x20000938 0xb40 1
        *(volatile uint32_t *) 0x20000938 = 0xb40;
      }
    }
  }
}
</code></pre></div>
<p>That‚Äôs how we created a barebones LED Driver for Ox64!</p>
<p>TODO: How NuttX starts our <strong>LED Driver</strong></p>
<p>TODO: Remember to add the <strong>Auto-LED Driver</strong></p>
<p><em>Ahem it looks a little messy‚Ä¶</em></p>
<p>TODO: No Worries! Later we‚Äôll replace the (awful) code above by the <strong>BL808 GPIO Driver</strong>. Which we‚Äôll copy from <strong>NuttX for BL602</strong>.</p>
<div class="example-wrap"><pre class="language-c"><code>TODO: GPIO
</code></pre></div>
<p><em>Anything else we patched?</em></p>
<p>TODO: RISC-V Timer</p>
<p><img src="https://lupyuen.github.io/images/nim-ox64.png" alt="Nim App runs OK on Apache NuttX Real-Time Operating System and Ox64 BL808 RISC-V SBC" /></p>
<h1 id="documentation"><a href="#documentation">8 Documentation</a></h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx-apps/pull/1597">NuttX support for Nim</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21372/files">Nim support for NuttX</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21384">For Nuttx, change ioselectors to use ‚Äúselect‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/issues/8604">Which implementation of NuttX select/poll/EPOLL is recommended in terms of performance and efficiency</a></p>
</li>
<li>
<p><a href="https://disconnected.systems/blog/nim-on-adruino/">Nim on Arduino</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/Nim/blob/devel/doc/nimc.md#nim-for-embedded-systems">Nim for Embedded Systems</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/nimc.html">Nim Compiler User Guide</a></p>
</li>
<li>
<p><a href="https://github.com/mantielero/lvgl.nim">Nim Wrapper for LVGL</a></p>
</li>
</ul>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nim.md"><strong>lupyuen.github.io/src/nim.md</strong></a></p>
<h1 id="appendix-risc-v-timer-with-opensbi"><a href="#appendix-risc-v-timer-with-opensbi">10 Appendix: RISC-V Timer with OpenSBI</a></h1>
<p>TODO</p>
<p><em>The <code>sleep</code> command hangs in NuttX Shell. How to fix it?</em></p>
<p>That‚Äôs because we haven‚Äôt implemented the RISC-V Timer for Ox64! We should call OpenSBI to handle the Timer, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/commit/57ea5f000636f739ac3cb8ea1e60936798f6c3a9#diff-535879ffd6d9fc8e7d84b37a88bdeb1609c4a90e3777150939a96bed18696aee">here‚Äôs the fix</a>.</p>
<p>(Ignore riscv_mtimer.c, we were verifying that mtime and mtimecmp¬†are unused in Kernel Mode)</p>
<p>We only need to change¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L116">arch/risc-v/src/bl808/bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Timer Frequency
#define MTIMER_FREQ 1000000

// This function is called during start-up to initialize the timer interrupt.
void up_timer_initialize(void) {
  struct oneshot_lowerhalf_s *lower = riscv_mtimer_initialize(
    0, 0, RISCV_IRQ_STIMER, MTIMER_FREQ);
  DEBUGASSERT(lower);
  up_alarm_set_lowerhalf(lower);
}
</code></pre></div>
<p>How it works: At startup, <code>up_timer_initialize</code> (above) calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/riscv_mtimer.c#L318-L332">riscv_mtimer_initialize</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/riscv_mtimer.c#L136-L141">riscv_mtimer_set_mtimecmp</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/supervisor/riscv_sbi.c#L94-L107">riscv_sbi_set_timer</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/supervisor/riscv_sbi.c#L53-L76">sbi_ecall</a> which makes an ecall to OpenSBI</p>
</li>
<li>
<p>Which accesses the System Timer</p>
</li>
</ul>
<p>Originally we set¬†MTIMER_FREQ to 10000000:¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 10000000
</code></pre></div>
<p>But this causes the command <code>sleep 1</code> to pause for 10 seconds. So we divide the frequency by 10: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 1000000
</code></pre></div>
<p>Now the <code>sleep</code> command works correctly in NuttX Shell!</p>
<p><a href="https://gist.github.com/lupyuen/8aa66e7f88d1e31a5f198958c15e4393">Here‚Äôs the log (ignore the errors)</a></p>
<h1 id="appendix-build-nuttx-for-qemu"><a href="#appendix-build-nuttx-for-qemu">11 Appendix: Build NuttX for QEMU</a></h1>
<p>In this article, we ran a Work-In-Progress Version of <strong>Apache NuttX RTOS for QEMU RISC-V (64-bit)</strong> that has Minor Fixes for Nim‚Ä¶</p>
<ul>
<li>
<p>TODO: LED Driver for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>This is how we download and build NuttX for <strong>QEMU RISC-V (64-bit)</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for QEMU RISC-V (64-bit)
cd nuttx
tools/configure.sh rv-virt:nsh64

## Build NuttX
make

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>This produces the NuttX ELF Image <strong>nuttx</strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU RISC-V Emulator (64-bit) with NuttX RTOS
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>TODO: <a href="https://gist.github.com/lupyuen/eda07e8fb1791e18451f0b4e99868324">(See the <strong>NuttX Log</strong>)</a></p>
<p>TODO: <a href="https://youtu.be/l7Y36nTkr8c">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<h1 id="appendix-build-nuttx-for-ox64"><a href="#appendix-build-nuttx-for-ox64">12 Appendix: Build NuttX for Ox64</a></h1>
<p>In this article, we ran a Work-In-Progress Version of <strong>Apache NuttX RTOS for Ox64</strong> that has Minor Fixes for Nim‚Ä¶</p>
<ul>
<li>
<p>TODO: LED Driver for Ox64</p>
</li>
<li>
<p>TODO: RISC-V Timer for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>This is how we download and build NuttX for <strong>Ox64 BL808 SBC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for Ox64 BL808 RISC-V SBC
cd nuttx
tools/configure.sh ox64:nsh

## Build NuttX
make

## Export the NuttX Kernel
## to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## Dump the hello_nim disassembly to hello_nim.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello_nim \
  &gt;hello_nim.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p>Then we build the <strong>Initial RAM Disk</strong> that contains NuttX Shell and NuttX Apps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build the Apps Filesystem
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd

## Generate the Initial RAM Disk `initrd`
## in ROMFS Filesystem Format
## from the Apps Filesystem `../apps/bin`
## and label it `NuttXBootVol`
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &quot;NuttXBootVol&quot;

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/578a7eb2d4d827aa252fff37c172dd18">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot">(Remember to flash <strong>OpenSBI and U-Boot Bootloader</strong>)</a></p>
<p>Then we do the <a href="https://lupyuen.github.io/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Overwrite the microSD Linux Image by the <strong>NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Overwrite the Linux Image
## on Ox64 microSD
cp Image \
  &quot;/Volumes/NO NAME/Image&quot;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <a href="https://lupyuen.github.io/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
<p>Ox64 boots <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI</strong></a>, which starts <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>, which starts <strong>NuttX Kernel</strong> and the NuttX Shell (NSH).</p>
<p>TODO: <a href="https://gist.github.com/lupyuen/eda07e8fb1791e18451f0b4e99868324">(See the <strong>NuttX Log</strong>)</a></p>
<p>TODO: <a href="https://youtu.be/l7Y36nTkr8c">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Outputs</strong>)</a></p>

    
</body>
</html>