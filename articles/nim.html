<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="Let's blink an LED on Pine64 Ox64 BL808 64-bit RISC-V Single-Board Computer... With Nim Programming Language and Apache NuttX Real-Time Operating System"
    data-rh="true">
<meta name="description" 
    content="Let's blink an LED on Pine64 Ox64 BL808 64-bit RISC-V Single-Board Computer... With Nim Programming Language and Apache NuttX Real-Time Operating System">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/nim-ox64.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/nim.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a><ul></ul></li>
<li><a href="#blink-an-led">2 Blink an LED</a><ul></ul></li>
<li><a href="#import-nuttx-functions">3 Import NuttX Functions</a><ul></ul></li>
<li><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a><ul></ul></li>
<li><a href="#nim-blinks-the-led-on-ox64">5 Nim blinks the LED on Ox64</a><ul></ul></li>
<li><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a><ul></ul></li>
<li><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a><ul></ul></li>
<li><a href="#experiments-with-nim-on-apache-nuttx-real-time-operating-system">8 Experiments with Nim on Apache NuttX Real-Time Operating System</a><ul></ul></li>
<li><a href="#fix-nuttx-for-nim">9 Fix NuttX for Nim</a><ul></ul></li>
<li><a href="#nim-on-apache-nuttx-rtos-and-ox64-bl808-risc-v-sbc">10 Nim on Apache NuttX RTOS and Ox64 BL808 RISC-V SBC</a><ul></ul></li>
<li><a href="#blink-an-led-with-nim">11 Blink an LED with Nim</a><ul></ul></li>
<li><a href="#build-nuttx-with-debian-container-in-vscode">12 Build NuttX with Debian Container in VSCode</a><ul></ul></li>
<li><a href="#usleep">13 usleep</a><ul></ul></li>
<li><a href="#documentation">14 Documentation</a><ul></ul></li>
<li><a href="#fix-the-risc-v-timer-with-opensbi">15 Fix the RISC-V Timer with OpenSBI</a><ul></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-qemu">17 Appendix: Build NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-ox64">18 Appendix: Build NuttX for Ox64</a><ul></ul></li></ul></nav><p>üìù <em>7 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!" /></p>
<p>Happy New Year! 2024 is here and we‚Äôre running <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) on Single-Board Computers with <strong>plenty of RAM</strong>‚Ä¶</p>
<p>Like <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> RISC-V SBC with 64 MB RAM! (Pic below)</p>
<p><em>How will we use the Plentiful RAM meaningfully?</em></p>
<p>Let‚Äôs create simpler, safer <strong>NuttX Apps</strong> with a Modern, <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage-Collected</strong></a> Language: <a href="https://nim-lang.org"><strong>Nim Programming Language</strong></a>!</p>
<p>TODO: how different from Zig and Rust?</p>
<p>Memory Safe (like Rust)
Garbage Collected
Compiles to C (instead of LLVM)
Syntax is Python like but static compiled </p>
<p><em>But Garbage Collection? Won‚Äôt it run-pause-run-pause?</em></p>
<p>Awesome folks Wilderness Labs are running .NET on NuttX with Garbage Collection. Maybe it‚Äôs not so bad!</p>
<p>Also TinyGo</p>
<p><em>But we need an Ox64 SBC?</em></p>
<p>No worries! We‚Äôll run Nim + NuttX on the <strong>QEMU Emulator</strong> for 64-bit RISC-V. Which works great on Linux, macOS and Windows machines.</p>
<p>Everything that happens on Ox64 SBC, we‚Äôll see the <strong>exact same thing</strong> in QEMU!</p>
<p>(Well everything except the blinkenlight)</p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)" /></p>
<h1 id="basic-nim-from-scratch"><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a></h1>
<p><em>(3 languages in a title heh heh)</em></p>
<p>This is the <strong>simplest Nim Program</strong> (that will run on NuttX): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L65">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim.
## Will be called by NuttX, so we export to C.
proc hello_nim() {.exportc, cdecl.} =

  ## Print something
  echo &quot;Hello Nim!&quot;

  ## Force the Garbage Collection
  GC_runOrc()
</code></pre></div>
<p>Which looks a lot like Python!</p>
<p><em>What‚Äôs GC_runOrc?</em></p>
<p>Our Nim Program will be <strong>called by C</strong>. (Remember NuttX?)</p>
<p>And Nim works with <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage Collection</strong></a>. Thus we call <strong>GC_runOrc</strong> to force the Garbage Collection to complete, clean up all remaining Nim Objects, before returning to C and NuttX.</p>
<p><em>What if we forget to call GC_runOrc?</em></p>
<p>Erm don‚Äôt! To make it unforgettable, we <strong><code>defer</code></strong> the Garbage Collection: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L65">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Print something
  echo &quot;Hello Nim!&quot;
</code></pre></div>
<p><strong><code>defer</code></strong> ensures that the Garbage Collection <strong>will always happen</strong>, as soon as we return from the Main Function.</p>
<p>Now we do something cool and enlightening‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nim-code.png" alt="Blink an LED with Nim" /></p>
<h1 id="blink-an-led"><a href="#blink-an-led">2 Blink an LED</a></h1>
<p>This is how we <strong>blink an LED</strong> with Nim on NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L21-L56">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Blink the LED
proc blink_led() =

  ## Open the LED Driver
  echo &quot;Opening /dev/userleds&quot;
  let fd = c_open(&quot;/dev/userleds&quot;, O_WRONLY)

  ## Check the File Descriptor for errors
  if fd &lt; 0:
    echo &quot;Failed to open /dev/userleds&quot;
    return
</code></pre></div>
<p>First we call the NuttX Function <strong><code>open</code></strong> to access the <strong>LED Driver</strong>.</p>
<p>We might forget to <strong><code>close</code></strong> the LED Driver (in case of errors), so we <strong><code>defer</code></strong> the closing‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## On Return: Close the LED Driver
  defer: c_close(fd)
</code></pre></div>
<p>Next we call the NuttX Function <strong><code>ioctl</code></strong> to flip <strong>LED 0 to On</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Turn on LED
  echo &quot;Set LED 0 to 1&quot;
  var ret = c_ioctl(fd, ULEDIOC_SETALL, 1)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return
</code></pre></div>
<p><strong>ULEDIOC_SETALL</strong> accepts a Bit Mask of LED States. The value <strong><code>1</code></strong> says LED 0 (Bit 0) will be flipped On. (Other LEDs will be flipped Off)</p>
<p>We <strong>pause a while</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Wait a second (literally)
  ## Because 1 million microseconds = 1 second
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)
</code></pre></div>
<p>Finally we flip <strong>LED 0 to Off</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Turn off LED
  echo &quot;Set LED 0 to 0&quot;
  ret = c_ioctl(fd, ULEDIOC_SETALL, 0)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return

  ## Wait again
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)
</code></pre></div>
<p>In our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L69"><strong>Main Function</strong></a>: We call the above function <strong>20 times</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Blink the LED 20 times
  for loop in 0..19:
    blink_led()
</code></pre></div>
<p>TODO: Looks very similar to C</p>
<p>And we‚Äôre almost done! Nim needs to discover our NuttX Functions‚Ä¶</p>
<h1 id="import-nuttx-functions"><a href="#import-nuttx-functions">3 Import NuttX Functions</a></h1>
<p><em>How will Nim know about open / close / ioctl / usleep?</em></p>
<p>We <strong>import the NuttX Functions</strong> from C into Nim: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L1-L21">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Import NuttX Functions from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

proc c_open(filename: cstring, mode: cint): cint {.
  importc: &quot;open&quot;,
  header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl.}

proc c_close(fd: cint): cint {.
  importc: &quot;close&quot;,
  header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl, discardable.}

proc c_ioctl(fd: cint, request: cint): cint {.
  importc: &quot;ioctl&quot;,
  header: &quot;&lt;sys/ioctl.h&gt;&quot;,
  nodecl, varargs.}

proc c_usleep(usec: cuint): cint {.
  importc: &quot;usleep&quot;,
  header: &quot;&lt;unistd.h&gt;&quot;,
  nodecl, discardable.}
</code></pre></div>
<p>(<strong>discardable</strong> tells Nim Compiler that the Return Value is optional)</p>
<p>(<strong>nodecl</strong> means don‚Äôt emit the C Declaration in the Generated Code)</p>
<p>We do the same for <strong>NuttX Macros</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Import NuttX Macros from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

var O_WRONLY {.
  importc: &quot;O_WRONLY&quot;, 
  header: &quot;&lt;fcntl.h&gt;&quot;.}: cint

var ULEDIOC_SETALL {.
  importc: &quot;ULEDIOC_SETALL&quot;, 
  header: &quot;&lt;nuttx/leds/userled.h&gt;&quot;.}: cint
</code></pre></div>
<p>We‚Äôre ready to run this!</p>
<h1 id="run-nim-on-qemu"><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a></h1>
<p>TODO: We begin by <strong>booting NuttX RTOS</strong> on RISC-V QEMU Emulator (64-bit)‚Ä¶</p>
<ol>
<li>
<p>Install <a href="https://www.qemu.org/download/"><strong>QEMU Emulator for RISC-V (64-bit)</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For macOS:
brew install qemu

## For Debian and Ubuntu:
sudo apt install qemu-system-riscv64
</code></pre></div></li>
<li>
<p>TODO: Download <strong><code>nuttx</code></strong> from the <a href="https://github.com/lupyuen/lupyuen.github.io/releases/tag/nuttx-riscv64"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p>TODO: <a href="https://github.com/lupyuen/lupyuen.github.io/releases/download/nuttx-riscv64/nuttx"><strong>nuttx: NuttX Image for 64-bit RISC-V QEMU</strong></a></p>
<p>TODO: If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Start the <strong>QEMU RISC-V Emulator</strong> (64-bit) with NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div></li>
<li>
<p>NuttX is now running in the QEMU Emulator! (Pic below)</p>
<div class="example-wrap"><pre class="language-text"><code>uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
nx_start_application: Starting init thread

NuttShell (NSH) NuttX-12.1.0-RC0
nsh&gt; nx_start: CPU0: Beginning Idle Loop
nsh&gt;
</code></pre></div>
<p>TODO: <a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8">(See the Complete Log)</a></p>
</li>
<li>
<p>TODO: hello_nim</p>
</li>
<li>
<p>TODO: Enter ‚Äú<strong>help</strong>‚Äù to see the available commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]

    .         break     dd        exit      ls        ps        source    umount
    [         cat       df        false     mkdir     pwd       test      unset
    ?         cd        dmesg     free      mkrd      rm        time      uptime
    alias     cp        echo      help      mount     rmdir     true      usleep
    unalias   cmp       env       hexdump   mv        set       truncate  xd
    basename  dirname   exec      kill      printf    sleep     uname

Builtin Apps:
    nsh     ostest  sh
</code></pre></div></li>
<li>
<p>TODO: NuttX works like a tiny version of Linux, so the commands will look familiar‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 12.1.0-RC0 275db39 Jun 16 2023 20:22:08 risc-v rv-virt

nsh&gt; ls /dev
/dev:
console
null
ttyS0
zero

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK           STACK   USED  FILLED COMMAND
    0     0   0 FIFO     Kthread N-- Ready              0000000000000000 002000 001224  61.2%  Idle Task
    1     1 100 RR       Task    --- Running            0000000000000000 002992 002024  67.6%  nsh_main
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8">(See the Complete Log)</a></p>
</li>
<li>
<p>To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>
</li>
</ol>
<h1 id="nim-blinks-the-led-on-ox64"><a href="#nim-blinks-the-led-on-ox64">5 Nim blinks the LED on Ox64</a></h1>
<p>TODO
We assume LED is connected to GPIO 29, Pin 21. <a href="https://wiki.pine64.org/wiki/File:Ox64_pinout.png">(See the Pinout)</a></p>
<p>(With a 47 Ohm Resistor, yellow-purple-black-gold)</p>
<h1 id="inside-nim-on-nuttx"><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a></h1>
<p><em>Nim runs incredibly well on NuttX. How is that possible?</em></p>
<p>That‚Äôs because <strong>Nim compiles to C</strong>. As far as NuttX is concerned‚Ä¶</p>
<p>Nim looks like <strong>another C Program!</strong></p>
<p><em>Whoa! How is Nim compiled to C?</em></p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L37-L41"><strong>NuttX Makefile</strong></a> calls the Nim Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Nim to C
export TOPDIR=$PWD/nuttx
cd apps/examples/hello_nim
nim c --header hello_nim_async.nim 
</code></pre></div>
<p>Nim Compiler compiles our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L63"><strong>Nim Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Nim Program that prints something
proc hello_nim() {.exportc, cdecl.} =
  echo &quot;Hello Nim!&quot;
</code></pre></div>
<p>Into this <a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L130-L146"><strong>C Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Main Function compiled from Nim to C:
// echo &quot;Hello Nim!&quot;
N_LIB_PRIVATE N_CDECL(void, hello_nim)(void) {
  ...
  // `echo` comes from the Nim System Library
  // https://github.com/nim-lang/Nim/blob/devel/lib/system.nim#L2849-L2902
  echoBinSafe(TM__1vqzGCGyH8jPEpAwiaNwvg_2, 1);
  ...
}

// String &quot;Hello Nim!&quot; compiled from Nim to C
static NIM_CONST tyArray__nHXaesL0DJZHyVS07ARPRA TM__1vqzGCGyH8jPEpAwiaNwvg_2 
  = {{10, (NimStrPayload*)&amp;TM__1vqzGCGyH8jPEpAwiaNwvg_3}};

// Actual String for &quot;Hello Nim!&quot;
static const struct { NI cap; NIM_CHAR data[10+1]; } TM__1vqzGCGyH8jPEpAwiaNwvg_3 
  = { 10 | NIM_STRLIT_FLAG, &quot;Hello Nim!&quot; };
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L130-L146">(From .nimcache/@mhello_nim_async.nim.c)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar">(See the nimcache)</a></p>
<p>Yep Nim Compiler has produced a perfectly valid C Program. That will compile with any C Compiler!</p>
<p><em>How will NuttX compile this?</em></p>
<p>Nim Compiler generates the code above into the <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> folder.</p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L31-L35"><strong>NuttX Makefile</strong></a> compiles everything inside <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> with the GCC Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Compile everything in the .nimcache folder
NIMPATH = $(shell choosenim show path)
CFLAGS += -I $(NIMPATH)/lib -I ../../.nimcache
CSRCS  += $(wildcard ../../.nimcache/*.c)
</code></pre></div>
<p>And links the Nim Modules (compiled by GCC) into NuttX.</p>
<p><em>So Nim Compiler is aware of NuttX?</em></p>
<p>Yep! Nim Compiler is internally wired to <strong>produce NuttX Code</strong> (that GCC will compile correctly)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21372/files"><strong>Nim Support for NuttX</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/config.nims"><strong>Nim Configuration for NuttX: config.nims</strong></a></p>
</li>
</ul>
<p>Kudos to <a href="https://github.com/centurysys"><strong>centurysys</strong></a> and the Nim Community for making this possible!</p>
<p><em>Everything is hunky dory with Nim on NuttX?</em></p>
<p>We made some <strong>Minor Fixes</strong>, we‚Äôll upstream to NuttX shortly‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>Here we see the Nim Compiler working perfectly, compiling our program for NuttX (by parsing the NuttX Build Config)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ export TOPDIR=/workspaces/bookworm/nuttx
$ cd /workspaces/bookworm/apps/examples/hello_nim
$ nim c --header hello_nim_async.nim

read_config: /workspaces/bookworm/nuttx/.config
line=CONFIG_DEBUG_SYMBOLS=y
line=CONFIG_DEBUG_FULLOPT=y
line=CONFIG_ARCH=&quot;risc-v&quot;
@[&quot;keyval=&quot;, &quot;ARCH&quot;, &quot;\&quot;risc-v\&quot;&quot;]
keyval[1]=&quot;risc-v&quot;
line=CONFIG_RAM_SIZE=33554432
* arch:    riscv64
* opt:     oSize
* debug:   true
* ramSize: 33554432
* isSim:   false
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/nim.cfg&#39; [Conf]
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/config.nims&#39; [Conf]
Hint: used config file &#39;/workspaces/bookworm/apps/config.nims&#39; [Conf]
....................................................................................................................................
Hint: mm: orc; opt: size; options: -d:danger
92931 lines; 1.214s; 137.633MiB peakmem; proj: /workspaces/bookworm/apps/examples/hello_nim/hello_nim_async.nim; out: /workspaces/bookworm/apps/.nimcache/hello_nim_async.json [SuccessX]
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/nim-gpio.jpg" alt="GPIO 29 in BL808 Reference Manual (Page 119)" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><em>GPIO 29 in BL808 Reference Manual (Page 119)</em></a></p>
<h1 id="led-driver-for-ox64"><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a></h1>
<p><em>Our Nim Experiment needs an LED Driver for Ox64‚Ä¶</em></p>
<p><em>What‚Äôs the Quickest Way to create a NuttX LED Driver?</em></p>
<p><strong>U-Boot Bootloader</strong> can help! Power up Ox64 and press Enter a few times to reveal the <strong>U-Boot Command Prompt</strong>.</p>
<p>We enter these <strong>U-Boot Commands</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the GPIO 29 Register at 0x20000938 (gpio_cfg29)
$ md 0x20000938 1
20000938: 00400803                             ..@.

## Set GPIO 29 Output to 1:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
## = 0x1000b40
$ mw 0x20000938 0x1000b40 1

## Dump the GPIO 29 Register to verify
$ md 020000938 1
20000938: 01000b40                             @...

## Set GPIO 29 Output to 0:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
## = 0xb40
$ mw 0x20000938 0xb40 1

## Dump the GPIO 29 Register to verify
$ md 0x20000938 1
20000938: 00000b40                             @...
</code></pre></div>
<p>And our LED (GPIO 29) will <strong>flip On and Off</strong>!</p>
<p>Thus we have verified the <strong>Magic Bits</strong> for flipping our LED‚Ä¶</p>
<ul>
<li>
<p>Write to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
</li>
<li>
<p>Register Value <strong><code>0x100</code> <code>0B40</code></strong> will flip the LED On</p>
</li>
<li>
<p>Register Value <strong><code>0xB40</code></strong> will flip the LED Off</p>
</li>
</ul>
<p><em>How did we figure out the Magic Bits for GPIO 29?</em></p>
<p>From <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>BL808 Reference Manual</strong></a> Page 56, ‚ÄúNormal GPIO Output Mode‚Äù‚Ä¶</p>
<ul>
<li>
<p>Set <strong>reg_gpio_29_oe</strong> (Bit 6) to <strong><code>1</code></strong> to enable GPIO Output Mode <br>
= (1 &lt;&lt; 6)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_func_sel</strong> (Bits 8 to 12) to <strong><code>11</code></strong> to enter SWGPIO Mode <br>
= (11 &lt;&lt; 8)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_mode</strong> (Bits 30 to 31) to <strong><code>0</code></strong> to enable Normal Output Function of I/O <br>
= (0 &lt;&lt; 30)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_pu</strong> (Bit 4) and <strong>reg_gpio_29_pd</strong> (Bit 5) to <strong><code>0</code></strong> to disable Internal Pull-Up and Pull-Down functions <br>
= (0 &lt;&lt; 4)</p>
</li>
<li>
<p>Set the Pin Level (<strong><code>0</code></strong> or <strong><code>1</code></strong>) through <strong>reg_gpio_29_o</strong> (Bit 24) <br>
= Either (0 &lt;&lt; 24) Or (1 &lt;&lt; 24)</p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/images/nim-gpio.jpg">(<strong>GPIO Bits</strong> are listed in the pic above)</a></p>
<p>Which means‚Ä¶</p>
<ul>
<li>
<p><strong>Set GPIO Output to 0</strong> <br>
= (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24) <br>
= <strong><code>0xB40</code></strong></p>
</li>
<li>
<p><strong>Set GPIO Output to 1</strong> <br>
= (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24) <br>
= <strong><code>0x100</code> <code>0B40</code></strong></p>
</li>
</ul>
<p>And we write the above values to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
<p><em>How to flip the GPIO in our LED Driver?</em></p>
<p>We do this in our <strong>NuttX LED Driver</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_userleds.c#L176-L209">bl808_userleds.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Flip the LEDs On and Off according to the LED Set
// (Bit 0 = LED 0)
void board_userled_all(uint32_t ledset) {

  // For LED 0 to 2...
  for (int i = 0; i &lt; BOARD_LEDS; i++) {

    // Get the desired state of the LED
    bool val = ((ledset &amp; g_led_setmap[i]) != 0);

    // If this is LED 0...
    if (i == 0) {

      // Flip it On or Off?
      if (val) {

        // Flip LED 0 (GPIO 29) to On:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
        // mw 0x20000938 0x1000b40 1
        *(volatile uint32_t *) 0x20000938 = 0x1000b40;
      } else {

        // Flip LED 0 (GPIO 29) to Off:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
        // mw 0x20000938 0xb40 1
        *(volatile uint32_t *) 0x20000938 = 0xb40;
      }
    }
  }
}
</code></pre></div>
<p>That‚Äôs how we created a barebones LED Driver for Ox64!</p>
<p>TODO: Startup</p>
<p><em>Ahem it looks a little messy‚Ä¶</em></p>
<p>TODO: No Worries! Later we‚Äôll replace the (awful) code above by the <strong>BL808 GPIO Driver</strong>. Which we‚Äôll copy from <strong>NuttX for BL602</strong>.</p>
<h1 id="experiments-with-nim-on-apache-nuttx-real-time-operating-system"><a href="#experiments-with-nim-on-apache-nuttx-real-time-operating-system">8 Experiments with Nim on Apache NuttX Real-Time Operating System</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/nim-title.png" alt="Nim App runs OK on Apache NuttX Real-Time Operating System" /></p>
<p>Today Apache NuttX RTOS runs on SBCs that have plenty of RAM: Ox64 with 64 MB RAM!</p>
<p>Now that we have plentiful RAM: Maybe we should build NuttX Apps with a Memory-Safe, Garbage-Collected language‚Ä¶ Like Nim!</p>
<p>This Nim App: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>import std/asyncdispatch
import std/strformat

proc hello_nim() {.exportc, cdecl.} =
  echo &quot;Hello Nim!&quot;
  GC_runOrc()
</code></pre></div>
<p>Runs OK on NuttX for QEMU RISC-V 64-bit!</p>
<div class="example-wrap"><pre class="language-text"><code>+ qemu-system-riscv64 -semihosting -M virt,aclint=on -cpu rv64 -smp 8 -bios none -kernel nuttx -nographic

NuttShell (NSH) NuttX-12.0.3
nsh&gt; uname -a
NuttX  12.0.3 45150e164c5 Dec 23 2023 07:24:20 risc-v rv-virt

nsh&gt; hello_nim
Hello Nim!
</code></pre></div>
<p>This is how we build NuttX with the Nim App inside‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install choosenim, add to PATH, select latest Dev Version of Nim Compiler
curl https://nim-lang.org/choosenim/init.sh -sSf | sh
export PATH=/home/vscode/.nimble/bin:$PATH
choosenim devel --latest

## Download WIP NuttX and Apps
git clone --branch nim https://github.com/lupyuen2/wip-pinephone-nuttx nuttx
git clone --branch nim https://github.com/lupyuen2/wip-pinephone-nuttx-apps apps

## Configure NuttX for QEMU RISC-V (64-bit)
cd nuttx
tools/configure.sh rv-virt:nsh64

## Build NuttX
make

## Start NuttX with QEMU RISC-V (64-bit)
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>We made some minor tweaks in NuttX‚Ä¶</p>
<h1 id="fix-nuttx-for-nim"><a href="#fix-nuttx-for-nim">9 Fix NuttX for Nim</a></h1>
<p>TODO</p>
<p><em>How did we fix NuttX to compile Nim Apps correctly?</em></p>
<p>We moved .nimcache 2 levels up: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile">apps/examples/hello_nim/Makefile</a></p>
<div class="example-wrap"><pre class="language-text"><code>## Move .nimcache 2 levels up
CFLAGS += -I $(NIMPATH)/lib -I ../../.nimcache
CSRCS += $(wildcard ../../.nimcache/*.c)

## Previously:
## CFLAGS += -I $(NIMPATH)/lib -I ./.nimcache
## CSRCS += $(wildcard .nimcache/*.c)
</code></pre></div>
<p>And we switched the Nim Target Architecture from RISC-V 32-bit to 64-bit: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/config.nims">apps/config.nims</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Assume we are compiling with `riscv-none-elf-gcc` instead of `riscv64-unknown-elf-gcc`
switch &quot;riscv32.nuttx.gcc.exe&quot;, &quot;riscv-none-elf-gcc&quot; ## TODO: Check for riscv64-unknown-elf-gcc
switch &quot;riscv64.nuttx.gcc.exe&quot;, &quot;riscv-none-elf-gcc&quot; ## TODO: Check for riscv64-unknown-elf-gcc
## Previously: switch &quot;riscv32.nuttx.gcc.exe&quot;, &quot;riscv64-unknown-elf-gcc&quot;
...
      case arch
      ...
      of &quot;risc-v&quot;:
        ## TODO: Check for riscv32 or riscv3
        ## CONFIG_ARCH_RV32=y or CONFIG_ARCH_RV64=y
        result.arch = &quot;riscv64&quot;
        ## Previously: result.arch = &quot;riscv32&quot;
</code></pre></div>
<p>See the modified files‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files">Changes to NuttX Apps</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files">Changes to NuttX Kernel</a></p>
</li>
</ul>
<h1 id="nim-on-apache-nuttx-rtos-and-ox64-bl808-risc-v-sbc"><a href="#nim-on-apache-nuttx-rtos-and-ox64-bl808-risc-v-sbc">10 Nim on Apache NuttX RTOS and Ox64 BL808 RISC-V SBC</a></h1>
<p>TODO</p>
<p>Nim also runs OK on Apache NuttX RTOS and Ox64 BL808 RISC-V SBC!</p>
<p>This Nim App: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>import std/asyncdispatch
import std/strformat

proc hello_nim() {.exportc, cdecl.} =
  echo &quot;Hello Nim!&quot;
  GC_runOrc()
</code></pre></div>
<p>Produces this output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
ABC
NuttShell (NSH) NuttX-12.0.3
nsh&gt; uname -a
NuttX  12.0.3 d27d0fd4be1-dirty Dec 24 2023 12:32:23 risc-v ox64

nsh&gt; hello_nim
Hello Nim!
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/adef0acd97669cd3570a0614e32166fc">(Source)</a></p>
<p>To build NuttX + Nim for Ox64 BL808 SBC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install choosenim, add to PATH, select latest Dev Version of Nim Compiler
curl https://nim-lang.org/choosenim/init.sh -sSf | sh
export PATH=/home/vscode/.nimble/bin:$PATH
choosenim devel --latest

## Download WIP NuttX and Apps
git clone --branch nim https://github.com/lupyuen2/wip-pinephone-nuttx nuttx
git clone --branch nim https://github.com/lupyuen2/wip-pinephone-nuttx-apps apps

## Configure NuttX for Ox64 BL808 RISC-V SBC
cd nuttx
tools/configure.sh ox64:nsh

## Build NuttX Kernel
make

## Build Apps Filesystem
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd

## Export the Binary Image to `nuttx.bin`
riscv-none-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Copy NuttX Image to Ox64 Linux microSD
cp Image &quot;/Volumes/NO NAME/&quot;
diskutil unmountDisk /dev/disk2

## TODO: Boot Ox64 with the microSD
</code></pre></div>
<p>See the modified files‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files">Changes to NuttX Apps</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files">Changes to NuttX Kernel</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/nim-ox64.png" alt="Nim App runs OK on Apache NuttX Real-Time Operating System and Ox64 BL808 RISC-V SBC" /></p>
<h1 id="blink-an-led-with-nim"><a href="#blink-an-led-with-nim">11 Blink an LED with Nim</a></h1>
<p>TODO</p>
<p>This is how we Blink an LED with Nim on NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>import std/strformat  ## String Formatting

## Import NuttX Functions and Macros from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim
proc c_open(filename: cstring, mode: cint): cint {.
  importc: &quot;open&quot;, header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl.}
proc c_close(fd: cint): cint {.
  importc: &quot;close&quot;, header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl, discardable.}
proc c_ioctl(fd: cint, request: cint): cint {.
  importc: &quot;ioctl&quot;, header: &quot;&lt;sys/ioctl.h&gt;&quot;,
  nodecl, varargs.}
proc c_usleep(usec: cuint): cint {.
  importc: &quot;usleep&quot;, header: &quot;&lt;unistd.h&gt;&quot;,
  nodecl, discardable.}
var O_WRONLY {.
  importc: &quot;O_WRONLY&quot;, header: &quot;&lt;fcntl.h&gt;&quot;.}: cint
var ULEDIOC_SETALL {.
  importc: &quot;ULEDIOC_SETALL&quot;, header: &quot;&lt;nuttx/leds/userled.h&gt;&quot;.}: cint

## Blink the LED
proc blink_led() =

  ## Open the LED Driver
  echo &quot;Opening /dev/userleds&quot;
  let fd = c_open(&quot;/dev/userleds&quot;, O_WRONLY)
  if fd &lt; 0:
    echo &quot;Failed to open /dev/userleds&quot;
    return

  ## On Return: Close the LED Driver
  defer: c_close(fd)

  ## Turn on LED
  echo &quot;Set LED 0 to 1&quot;
  var ret = c_ioctl(fd, ULEDIOC_SETALL, 1)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return

  ## Wait a second (literally)
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)

  ## Turn off LED
  echo &quot;Set LED 0 to 0&quot;
  ret = c_ioctl(fd, ULEDIOC_SETALL, 0)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return

  ## Wait again
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)

## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Print something
  echo &quot;Hello Nim!&quot;

  ## Blink the LED 20 times
  for loop in 0..19:
    blink_led()
</code></pre></div>
<p>Which calls our barebones NuttX LED Driver for Ox64 BL808‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-ox64#led-driver-for-ox64-bl808">‚ÄúLED Driver for Ox64 BL808‚Äù</a></li>
</ul>
<p>And Nim blinks our LED on Ox64 BL808 SBC!</p>
<ul>
<li>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">Watch the Demo on YouTube</a></p>
</li>
<li>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96">See the Log</a></p>
</li>
</ul>
<p><em>How did we figure out the Nim Code?</em></p>
<p>The code above is equivalent to this in C: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello/hello_main.c#L25-L85">hello_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;nuttx/config.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;nuttx/leds/userled.h&gt;

int main(int argc, FAR char *argv[])
{
  printf(&quot;Hello, World!!\n&quot;);

  // Open the LED driver
  printf(&quot;Opening /dev/userleds\n&quot;);
  int fd = open(&quot;/dev/userleds&quot;, O_WRONLY);
  if (fd &lt; 0)
    {
      int errcode = errno;
      printf(&quot;ERROR: Failed to open /dev/userleds: %d\n&quot;,
             errcode);
      return EXIT_FAILURE;
    }

  // Turn on LED
  puts(&quot;Set LED 0 to 1&quot;);
  int ret = ioctl(fd, ULEDIOC_SETALL, 1);
  if (ret &lt; 0)
    {
      int errcode = errno;
      printf(&quot;ERROR: ioctl(ULEDIOC_SUPPORTED) failed: %d\n&quot;,
              errcode);
      return EXIT_FAILURE;
    }

  // Sleep a while
  puts(&quot;Waiting...&quot;);
  usleep(500 * 1000L);

  // Turn off LED
  puts(&quot;Set LED 0 to 0&quot;);
  ret = ioctl(fd, ULEDIOC_SETALL, 0);
  if (ret &lt; 0)
    {
      int errcode = errno;
      printf(&quot;ERROR: ioctl(ULEDIOC_SUPPORTED) failed: %d\n&quot;,
              errcode);
      return EXIT_FAILURE;
    }

  // Close the LED Driver
  close(fd);

  return 0;
}
</code></pre></div><h1 id="build-nuttx-with-debian-container-in-vscode"><a href="#build-nuttx-with-debian-container-in-vscode">12 Build NuttX with Debian Container in VSCode</a></h1>
<p>TODO</p>
<p>Nim Compiler won‚Äôt install on some machines (like a 10-year-old Mac). So we create a Debian Bookworm Container in VSCode that will compile Nim and NuttX‚Ä¶</p>
<ol>
<li>
<p>Install <a href="https://rancherdesktop.io/">Rancher Desktop</a></p>
</li>
<li>
<p>In Rancher Desktop, click ‚ÄúSettings‚Äù‚Ä¶</p>
<p>Set ‚ÄúContainer Engine‚Äù to ‚Äúdockerd (moby)‚Äù</p>
<p>Under ‚ÄúKubernetes‚Äù, uncheck ‚ÄúEnable Kubernetes‚Äù</p>
<p>(To reduce CPU Utilisation)</p>
</li>
<li>
<p>Restart VSCode to use the new PATH</p>
<p>Install the <a href="https://code.visualstudio.com/docs/devcontainers/containers">VSCode Dev Containers Extension</a></p>
</li>
<li>
<p>In VSCode, click the ‚ÄúRemote Explorer‚Äù icon in the Left Bar</p>
</li>
<li>
<p>Under ‚ÄúDev Container‚Äù, click ‚Äú+‚Äù (New Dev Container)</p>
</li>
<li>
<p>Select ‚ÄúNew Dev Container‚Äù</p>
</li>
<li>
<p>Select ‚ÄúDebian‚Äù</p>
</li>
<li>
<p>Select ‚ÄúAdditional Options‚Äù &gt; ‚ÄúBookworm‚Äù</p>
<p>(With other versions of Debian, ‚Äúapt install‚Äù will install outdated packages)</p>
</li>
</ol>
<p>Inside the Debian Bookworm Container:</p>
<p>Install NuttX Prerequisites‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## From https://lupyuen.github.io/articles/nuttx#install-prerequisites
sudo apt update &amp;&amp; sudo apt upgrade
sudo apt install \
  bison flex gettext texinfo libncurses5-dev libncursesw5-dev \
  gperf automake libtool pkg-config build-essential gperf genromfs \
  libgmp-dev libmpc-dev libmpfr-dev libisl-dev binutils-dev libelf-dev \
  libexpat-dev gcc-multilib g++-multilib picocom u-boot-tools util-linux \
  kconfig-frontends

## Extra Tools for RISCV QEMU
sudo apt install xxd
sudo apt install qemu-system-riscv64
</code></pre></div>
<p>Install RISC-V Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download xPack GNU RISC-V Embedded GCC Toolchain for 64-bit RISC-V
wget https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack/releases/download/v13.2.0-2/xpack-riscv-none-elf-gcc-13.2.0-2-linux-x64.tar.gz
tar xf xpack-riscv-none-elf-gcc-13.2.0-2-linux-x64.tar.gz

## Add to PATH
export PATH=$PWD/xpack-riscv-none-elf-gcc-13.2.0-2/bin:$PATH

## Test gcc:
## gcc version 13.2.0 (xPack GNU RISC-V Embedded GCC x86_64) 
riscv-none-elf-gcc -v
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-xpack-gnu-risc-v-embedded-gcc-toolchain-for-64-bit-risc-v">(Why we use xPack Toolchain)</a></p>
<p>Assuming that we need <a href="https://nim-lang.org/install_unix.html">Nim Compiler</a>‚Ä¶</p>
<ol>
<li>
<p>Install <a href="https://nim-lang.org/install_unix.html">Nim Compiler</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>curl https://nim-lang.org/choosenim/init.sh -sSf | sh
</code></pre></div></li>
<li>
<p>Add to PATH‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>export PATH=/home/vscode/.nimble/bin:$PATH
</code></pre></div></li>
<li>
<p>Select Latest Dev Version of Nim‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Will take a while!
choosenim devel --latest
</code></pre></div></li>
<li>
<p>Create a file named <code>a.nim</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>echo &quot;Hello World&quot;
</code></pre></div></li>
<li>
<p>Test Nim‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ nim c a.nim
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/nim.cfg&#39; [Conf]
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/config.nims&#39; [Conf]
.....................................................................
Hint:  [Link]
Hint: mm: orc; threads: on; opt: none (DEBUG BUILD, `-d:release` generates faster code)
27941 lines; 0.342s; 30.445MiB peakmem; proj: /workspaces/debian/a.nim; out: /workspaces/debian/a [SuccessX]

$ ls -l a
-rwxr-xr-x 1 vscode vscode 96480 Dec 22 12:19 a

$ ./a
Hello World
</code></pre></div></li>
</ol>
<p>Git Clone the <code>nuttx</code> and <code>apps</code> folders. Then configure NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: git clone ... nuttx
## TODO: git clone ... apps

## Configure NuttX for QEMU RISC-V (64-bit)
cd nuttx
tools/configure.sh rv-virt:nsh64
make menuconfig
</code></pre></div>
<p>Enable the settings‚Ä¶</p>
<ul>
<li>
<p>‚ÄúDevice Drivers &gt; LED Support &gt; LED Driver‚Äù</p>
</li>
<li>
<p>‚ÄúDevice Drivers &gt; LED Support &gt; Generic Lower Half LED Driver‚Äù</p>
</li>
<li>
<p>‚ÄúApplication Configuration &gt; Examples &gt; Hello World Example (Nim)‚Äù</p>
</li>
<li>
<p>‚ÄúApplication Configuration &gt; Examples &gt; LED Driver Example‚Äù</p>
</li>
</ul>
<p>If we need NuttX Networking: Select‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Networking support: Enable &quot;Networking support&quot;
Networking Support ‚Üí SocketCAN Support:
  Enable &quot;SocketCAN Support&quot;
  Enable &quot;sockopt support&quot;
RTOS Features ‚Üí Tasks and Scheduling:
  Enable &quot;Support parent/child task relationships&quot;
  Enable &quot;Retain child exit status&quot;
</code></pre></div>
<p>Save and exit menuconfig, then build and run NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX
make

## Start NuttX with QEMU RISC-V (64-bit)
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div><h1 id="usleep"><a href="#usleep">13 usleep</a></h1>
<p>TODO</p>
<p>usleep calls clock_nanosleep‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>00000000000007e8 &lt;usleep&gt;:
usleep():
/workspaces/bookworm/nuttx/libs/libc/unistd/lib_usleep.c:100
{
  struct timespec rqtp;
  time_t sec;
  int ret = 0;

  if (usec)
     7e8:	cd15                	beqz	a0,824 &lt;.L3&gt;	7e8: R_RISCV_RVC_BRANCH	.L3

00000000000007ea &lt;.LVL1&gt;:
/workspaces/bookworm/nuttx/libs/libc/unistd/lib_usleep.c:104
    {
      /* Let clock_nanosleep() do all of the work. */

      sec          = usec / 1000000;
     7ea:	000f47b7          	lui	a5,0xf4
     7ee:	2407879b          	addw	a5,a5,576 # f4240 &lt;.LASF110+0xe2ec1&gt;
     7f2:	02f5573b          	divuw	a4,a0,a5
/workspaces/bookworm/nuttx/libs/libc/unistd/lib_usleep.c:95
{
     7f6:	1101                	add	sp,sp,-32
/workspaces/bookworm/nuttx/libs/libc/unistd/lib_usleep.c:108
      rqtp.tv_sec  = sec;
      rqtp.tv_nsec = (usec - (sec * 1000000)) * 1000;

      ret = clock_nanosleep(CLOCK_REALTIME, 0, &amp;rqtp, NULL);
     7f8:	860a                	mv	a2,sp
     7fa:	4681                	li	a3,0
     7fc:	4581                	li	a1,0
</code></pre></div>
<p>clock_nanosleep makes ecall to Kernel clock_nanosleep‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>0000000000001dee &lt;clock_nanosleep&gt;:
clock_nanosleep():
/workspaces/bookworm/nuttx/syscall/proxies/PROXY_clock_nanosleep.c:8
#include &lt;nuttx/config.h&gt;
#include &lt;time.h&gt;
#include &lt;syscall.h&gt;

int clock_nanosleep(clockid_t parm1, int parm2, FAR const struct timespec * parm3, FAR struct timespec * parm4)
{
    1dee:	88aa                	mv	a7,a0

0000000000001df0 &lt;.LVL1&gt;:
    1df0:	882e                	mv	a6,a1

0000000000001df2 &lt;.LVL2&gt;:
    1df2:	87b2                	mv	a5,a2

0000000000001df4 &lt;.LVL3&gt;:
    1df4:	8736                	mv	a4,a3

0000000000001df6 &lt;.LBB4&gt;:
sys_call4():
/workspaces/bookworm/nuttx/include/arch/syscall.h:281
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);
    1df6:	03100513          	li	a0,49

0000000000001dfa &lt;.LVL5&gt;:
/workspaces/bookworm/nuttx/include/arch/syscall.h:282
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
    1dfa:	85c6                	mv	a1,a7

0000000000001dfc &lt;.LVL6&gt;:
/workspaces/bookworm/nuttx/include/arch/syscall.h:283
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
    1dfc:	8642                	mv	a2,a6

0000000000001dfe &lt;.LVL7&gt;:
/workspaces/bookworm/nuttx/include/arch/syscall.h:284
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);
    1dfe:	86be                	mv	a3,a5

0000000000001e00 &lt;.LVL8&gt;:
/workspaces/bookworm/nuttx/include/arch/syscall.h:287
  asm volatile
    1e00:	00000073          	ecall
/workspaces/bookworm/nuttx/include/arch/syscall.h:294
  asm volatile(&quot;nop&quot; : &quot;=r&quot;(r0));
    1e04:	0001                	nop

0000000000001e06 &lt;.LBE4&gt;:
clock_nanosleep():
/workspaces/bookworm/nuttx/syscall/proxies/PROXY_clock_nanosleep.c:10
  return (int)sys_call4((unsigned int)SYS_clock_nanosleep, (uintptr_t)parm1, (uintptr_t)parm2, (uintptr_t)parm3, (uintptr_t)parm4);
}
    1e06:	2501                	sext.w	a0,a0
    1e08:	8082                	ret
</code></pre></div>
<p>System Call Number for clock_nanosleep is 49‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code> &lt;2&gt;&lt;b5b0&gt;: Abbrev Number: 1 (DW_TAG_enumerator)
    &lt;b5b1&gt;   DW_AT_name        : (strp) (offset: 0x8ca9): SYS_clock_nanosleep
    &lt;b5b5&gt;   DW_AT_const_value : (data1) 49
</code></pre></div><h1 id="documentation"><a href="#documentation">14 Documentation</a></h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx-apps/pull/1597">NuttX support for Nim</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21372/files">Nim support for NuttX</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21384">For Nuttx, change ioselectors to use ‚Äúselect‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/issues/8604">Which implementation of NuttX select/poll/EPOLL is recommended in terms of performance and efficiency</a></p>
</li>
<li>
<p><a href="https://disconnected.systems/blog/nim-on-adruino/">Nim on Arduino</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/Nim/blob/devel/doc/nimc.md#nim-for-embedded-systems">Nim for Embedded Systems</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/nimc.html">Nim Compiler User Guide</a></p>
</li>
<li>
<p><a href="https://github.com/mantielero/lvgl.nim">Nim Wrapper for LVGL</a></p>
</li>
</ul>
<h1 id="fix-the-risc-v-timer-with-opensbi"><a href="#fix-the-risc-v-timer-with-opensbi">15 Fix the RISC-V Timer with OpenSBI</a></h1>
<p>TODO</p>
<p><em>The <code>sleep</code> command hangs in NuttX Shell. How to fix it?</em></p>
<p>That‚Äôs because we haven‚Äôt implemented the RISC-V Timer for Ox64! We should call OpenSBI to handle the Timer, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/commit/57ea5f000636f739ac3cb8ea1e60936798f6c3a9#diff-535879ffd6d9fc8e7d84b37a88bdeb1609c4a90e3777150939a96bed18696aee">here‚Äôs the fix</a>.</p>
<p>(Ignore riscv_mtimer.c, we were verifying that mtime and mtimecmp¬†are unused in Kernel Mode)</p>
<p>We only need to change¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L116">arch/risc-v/src/bl808/bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Timer Frequency
#define MTIMER_FREQ 1000000

// This function is called during start-up to initialize the timer interrupt.
void up_timer_initialize(void) {
  struct oneshot_lowerhalf_s *lower = riscv_mtimer_initialize(
    0, 0, RISCV_IRQ_STIMER, MTIMER_FREQ);
  DEBUGASSERT(lower);
  up_alarm_set_lowerhalf(lower);
}
</code></pre></div>
<p>How it works: At startup, <code>up_timer_initialize</code> (above) calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/riscv_mtimer.c#L318-L332">riscv_mtimer_initialize</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/riscv_mtimer.c#L136-L141">riscv_mtimer_set_mtimecmp</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/supervisor/riscv_sbi.c#L94-L107">riscv_sbi_set_timer</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/supervisor/riscv_sbi.c#L53-L76">sbi_ecall</a> which makes an ecall to OpenSBI</p>
</li>
<li>
<p>Which accesses the System Timer</p>
</li>
</ul>
<p>Originally we set¬†MTIMER_FREQ to 10000000:¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 10000000
</code></pre></div>
<p>But this causes the command <code>sleep 1</code> to pause for 10 seconds. So we divide the frequency by 10: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 1000000
</code></pre></div>
<p>Now the <code>sleep</code> command works correctly in NuttX Shell!</p>
<p><a href="https://gist.github.com/lupyuen/8aa66e7f88d1e31a5f198958c15e4393">Here‚Äôs the log (ignore the errors)</a></p>
<h1 id="whats-next"><a href="#whats-next">16 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nim.md"><strong>lupyuen.github.io/src/nim.md</strong></a></p>
<h1 id="appendix-build-nuttx-for-qemu"><a href="#appendix-build-nuttx-for-qemu">17 Appendix: Build NuttX for QEMU</a></h1>
<p>TODO</p>
<h1 id="appendix-build-nuttx-for-ox64"><a href="#appendix-build-nuttx-for-ox64">18 Appendix: Build NuttX for Ox64</a></h1>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">ox64-1</a></p>

    
</body>
</html>