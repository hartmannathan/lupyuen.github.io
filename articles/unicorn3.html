<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Inside Arm64 MMU: Unicorn Emulator vs Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Inside Arm64 MMU: Unicorn Emulator vs Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content="Spotted in Unicorn Emulator: A Demo of Arm64 Memory Management Unit (MMU)... in 18 Lines of Arm64 Assembly! Today we decipher the code inside the Arm64 MMU Demo, figure out how it works. Which turns out to be surprisingly helpful for emulating Apache NuttX RTOS, compiled for Arm64 SBCs."
    data-rh="true">
<meta name="description" 
    content="Spotted in Unicorn Emulator: A Demo of Arm64 Memory Management Unit (MMU)... in 18 Lines of Arm64 Assembly! Today we decipher the code inside the Arm64 MMU Demo, figure out how it works. Which turns out to be surprisingly helpful for emulating Apache NuttX RTOS, compiled for Arm64 SBCs.">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn3-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/unicorn3.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Inside Arm64 MMU: Unicorn Emulator vs Apache NuttX RTOS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#memory-management-unit" title="Memory Management Unit">1 Memory Management Unit</a><ul></ul></li>
<li><a href="#level-1-page-table" title="Level 1 Page Table">2 Level 1 Page Table</a><ul></ul></li>
<li><a href="#page-table-entry" title="Page Table Entry">3 Page Table Entry</a><ul></ul></li>
<li><a href="#translation-control-register" title="Translation Control Register">4 Translation Control Register</a><ul></ul></li>
<li><a href="#enable-the-mmu" title="Enable the MMU">5 Enable the MMU</a><ul></ul></li>
<li><a href="#run-the-mmu-demo" title="Run the MMU Demo">6 Run the MMU Demo</a><ul></ul></li>
<li><a href="#nuttx-crashes-in-unicorn" title="NuttX crashes in Unicorn">7 NuttX crashes in Unicorn</a><ul></ul></li>
<li><a href="#level-1-and-2-page-tables" title="Level 1 and 2 Page Tables">8 Level 1 and 2 Page Tables</a><ul></ul></li>
<li><a href="#translation-control-register-for-nuttx" title="Translation Control Register for NuttX">9 Translation Control Register for NuttX</a><ul></ul></li>
<li><a href="#nuttx-vs-mmu-demo" title="NuttX vs MMU Demo">10 NuttX vs MMU Demo</a><ul></ul></li>
<li><a href="#32-bits-of-virtual-address" title="32 Bits of Virtual Address">11 32 Bits of Virtual Address</a><ul></ul></li>
<li><a href="#nuttx-boot-flow" title="NuttX Boot Flow">12 NuttX Boot Flow</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">13 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-simplified-nuttx-for-qemu" title="Appendix: Simplified NuttX for QEMU">14 Appendix: Simplified NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-decoding-the-bits-with-javascript" title="Appendix: Decoding the Bits with JavaScript">15 Appendix: Decoding the Bits with JavaScript</a><ul></ul></li></ul></nav><p>üìù <em>30 Mar 2025</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn3-title.png" alt="A Demo of Arm64 Memory Management Unit (MMU)‚Ä¶ in 18 Lines of Arm64 Assembly!" /></p>
<p>Spotted in <a href="https://www.unicorn-engine.org/"><strong>Unicorn Emulator</strong></a>: A Demo of <strong>Arm64 Memory Management Unit</strong> (MMU)‚Ä¶ in <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L376-L583"><strong>18 Lines of Arm64 Assembly</strong></a>! <em>(Pic above)</em></p>
<p>Today we decipher the code inside the <strong>Arm64 MMU Demo</strong>, figure out how it works. Which turns out to be surprisingly helpful for emulating <a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX RTOS</strong></a>, compiled for Arm64 SBCs‚Ä¶</p>
<ul>
<li>
<p>We look inside the <strong>Page Tables</strong> and <strong>Control Registers</strong> for MMU Demo</p>
</li>
<li>
<p>Study a mysterious bug that crashes <strong>NuttX on Unicorn Emulator</strong></p>
</li>
<li>
<p>Somehow Unicorn won‚Äôt <strong>Enable the MMU</strong> for NuttX?</p>
</li>
<li>
<p>We simplify <strong>NuttX Kernel for QEMU</strong> and isolate</p>
</li>
<li>
<p>Aha it‚Äôs a problem with the <strong>VM Addressable Size</strong>!</p>
</li>
<li>
<p>Thanks to Unicorn: We render a detailed <strong>NuttX Boot Flow</strong></p>
</li>
<li>
<p>Soon we‚Äôll have a Unicorn Emulator for <strong>Avaota-A1 Arm64 SBC</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn3-mmu.jpg" alt="Arm64 Memory Management Unit" /></p>
<p><em>What‚Äôs this MMU again? (Pic above)</em></p>
<p>We need the Arm64 <strong>Memory Management Unit</strong> for‚Ä¶</p>
<ul>
<li>
<p><strong>Memory Protection</strong>: Prevent Applications <em>(and Kernel)</em> from meddling with things <em>(in System Memory)</em> that they‚Äôre not supposed to</p>
</li>
<li>
<p><strong>Virtual Memory</strong>: Allow Applications to access chunks of <em>‚ÄúImaginary Memory‚Äù</em> at Exotic Addresses <em>(0x8000_0000!)</em></p>
<p>But in reality: They‚Äôre System RAM recycled from boring old addresses <em>(like 0x40A0_4000)</em></p>
</li>
</ul>
<p>If we don‚Äôt configure MMU correctly‚Ä¶</p>
<ul>
<li>
<p><strong>NuttX Kernel</strong> won‚Äôt boot: <em>‚ÄúHelp! I can‚Äôt access my Kernel Code and Data!‚Äù</em></p>
</li>
<li>
<p><strong>NuttX Apps</strong> won‚Äôt run: <em>‚ÄúWhoops where‚Äôs the App Code and Data that Kernel promised?‚Äù</em></p>
</li>
</ul>
<p>We dive deeper inside MMU‚Ä¶</p>
<h1 id="memory-management-unit"><a class="doc-anchor" href="#memory-management-unit">¬ß</a>1 Memory Management Unit</h1>
<p><em>Ah so MMU will allow this switcheroo business?</em></p>
<ol>
<li>
<p><strong>MMU is Disabled</strong> initially</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-mmu2.jpg" alt="Without MMU" /></p>
</li>
<li>
<p>We read from <strong>Physical Address</strong> <em>0x4000_0000</em></p>
</li>
<li>
<p><strong>Enable the MMU</strong>: Map Virtual Address <em>0x8000_0000</em> to Physical Address <em>0x4000_0000</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn3-mmu.jpg" alt="Arm64 Memory Management Unit" /></p>
</li>
<li>
<p>We read from <strong>Virtual Address</strong> <em>0x8000_0000</em></p>
</li>
<li>
<p>Both reads produce <strong>the same value</strong></p>
</li>
</ol>
<p>Indeed! That‚Äôs precisely what our <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L376-L583"><strong>MMU Demo</strong></a> above shall do‚Ä¶</p>
<ol>
<li>
<p>Read from <strong>Physical Address</strong> <em>0x4000_0000</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read data from physical address
// Into Register X1
</span>ldr X0, =<span class="number">0x4000_0000
</span>ldr X1, [X0]</code></pre></div>
</li>
<li>
<p><strong>Map Virtual Address</strong> to Physical Address:</p>
<p><em>0x8000_0000</em> becomes <em>0x4000_0000</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init the MMU Registers
</span>ldr X0, =<span class="number">0x1_8080_3F20
</span>msr TCR_EL1, X0
ldr X0, =<span class="number">0xFFFF_FFFF
</span>msr MAIR_EL1, X0

<span class="comment">// Set the MMU Page Table
</span>adr X0, ttb0_base
msr TTBR0_EL1, X0</code></pre></div>
<p><em>(We‚Äôll explain this)</em></p>
</li>
<li>
<p><strong>Enable the MMU</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Enable Caches and the MMU
</span>mrs X0, SCTLR_EL1
orr X0, X0, #<span class="number">0x1         </span><span class="comment">// M bit (MMU)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// C bit (data cache)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// I bit (instruction cache)
</span>msr SCTLR_EL1, X0
dsb SY
isb</code></pre></div>
<p><em>(We‚Äôll explain this)</em></p>
</li>
<li>
<p>Read from <strong>Virtual Address</strong> <em>0x8000_0000</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read the same Memory Area through Virtual Address
// Into Register X2
</span>ldr X0, =<span class="number">0x8000_0000
</span>ldr X2, [X0]</code></pre></div>
</li>
<li>
<p>Assuming that Physical Address <em>0x4000_0000</em> is filled with <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L503-L519"><em>44 44 44 44 ‚Ä¶</em></a></p>
<p>Both reads will produce <a href="https://gist.github.com/lupyuen/6c8cf74ee68a6f11ca61c2fa3c5573d0"><strong>the same value</strong></a>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Register X1 == Register X2
</span>x1 = <span class="number">0x4444_4444_4444_4444
</span>x2 = <span class="number">0x4444_4444_4444_4444</span></code></pre></div>
</li>
</ol>
<p>Yeah the steps for <em>‚ÄúMap Virtual Address‚Äù</em> and <em>‚ÄúEnable The MMU‚Äù</em> are extremely cryptic. We break them down‚Ä¶</p>
<h1 id="level-1-page-table"><a class="doc-anchor" href="#level-1-page-table">¬ß</a>2 Level 1 Page Table</h1>
<p><em>What‚Äôs this mystery code from above?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init the MMU Registers:
// TCR_EL1 becomes 0x1_8080_3F20
</span>ldr X0, =<span class="number">0x1_8080_3F20  </span><span class="comment">// Load 0x1_8080_3F20 into Register X0
</span>msr TCR_EL1, X0         <span class="comment">// Write X0 into System Register TCR_EL1

// MAIR_EL1 becomes 0xFFFF_FFFF
</span>ldr X0, =<span class="number">0xFFFF_FFFF  </span><span class="comment">// Load 0xFFFF_FFFF into Register X0
</span>msr MAIR_EL1, X0      <span class="comment">// Write X0 into System Register MAIR_EL1

// Set the MMU Page Table:
// TTBR0_EL1 becomes ttb0_base
</span>adr X0, ttb0_base  <span class="comment">// Load ttb0_base into Register X0
</span>msr TTBR0_EL1, X0  <span class="comment">// Write X0 into System Register TTBR0_EL1</span></code></pre></div>
<p>This code will <strong>Map Virtual Addresses</strong> to Physical Addresses, so that <em>0x8000_0000</em> (virtually) becomes <em>0x4000_0000</em>.</p>
<p>Later we‚Äôll explain TCR and MAIR, but first‚Ä¶</p>
<p><em>What‚Äôs TTBR0_EL1? Why set it to ttb0_base?</em></p>
<p>That‚Äôs the <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TTBR0-EL1--Translation-Table-Base-Register-0--EL1-"><strong>Translation Table Base Register 0</strong></a> for Exception Level 1.</p>
<p>It points to the <strong>Level 1 Page Table</strong>, telling MMU our Virtual-to-Physical Mapping. Suppose we‚Äôre mapping <strong>Four Chunks of 1 GB</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center">Virtual Address</th><th style="text-align: center">Physical Address</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>0x0000_0000</code></strong></td><td style="text-align: center"><code>0x0000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0x4000_0000</code></strong></td><td style="text-align: center"><code>0xC000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0x8000_0000</code></strong></td><td style="text-align: center"><code>0x4000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0xC000_0000</code></strong></td><td style="text-align: center"><code>0x8000_0000</code></td><td style="text-align: center">1 GB</td></tr>
</tbody></table>
</div></div>
</p>
<p>Our <strong>Level 1 Page Table</strong> <em>(TTBR0_EL1)</em> will be this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-table1.jpg" alt="Level 1 Page Table" /></p>
<p>Which we <strong>Store in RAM</strong> <em>(ttb0_base)</em> as‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: center">Value</th><th style="text-align: left">Because</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>0x1000</code></strong></td><td style="text-align: center"><code>0x0000_0741</code></td><td style="text-align: left"><em>Page Table Entry #0</em></td></tr>
<tr><td style="text-align: center"><strong><code>0x1008</code></strong></td><td style="text-align: center"><code>0xC000_0741</code></td><td style="text-align: left"><em>Page Table Entry #1</em></td></tr>
<tr><td style="text-align: center"><strong><code>0x1010</code></strong></td><td style="text-align: center"><code>0x4000_0741</code></td><td style="text-align: left"><em>Page Table Entry #2</em></td></tr>
<tr><td style="text-align: center"><strong><code>0x1018</code></strong></td><td style="text-align: center"><code>0x8000_0741</code></td><td style="text-align: left"><em>Page Table Entry #3</em></td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://gist.github.com/lupyuen/6c8cf74ee68a6f11ca61c2fa3c5573d0">(See the <strong>Unicorn Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L376-L583">(And the <strong>Unicorn Code</strong>)</a></p>
<p><em>What if we read from 0x4000_0000 AFTER enabling MMU? (Physical Address 0xC000_0000)</em></p>
<p>We‚Äôll see <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L503-L519"><em>CC CC CC CC‚Ä¶</em></a> because that‚Äôs how we populated Physical Address <em>0xC000_0000</em>. Yep our MMU can remap memory in fun convoluted ways.</p>
<p><em>Why map 0x0000_0000 to itself?</em></p>
<p>Our code runs at <em>0x0000_0000</em>. If we don‚Äôt map <em>0x0000_0000</em> to itself, there won‚Äôt be no runway for our demo.</p>
<p><em>For TTBR0_EL1: Why Exception Level 1?</em></p>
<p>Our code <em>(NuttX Kernel)</em> runs at <a href="https://developer.arm.com/documentation/102412/0103/Privilege-and-Exception-levels/Exception-levels"><strong>Exception Level 1</strong></a>. Later we‚Äôll run NuttX Apps at <strong>Exception Level 0</strong>, which has Less Privilege. That‚Äôs how we protect NuttX Kernel from getting messed up by NuttX Apps.</p>
<h1 id="page-table-entry"><a class="doc-anchor" href="#page-table-entry">¬ß</a>3 Page Table Entry</h1>
<p><em>In the Page Table Entries above: Why 741?</em></p>
<p>We decode the <strong>Page Table Entry</strong> based on <a href="https://developer.arm.com/documentation/ddi0487/latest/"><strong>VMSAv8-64 Block Descriptors</strong></a> <em>(Page D8-6491)</em>. <code>0x741</code> says‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-block.png" alt="VMSAv8-64 Block Descriptors" /></p>
<ul>
<li>
<p><strong>Bits 00-01:</strong> BLOCK_DESC = 1 <br> <em>This Page Table Entry describes a Block, not a Page</em></p>
</li>
<li>
<p><strong>Bits 06-07:</strong> BLOCK_DESC_AP_USER = 1 <br> <em>This Block is Read-Writeable by Kernel, Read-Writeable by Apps</em></p>
</li>
<li>
<p><strong>Bits 08-09:</strong> BLOCK_DESC_INNER_SHARE = 3 <br> <em>This Block is Inner Shareable (see below)</em></p>
</li>
<li>
<p><strong>Bits 10-10:</strong> BLOCK_DESC_AF = 1 <br> <em>Allow this Virtual-to-Physical Mapping to be cached</em></p>
</li>
<li>
<p>Which means each chunk of <strong>Virtual Memory</strong> <em>(like 0x4000_0000)</em> is a Memory Block that‚Äôs accessible by Kernel and Apps</p>
</li>
</ul>
<p>NuttX defines the whole list here: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.h#L95-L122">arm64_mmu.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// PTE descriptor can be Block descriptor or Table descriptor or Page descriptor
#define PTE_BLOCK_DESC              1U
#define PTE_TABLE_DESC              3U

// Block and Page descriptor attributes fields
#define PTE_BLOCK_DESC_MEMTYPE(x)   ((x) &lt;&lt; 2)
#define PTE_BLOCK_DESC_NS           (1ULL &lt;&lt; 5) // Non-Secure
#define PTE_BLOCK_DESC_AP_USER      (1ULL &lt;&lt; 6) // User Read-Write
#define PTE_BLOCK_DESC_AP_RO        (1ULL &lt;&lt; 7) // Kernel Read-Only
#define PTE_BLOCK_DESC_AP_RW        (0ULL &lt;&lt; 7) // Kernel Read-Write
#define PTE_BLOCK_DESC_AP_MASK      (3ULL &lt;&lt; 6)
#define PTE_BLOCK_DESC_NON_SHARE    (0ULL &lt;&lt; 8)
#define PTE_BLOCK_DESC_OUTER_SHARE  (2ULL &lt;&lt; 8)
#define PTE_BLOCK_DESC_INNER_SHARE  (3ULL &lt;&lt; 8)
#define PTE_BLOCK_DESC_AF           (1ULL &lt;&lt; 10) // A Flag
#define PTE_BLOCK_DESC_NG           (1ULL &lt;&lt; 11) // Non-Global
#define PTE_BLOCK_DESC_DIRTY        (1ULL &lt;&lt; 51) // D Flag
#define PTE_BLOCK_DESC_PXN          (1ULL &lt;&lt; 53) // Kernel Execute Never
#define PTE_BLOCK_DESC_UXN          (1ULL &lt;&lt; 54) // User Execute Never</code></pre></div>
<p><em>Why Stage 1? Not Stage 2?</em></p>
<p>We‚Äôre doing <strong>Stage 1 Only</strong>: Single-Stage Translation from <em>Virtual Address (VA)</em> to <em>Physical Address (PA)</em>. No need for Stage 2 and <em>Intermediate Physical Address (IPA)</em> <a href="https://developer.arm.com/documentation/ddi0487/latest/">(Page D8-6448)</a></p>
<p><img src="https://lupyuen.github.io/images/unicorn3-stage.png" alt="Translation Table Walk" /></p>
<p><em>Why Inner vs Outer Shareable? Something about ‚ÄúSeverance‚Äù?</em></p>
<p><strong>Inner / Outer Sharing</strong> is for Multiple CPU Cores, which we‚Äôll ignore for now <a href="https://developer.arm.com/documentation/ddi0487/latest/">(Page B2-293)</a></p>
<p><img src="https://lupyuen.github.io/images/unicorn3-shareable.png" alt="Inner / Outer Sharing" /></p>
<p><a href="https://developer.arm.com/documentation/102404/0202/Common-architecture-terms"><em>(PE = Processing Element = One Arm64 Core)</em></a></p>
<h1 id="translation-control-register"><a class="doc-anchor" href="#translation-control-register">¬ß</a>4 Translation Control Register</h1>
<p><em>What‚Äôs TCR_EL1? Why set it to 0x1_8080_3F20?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init the MMU Registers:
// TCR_EL1 becomes 0x1_8080_3F20
</span>ldr X0, =<span class="number">0x1_8080_3F20  </span><span class="comment">// Load 0x1_8080_3F20 into Register X0
</span>msr TCR_EL1, X0         <span class="comment">// Write X0 into System Register TCR_EL1

// MAIR_EL1 becomes 0xFFFF_FFFF
</span>ldr X0, =<span class="number">0xFFFF_FFFF  </span><span class="comment">// Load 0xFFFF_FFFF into Register X0
</span>msr MAIR_EL1, X0      <span class="comment">// Write X0 into System Register MAIR_EL1</span></code></pre></div>
<p>That‚Äôs the <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>Translation Control Register</strong></a> for Exception Level 1. According to <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>TCR_EL1 Doc</strong></a>, <em>0x1_8080_3F20</em> decodes as‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-tcr.png" alt="Translation Control Register" /></p>
<ul>
<li>
<p><strong>Bits 00-05:</strong> T0SZ = 0x20 <br> <em>32 bits of Virtual Address Space</em></p>
</li>
<li>
<p><strong>Bits 08-09:</strong> IRGN0_WBNWA = 3 <br> <em>Normal memory, Inner Write-Back Read-Allocate No Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 10-11:</strong> ORGN0_WBNWA = 3 <br> <em>Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 12-13:</strong> SH0_SHARED_INNER = 3 <br> <em>Inner Shareable for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 14-15:</strong> TG0_4K = 0 <br> <em>EL1 Granule Size (Page Size) is 4 KB for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 23-23:</strong> EPD1_DISABLE = 1 <br> <em>Perform translation table walks using TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 30-31:</strong> TG1_4K = 2 <br> <em>EL1 Granule Size (Page Size) is 4 KB for TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 32-34:</strong> EL1_IPS = 1 <br> <em>36 bits (64 GB) of Physical Address Space</em></p>
</li>
<li>
<p>Thus our MMU shall map <strong>32-bit Virtual Addresses</strong> into <strong>36-bit Physical Addresses</strong>. Each Physical Address points to a <strong>4 KB Memory Page</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/unicorn3.html#page-table-entry"><em>(We spoke about Innies and Outies earlier)</em></a></p>
<p><a href="https://lupyuen.github.io/articles/unicorn3.html#appendix-decoding-the-bits-with-javascript"><em>(Decoding the Bits with JavaScript)</em></a></p>
</li>
</ul>
<p><em>What about MAIR?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// MAIR_EL1 becomes 0xFFFF_FFFF
</span>ldr X0, =<span class="number">0xFFFF_FFFF  </span><span class="comment">// Load 0xFFFF_FFFF into Register X0
</span>msr MAIR_EL1, X0      <span class="comment">// Write X0 into System Register MAIR_EL1</span></code></pre></div>
<p>Hmmm <em>0xFFFF_FFFF</em> looks kinda fake? Unicorn Emulator probably ignores the <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/MAIR-EL1--Memory-Attribute-Indirection-Register--EL1-"><strong>MAIR Bits</strong></a>. We‚Äôll see a Real MAIR in a while.</p>
<h1 id="enable-the-mmu"><a class="doc-anchor" href="#enable-the-mmu">¬ß</a>5 Enable the MMU</h1>
<p>Wrapping up our Mystery Code: This is how we <strong>Enable the MMU</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read System Register SCTLR_EL1 into X0
</span>mrs X0, SCTLR_EL1

<span class="comment">// In X0: Set the bits to Enable MMU, Data Cache and Instruction Cache
</span>orr X0, X0, #<span class="number">0x1         </span><span class="comment">// M bit (MMU)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// C bit (Data Cache)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// I bit (Instruction Cache)

// Write X0 into System Register SCTLR_EL1
</span>msr SCTLR_EL1, X0

<span class="comment">// Flush the Data Cache and Instruction Cache
</span>dsb SY ; isb</code></pre></div>
<p><em>SCTLR_EL1 is for?</em></p>
<p>The <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/SCTLR-EL1--System-Control-Register--EL1-"><strong>System Control Register</strong></a> in Exception Level 1. We set these bits to <strong>Enable the MMU with Caching</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-sctlr.png" alt="System Control Register" /></p>
<ul>
<li>
<p><strong>Bit 0:</strong> M = 1 <br> <em>Enable MMU for Address Translation</em></p>
</li>
<li>
<p><strong>Bit 2:</strong> C = 1 <br> <em>Enable the Data Cache</em></p>
</li>
<li>
<p><strong>Bit 12:</strong> I = 1 <br> <em>Enable the Instruction Cache</em></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_arch.h#L74-L123">(NuttX defines them in <strong>arm64_arch.h</strong>)</a></p>
</li>
</ul>
<p>We‚Äôre ready to run the demo‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-mmu.jpg" alt="Arm64 Memory Management Unit" /></p>
<h1 id="run-the-mmu-demo"><a class="doc-anchor" href="#run-the-mmu-demo">¬ß</a>6 Run the MMU Demo</h1>
<p>This is how we run the MMU Demo in <strong>Unicorn Emulator</strong>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L376-L451">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Arm64 Machine Code for our MMU Demo, based on https://github.com/unicorn-engine/unicorn/blob/master/tests/unit/test_arm64.c#L378-L486
// Disassembly: https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L556-L583
</span><span class="kw">let </span>arm64_code = [
  <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0xf9</span>, <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x40</span>, <span class="number">0x20</span>, <span class="number">0x18</span>,
  <span class="number">0xd5</span>, <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x00</span>, <span class="number">0xa2</span>, <span class="number">0x18</span>, <span class="number">0xd5</span>, <span class="number">0x40</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x20</span>,
  <span class="number">0x18</span>, <span class="number">0xd5</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x38</span>, <span class="number">0xd5</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7e</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>,
  <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x18</span>, <span class="number">0xd5</span>, <span class="number">0x9f</span>, <span class="number">0x3f</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>, <span class="number">0xdf</span>, <span class="number">0x3f</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>,
  <span class="number">0xe0</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0xf9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x1f</span>, <span class="number">0x20</span>, <span class="number">0x03</span>,
  <span class="number">0xd5</span>, <span class="number">0x1f</span>, <span class="number">0x20</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>, <span class="number">0x1F</span>, <span class="number">0x20</span>, <span class="number">0x03</span>, <span class="number">0xD5</span>, <span class="number">0x1F</span>, <span class="number">0x20</span>, <span class="number">0x03</span>, <span class="number">0xD5</span>,       
];

<span class="comment">// Init the Emulator in Arm64 mode
</span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
  Arch::ARM64,
  Mode::LITTLE_ENDIAN
).expect(<span class="string">"failed to init Unicorn"</span>);

<span class="comment">// Enable the MMU Translation
</span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;
emu.ctl_tlb_type(unicorn_engine::TlbType::CPU).unwrap();

<span class="comment">// Map the Read/Write/Execute Memory at 0x0000 0000
</span>emu.mem_map(
  <span class="number">0</span>,       <span class="comment">// Address
  </span><span class="number">0x2000</span>,  <span class="comment">// Size
  </span>Permission::ALL  <span class="comment">// Read/Write/Execute Access
</span>).expect(<span class="string">"failed to map memory"</span>);

<span class="comment">// Write the Arm64 Machine Code to the emulated Executable Memory
</span><span class="kw">const </span>ADDRESS: u64 = <span class="number">0</span>;
emu.mem_write(
  ADDRESS, 
  <span class="kw-2">&amp;</span>arm64_code
).expect(<span class="string">"failed to write instructions"</span>);</code></pre></div>
<p>We populate the <a href="https://lupyuen.github.io/articles/unicorn3.html#level-1-page-table"><strong>Level 1 Page Table</strong></a> from earlier: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L451-L503">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Generate the Page Table Entries...
// Page Table Entry @ 0x1000: 0x0000_0741
// Physical Address: 0x0000_0000
// Bit 00-01: PTE_BLOCK_DESC=1
// Bit 06-07: PTE_BLOCK_DESC_AP_USER=1
// Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
// Bit 10:    PTE_BLOCK_DESC_AF=1  
</span><span class="kw">let </span><span class="kw-2">mut </span>tlbe: [u8; <span class="number">8</span>] = [<span class="number">0</span>; <span class="number">8</span>];
tlbe[<span class="number">0</span>..<span class="number">2</span>].copy_from_slice(<span class="kw-2">&amp;</span>[<span class="number">0x41</span>, <span class="number">0x07</span>]);
emu.mem_write(<span class="number">0x1000</span>, <span class="kw-2">&amp;</span>tlbe).unwrap();

<span class="comment">// Page Table Entry @ 0x1008: 0xC000_0741
// Page Table Entry @ 0x1010: 0x4000_0741
// Page Table Entry @ 0x1018: 0x8000_0741
</span>...

<span class="comment">// Not the Page Table, but
// Data Referenced by our Assembly Code:
// Data @ 0x1020: 0x4000_0000
</span>tlbe[<span class="number">0</span>..<span class="number">4</span>].copy_from_slice(<span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>]);
emu.mem_write(<span class="number">0x1020</span>, <span class="kw-2">&amp;</span>tlbe).unwrap();

<span class="comment">// Data @ 0x1028: 0x1_8080_3F20
// Data @ 0x1030: 0xFFFF_FFFF
// Data @ 0x1038: 0x8000_0000
</span>...</code></pre></div>
<p>To verify that it works: We <strong>Fill the Physical Memory</strong> with <em>0x44</em> then <em>0x88</em> then <em>0xCC</em>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L503-L519">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 3 Chunks of Data filled with 0x44, 0x88, 0xCC respectively
</span><span class="kw">let </span><span class="kw-2">mut </span>data:  [u8; <span class="number">0x1000</span>] = [<span class="number">0x44</span>; <span class="number">0x1000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>data2: [u8; <span class="number">0x1000</span>] = [<span class="number">0x88</span>; <span class="number">0x1000</span>];
<span class="kw">let </span><span class="kw-2">mut </span>data3: [u8; <span class="number">0x1000</span>] = [<span class="number">0xcc</span>; <span class="number">0x1000</span>];

<span class="comment">// 0x4000_0000 becomes 0x44 44 44 44...
// 0x8000_0000 becomes 0x88 88 88 88...
// 0xC000_0000 becomes 0xCC CC CC CC...
</span>emu.mem_map_ptr(<span class="number">0x40000000</span>, <span class="number">0x1000</span>, Permission::READ,
  data.as_mut_ptr() <span class="kw">as _</span>).unwrap();
emu.mem_map_ptr(<span class="number">0x80000000</span>, <span class="number">0x1000</span>, Permission::READ,
  data2.as_mut_ptr() <span class="kw">as _</span>).unwrap();
emu.mem_map_ptr(<span class="number">0xc0000000</span>, <span class="number">0x1000</span>, Permission::READ,
  data3.as_mut_ptr() <span class="kw">as _</span>).unwrap();</code></pre></div>
<p>Finally we <strong>Start the Emulator</strong>: <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L519-L539">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Start the Unicorn Emulator
</span><span class="kw">let </span>err = emu.emu_start(<span class="number">0</span>, <span class="number">0x44</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">println!</span>(<span class="string">"err={:?}"</span>, err);

<span class="comment">// Read registers X0, X1, X2
</span><span class="kw">let </span>x0 = emu.reg_read(RegisterARM64::X0).unwrap();
<span class="kw">let </span>x1 = emu.reg_read(RegisterARM64::X1).unwrap();
<span class="kw">let </span>x2 = emu.reg_read(RegisterARM64::X2).unwrap();

<span class="comment">// Check the values
</span><span class="macro">assert!</span>(x0 == <span class="number">0x80000000</span>);
<span class="macro">assert!</span>(x1 == <span class="number">0x4444444444444444</span>);
<span class="macro">assert!</span>(x2 == <span class="number">0x4444444444444444</span>);</code></pre></div>
<p>And it works!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Here are Registers X0, X1 and X2
err = Ok(())
x0  = 0x8000_0000
x1  = 0x4444_4444_4444_4444
x2  = 0x4444_4444_4444_4444</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6c8cf74ee68a6f11ca61c2fa3c5573d0">(See the <strong>Unicorn Log</strong>)</a></p>
<h1 id="nuttx-crashes-in-unicorn"><a class="doc-anchor" href="#nuttx-crashes-in-unicorn">¬ß</a>7 NuttX crashes in Unicorn</h1>
<p><em>What‚Äôs Unicorn Emulator got to do with Apache NuttX RTOS?</em></p>
<p>Two Years Ago: We tried creating a <a href="https://lupyuen.github.io/articles/unicorn.html"><strong>PinePhone Emulator</strong></a> with NuttX and Unicorn. But NuttX kept crashing on Unicorn‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Simplified NuttX for QEMU Arm64 (Kernel Build)
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch unicorn-qemu-before
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch unicorn-qemu
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## NuttX boots OK on QEMU.
## NSH Shell won&#39;t appear yet because we haven&#39;t compiled the NuttX Apps.
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx

## But NuttX crashes in Unicorn Emulator (Remember to Disable MMU Logging)
## Here&#39;s the funny thing: Unicorn is actually based on QEMU!
git clone https://github.com/lupyuen/nuttx-arm64-emulator --branch qemu \
  $HOME/nuttx-arm64-emulator
cp nuttx nuttx.bin nuttx.S \
  $HOME/nuttx-arm64-emulator/nuttx/
cd $HOME/nuttx-arm64-emulator
cargo run

## err=Err(EXCEPTION)
## PC=0x402805f0
## call_graph:  setup_page_tables --&gt; ***_HALT_***
## call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
## env.exception = { syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1 }</code></pre></div>
<p>Two Years Later: The bug stops here! Let‚Äôs fix it today.</p>
<p><em>Where does it crash?</em></p>
<p>According to <a href="https://gist.github.com/lupyuen/67b8dc6f83cb39c0bc6d622f24b96cc1#file-gistfile1-txt-L1731-L1754"><strong>Unicorn Log</strong></a>: Our <a href="https://lupyuen.github.io/articles/unicorn3.html#appendix-simplified-nuttx-for-qemu"><strong>Simplified NuttX</strong></a> crashes here in Unicorn Emulator: <a href="https://github.com/lupyuen2/wip-nuttx/blob/unicorn-qemu/arch/arm64/src/common/arm64_mmu.c#L635-L661">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX enables the MMU for Exception Level 1
static void enable_mmu_el1(unsigned int flags) {

  // Set the MAIR, TCR and TTBR registers
  write_sysreg(MEMORY_ATTRIBUTES, mair_el1);
  write_sysreg(get_tcr(1), tcr_el1);
  write_sysreg(base_xlat_table, ttbr0_el1);

  // Ensure the above updates are committed
  // before we enable the MMU: `dsb sy ; isb`
  UP_MB();

  // Read the System Control Register (Exception Level 1)
  uint64_t value = read_sysreg(sctlr_el1);

  // Update the System Control Register (Exception Level 1)
  // Enable the MMU, Data Cache and Instruction Cache
  write_sysreg(
    value 
    | (1 &lt;&lt;  0)  // Set Bit 00: M_BIT (Enable MMU)
    | (1 &lt;&lt;  2)  // Set Bit 02: C_BIT (Enable Data Cache)
    | (1 &lt;&lt; 12), // Set Bit 12: I_BIT (Enable Instruction Cache)
    sctlr_el1
  );

  // Oops! Unicorn Emulator fails with an Arm64 Exception
  // syndrome = 2248146949, fsr = 517, vaddress = 1344798719, target_el = 1</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_arch.h#L74-L123">(NuttX defines SCTLR_EL1 in <strong>arm64_arch.h</strong>)</a></p>
<p>Which is mighty similar to the <a href="https://lupyuen.github.io/articles/unicorn3.html#enable-the-mmu"><strong>MMU Demo</strong></a> that we saw earlier‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// MMU Demo Works OK:
// Read System Register SCTLR_EL1 into X0
</span>mrs X0, SCTLR_EL1

<span class="comment">// In X0: Set the bits to Enable MMU, Data Cache and Instruction Cache
</span>orr X0, X0, #<span class="number">0x1         </span><span class="comment">// M bit (MMU)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// C bit (Data Cache)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// I bit (Instruction Cache)

// Write X0 into System Register SCTLR_EL1
</span>msr SCTLR_EL1, X0</code></pre></div>
<p>Maybe our Page Tables are bad? Or Translation Control Register? We investigate‚Ä¶</p>
<h1 id="level-1-and-2-page-tables"><a class="doc-anchor" href="#level-1-and-2-page-tables">¬ß</a>8 Level 1 and 2 Page Tables</h1>
<p>NuttX on Unicorn Emulator will fail with this <a href="https://gist.github.com/lupyuen/67b8dc6f83cb39c0bc6d622f24b96cc1#file-gistfile1-txt-L1731-L1754"><strong>Arm64 Exception</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>env.exception =
  Syndrome:        0x8600_0005
  FSR:             0x0000_0205
  Virtual Address: 0x5027_ffff (Why?)
  Target Exception Level: 1</code></pre></div>
<p>Which means: <a href="https://github.com/lupyuen/nuttx-arm64-emulator?#arm64-mmu-exception"><strong>‚ÄúOops! Can‚Äôt enable MMU‚Äù</strong></a></p>
<p>To troubleshoot, we enable <strong>MMU Logging</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/blob/unicorn-qemu-before/arch/arm64/src/common/arm64_mmu.c#L54-L61">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable MMU Logging
#define CONFIG_MMU_ASSERT   1
#define CONFIG_MMU_DEBUG    1
#define CONFIG_MMU_DUMP_PTE 1
#define trace_printf _info
#undef sinfo
#define sinfo _info</code></pre></div>
<p>We simplify the <strong>Memory Regions</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/blob/unicorn-qemu/arch/arm64/src/qemu/qemu_boot.c#L59-L89">qemu_boot.c</a></p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center">Virtual Address</th><th style="text-align: center">Physical Address</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>0x0000_0000</code></strong></td><td style="text-align: center"><code>0x0000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0x4000_0000</code></strong></td><td style="text-align: center"><code>0x4000_0000</code></td><td style="text-align: center">8 MB</td></tr>
</tbody></table>
</div></div>
</p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Memory Regions for Arm64 MMU (Simplified)
struct arm_mmu_region g_mmu_regions[] = {

  // Memory Region for I/O Memory
  MMU_REGION_FLAT_ENTRY(
    &quot;DEVICE_REGION&quot;,  // Name
    0x0000_0000,      // Start Address
    0x4000_0000,      // Size: 1 GB
    MT_DEVICE_NGNRNE | MT_RW),  // Read-Write I/O Memory

  // Memory Region for RAM
  MMU_REGION_FLAT_ENTRY(
    &quot;DRAM0_S0&quot;,   // Name
    0x4000_0000,  // Start Address
    0x0080_0000,  // Size: 8 MB
    MT_NORMAL | MT_RW | MT_EXECUTE),  // Allow Read, Write and Execute

};  // Other Memory Regions? We removed them all</code></pre></div>
<p>According to <a href="https://gist.github.com/lupyuen/b9d23fe902c097debc53b3926920045a#file-gistfile1-txt-L78-L884"><strong>NuttX QEMU Log</strong></a>: NuttX creates a <strong>Two-Level Page Table</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-table2.jpg" alt="Level 1 Page Table for NuttX" /></p>
<p><a href="https://developer.arm.com/documentation/102376/0200/Permissions/Execution-permissions"><em>(PXN / UXN = Privileged / User Never-Execute)</em></a></p>
<p>Why Two Levels? Because we‚Äôre mapping <strong>8 MB of RAM</strong>, instead of a Complete 1 GB Chunk. Thus we break up into Level 2 with <strong>Smaller 2 MB Chunks</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-table3.jpg" alt="Level 2 Page Table for NuttX" /></p>
<p>Looks legit, we move on‚Ä¶</p>
<h1 id="translation-control-register-for-nuttx"><a class="doc-anchor" href="#translation-control-register-for-nuttx">¬ß</a>9 Translation Control Register for NuttX</h1>
<p><em>What about the Translation Control Register?</em></p>
<p>We check the <a href="https://gist.github.com/lupyuen/b9d23fe902c097debc53b3926920045a#file-gistfile1-txt-L78-L884"><strong>NuttX QEMU Log</strong></a>, with <a href="https://lupyuen.github.io/articles/unicorn3.html#level-1-and-2-page-tables"><strong>MMU Logging Enabled</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>get_tcr: Virtual Address Bits: 36
get_tcr: Bit 32-33: TCR_EL1_IPS=1
get_tcr: Bit 23:    TCR_EPD1_DISABLE=1
get_tcr: Bit 00-05: TCR_T0SZ=0x1c
get_tcr: Bit 08-09: TCR_IRGN_WBWA=1
get_tcr: Bit 10-11: TCR_ORGN_WBWA=1
get_tcr: Bit 12-13: TCR_SHARED_INNER=3
get_tcr: Bit 14-15: TCR_TG0_4K=0
get_tcr: Bit 30-31: TCR_TG1_4K=2
get_tcr: Bit 37-38: TCR_TBI_FLAGS=0

enable_mmu_el1: tcr_el1   = 0x1_8080_351C
enable_mmu_el1: mair_el1  = 0xFF_440C_0400
enable_mmu_el1: ttbr0_el1 = 0x402B_2000</code></pre></div>
<p>According to <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>TCR_EL1 Doc</strong></a>, <em>0x1_8080_351C</em> decodes as‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-tcr.png" alt="Translation Control Register for NuttX" /></p>
<ul>
<li>
<p><strong>Bits 00-05:</strong> T0SZ = 0x1C <br> <em>36 bits of Virtual Address Space</em></p>
</li>
<li>
<p><strong>Bits 08-09:</strong> IRGN0_WBWA = 1 <br> <em>Normal memory, Inner Write-Back Read-Allocate Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 10-11:</strong> ORGN0_WBWA = 1 <br> <em>Normal memory, Outer Write-Back Read-Allocate Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 12-13:</strong> SH0_SHARED_INNER = 3 <br> <em>Inner Shareable for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 14-15:</strong> TG0_4K = 0 <br> <em>EL1 Granule Size (Page Size) is 4 KB for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 23-23:</strong> EPD1_DISABLE = 1 <br> <em>Perform translation table walks using TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 30-31:</strong> TG1_4K = 2 <br> <em>EL1 Granule Size (Page Size) is 4 KB for TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 32-34:</strong> EL1_IPS = 1 <br> <em>36 bits (64 GB) of Physical Address Space</em></p>
</li>
</ul>
<p>Hmmm something looks different‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/unicorn3.html#page-table-entry"><em>(We spoke about Innies and Outies earlier)</em></a></p>
<p><a href="https://lupyuen.github.io/articles/unicorn3.html#appendix-decoding-the-bits-with-javascript"><em>(Decoding the Bits with JavaScript)</em></a></p>
<h1 id="nuttx-vs-mmu-demo"><a class="doc-anchor" href="#nuttx-vs-mmu-demo">¬ß</a>10 NuttX vs MMU Demo</h1>
<p><em>MMU Demo works OK, but NuttX doesn‚Äôt. How are they different?</em></p>
<p>Based on the info above, we compare <strong>NuttX vs MMU Demo</strong> for the Translation Control Register‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left">NuttX QEMU</th><th style="text-align: left">MMU Demo</th></tr></thead><tbody>
<tr><td style="text-align: left"><hr> T0SZ = 0x1C <br> <em>36 bits of Virtual Address Space</em></td><td style="text-align: left"><hr> T0SZ = 0x20 <br> <em>32 bits of Virtual Address Space</em></td></tr>
<tr><td style="text-align: left"><hr> IRGN0_WBWA = 1 <br> <em>Write-Allocate Cacheable (Inner)</em></td><td style="text-align: left"><hr> IRGN0_WBNWA = 3 <br> <em>No Write-Allocate Cacheable (Inner)</em></td></tr>
<tr><td style="text-align: left"><hr> ORGN0_WBWA = 1 <br> <em>Write-Allocate Cacheable (Outer)</em></td><td style="text-align: left"><hr> ORGN0_WBNWA = 3 <br> <em>No Write-Allocate Cacheable (Outer)</em></td></tr>
<tr><td style="text-align: left"><hr> Won‚Äôt Boot On Unicorn</td><td style="text-align: left"><hr> Works OK On Unicorn</td></tr>
</tbody></table>
</div></div>
</p>
<p>Ah we see a major discrepancy‚Ä¶</p>
<ul>
<li>
<p><strong>Virtual Address:</strong> NuttX uses <strong>36 Bits</strong>, MMU Demo uses <strong>32 Bits</strong></p>
</li>
<li>
<p><strong>Inner / Outer Caching?</strong> Probably won‚Äôt matter for our Unicorn Emulator</p>
</li>
<li>
<p>Though truthfully: We already made <a href="https://lupyuen.github.io/articles/unicorn3.html#appendix-simplified-nuttx-for-qemu"><strong>plenty of fixes</strong></a></p>
</li>
</ul>
<p>We fix the Virtual Addresses‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-bootflow2.png" alt="NuttX Boot Flow with MMU Enabled" /></p>
<h1 id="32-bits-of-virtual-address"><a class="doc-anchor" href="#32-bits-of-virtual-address">¬ß</a>11 32 Bits of Virtual Address</h1>
<p>Remember NuttX was using 36 Bits for <strong>Virtual Address Space</strong>? We cut down to <strong>32 Bits</strong>: <a href="https://github.com/apache/nuttx/commit/ce18a505fb295fc95167f505261f060c7601ce61">knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the Virtual Address Space to 32 bits
CONFIG_ARM64_VA_BITS=32

## Previously: Virtual Address Space was 36 bits
## CONFIG_ARM64_VA_BITS=36</code></pre></div>
<p>Inside <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>Translation Control Register</strong></a> (TCR_EL1): <strong>T0SZ</strong> becomes 32 bits‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>get_tcr: Virtual Address Bits: 32
get_tcr: Bit 32-33: TCR_EL1_IPS=1
get_tcr: Bit 23:    TCR_EPD1_DISABLE=1
get_tcr: Bit 00-05: TCR_T0SZ=0x20
get_tcr: Bit 08-09: TCR_IRGN_WBWA=1
get_tcr: Bit 10-11: TCR_ORGN_WBWA=1
get_tcr: Bit 12-13: TCR_SHARED_INNER=3
get_tcr: Bit 14-15: TCR_TG0_4K=0
get_tcr: Bit 30-31: TCR_TG1_4K=2
get_tcr: Bit 37-38: TCR_TBI_FLAGS=0

enable_mmu_el1: tcr_el1   = 0x1_8080_3520
enable_mmu_el1: mair_el1  = 0xFF_440C_0400
enable_mmu_el1: ttbr0_el1 = 0x402B_2000</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f66c93314c5b081c1d2fc4bb1027163e#file-gistfile1-txt-L869-L884">(See the <strong>QEMU Log</strong>)</a></p>
<p>NuttX now <strong>enables MMU successfully</strong> in Unicorn yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-bash"><code>hook_block:  address=0x402805a4, size=08, setup_page_tables, arch/arm64/src/common/arm64_mmu.c:547:29
call_graph:  enable_mmu_el1 --&gt; setup_page_tables
call_graph:  click enable_mmu_el1 href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L616&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
hook_block:  address=0x40280614, size=16, enable_mmu_el1, arch/arm64/src/common/arm64_mmu.c:608:3
call_graph:  setup_page_tables --&gt; enable_mmu_el1
call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
hook_block:  address=0x4028062c, size=04, enable_mmu_el1, arch/arm64/src/common/arm64_mmu.c:617:3
hook_block:  address=0x40280380, size=88, arm64_boot_el1_init, arch/arm64/src/common/arm64_boot.c:215:1
call_graph:  enable_mmu_el1 --&gt; arm64_boot_el1_init</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f9648b37c2b94ec270946c35c1e83c20#file-gistfile1-txt-L627-L635">(See the <strong>Unicorn Log</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/unicorn3-table.png" alt="Arm64 Page Tables" /></p>
<p><em>Reducing Virtual Addresses from 36 Bits to 32 Bits: Why did it work?</em></p>
<p>Needs More Investigation: Maybe NuttX didn‚Äôt populate the Page Tables completely for 36 Bits? <em>(Something about 0x5027_FFFF?)</em></p>
<p>For Now: 32-bit Virtual Addresses are totally sufficient. And NuttX boots OK on Unicorn!</p>
<p><a href="https://github.com/unicorn-engine/unicorn/blob/master/qemu/target/arm/helper.c#L10978-L11172">(<strong>MMU Translation Logic</strong> inside Unicorn)</a></p>
<p><em>Why are we doing all this: NuttX on Unicorn?</em></p>
<p>We‚Äôre about to create a <strong>NuttX Emulator</strong> for <a href="https://lupyuen.github.io/articles/avaota"><strong>Avaota-A1 Arm64 SBC</strong></a> (Allwinner A527), based on Unicorn Emulator. So that we can Build and Test NuttX on the Avaota-A1 Emulator, without requiring the Actual Hardware. <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/avaota/nuttx-boot-flow.pdf">(<strong>NuttX Boot Flow</strong> for Avaota-A1)</a></p>
<p><em>After switching to 32-bit Virtual Address: Any change to the Page Tables?</em></p>
<p>The Page Tables <a href="https://gist.github.com/lupyuen/f66c93314c5b081c1d2fc4bb1027163e#file-gistfile1-txt-L78-L884"><strong>are identical</strong></a>. Thanks to Unicorn, we learnt so much about <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c"><strong>arm64_mmu.c</strong></a>! One more fun thing to do‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-bootflow.jpg" alt="NuttX Boot Flow" /></p>
<h1 id="nuttx-boot-flow"><a class="doc-anchor" href="#nuttx-boot-flow">¬ß</a>12 NuttX Boot Flow</h1>
<p><em>Inside the Unicorn Log: Why the funny arrows?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>call_graph:  enable_mmu_el1 --&gt; setup_page_tables
call_graph:  click enable_mmu_el1 href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L616&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
call_graph:  setup_page_tables --&gt; enable_mmu_el1
call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
call_graph:  enable_mmu_el1 --&gt; arm64_boot_el1_init</code></pre></div>
<p>That‚Äôs because our Unicorn Emulator renders the <strong>NuttX Boot Flow</strong> (pic above) as a Clickable Mermaid Flowchart. It describes how NuttX boots on Arm64‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/nuttx-boot-flow.pdf"><strong>Download the PDF</strong></a> / <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/nuttx-boot-flow.png"><strong>PNG</strong></a> / <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/nuttx-boot-flow.svg"><strong>SVG</strong></a></li>
</ul>
<p>Here are the steps to produce the <strong>Mermaid Flowchart</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot NuttX in Unicorn Emulator. Capture the Mermaid Flowchart.
git clone https://github.com/lupyuen/nuttx-arm64-emulator --branch qemu \
  $HOME/nuttx-arm64-emulator
cd $HOME/nuttx-arm64-emulator
cargo run | grep call_graph | colrm 1 13 \
  &gt;$HOME/nuttx-arm64-emulator/nuttx-boot-flow.mmd

## Omitted: Clean up the bad syntax in nuttx-boot-flow.mmd
vi $HOME/nuttx-arm64-emulator/nuttx-boot-flow.mmd

## Convert the Mermaid Flowchart to PDF
sudo docker pull minlag/mermaid-cli
sudo docker run \
  --rm -u `id -u`:`id -g` -v \
  $HOME/nuttx-arm64-emulator:/data minlag/mermaid-cli \
  --configFile=&quot;mermaidRenderConfig.json&quot; \
  -i nuttx-boot-flow.mmd \
  -o nuttx-boot-flow.pdf

## Then change &quot;.pdf&quot; above to &quot;.png&quot; or &quot;.svg&quot;</code></pre></div>
<p><a href="https://raw.githubusercontent.com/lupyuen/nuttx-arm64-emulator/refs/heads/qemu/nuttx-boot-flow.mmd">(<strong>nuttx-boot-flow.mmd</strong> is here)</a></p>
<p>How did we create the Mermaid Flowchart? Check the details here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2.html"><strong>‚Äú(Clickable) Call Graph for Apache NuttX Real-Time Operating System‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn3-bootflow3.png" alt="Unicorn is stuck forever in PL011 UART Driver" /></p>
<p><em>Why won‚Äôt Unicorn boot to NSH Shell?</em></p>
<p>We haven‚Äôt emulated the <a href="https://github.com/lupyuen/nuttx-arm64-emulator/blob/qemu/src/main.rs#L70-L76"><strong>PL011 UART Hardware</strong></a>, that‚Äôs why Unicorn is looping forever while printing System Messages. Hope to fix it someday! (Pic above)</p>
<p><em>That should keep us busy for a loooong while?</em></p>
<p>One Last Thing: Suppose we‚Äôre in some Wacky Alternate Universe in which Rust was invented before C. What would <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c"><strong>arm64_mmu.c</strong></a> look like? Might be fun to take a peek at the Alternate Version of <em>arm64_mmu.c</em> ü§î</p>
<p><img src="https://lupyuen.github.io/images/unicorn3-avaota.jpg" alt="Unicorn Emulator for Avaota-A1 SBC" /></p>
<p><a href="https://github.com/lupyuen/nuttx-arm64-emulator/tree/avaota"><em>Unicorn Emulator for Avaota-A1 SBC</em></a></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>13 What‚Äôs Next</h1>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=43517823"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-starpro64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for StarPro64 EIC7700X‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Other Project: ‚ÄúNuttX for Oz64 SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>Older Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/unicorn3.md"><strong>lupyuen.org/src/unicorn3.md</strong></a></p>
<h1 id="appendix-simplified-nuttx-for-qemu"><a class="doc-anchor" href="#appendix-simplified-nuttx-for-qemu">¬ß</a>14 Appendix: Simplified NuttX for QEMU</h1>
<p>In this article we took <strong>NuttX for QEMU Arm64</strong> (Kernel Build) and made it smaller and simpler.</p>
<p>Why did we <strong>Simplify NuttX</strong>? So we can be as close to MMU Demo as possible, and isolate the crashing problem. This is how we Build and Test our simpler version of <strong>NuttX for QEMU Arm64</strong> (Kernel Build)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Before Fixing: Compile Simplified NuttX for QEMU Arm64 (Kernel Build)
git clone https://github.com/lupyuen2/wip-nuttx nuttx \
  --branch unicorn-qemu-before
git clone https://github.com/lupyuen2/wip-nuttx-apps apps \
  --branch unicorn-qemu
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## NuttX boots OK on QEMU.
## NSH Shell won&#39;t appear yet because we haven&#39;t compiled the NuttX Apps.
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx

## But NuttX crashes in Unicorn Emulator.
## Remember to Disable MMU Logging.
git clone https://github.com/lupyuen/nuttx-arm64-emulator --branch qemu \
  $HOME/nuttx-arm64-emulator
cp nuttx nuttx.bin nuttx.S \
  $HOME/nuttx-arm64-emulator/nuttx/
cd $HOME/nuttx-arm64-emulator
cargo run

## err=Err(EXCEPTION)
## PC=0x402805f0
## call_graph:  setup_page_tables --&gt; ***_HALT_***
## call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
## env.exception={syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/67b8dc6f83cb39c0bc6d622f24b96cc1">(Before Fix: Unicorn Log)</a></p>
<p><a href="https://gist.github.com/lupyuen/b9d23fe902c097debc53b3926920045a#file-gistfile1-txt-L78-L884">(Before Fix: QEMU Log)</a></p>
<p>To fix the crashing bug, we reduced the <strong>Virtual Address Size</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn3.html#32-bits-of-virtual-address"><strong>‚Äú32 Bits of Virtual Address‚Äù</strong></a></li>
</ul>
<p>The <strong>Fixed Version</strong> (that won‚Äôt crash in Unicorn) is here‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## After Fixing: Simplified NuttX for QEMU Arm64 (Kernel Build)
git clone https://github.com/lupyuen2/wip-nuttx nuttx \
  --branch unicorn-qemu-after
git clone https://github.com/lupyuen2/wip-nuttx-apps apps \
  --branch unicorn-qemu</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f9648b37c2b94ec270946c35c1e83c20">(After Fix: Unicorn Log)</a></p>
<p><a href="https://gist.github.com/lupyuen/f66c93314c5b081c1d2fc4bb1027163e#file-gistfile1-txt-L78-L884">(After Fix: QEMU Log)</a></p>
<p><strong>For QEMU Testing:</strong> Enable MMU Logging by uncommenting the lines below.</p>
<p><strong>For Unicorn Emulator:</strong> Don‚Äôt enable MMU Logging, because the PL011 UART Driver will get stuck. Comment out the lines below.</p>
<p>From <a href="https://github.com/lupyuen2/wip-nuttx/blob/unicorn-qemu-before/arch/arm64/src/common/arm64_mmu.c#L54-L61">arch/arm64/src/common/arm64_mmu.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>// Enable MMU Logging
#define CONFIG_MMU_ASSERT   1
#define CONFIG_MMU_DEBUG    1
#define CONFIG_MMU_DUMP_PTE 1
#define trace_printf _info
#undef sinfo
#define sinfo _info</code></pre></div>
<p>Here‚Äôs the <a href="https://github.com/lupyuen2/wip-nuttx/pull/103/commits"><strong>Complete List of Changes</strong></a> for our Simplified NuttX. Below are the highlights‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/b024360cc3e4018ed3e80c60add1ea6a205d52b5"><strong>Remove the MMU Regions: PCI*, nx*</strong></a></p>
<p><em>(Simplify the Memory Map)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/5ac9404d0a3a8f40d252a8bc8e926736add1865a"><strong>Set the RAM Size to 8 MB</strong></a></p>
<p><em>(Simplify the Page Tables)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/19107b4f253d5c0f552eafc4a89fb8ede7254117"><strong>Enable the Data Cache and Instruction Cache</strong></a></p>
<p><em>(Sync with MMU Demo)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/cab2373720e615e6bf2539bbc444ddf23d6f673f"><strong>Add TCR_TG1_4K</strong></a></p>
<p><em>(Missing from NuttX. Should this be fixed?)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/19a95b066ff7dc8388e1c67e3e18d4c19f0406d6"><strong>Change Physical Address from 48 to 36 bits</strong></a></p>
<p><em>(Sync with MMU Demo)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/2d9e4aad8ce187dd2efe38a833c8b19a5174b10f"><strong>Reduce MMU Translation Tables from 10 to 1</strong></a></p>
<p><em>(Simplify the Page Tables)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/4409999739c52560ad523be4094221d41f3849c9"><strong>Disable Device Tree</strong></a></p>
<p><em>(Unicorn won‚Äôt boot with Device Tree)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/c6b13b4a02dc3bcae9b332e3adad7ce7719d2391"><strong>Disable PSCI</strong></a></p>
<p><em>(Unicorn won‚Äôt boot with PSCI)</em></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/102/files#diff-230f2ffd9be0a8ce48d4c9fb79df8f003b0c31fa0a18b6c0876ede5b4e334bb9"><strong>Added MMU Logging</strong></a></p>
<p><em>(Lotsa logs in arch/arm64/src/common/arm64_mmu.c)</em></p>
</li>
<li>
<p>The changes above: Could they contribute to NuttX booting successfully on Unicorn? It‚Äôs possible, we might have missed something.</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/103/files">(Before Fix: See the Modified Files)</a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/102/files">(After Fix: See the Modified Files)</a></p>
</li>
</ol>
<p><strong>Update:</strong> Unicorn definitely needs <a href="https://github.com/lupyuen2/wip-nuttx/commit/cab2373720e615e6bf2539bbc444ddf23d6f673f"><strong>TCR_TG1_4K</strong></a>, otherwise MMU will fail. We verified with <a href="https://github.com/lupyuen2/wip-nuttx/commit/640084e1fb1692887266716ecda52dc7ea4bf8e0"><strong>Avaota-A1 Emulator</strong></a> on Unicorn. Which means we should patch NuttX too?</p>
<h1 id="appendix-decoding-the-bits-with-javascript"><a class="doc-anchor" href="#appendix-decoding-the-bits-with-javascript">¬ß</a>15 Appendix: Decoding the Bits with JavaScript</h1>
<p>Here‚Äôs a nifty tricky to <strong>Decode The Bits</strong> for our Arm64 MMU Registers‚Ä¶</p>
<ol>
<li>
<p>In our <strong>Web Browser</strong>, launch the <strong>JavaScript Console</strong>‚Ä¶</p>
<p>Click <em>Menu &gt; More Tools &gt; Developer Tools</em></p>
</li>
<li>
<p>To decode <em>0x1_8080_3F20</em> for MMU Demo, we enter this‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>a=0x180803F20n
for (i = 0n; i &lt; 63n; i++) { if (a &amp; (1n &lt;&lt; i)) { console.log(`Bit ${i}`); } }</code></pre></div></li>
<li>
<p>We‚Äôll see the <strong>Decoded Bits</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Bit 5
Bit 8
Bit 9
Bit 10
Bit 11
Bit 12
Bit 13
Bit 23
Bit 31
Bit 32</code></pre></div></li>
<li>
<p>To decode <em>0x1_8080_351C</em> for NuttX QEMU, we enter this‚Ä¶</p>
<div class="example-wrap"><pre class="language-javascript"><code>a=0x18080351Cn
for (i = 0n; i &lt; 63n; i++) { if (a &amp; (1n &lt;&lt; i)) { console.log(`Bit ${i}`); } }</code></pre></div></li>
<li>
<p>And we‚Äôll see the <strong>Decoded Bits</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Bit 2
Bit 3
Bit 4
Bit 8
Bit 10
Bit 12
Bit 13
Bit 23
Bit 31
Bit 32</code></pre></div></li>
</ol>
<p><em>Why the ‚Äún‚Äù?</em></p>
<p>The <strong>‚Äú<code>n</code>‚Äù</strong> suffix will enable <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><strong>BigInt Support</strong></a> in JavaScript. Without this, our Decoded Bits will overflow.</p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>