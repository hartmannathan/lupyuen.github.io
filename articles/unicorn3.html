<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Inside Arm64 MMU: Unicorn Emulator vs Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Inside Arm64 MMU: Unicorn Emulator vs Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn3-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/unicorn3.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Inside Arm64 MMU: Unicorn Emulator vs Apache NuttX RTOS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#memory-management-unit" title="Memory Management Unit">1 Memory Management Unit</a><ul></ul></li>
<li><a href="#level-1-page-table" title="Level 1 Page Table">2 Level 1 Page Table</a><ul></ul></li>
<li><a href="#page-table-entry" title="Page Table Entry">3 Page Table Entry</a><ul></ul></li>
<li><a href="#translation-control-register" title="Translation Control Register">4 Translation Control Register</a><ul></ul></li>
<li><a href="#enable-the-mmu" title="Enable the MMU">5 Enable the MMU</a><ul></ul></li>
<li><a href="#run-the-mmu-demo" title="Run the MMU Demo">6 Run the MMU Demo</a><ul></ul></li>
<li><a href="#nuttx-crashes-in-unicorn" title="NuttX crashes in Unicorn">7 NuttX crashes in Unicorn</a><ul></ul></li>
<li><a href="#level-1-and-2-page-tables" title="Level 1 and 2 Page Tables">8 Level 1 and 2 Page Tables</a><ul></ul></li>
<li><a href="#translation-control-register-for-nuttx" title="Translation Control Register for NuttX">9 Translation Control Register for NuttX</a><ul></ul></li>
<li><a href="#nuttx-vs-mmu-demo" title="NuttX vs MMU Demo">10 NuttX vs MMU Demo</a><ul></ul></li>
<li><a href="#after-fixing-nuttx" title="After Fixing NuttX">11 After Fixing NuttX</a><ul></ul></li>
<li><a href="#boot-flow" title="Boot Flow">12 Boot Flow</a><ul></ul></li>
<li><a href="#todo" title="TODO">13 TODO</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">14 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-simplified-nuttx-for-qemu" title="Appendix: Simplified NuttX for QEMU">15 Appendix: Simplified NuttX for QEMU</a><ul></ul></li></ul></nav><p>üìù <em>9 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/unicorn3-title.png" alt="TODO" /></p>
<p><a href="TODO"><strong>Unicorn Emulator</strong></a> has a fascinating demo of <a href="TODO"><strong>Arm64 MMU</strong></a> <em>(Memory Management Unit)</em> ‚Ä¶ Only <a href="TODO"><strong>18 Lines of Arm64 Assembly</strong></a>! <em>(Pic above)</em></p>
<p>This article deciphers the code inside <strong>Arm64 MMU Demo</strong>, how it works. And why it‚Äôs super helpful for emulating <a href="TODO"><strong>Apache NuttX RTOS</strong></a> compiled for Arm64 SBCs!</p>
<ol>
<li>
<p>We look inside the <strong>Page Tables</strong> and <strong>Control Registers</strong> for MMU Demo</p>
</li>
<li>
<p>Study a mysterious bug that crashes <strong>NuttX on Unicorn Emulator</strong></p>
</li>
<li>
<p>Somehow Unicorn won‚Äôt <strong>Enable the MMU</strong> for NuttX?</p>
</li>
<li>
<p>We simplify <strong>NuttX Kernel for QEMU</strong> and isolate</p>
</li>
<li>
<p>Aha it‚Äôs a problem with the <strong>VM Addressable Size</strong>!</p>
</li>
<li>
<p>Soon we might have a Unicorn Emulator for <strong>Avaota-A1 SBC</strong></p>
</li>
</ol>
<p><em>What‚Äôs this MMU again?</em></p>
<p>We require the Arm64 <strong>Memory Management Unit</strong> for‚Ä¶</p>
<ul>
<li>
<p><strong>Memory Protection</strong>: Prevent Applications <em>(and Kernel)</em> from meddling with things <em>(in System Memory)</em> that they‚Äôre not supposed to</p>
</li>
<li>
<p><strong>Virtual Memory</strong>: Allow Applications to access chunks of <em>‚ÄúImaginary Memory‚Äù</em> at Exotic Addresses <em>(0x8000_0000!)</em></p>
<p>But in reality: They‚Äôre System RAM recycled from boring old addresses <em>(like 0x40A0_4000)</em></p>
</li>
</ul>
<p>If we don‚Äôt configure MMU with the correct <strong>Memory Map</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>NuttX Kernel</strong> won‚Äôt boot: <em>‚ÄúHelp! I can‚Äôt access my Kernel Code and Data!‚Äù</em></p>
</li>
<li>
<p><strong>NuttX Apps</strong> won‚Äôt run: <em>‚ÄúWhoops where‚Äôs the App Code and Data that Kernel promised?‚Äù</em></p>
</li>
</ul>
<p>Let‚Äôs go deeper inside MMU‚Ä¶</p>
<p>TODO: Pic of Virtual Address <em>0x8000_0000</em> to Physical Address <em>0x4000_0000</em>, 0x4444</p>
<h1 id="memory-management-unit"><a class="doc-anchor" href="#memory-management-unit">¬ß</a>1 Memory Management Unit</h1>
<p><em>Ah so MMU will allow this switcheroo business? (Pic above)</em></p>
<ol>
<li>
<p><strong>MMU is Disabled</strong> initially</p>
</li>
<li>
<p>Read from <strong>Physical Address</strong> <em>0x4000_0000</em></p>
</li>
<li>
<p><strong>Enable MMU</strong>: Map Virtual Address <em>0x8000_0000</em> to Physical Address <em>0x4000_0000</em></p>
</li>
<li>
<p>Read from <strong>Virtual Address</strong> <em>0x8000_0000</em></p>
</li>
<li>
<p>Both reads produce <strong>the same value</strong></p>
</li>
</ol>
<p>Indeed! That‚Äôs precisely what our <a href="TODO"><strong>MMU Demo</strong></a> above shall do‚Ä¶</p>
<ol>
<li>
<p>Read from <strong>Physical Address</strong> <em>0x4000_0000</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read data from physical address
// Into Register X1
</span>ldr X0, =<span class="number">0x4000_0000
</span>ldr X1, [X0]</code></pre></div>
</li>
<li>
<p><strong>Map Virtual Address</strong> to Physical Address:</p>
<p><em>0x8000_0000</em> becomes <em>0x4000_0000</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init the MMU Registers
</span>ldr X0, =<span class="number">0x1_8080_3F20
</span>msr TCR_EL1, X0
ldr X0, =<span class="number">0xFFFF_FFFF
</span>msr MAIR_EL1, X0

<span class="comment">// Set the MMU Page Table
</span>adr X0, ttb0_base
msr TTBR0_EL1, X0</code></pre></div>
<p><em>(We‚Äôll explain this)</em></p>
</li>
<li>
<p><strong>Enable the MMU</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Enable caches and the MMU
</span>mrs X0, SCTLR_EL1
orr X0, X0, #<span class="number">0x1         </span><span class="comment">// M bit (MMU)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// C bit (data cache)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// I bit (instruction cache)
</span>msr SCTLR_EL1, X0
dsb SY
isb</code></pre></div>
<p><em>(We‚Äôll explain this)</em></p>
</li>
<li>
<p>Read from <strong>Virtual Address</strong> <em>0x8000_0000</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read the same memory area through virtual address
// Into Regiser X2
</span>ldr X0, =<span class="number">0x8000_0000
</span>ldr X2, [X0]</code></pre></div>
</li>
<li>
<p>Assume that Physical Address <em>0x4000_0000</em> is filled with <a href="TODO"><em>0x44 44 44 44 ‚Ä¶</em></a></p>
<p>Both reads will produce <a href="https://gist.github.com/lupyuen/6c8cf74ee68a6f11ca61c2fa3c5573d0"><strong>the same value</strong></a>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Register X1 == Register X2
</span>x1=<span class="number">0x4444_4444_4444_4444
</span>x2=<span class="number">0x4444_4444_4444_4444</span></code></pre></div>
</li>
</ol>
<p>Yeah the steps for <em>‚ÄúMap Virtual Address‚Äù</em> and <em>‚ÄúEnable MMU‚Äù</em> are extremely cryptic. We break them down‚Ä¶</p>
<h1 id="level-1-page-table"><a class="doc-anchor" href="#level-1-page-table">¬ß</a>2 Level 1 Page Table</h1>
<p><em>What‚Äôs this mystery code from above?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init the MMU Registers:
// TCR_EL1 becomes 0x1_8080_3F20
</span>ldr X0, =<span class="number">0x1_8080_3F20  </span><span class="comment">// Load 0x1_8080_3F20 into Register X0
</span>msr TCR_EL1, X0         <span class="comment">// Write X0 into System Register TCR_EL1

// MAIR_EL1 becomes 0xFFFF_FFFF
</span>ldr X0, =<span class="number">0xFFFF_FFFF  </span><span class="comment">// Load 0xFFFF_FFFF into Register X0
</span>msr MAIR_EL1, X0      <span class="comment">// Write X0 into System Register MAIR_EL1

// Set the MMU Page Table:
// TTBR0_EL1 becomes ttb0_base
</span>adr X0, ttb0_base  <span class="comment">// Load ttb0_base into Register X0
</span>msr TTBR0_EL1, X0  <span class="comment">// Write X0 into System Register TTBR0_EL1</span></code></pre></div>
<p>This code will <strong>Map Virtual Address</strong> to Physical Address, so that <em>0x8000_0000</em> (virtually) becomes <em>0x4000_0000</em>.</p>
<p>Later we‚Äôll explain TCR and MAIR, but first‚Ä¶</p>
<p><em>What‚Äôs TTBR0_EL1? Why set it to ttb0_base?</em></p>
<p>That‚Äôs the <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TTBR0-EL1--Translation-Table-Base-Register-0--EL1-"><strong>Translation Table Base Register 0</strong></a> for Exception Level 1.</p>
<p>It points to the <a href="TODO"><strong>Level 1 Page Table</strong></a>, telling MMU our <strong>Virtual-to-Physical Mapping</strong>. Suppose we‚Äôre mapping <strong>Four Chunks of 1 GB</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center">Virtual Address</th><th style="text-align: center">Physical Address</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>0x0000_0000</code></strong></td><td style="text-align: center"><code>0x0000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0x4000_0000</code></strong></td><td style="text-align: center"><code>0xA000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0x8000_0000</code></strong></td><td style="text-align: center"><code>0x4000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0xC000_0000</code></strong></td><td style="text-align: center"><code>0x8000_0000</code></td><td style="text-align: center">1 GB</td></tr>
</tbody></table>
</div></div>
</p>
<p>Our <a href="TODO"><strong>Level 1 Page Table</strong></a> <em>(TTBR0_EL1)</em> will be this‚Ä¶</p>
<p>TODO: Pic of Level 1 Page Table</p>
<p>Which we <strong>Store in RAM</strong> <em>(ttb0_base)</em> as‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: center">Value</th><th style="text-align: left">Because</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>0x1000</code></strong></td><td style="text-align: center"><code>0x0000_0741</code></td><td style="text-align: left"><em>Page Table Entry #0</em></td></tr>
<tr><td style="text-align: center"><strong><code>0x1008</code></strong></td><td style="text-align: center"><code>0xA000_0741</code></td><td style="text-align: left"><em>Page Table Entry #1</em></td></tr>
<tr><td style="text-align: center"><strong><code>0x1010</code></strong></td><td style="text-align: center"><code>0x4000_0741</code></td><td style="text-align: left"><em>Page Table Entry #2</em></td></tr>
<tr><td style="text-align: center"><strong><code>0x1018</code></strong></td><td style="text-align: center"><code>0x8000_0741</code></td><td style="text-align: left"><em>Page Table Entry #3</em></td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://gist.github.com/lupyuen/6c8cf74ee68a6f11ca61c2fa3c5573d0">(See the <strong>Unicorn Log</strong>)</a></p>
<p><a href="TODO">(And the <strong>Unicorn Code</strong>)</a></p>
<p><em>What if we read from 0x4000_0000 AFTER enabling MMU? (Physical Address 0xA000_0000)</em></p>
<p>We‚Äôll see <a href="TODO"><em>AA AA AA AA‚Ä¶</em></a> because that‚Äôs how we populated Physical Address <em>0xA000_0000</em>. Yep the MMU can remap memory in fun interesting ways.</p>
<p><em>Why map 0x0000_0000 to itself?</em></p>
<p>Our code runs at <em>0x0000_0000</em>. If we don‚Äôt map <em>0x0000_0000</em> to itself, there won‚Äôt be no runway for our demo.</p>
<p><em>For TTBR0_EL1: Why Exception Level 1?</em></p>
<p>Our code <em>(NuttX Kernel)</em> runs at <a href="https://developer.arm.com/documentation/102412/0103/Privilege-and-Exception-levels/Exception-levels"><strong>Exception Level 1</strong></a>. Later we‚Äôll run NuttX Apps at <strong>Exception Level 0</strong>, which has Less Privilege. That‚Äôs how we protect NuttX Kernel from getting messed up by NuttX Apps.</p>
<h1 id="page-table-entry"><a class="doc-anchor" href="#page-table-entry">¬ß</a>3 Page Table Entry</h1>
<p><em>In the Page Table Entries above: Why 741?</em></p>
<p>We decode each <strong>Page Table Entry</strong> based on <a href="TODO"><strong>VMSAv8-64 Block Descriptors</strong></a> <em>(Page D8-6491)</em>. <code>0x741</code> says‚Ä¶</p>
<p><img src="https://lupyuen.org/images/unicorn3-block.png" alt="TODO" /></p>
<ul>
<li>
<p><strong>Bits 00-01:</strong> BLOCK_DESC = 1 <br> <em>This Page Table Entry describes a Block, not a Page</em></p>
</li>
<li>
<p><strong>Bits 06-07:</strong> BLOCK_DESC_AP_USER = 1 <br> <em>This Block is Read-Writeable by Kernel, Read-Writeable by Apps</em></p>
</li>
<li>
<p><strong>Bits 08-09:</strong> BLOCK_DESC_INNER_SHARE = 3 <br> <em>This Block is Inner Shareable (see below)</em></p>
</li>
<li>
<p><strong>Bits 10-10:</strong> BLOCK_DESC_AF = 1 <br> <em>Allow this Virtual-to-Physical Mapping to be cached</em></p>
</li>
<li>
<p>Which means each chunk of <strong>Virtual-Physical Memory</strong> <em>(like 0x4000_0000)</em> is a Memory Block that‚Äôs accessible by Kernel and Apps</p>
</li>
</ul>
<p>NuttX defines the whole list here: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.h#L95-L122">arm64_mmu.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// PTE descriptor can be Block descriptor or Table descriptor or Page descriptor
#define PTE_BLOCK_DESC              1U
#define PTE_TABLE_DESC              3U

// Block and Page descriptor attributes fields
#define PTE_BLOCK_DESC_MEMTYPE(x)   ((x) &lt;&lt; 2)
#define PTE_BLOCK_DESC_NS           (1ULL &lt;&lt; 5) // Non-Secure
#define PTE_BLOCK_DESC_AP_USER      (1ULL &lt;&lt; 6) // User Read-Write
#define PTE_BLOCK_DESC_AP_RO        (1ULL &lt;&lt; 7) // Kernel Read-Only
#define PTE_BLOCK_DESC_AP_RW        (0ULL &lt;&lt; 7) // Kernel Read-Write
#define PTE_BLOCK_DESC_AP_MASK      (3ULL &lt;&lt; 6)
#define PTE_BLOCK_DESC_NON_SHARE    (0ULL &lt;&lt; 8)
#define PTE_BLOCK_DESC_OUTER_SHARE  (2ULL &lt;&lt; 8)
#define PTE_BLOCK_DESC_INNER_SHARE  (3ULL &lt;&lt; 8)
#define PTE_BLOCK_DESC_AF           (1ULL &lt;&lt; 10) // A Flag
#define PTE_BLOCK_DESC_NG           (1ULL &lt;&lt; 11) // Non-Global
#define PTE_BLOCK_DESC_DIRTY        (1ULL &lt;&lt; 51) // D Flag
#define PTE_BLOCK_DESC_PXN          (1ULL &lt;&lt; 53) // Kernel Execute Never
#define PTE_BLOCK_DESC_UXN          (1ULL &lt;&lt; 54) // User Execute Never</code></pre></div>
<p><em>Why Stage 1? Not Stage 2?</em></p>
<p>We‚Äôre doing <strong>Stage 1 Only</strong>: Single-Stage Translation from <em>Virtual Address (VA)</em> to <em>Physical Address (PA)</em>. No need for Stage 2 and <em>Intermediate Physical Address (IPA)</em> <a href="TODO">(Page D8-6448)</a></p>
<p><img src="https://lupyuen.org/images/unicorn3-stage.png" alt="TODO" /></p>
<p><em>Why Inner vs Outer Shareable? Something about ‚ÄúSeverance‚Äù?</em></p>
<p><strong>Inner / Outer Sharing</strong> is for Multiple CPU Cores, which we‚Äôll ignore for now <a href="TODO">(Page B2-293)</a></p>
<p><img src="https://lupyuen.org/images/unicorn3-shareable.png" alt="TODO" /></p>
<p><a href="https://developer.arm.com/documentation/102404/0202/Common-architecture-terms"><em>(PE = Processing Element = One Arm64 Core)</em></a></p>
<h1 id="translation-control-register"><a class="doc-anchor" href="#translation-control-register">¬ß</a>4 Translation Control Register</h1>
<p>We return to this mysterious code‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Init the MMU Registers:
// TCR_EL1 becomes 0x1_8080_3F20
</span>ldr X0, =<span class="number">0x1_8080_3F20  </span><span class="comment">// Load 0x1_8080_3F20 into Register X0
</span>msr TCR_EL1, X0         <span class="comment">// Write X0 into System Register TCR_EL1

// MAIR_EL1 becomes 0xFFFF_FFFF
</span>ldr X0, =<span class="number">0xFFFF_FFFF  </span><span class="comment">// Load 0xFFFF_FFFF into Register X0
</span>msr MAIR_EL1, X0      <span class="comment">// Write X0 into System Register MAIR_EL1</span></code></pre></div>
<p><em>What‚Äôs TCR_EL1? Why set it to 0x1_8080_3F20?</em></p>
<p>That‚Äôs the <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>Translation Control Register</strong></a> for Exception Level 1. According to <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>TCR_EL1 Doc</strong></a>, <em>0x1_8080_3F20</em> decodes as‚Ä¶</p>
<p><img src="https://lupyuen.org/images/unicorn3-tcr.png" alt="TODO" /></p>
<ul>
<li>
<p><strong>Bits 00-05:</strong> T0SZ = 0x20 <br> <em>32 bits of Virtual Address Space</em></p>
</li>
<li>
<p><strong>Bits 08-09:</strong> IRGN0_WBNWA = 3 <br> <em>Normal memory, Inner Write-Back Read-Allocate No Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 10-11:</strong> ORGN0_WBNWA = 3 <br> <em>Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 12-13:</strong> SH0_SHARED_INNER = 3 <br> <em>Inner Shareable for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 14-15:</strong> TG0_4K = 0 <br> <em>EL1 Granule Size is 4 KB for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 23-23:</strong> EPD1_DISABLE = 1 <br> <em>Perform translation table walks using TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 30-31:</strong> TG1_4K = 2 <br> <em>EL1 Granule Size is 4 KB for TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 32-34:</strong> EL1_IPS = 1 <br> <em>36 bits, 64 GB of Physical Address Space</em></p>
</li>
<li>
<p>Thus our MMU shall map <strong>32-bit Virtual Addresses</strong> into <strong>36-bit Physical Addresses</strong>. Each Physical Address points to a <strong>4 KB Memory Page</strong>.</p>
<p><a href="TODO"><em>(We spoke about Innies and Outies earlier)</em></a></p>
<p><a href="TODO"><em>(Decoding the Bits with JavaScript)</em></a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>a=0x180803F20n
for (i = 0n; i &lt; 63n; i++) { if (a &amp; (1n &lt;&lt; i)) { console.log(`Bit ${i}`); } }
Bit 5
Bit 8
Bit 9
Bit 10
Bit 11
Bit 12
Bit 13
Bit 23
Bit 31
Bit 32</code></pre></div>
<p><em>What about MAIR?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// MAIR_EL1 becomes 0xFFFF_FFFF
</span>ldr X0, =<span class="number">0xFFFF_FFFF  </span><span class="comment">// Load 0xFFFF_FFFF into Register X0
</span>msr MAIR_EL1, X0      <span class="comment">// Write X0 into System Register MAIR_EL1</span></code></pre></div>
<p>Hmmm <em>0xFFFF_FFFF</em> looks kinda fake? Unicorn Emulator probably ignores the <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/MAIR-EL1--Memory-Attribute-Indirection-Register--EL1-"><strong>MAIR Bits</strong></a>. We‚Äôll see a Real MAIR in a while.</p>
<h1 id="enable-the-mmu"><a class="doc-anchor" href="#enable-the-mmu">¬ß</a>5 Enable the MMU</h1>
<p>Wrapping up our Mystery Code: This is how we <strong>Enable the MMU</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read System Register SCTLR_EL1 into X0
</span>mrs X0, SCTLR_EL1

<span class="comment">// In X0: Set the bits to Enable MMU, Data Cache and Instruction Cache
</span>orr X0, X0, #<span class="number">0x1         </span><span class="comment">// M bit (MMU)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// C bit (Data Cache)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// I bit (Instruction Cache)

// Write X0 into System Register SCTLR_EL1
</span>msr SCTLR_EL1, X0

<span class="comment">// Flush the Data Cache and Instruction Cache
</span>dsb SY ; isb</code></pre></div>
<p><em>SCTLR_EL1 is for?</em></p>
<p>The <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/SCTLR-EL1--System-Control-Register--EL1-"><strong>System Control Register</strong></a> for Exception Level 1. We set these bits to <strong>Enable the MMU with Caching</strong>‚Ä¶ <em>(oh yes another bikini brief)</em></p>
<p><img src="https://lupyuen.org/images/unicorn3-sctlr.png" alt="TODO" /></p>
<ul>
<li>
<p><strong>Bit 0:</strong> M = 1 <br> <em>Enable MMU for Address Translation</em></p>
</li>
<li>
<p><strong>Bit 2:</strong> C = 1 <br> <em>Enable the Data Cache</em></p>
</li>
<li>
<p><strong>Bit 12:</strong> I = 1 <br> <em>Enable the Instruction Cache</em></p>
</li>
</ul>
<p>We‚Äôre ready to run MMU Demo!</p>
<h1 id="run-the-mmu-demo"><a class="doc-anchor" href="#run-the-mmu-demo">¬ß</a>6 Run the MMU Demo</h1>
<p>This is how we run the MMU Demo in <strong>Unicorn Emulator</strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/qemu/src/main.rs#L376-L565">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Run the Arm64 MMU Demo, based on
/// https://github.com/unicorn-engine/unicorn/blob/master/tests/unit/test_arm64.c#L378-L486
</span><span class="kw">fn </span>test_arm64_mmu() {

  <span class="comment">// Arm64 Machine Code for our MMU Demo.
  // Disassembly: https://github.com/lupyuen/pinephone-emulator/blob/qemu/src/main.rs#L556-L583
  </span><span class="kw">let </span>arm64_code = [
    <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0xf9</span>, <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x40</span>, <span class="number">0x20</span>, <span class="number">0x18</span>,
    <span class="number">0xd5</span>, <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x00</span>, <span class="number">0xa2</span>, <span class="number">0x18</span>, <span class="number">0xd5</span>, <span class="number">0x40</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x20</span>,
    <span class="number">0x18</span>, <span class="number">0xd5</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x38</span>, <span class="number">0xd5</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7e</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x74</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>,
    <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x18</span>, <span class="number">0xd5</span>, <span class="number">0x9f</span>, <span class="number">0x3f</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>, <span class="number">0xdf</span>, <span class="number">0x3f</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>,
    <span class="number">0xe0</span>, <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x58</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0xf9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="number">0x1f</span>, <span class="number">0x20</span>, <span class="number">0x03</span>,
    <span class="number">0xd5</span>, <span class="number">0x1f</span>, <span class="number">0x20</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>, <span class="number">0x1F</span>, <span class="number">0x20</span>, <span class="number">0x03</span>, <span class="number">0xD5</span>, <span class="number">0x1F</span>, <span class="number">0x20</span>, <span class="number">0x03</span>, <span class="number">0xD5</span>,       
  ];

  <span class="comment">// Init Emulator in Arm64 mode
  </span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
    Arch::ARM64,
    Mode::LITTLE_ENDIAN
  ).expect(<span class="string">"failed to init Unicorn"</span>);

  <span class="comment">// Enable MMU Translation
  </span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;
  emu.ctl_tlb_type(unicorn_engine::TlbType::CPU).unwrap();

  <span class="comment">// Map Read/Write/Execute Memory at 0x0000 0000
  </span>emu.mem_map(
    <span class="number">0</span>,       <span class="comment">// Address
    </span><span class="number">0x2000</span>,  <span class="comment">// Size
    </span>Permission::ALL  <span class="comment">// Read/Write/Execute Access
  </span>).expect(<span class="string">"failed to map memory"</span>);

  <span class="comment">// Write Arm64 Machine Code to emulated Executable Memory
  </span><span class="kw">const </span>ADDRESS: u64 = <span class="number">0</span>;
  emu.mem_write(
    ADDRESS, 
    <span class="kw-2">&amp;</span>arm64_code
  ).expect(<span class="string">"failed to write instructions"</span>);</code></pre></div>
<p>Our MMU Demo needs a <a href="TODO"><strong>Level 1 Page Table</strong></a>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/qemu/src/main.rs#L376-L565">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Generate the Page Table Entries
  // Page Table Entry @ 0x1000: 0x0000_0741
  // Physical Address: 0x0000_0000
  // Bit 00-01: PTE_BLOCK_DESC=1
  // Bit 06-07: PTE_BLOCK_DESC_AP_USER=1
  // Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
  // Bit 10:    PTE_BLOCK_DESC_AF=1  
  </span><span class="kw">let </span><span class="kw-2">mut </span>tlbe: [u8; <span class="number">8</span>] = [<span class="number">0</span>; <span class="number">8</span>];
  tlbe[<span class="number">0</span>..<span class="number">2</span>].copy_from_slice(<span class="kw-2">&amp;</span>[<span class="number">0x41</span>, <span class="number">0x07</span>]);
  emu.mem_write(<span class="number">0x1000</span>, <span class="kw-2">&amp;</span>tlbe).unwrap();

  <span class="comment">// Page Table Entry @ 0x1008: 0xA000_0741
  // Page Table Entry @ 0x1010: 0x4000_0741
  // Page Table Entry @ 0x1018: 0x8000_0741

  // Not the Page Table, but
  // Data Referenced by our Assembly Code
  // Data @ 0x1020: 0x4000_0000
  </span>tlbe[<span class="number">0</span>..<span class="number">4</span>].copy_from_slice(<span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>]);
  emu.mem_write(<span class="number">0x1020</span>, <span class="kw-2">&amp;</span>tlbe).unwrap();

  <span class="comment">// Data @ 0x1028: 0x1_8080_3F20
  // Data @ 0x1030: 0xFFFF_FFFF
  // Data @ 0x1038: 0x8000_0000
  </span>...</code></pre></div>
<p>To Verify MMU Demo: We <strong>Fill the Physical Memory</strong> with <em>0x44</em> then <em>0x88</em> then <em>0xCC</em>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/qemu/src/main.rs#L376-L565">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// 3 Chunks of Data filled with 0x44, 0x88, 0xCC respectively
  </span><span class="kw">let </span><span class="kw-2">mut </span>data:  [u8; <span class="number">0x1000</span>] = [<span class="number">0x44</span>; <span class="number">0x1000</span>];
  <span class="kw">let </span><span class="kw-2">mut </span>data2: [u8; <span class="number">0x1000</span>] = [<span class="number">0x88</span>; <span class="number">0x1000</span>];
  <span class="kw">let </span><span class="kw-2">mut </span>data3: [u8; <span class="number">0x1000</span>] = [<span class="number">0xcc</span>; <span class="number">0x1000</span>];
  <span class="kw">unsafe </span>{
    <span class="comment">// 0x4000_0000 becomes 0x44 44 44 44...
    </span>emu.mem_map_ptr(<span class="number">0x40000000</span>, <span class="number">0x1000</span>, Permission::READ, data.as_mut_ptr() <span class="kw">as _</span>).unwrap();

    <span class="comment">// 0x8000_0000 becomes 0x88 88 88 88...
    </span>emu.mem_map_ptr(<span class="number">0x80000000</span>, <span class="number">0x1000</span>, Permission::READ, data2.as_mut_ptr() <span class="kw">as _</span>).unwrap();

    <span class="comment">// 0xA000_0000 becomes 0xCC CC CC CC...
    </span>emu.mem_map_ptr(<span class="number">0xa0000000</span>, <span class="number">0x1000</span>, Permission::READ, data3.as_mut_ptr() <span class="kw">as _</span>).unwrap();
  }</code></pre></div>
<p>Finally we <strong>Start the Emulator</strong>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/qemu/src/main.rs#L376-L565">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Start the Unicorn Emulator
  </span><span class="kw">let </span>err = emu.emu_start(<span class="number">0</span>, <span class="number">0x44</span>, <span class="number">0</span>, <span class="number">0</span>);
  <span class="macro">println!</span>(<span class="string">"\nerr={:?}"</span>, err);

  <span class="comment">// Read registers X0, X1, X2
  </span><span class="kw">let </span>x0 = emu.reg_read(RegisterARM64::X0).unwrap();
  <span class="kw">let </span>x1 = emu.reg_read(RegisterARM64::X1).unwrap();
  <span class="kw">let </span>x2 = emu.reg_read(RegisterARM64::X2).unwrap();

  <span class="comment">// Check the values
  </span><span class="macro">assert!</span>(x0 == <span class="number">0x80000000</span>);
  <span class="macro">assert!</span>(x1 == <span class="number">0x4444444444444444</span>);
  <span class="macro">assert!</span>(x2 == <span class="number">0x4444444444444444</span>);
}</code></pre></div>
<p>And it works!</p>
<div class="example-wrap"><pre class="language-text"><code>TODO</code></pre></div>
<p><a href="TODO">(See the <strong>Unicorn Log</strong>)</a></p>
<h1 id="nuttx-crashes-in-unicorn"><a class="doc-anchor" href="#nuttx-crashes-in-unicorn">¬ß</a>7 NuttX crashes in Unicorn</h1>
<p><em>What‚Äôs Unicorn Emulator got to do with NuttX RTOS?</em></p>
<p>Two Years Ago: We tried creating a <a href="TODO"><strong>PinePhone Emulator</strong></a> with NuttX and Unicorn. But NuttX kept crashing on Unicorn‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Simplified NuttX for QEMU Arm64 (Kernel Build)
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch unicorn-qemu-before
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch /unicorn-qemu
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## NuttX boots OK on QEMU.
## NSH Shell won&#39;t appear yet because we haven&#39;t compiled the NuttX Apps.
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx

## But NuttX crashes in Unicorn Emulator
git clone https://github.com/lupyuen/pinephone-emulator --branch qemu \
  $HOME/pinephone-emulator
cp nuttx.bin nuttx.S \
  $HOME/pinephone-emulator/nuttx/
cd $HOME/pinephone-emulator
cargo run

## err=Err(EXCEPTION)
## PC=0x402805f0
## call_graph:  setup_page_tables --&gt; ***_HALT_***
## call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
## env.exception={syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}</code></pre></div>
<p>Two Years Later: The bug stops here! Let‚Äôs fix it today.</p>
<p><em>Where does it crash?</em></p>
<p>According to <a href="https://gist.github.com/lupyuen/67b8dc6f83cb39c0bc6d622f24b96cc1#file-gistfile1-txt-L1731-L1754"><strong>Unicorn Log</strong></a>: Our <a href="TODO"><strong>Simplified NuttX</strong></a> crashes here in Unicorn Emulator: <a href="https://github.com/lupyuen2/wip-nuttx/blob/unicorn-qemu/arch/arm64/src/common/arm64_mmu.c#L635-L661">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable the MMU for Exception Level 1
static void enable_mmu_el1(unsigned int flags) {

  // Set the MAIR, TCR and TBBR registers
  write_sysreg(MEMORY_ATTRIBUTES, mair_el1);
  write_sysreg(get_tcr(1), tcr_el1);
  write_sysreg(base_xlat_table, ttbr0_el1);

  // Ensure the above updates are committed
  // before we enable the MMU: `dsb sy ; isb`
  UP_MB();

  // Read the System Control Register (Exception Level 1)
  uint64_t value = read_sysreg(sctlr_el1);

  // Update the System Control Register (Exception Level 1)
  // Enable the MMU, Data Cache and Instruction Cache
  write_sysreg(
    value 
    | (1 &lt;&lt;  0)  // Set Bit 00: M_BIT (Enable MMU)
    | (1 &lt;&lt;  2)  // Set Bit 02: C_BIT (Enable Data Cache)
    | (1 &lt;&lt; 12), // Set Bit 12: I_BIT (Enable Instruction Cache)
    sctlr_el1
  );

  // Oops! Unicorn Emulator fails with an Arm64 Exception
  // {syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}</code></pre></div>
<p>Which is mighty similar to the <a href="TODO"><strong>MMU Demo</strong></a> we saw earlier‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// MMU Demo Works OK:
// Read System Register SCTLR_EL1 into X0
</span>mrs X0, SCTLR_EL1

<span class="comment">// In X0: Set the bits to Enable MMU, Data Cache and Instruction Cache
</span>orr X0, X0, #<span class="number">0x1         </span><span class="comment">// M bit (MMU)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// C bit (Data Cache)
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// I bit (Instruction Cache)

// Write X0 into System Register SCTLR_EL1
</span>msr SCTLR_EL1, X0</code></pre></div>
<p>Maybe our Page Tables are bad? Or Translation Control Register? We investigate‚Ä¶</p>
<h1 id="level-1-and-2-page-tables"><a class="doc-anchor" href="#level-1-and-2-page-tables">¬ß</a>8 Level 1 and 2 Page Tables</h1>
<p>NuttX on Unicorn Emulator will fail with this <a href="https://gist.github.com/lupyuen/67b8dc6f83cb39c0bc6d622f24b96cc1#file-gistfile1-txt-L1731-L1754"><strong>Arm64 Exception</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>env.exception =
  Syndrome:        0x8600_0005
  FSR:             0x0000_0205
  Virtual Address: 0x5027_ffff (Why?)
  Target Exception Level: 1</code></pre></div>
<p>Which means: <a href="https://github.com/lupyuen/pinephone-emulator?#arm64-mmu-exception"><strong>‚ÄúOops! Can‚Äôt enable MMU‚Äù</strong></a></p>
<p>To troubleshoot, we enable <strong>MMU Logging</strong>: <a href="TODO">arch/arm64/src/common/arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable MMU Logging
#define CONFIG_MMU_ASSERT   1
#define CONFIG_MMU_DEBUG    1
#define CONFIG_MMU_DUMP_PTE 1
#define trace_printf _info
#undef  sinfo
#define sinfo _info</code></pre></div>
<p>We simplify the <strong>Memory Regions</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/blob/unicorn-qemu/arch/arm64/src/qemu/qemu_boot.c#L59-L89">qemu_boot.c</a></p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center">Virtual Address</th><th style="text-align: center">Physical Address</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>0x0000_0000</code></strong></td><td style="text-align: center"><code>0x0000_0000</code></td><td style="text-align: center">1 GB</td></tr>
<tr><td style="text-align: center"><strong><code>0x4000_0000</code></strong></td><td style="text-align: center"><code>0x4000_0000</code></td><td style="text-align: center">8 MB</td></tr>
</tbody></table>
</div></div>
</p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Memory Regions for Arm64 MMU (Simplified)
struct arm_mmu_region g_mmu_regions[] = {

  // Memory Region for I/O Memory
  MMU_REGION_FLAT_ENTRY(
    &quot;DEVICE_REGION&quot;,  // Name
    0x0000_0000,      // Start Address
    0x4000_0000,      // Size: 1 GB
    MT_DEVICE_NGNRNE | MT_RW),  // Read-Write I/O Memory

  // Memory Region for RAM
  MMU_REGION_FLAT_ENTRY(
    &quot;DRAM0_S0&quot;,   // Name
    0x4000_0000,  // Start Address
    0x0080_0000,  // Size: 8 MB
    MT_NORMAL | MT_RW | MT_EXECUTE),  // Allow Read, Write and Execute

};  // Other Memory Regions? We removed them all</code></pre></div>
<p>According to <a href="https://gist.github.com/lupyuen/b9d23fe902c097debc53b3926920045a#file-gistfile1-txt-L78-L884"><strong>NuttX QEMU Log</strong></a>: We have a <strong>Two-Level Page Table</strong>‚Ä¶</p>
<p>TODO: Pic of 2-Level Page Table</p>
<p>TODO: <a href="https://gist.github.com/lupyuen/b9d23fe902c097debc53b3926920045a#file-gistfile1-txt-L78-L884">Before Fix: QEMU Log</a></p>
<div class="example-wrap"><pre class="language-bash"><code>arm64_mmu_init: base table(L1): 0x402b2000, 64 entries
arm64_mmu_init: xlat table #0: 0x402b1000

init_xlat_tables: mmap: virt 0 phys 0 size 0x40000000
set_pte_block_desc: Bit 00-01: PTE_BLOCK_DESC=1
set_pte_block_desc: Bit 10:    PTE_BLOCK_DESC_AF=1
set_pte_block_desc: Bit 08-09: PTE_BLOCK_DESC_OUTER_SHAR=2
set_pte_block_desc: Bit 53:    PTE_BLOCK_DESC_PXN=1
set_pte_block_desc: Bit 54:    PTE_BLOCK_DESC_UXN=1
set_pte_block_desc: addr_pa=0
set_pte_block_desc: level=1
set_pte_block_desc: pte=0x402b2000
set_pte_block_desc: mem_type=DEV
set_pte_block_desc: Bit 03:    MT_RW=RW
set_pte_block_desc: Bit 04:    MT_NS=S
set_pte_block_desc: Bit 05:    MT_EXECUTE_NEVER=EXEC
set_pte_block_desc: PTE @ 0x402b2000 set to desc=0x60000000000601

init_xlat_tables: mmap: virt 0x40000000 phys 0x40000000 size 0x8000000
set_pte_table_desc:   
set_pte_table_desc: 0x402b2008: [Table] 0x402b1000
set_pte_table_desc: PTE @ 0x402b2008 points to Xlat Table 0x402b1000
set_pte_table_desc: Bit 00-01: PTE_TABLE_DESC=3

set_pte_block_desc: Bit 00-01: PTE_BLOCK_DESC=1
set_pte_block_desc: Bit 10:    PTE_BLOCK_DESC_AF=1
set_pte_block_desc: Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
set_pte_block_desc: addr_pa=0x40000000
set_pte_block_desc: level=2
set_pte_block_desc: pte=0x402b1000
set_pte_block_desc: mem_type=MEM
set_pte_block_desc: Bit 03:    MT_RW=RW
set_pte_block_desc: Bit 04:    MT_NS=S
set_pte_block_desc: Bit 05:    MT_EXECUTE_NEVER=EXEC
set_pte_block_desc: PTE @ 0x402b1000 set to desc=0x40000711

set_pte_block_desc: Bit 00-01: PTE_BLOCK_DESC=1
set_pte_block_desc: Bit 10:    PTE_BLOCK_DESC_AF=1
set_pte_block_desc: Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
set_pte_block_desc: addr_pa=0x40200000
set_pte_block_desc: level=2
set_pte_block_desc: pte=0x402b1008
set_pte_block_desc: mem_type=MEM
set_pte_block_desc: Bit 03:    MT_RW=RW
set_pte_block_desc: Bit 04:    MT_NS=S
set_pte_block_desc: Bit 05:    MT_EXECUTE_NEVER=EXEC
set_pte_block_desc: PTE @ 0x402b1008 set to desc=0x40200711

set_pte_block_desc: Bit 00-01: PTE_BLOCK_DESC=1
set_pte_block_desc: Bit 10:    PTE_BLOCK_DESC_AF=1
set_pte_block_desc: Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
set_pte_block_desc: addr_pa=0x40400000
set_pte_block_desc: level=2
set_pte_block_desc: pte=0x402b1010
set_pte_block_desc: mem_type=MEM
set_pte_block_desc: Bit 03:    MT_RW=RW
set_pte_block_desc: Bit 04:    MT_NS=S
set_pte_block_desc: Bit 05:    MT_EXECUTE_NEVER=EXEC
set_pte_block_desc: PTE @ 0x402b1010 set to desc=0x40400711
...
get_tcr: va_bits: 0x24
get_tcr: Bit 32-33: TCR_EL1_IPS=1
get_tcr: Bit 23:    TCR_EPD1_DISABLE=1
get_tcr: Bit 00-05: TCR_T0SZ=0x1c
get_tcr: Bit 08-09: TCR_IRGN_WBWA=1
get_tcr: Bit 10-11: TCR_ORGN_WBWA=1
get_tcr: Bit 12-13: TCR_SHARED_INNER=3
get_tcr: Bit 14-15: TCR_TG0_4K=0
get_tcr: Bit 30-31: TCR_TG1_4K=2
get_tcr: Bit 37-38: TCR_TBI_FLAGS=0

enable_mmu_el1: tcr_el1=0x18080351c
enable_mmu_el1: mair_el1=0xff440c0400
enable_mmu_el1: ttbr0_el1=0x402b2000</code></pre></div>
<p>Looks legit, we move on‚Ä¶</p>
<h1 id="translation-control-register-for-nuttx"><a class="doc-anchor" href="#translation-control-register-for-nuttx">¬ß</a>9 Translation Control Register for NuttX</h1><div class="example-wrap"><pre class="language-bash"><code>get_tcr: va_bits: 0x24
get_tcr: Bit 32-33: TCR_EL1_IPS=1
get_tcr: Bit 23:    TCR_EPD1_DISABLE=1
get_tcr: Bit 00-05: TCR_T0SZ=0x1c
get_tcr: Bit 08-09: TCR_IRGN_WBWA=1
get_tcr: Bit 10-11: TCR_ORGN_WBWA=1
get_tcr: Bit 12-13: TCR_SHARED_INNER=3
get_tcr: Bit 14-15: TCR_TG0_4K=0
get_tcr: Bit 30-31: TCR_TG1_4K=2
get_tcr: Bit 37-38: TCR_TBI_FLAGS=0

enable_mmu_el1: tcr_el1=0x18080351c
enable_mmu_el1: mair_el1=0xff440c0400
enable_mmu_el1: ttbr0_el1=0x402b2000</code></pre></div>
<p>According to <a href="https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-"><strong>TCR_EL1 Doc</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.org/images/unicorn3-tcr.png" alt="TODO" /></p>
<ul>
<li>
<p><strong>Bits 00-05:</strong> T0SZ = 0x1C <br> <em>36 bits of Virtual Address Space</em></p>
</li>
<li>
<p><strong>Bits 08-09:</strong> IRGN0_WBWA = 1 <br> <em>Normal memory, Inner Write-Back Read-Allocate Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 10-11:</strong> ORGN0_WBWA = 1 <br> <em>Normal memory, Outer Write-Back Read-Allocate Write-Allocate Cacheable</em></p>
</li>
<li>
<p><strong>Bits 12-13:</strong> SH0_SHARED_INNER = 3 <br> <em>Inner Shareable for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 14-15:</strong> TG0_4K = 0 <br> <em>EL1 Granule Size is 4 KB for TTBR0_EL1</em></p>
</li>
<li>
<p><strong>Bits 23-23:</strong> EPD1_DISABLE = 1 <br> <em>Perform translation table walks using TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 30-31:</strong> TG1_4K = 2 <br> <em>EL1 Granule Size is 4 KB for TTBR1_EL1</em></p>
</li>
<li>
<p><strong>Bits 32-34:</strong> EL1_IPS = 1 <br> <em>36 bits, 64 GB of Physical Address Space</em></p>
<p><a href="TODO"><em>(We spoke about Innies and Outies earlier)</em></a></p>
<p><a href="TODO"><em>(Decoding the Bits with JavaScript)</em></a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>a=0x18080351Cn
for (i = 0n; i &lt; 63n; i++) { if (a &amp; (1n &lt;&lt; i)) { console.log(`Bit ${i}`); } }
Bit 2
Bit 3
Bit 4
Bit 8
Bit 10
Bit 12
Bit 13
Bit 23
Bit 31
Bit 32</code></pre></div><h1 id="nuttx-vs-mmu-demo"><a class="doc-anchor" href="#nuttx-vs-mmu-demo">¬ß</a>10 NuttX vs MMU Demo</h1>
<ul>
<li><strong>Bits 00-05:</strong> T0SZ = 0x1C <br> <em>36 bits of Virtual Address Space</em></li>
</ul>
<p>vs</p>
<ul>
<li><strong>Bits 00-05:</strong> T0SZ = 0x20 <br> <em>32 bits of Virtual Address Space</em></li>
</ul>
<hr>
<ul>
<li><strong>Bits 08-09:</strong> IRGN0_WBWA = 1 <br> <em>Normal memory, Inner Write-Back Read-Allocate Write-Allocate Cacheable</em></li>
</ul>
<p>vs</p>
<ul>
<li><strong>Bits 08-09:</strong> IRGN0_WBNWA = 3 <br> <em>Normal memory, Inner Write-Back Read-Allocate No Write-Allocate Cacheable</em></li>
</ul>
<hr>
<ul>
<li><strong>Bits 10-11:</strong> ORGN0_WBWA = 1 <br> <em>Normal memory, Outer Write-Back Read-Allocate Write-Allocate Cacheable</em></li>
</ul>
<p>vs</p>
<ul>
<li><strong>Bits 10-11:</strong> ORGN0_WBNWA = 3 <br> <em>Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable</em></li>
</ul>
<h1 id="after-fixing-nuttx"><a class="doc-anchor" href="#after-fixing-nuttx">¬ß</a>11 After Fixing NuttX</h1>
<p>Change 36 bits of Virtual Address Space to 32 bits:</p>
<p><a href="https://github.com/apache/nuttx/commit/ce18a505fb295fc95167f505261f060c7601ce61">CONFIG_ARM64_VA_BITS=32</a></p>
<p>boards/arm64/qemu/qemu-armv8a/configs/knsh/defconfig</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the Virtual Address Space to 32 bits
CONFIG_ARM64_VA_BITS=32

## Previously: Virtual Address Space is 36 bits
## CONFIG_ARM64_VA_BITS=36</code></pre></div>
<p>TODO: <a href="https://gist.github.com/lupyuen/f66c93314c5b081c1d2fc4bb1027163e#file-gistfile1-txt-L869-L884">After Fix: QEMU Log</a></p>
<div class="example-wrap"><pre class="language-bash"><code>get_tcr: va_bits: 0x20
get_tcr: Bit 32-33: TCR_EL1_IPS=1
get_tcr: Bit 23:    TCR_EPD1_DISABLE=1
get_tcr: Bit 00-05: TCR_T0SZ=0x20
get_tcr: Bit 08-09: TCR_IRGN_WBWA=1
get_tcr: Bit 10-11: TCR_ORGN_WBWA=1
get_tcr: Bit 12-13: TCR_SHARED_INNER=3
get_tcr: Bit 14-15: TCR_TG0_4K=0
get_tcr: Bit 30-31: TCR_TG1_4K=2
get_tcr: Bit 37-38: TCR_TBI_FLAGS=0

enable_mmu_el1: tcr_el1=0x180803520
enable_mmu_el1: mair_el1=0xff440c0400
enable_mmu_el1: ttbr0_el1=0x402b2000</code></pre></div>
<p>TODO: <a href="https://gist.github.com/lupyuen/f9648b37c2b94ec270946c35c1e83c20#file-gistfile1-txt-L627-L635">After Fix: Unicorn Log</a></p>
<div class="example-wrap"><pre class="language-bash"><code>hook_block:  address=0x402805a4, size=08, setup_page_tables, arch/arm64/src/common/arm64_mmu.c:547:29
call_graph:  enable_mmu_el1 --&gt; setup_page_tables
call_graph:  click enable_mmu_el1 href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L616&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
hook_block:  address=0x40280614, size=16, enable_mmu_el1, arch/arm64/src/common/arm64_mmu.c:608:3
call_graph:  setup_page_tables --&gt; enable_mmu_el1
call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
hook_block:  address=0x4028062c, size=04, enable_mmu_el1, arch/arm64/src/common/arm64_mmu.c:617:3
hook_block:  address=0x40280380, size=88, arm64_boot_el1_init, arch/arm64/src/common/arm64_boot.c:215:1
call_graph:  enable_mmu_el1 --&gt; arm64_boot_el1_init</code></pre></div>
<p>Maybe Unicorn doesn‚Äôt support 36 bits</p>
<p>Or maybe NuttX didn‚Äôt populate the Page Tables correctly for 36 bits? (Something about 0x5027ffff)</p>
<p>Needs more investigation. But at least NuttX boots OK on Unicorn!</p>
<h1 id="boot-flow"><a class="doc-anchor" href="#boot-flow">¬ß</a>12 Boot Flow</h1>
<p>TODO</p>
<h1 id="todo"><a class="doc-anchor" href="#todo">¬ß</a>13 TODO</h1>
<p>TODO: What‚Äôs the diff?</p>
<p>TODO: Why are we doing this?</p>
<p>TODO: Changes to NuttX</p>
<p>TODO: HostFS</p>
<p>TODO</p>
<p><img src="https://lupyuen.org/images/unicorn3-table.png" alt="TODO" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.org/images/unicorn3-access.png" alt="TODO" /></p>
<p>TODO: PTE_BLOCK_DESC_AP_USER=1</p>
<div class="example-wrap"><pre class="language-text"><code>[7] AP[2] Stage 1 Indirect permissions are disabled.
See Stage 1 data accesses using Direct permissions.

[6] RES1 Stage 1 Indirect permissions are disabled and the translation regime supports a single privilege
level.
AP[1] Stage 1 Indirect permissions are disabled and the translation regime supports two privilege
levels.
See Stage 1 data accesses using Direct permissions.
PIIndex[0] Stage 1 Indirect permissions are enabled.
See Stage 1 Indirect permissions.</code></pre></div>
<p>TODO: AP[2:1]</p>
<div class="example-wrap"><pre class="language-text"><code>AP[2:1] Permissions
00 PrivRead, PrivWrite
01 PrivRead, PrivWrite, UnprivRead, UnprivWrite
10 PrivRead
11 PrivRead, UnprivRead
RPSZJJ</code></pre></div>
<p>TODO</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Read data from physical address
</span>ldr X0, =<span class="number">0x40000000
</span>ldr X1, [X0]

<span class="comment">// Initialize translation table control registers
</span>ldr X0, =<span class="number">0x180803F20
</span>msr TCR_EL1, X0
ldr X0, =<span class="number">0xFFFFFFFF
</span>msr MAIR_EL1, X0

<span class="comment">// Set translation table
</span>adr X0, ttb0_base
msr TTBR0_EL1, X0

<span class="comment">// Enable caches and the MMU
</span>mrs X0, SCTLR_EL1
orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">2</span>)  <span class="comment">// The C bit (data cache).
</span>orr X0, X0, #(<span class="number">0x1 </span>&lt;&lt; <span class="number">12</span>) <span class="comment">// The I bit (instruction cache).
</span>orr X0, X0, #<span class="number">0x1         </span><span class="comment">// The M bit (MMU).
</span>msr SCTLR_EL1, X0
dsb SY
isb

<span class="comment">// Read the same memory area through virtual address
</span>ldr X0, =<span class="number">0x80000000
</span>ldr X2, [X0]</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-bash"><code>## Level 1 Page Table with 4 Page Table Entries
## Entry #0
Page Table Entry @ 0x1000:
  0x0000_0741
Physical Address:
  0x0000_0000
Bit 00-01: PTE_BLOCK_DESC=1
Bit 06-07: PTE_BLOCK_DESC_AP_USER=1
Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
Bit 10:    PTE_BLOCK_DESC_AF=1

## Entry #1
Page Table Entry @ 0x1008:
  0xA000_0741
Physical Address:
  0xA000_0000
(Same Bits as above)

## Entry #2
Page Table Entry @ 0x1010:
  0x4000_0741
Physical Address:
  0x4000_0000
(Same Bits as above)

## Entry #3
Page Table Entry @ 0x1018:
  0x8000_0741
Physical Address:
  0x8000_0000
(Same Bits as above)

## Not the Page Table, but
## Data Referenced by our Assembly Code
Data @ 0x1020: 0x4000_0000
Data @ 0x1028: 0x1_8080_3F20
Data @ 0x1030: 0xFFFF_FFFF
Data @ 0x1038: 0x8000_0000</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-text"><code>Arm Architecture Reference Manual for A-profile architecture
https://developer.arm.com/documentation/ddi0487/latest/

My Deepest darkest fantasy:
Suppose we&#39;re in some wacky alternate universe 
What would it look like 
If arm64_mmu.c were created
Not in C
But in Rust?
 
pc: 1076364852
0x40280634

syndrome:2248147007
0x8600003f

fsr:5

vaddress:1076623231
0x402bf77f

target_el:1

test_arm64_mmu
https://github.com/unicorn-engine/unicorn/blob/master/tests/unit/test_arm64.c#L379

Add NOP and DSB SY
/private/tmp/250313/nuttx/arch/arm64/src/common/arm64_mmu.c:617
  write_sysreg((value | SCTLR_M_BIT
    40280628:	d28000a1 	mov	x1, #0x5                   	// #5
    4028062c:	aa010000 	orr	x0, x0, x1
    40280630:	d5181000 	msr	sctlr_el1, x0
/private/tmp/250313/nuttx/arch/arm64/src/common/arm64_mmu.c:625
  __asm__ volatile (&quot;nop&quot; : : : &quot;memory&quot;); ////
    40280634:	d503201f 	nop
/private/tmp/250313/nuttx/arch/arm64/src/common/arm64_mmu.c:626
  __asm__ volatile (&quot;nop&quot; : : : &quot;memory&quot;); ////
    40280638:	d503201f 	nop
/private/tmp/250313/nuttx/arch/arm64/src/common/arm64_mmu.c:627
  __asm__ volatile (&quot;dsb SY&quot; : : : &quot;memory&quot;); ////
    4028063c:	d5033f9f 	dsb	sy
/private/tmp/250313/nuttx/arch/arm64/src/common/arm64_mmu.c:628
  UP_ISB();
    40280640:	d5033fdf 	isb
arm64_mmu_init():
/private/tmp/250313/nuttx/arch/arm64/src/common/arm64_mmu.c:716
#else
  enable_mmu_el1(flags);
#endif

Still crash same place
PC=0x40280634

So MSR is crashing, not NOP
Why???
Why 0x402bf77f?

| Name | Physical | Size |
|:--------|:--------:|:----:|
| _DEVICE_REGION_ | 0x0700_0000 | _0x2000_0000_
| _DRAM0_S0_ | 0x4000_0000 | _0x0800_0000_
| _PCI_CFG_ | 0x40_1000_0000 | _0x1000_0000_
| _PCI_MEM_ | 0x80_0000_0000 | _0x80_0000_0000_
| _PCI_IO_ | 0x3EFF_0000 | _0x0001_0000_
| _nx_code_ | 0x4080_0000 | _0x0002_A000_
| _nx_rodata_ | 0x4082_A000 | _0x0000_6000_
| _nx_data_ | 0x4083_0000 | _0x0001_3000_
| _nx_pgpool_ | 0x40A0_0000 | _0x0040_0000_

Let&#39;s remove PCI*, nx*
arch/arm64/src/qemu/qemu_boot.c
static const struct arm_mmu_region g_mmu_regions[] =
{
  MMU_REGION_FLAT_ENTRY(&quot;DEVICE_REGION&quot;,
                        CONFIG_DEVICEIO_BASEADDR, CONFIG_DEVICEIO_SIZE,
                        MT_DEVICE_NGNRNE | MT_RW | MT_SECURE),

  MMU_REGION_FLAT_ENTRY(&quot;DRAM0_S0&quot;,
                        CONFIG_RAMBANK1_ADDR, CONFIG_RAMBANK1_SIZE,
                        MT_NORMAL | MT_RW | MT_SECURE),

  // MMU_REGION_FLAT_ENTRY(&quot;PCI_CFG&quot;,
  //                       CONFIG_PCI_CFG_BASEADDR, CONFIG_PCI_CFG_SIZE,
  //                       MT_NORMAL | MT_RW | MT_SECURE),

  // MMU_REGION_FLAT_ENTRY(&quot;PCI_MEM&quot;,
  //                       CONFIG_PCI_MEM_BASEADDR, CONFIG_PCI_MEM_SIZE,
  //                       MT_NORMAL | MT_RW | MT_SECURE),

  // MMU_REGION_FLAT_ENTRY(&quot;PCI_IO&quot;,
  //                       CONFIG_PCI_IO_BASEADDR, CONFIG_PCI_IO_SIZE,
  //                       MT_NORMAL | MT_RW | MT_SECURE),
};

nuttx/arch/arm64/src/common/arm64_mmu.c
static const struct arm_mmu_region g_mmu_nxrt_regions[] =
{
//   /* Mark text segment cacheable,read only and executable */

//   MMU_REGION_FLAT_ENTRY(&quot;nx_code&quot;,
//                         (uint64_t)_stext,
//                         (uint64_t)_sztext,
//                         MT_CODE | MT_SECURE),

//   /* Mark rodata segment cacheable, read only and execute-never */

//   MMU_REGION_FLAT_ENTRY(&quot;nx_rodata&quot;,
//                         (uint64_t)_srodata,
//                         (uint64_t)_szrodata,
//                         MT_RODATA | MT_SECURE),

//   /* Mark rest of the mirtos execution regions (data, bss, noinit, etc.)
//    * cacheable, read-write
//    * Note: read-write region is marked execute-ever internally
//    */

//   MMU_REGION_FLAT_ENTRY(&quot;nx_data&quot;,
//                         (uint64_t)_sdata,
//                         (uint64_t)_szdata,
//                         MT_NORMAL | MT_RW | MT_SECURE),

// #ifdef CONFIG_BUILD_KERNEL
//   MMU_REGION_FLAT_ENTRY(&quot;nx_pgpool&quot;,
//                         (uint64_t)CONFIG_ARCH_PGPOOL_PBASE,
//                         (uint64_t)CONFIG_ARCH_PGPOOL_SIZE,
//                         MT_NORMAL | MT_RW | MT_SECURE),
// #endif
};

{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}
vaddress:1076623231

Let&#39;s disable DRAM0_S0, enable nx*
{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}
Same same

Enable DRAM0_S0, set size to 0x80_0000
{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}
Same same

0x402bf77f is inside stack:
 .initstack     0x00000000402bc780     0x3000 /private/tmp/250317/nuttx/staging/libkarch.a(arm64_initialize.o)
                0x00000000402bc780                g_interrupt_stack
                0x00000000402bd780                g_idle_stack
                0x00000000402c0000                . = ALIGN (0x1000)
                0x00000000402c0000                g_idle_topstack = .
                0x00000000402c0000                _e_initstack = .
                0x0000000000013000                _szdata = (_e_initstack - _sdata)

enable_mmu_el1: &amp;stack=0x402bf75c

Enable Instruction Cache SCTLR_I_BIT
  /* Enable the MMU and data cache */

  value = read_sysreg(sctlr_el1);
//   write_sysreg((value | SCTLR_M_BIT
// #ifndef CONFIG_ARM64_DCACHE_DISABLE
//                | SCTLR_C_BIT
// #endif
//                ), sctlr_el1);
  write_sysreg(value | (1 &lt;&lt; 2) | (1 &lt;&lt; 12) | 1, sctlr_el1); ////

Nope still the same
{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}

Why is 0x402bf77f misaligned?

Register x24=
1076623232

sp_el (SP_EL0, 1, 2, 3)
{1076623232, 1076623232, 0, 0}

Reduce to 2 MMU Regions, remove nx*
  MMU_REGION_FLAT_ENTRY(&quot;DEVICE_REGION&quot;,
                        0x0, 0x40000000,
                        MT_DEVICE_NGNRNE | MT_RW),
                        // CONFIG_DEVICEIO_BASEADDR, CONFIG_DEVICEIO_SIZE,
                        // MT_DEVICE_NGNRNE | MT_RW | MT_SECURE),

  MMU_REGION_FLAT_ENTRY(&quot;DRAM0_S0&quot;,
                        0x40000000, 0x40000000,
                        MT_NORMAL | MT_RW | MT_EXECUTE),
                        // CONFIG_RAMBANK1_ADDR, CONFIG_RAMBANK1_SIZE,
                        // MT_NORMAL | MT_RW | MT_SECURE),

Same same:
{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}

Debug the TLB Entries
https://gist.github.com/lupyuen/6bf2193fb5b512c634d1f14a9b5b1dd6
arm64_mmu_init: xlat tables:
arm64_mmu_init: base table(L0): 0x402bb000, 512 entries
arm64_mmu_init: 0: 0x402b1000
arm64_mmu_init: 1: 0x402b2000
arm64_mmu_init: 2: 0x402b3000
arm64_mmu_init: 3: 0x402b4000
arm64_mmu_init: 4: 0x402b5000
arm64_mmu_init: 5: 0x402b6000
arm64_mmu_init: 6: 0x402b7000
arm64_mmu_init: 7: 0x402b8000
arm64_mmu_init: 8: 0x402b9000
arm64_mmu_init: 9: 0x402ba000
init_xlat_tables: mmap: virt 0 phys 0 size 0x40000000
set_pte_table_desc: 
set_pte_table_desc: 0x402bb000: [Table] 0x402b1000
set_pte_block_desc:    
set_pte_block_desc: 0x402b1000: 
set_pte_block_desc: DEV 
set_pte_block_desc: -RW 
set_pte_block_desc: -S 
set_pte_block_desc: -EXEC 
set_pte_block_desc: 
init_xlat_tables: mmap: virt 0x40000000 phys 0x40000000 size 0x40000000
set_pte_block_desc:    
set_pte_block_desc: 0x402b1008: 
set_pte_block_desc: MEM 
set_pte_block_desc: -RW 
set_pte_block_desc: -S 
set_pte_block_desc: -EXEC 
set_pte_block_desc: 
enable_mmu_el1: MMU enabled with dcache

Change MT_DEVICE_NGNRNE to:
  MMU_REGION_FLAT_ENTRY(&quot;DEVICE_REGION&quot;,
                        0x0, 0x40000000,
                        MT_NORMAL | MT_RW | MT_EXECUTE),
Same same:
{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}

    // Map 2 GB Read/Write/Execute Memory at 0x0000 0000 for
    // Memory-Mapped I/O and Arm64 Machine Code
    emu.mem_map(
        0x0000_0000,  // Address
        0x8000_0000,  // Size
        Permission::ALL  // Read/Write/Execute Access
    ).expect(&quot;failed to map memory&quot;);

Same same:
{syndrome:2248147007, fsr:5, vaddress:1076623231, target_el:1}

Does test_arm64_mmu work?
Yep test_arm64_mmu tested OK

    // Copy NuttX Kernel into the above address
    let kernel = include_bytes!(&quot;../nuttx/nuttx.bin&quot;);
    let mut arm64_code: [u8; 256 * 1024] = [0; 256 * 1024];
    assert!(arm64_code.len() &gt;= kernel.len());
    arm64_code[0..kernel.len()].copy_from_slice(kernel);

{syndrome:2248147007, fsr:5, vaddress:1076625407, target_el:1}
vaddress=0x402bffff

{syndrome:2248147007, fsr:5, vaddress:1076887551, target_el:1}

{syndrome:2248147007, fsr:5, vaddress:1084751871, target_el:1}
vaddress=0x40a7ffff

Increase Kernel Size to 16 MB
still fails
{syndrome:2248147007, fsr:5, vaddress:1093140479, target_el:1}
vaddress=0x4127ffff

Is NuttX Kernel mapping too much RAM into MMU?
What is the meaning of the TLB Entries in Unicorn Unit Test?

/*  Maximum numbers of translation tables
 *      This option specifies the maximum numbers of translation tables
 *  excluding the base translation table. Based on this, translation
 *  tables are allocated at compile time and used at runtime as needed.
 *  If the runtime need exceeds preallocated numbers of translation
 *  tables, it will result in assert. Number of translation tables
 *  required is decided based on how many discrete memory regions
 *  (both normal and device memory) are present on given platform and
 *  how much granularity is required while assigning attributes
 *  to these memory regions.
 */
#define CONFIG_MAX_XLAT_TABLES      10

That&#39;s why 10 xlat tables
Do we need 10?
arm64_mmu_init: xlat tables:
arm64_mmu_init: base table(L0): 0x402bb000, 512 entries
arm64_mmu_init: 0: 0x402b1000
arm64_mmu_init: 1: 0x402b2000
arm64_mmu_init: 2: 0x402b3000
arm64_mmu_init: 3: 0x402b4000
arm64_mmu_init: 4: 0x402b5000
arm64_mmu_init: 5: 0x402b6000
arm64_mmu_init: 6: 0x402b7000
arm64_mmu_init: 7: 0x402b8000
arm64_mmu_init: 8: 0x402b9000
arm64_mmu_init: 9: 0x402ba000

Reduce from 10 to 2
Same same
{syndrome:2248147007, fsr:5, vaddress:1093140479, target_el:1}
vaddress=0x4127ffff

https://gist.github.com/lupyuen/148410a14fe564028895d58236fe997e
set_pte_block_desc: addr_pa=0x47e00000
set_pte_block_desc: level=2
set_pte_block_desc: pte=0x402b21f8
set_pte_block_desc: mem_type=MEM
set_pte_block_desc: MT_RW=-RW
set_pte_block_desc: MT_NS=-S
set_pte_block_desc: MT_EXECUTE_NEVER=-EXEC
set_pte_block_desc: desc=0x47e00711

Mapped memory up to 0x800_0000
{syndrome:2248147007, fsr:5, vaddress:1210580991, target_el:1}
{syndrome:2248147007, fsr:5, vaddress:1344798719, target_el:1}
0x5027ffff

PTE Format
https://developer.arm.com/documentation/101811/0104/Address-spaces

enable_mmu_el1: mair_el1=0xff440c0400
enable_mmu_el1: tcr_el1=0x500803510
enable_mmu_el1: ttbr0_el1=0x402b3000

     * ldr X0, =0xFFFFFFFF
     * msr MAIR_EL1, X0

     * // Initialize translation table control registers
     * ldr X0, =0x180803F20
     * msr TCR_EL1, X0

     * // Set translation table
     * adr X0, ttb0_base
     * msr TTBR0_EL1, X0

https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/MAIR-EL1--Memory-Attribute-Indirection-Register--EL1-

https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TCR-EL1--Translation-Control-Register--EL1-

https://developer.arm.com/documentation/ddi0601/2024-12/AArch64-Registers/TTBR0-EL1--Translation-Table-Base-Register-0--EL1-

-----
tcr_el1
qemu 48 bits VA: 0x500803510
after 36 bits VA: 0x18080351c
after 32 bits VA: 0x180803520

Bit 0-5: 0b010000
T0SZ=0x10
48 bits of Virtual Address Space

Bit 8-9: 0b01
IRGN0=Normal memory, Inner Write-Back Read-Allocate Write-Allocate Cacheable.

Bit 14-15: 0
TG0=4KB

Bit 30-31: 0
TG1=Reserved???

Bit 32-34: 0b101
IPS=48 bits, 256 TB

-----
unicorn: 0x180803F20

Bit 0-5: 0b10000
T0SZ=0x20
32 bits of Virtual Address Space

Bit 8-9: 0b11
IRGN0=Normal memory, Inner Write-Back Read-Allocate No Write-Allocate Cacheable.

Bit 10-11: 0b11
ORGN0=Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable.

Bit 14-15: 0
TG0=4KB

Bit 30-31: 0b10
TG1=4KB

Bit 32-34: 1
IPS=36 bits, 64 GB

-----
Common:
Bit 12-13: TCR_SHARED_INNER
Bit 23

-----
a=0x0n
for (i = 0n; i &lt; 63n; i++) { if (a &amp; (1n &lt;&lt; i)) { console.log(`Bit ${i}`); } }

Add TG1:
  tcr |= TCR_TG0_4K | TCR_SHARED_INNER | TCR_ORGN_WBWA |
         TCR_IRGN_WBWA | TCR_TBI_FLAGS
         | TCR_TG1_4K ////
         ;

Same same:
{syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}

https://gist.github.com/lupyuen/7532d6e522e3a692b7ffec487727a515
enable_mmu_el1: mair_el1=0xff440c0400
enable_mmu_el1: tcr_el1=0x580803510
enable_mmu_el1: ttbr0_el1=0x402b3000

Change Physical Address from 48 to 36 bits
https://gist.github.com/lupyuen/728b09461f5f4ab32e7e4a80d744ba4d
enable_mmu_el1: mair_el1=0xff440c0400
enable_mmu_el1: tcr_el1=0x18080351c
enable_mmu_el1: ttbr0_el1=0x402b3000

Same same:
{syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}

Decode unicorn sample
TLBE @ 0x1000: 0x0000000000000741
TLBE @ 0x1008: 0x0000000040000741
TLBE @ 0x1010: 0x0000000040000741
TLBE @ 0x1018: 0x0000000040000741

TLBE @ 0x1020: 0x0000000040000000
TLBE @ 0x1028: 0x0000000180803f20
TLBE @ 0x1030: 0x00000000ffffffff
TLBE @ 0x1038: 0x0000000080000000

0x741=
Bit 0-1: PTE_BLOCK_DESC=1
Bit 6: PTE_BLOCK_DESC_AP_USER=1
Bit 8-9: PTE_BLOCK_DESC_INNER_SHARE=3
Bit 10: PTE_BLOCK_DESC_AF=1

#define CONFIG_MAX_XLAT_TABLES      1
https://gist.github.com/lupyuen/dedf2fc1d24f03ac293e8bc52d5b7b50

Same same:
{syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}

Change 36 bits of Virtual Address Space to 32 bits
CONFIG_ARM64_VA_BITS=32

https://gist.github.com/lupyuen/e53e71cdd06dd2f3baf6f80182a2f8c8
enable_mmu_el1: tcr_el1=0x180803520

https://gist.github.com/lupyuen/d541b88139cc28fd23ec63d3a5e75ec7
Boot OK yay!
err=Err(MAP)
PC=0x4028cfc0

000000004028cfa4 &lt;fdt_register&gt;:
fdt_register():
/Users/luppy/unicorn/nuttx/drivers/devicetree/fdt.c:66 (discriminator 1)
int fdt_register(FAR const char *fdt_base)
{
  struct fdt_header_s *fdt_header;
  DEBUGASSERT(fdt_base);
    4028cfa4:	b50000e0 	cbnz	x0, 4028cfc0 &lt;fdt_register+0x1c&gt;
/Users/luppy/unicorn/nuttx/drivers/devicetree/fdt.c:63

{syndrome:2248146950, fsr:518, vaddress:1344798719, target_el:1}
?syndrome
vaddress the same? 1344798719

Test more regions
TLBE @ 0x1000: 0x0000000000000741
addr_pa=0x00000000
Bit 00-01: PTE_BLOCK_DESC=1
Bit 06:    PTE_BLOCK_DESC_AP_USER=1
Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
Bit 10:    PTE_BLOCK_DESC_AF=1

TLBE @ 0x1008: 0x00000000a0000741
addr_pa=0xa0000000
Bit 00-01: PTE_BLOCK_DESC=1
Bit 06:    PTE_BLOCK_DESC_AP_USER=1
Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
Bit 10:    PTE_BLOCK_DESC_AF=1

TLBE @ 0x1010: 0x0000000040000741
addr_pa=0x40000000
Bit 00-01: PTE_BLOCK_DESC=1
Bit 06:    PTE_BLOCK_DESC_AP_USER=1
Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
Bit 10:    PTE_BLOCK_DESC_AF=1

TLBE @ 0x1018: 0x0000000080000741
addr_pa=0x80000000
Bit 00-01: PTE_BLOCK_DESC=1
Bit 06:    PTE_BLOCK_DESC_AP_USER=1
Bit 08-09: PTE_BLOCK_DESC_INNER_SHARE=3
Bit 10:    PTE_BLOCK_DESC_AF=1

x0=0x80000000
x1=0x4444444444444444
x2=0x4444444444444444

Disable Device Tree
https://gist.github.com/lupyuen/afcfafb5fbf48f9e399909e47f5b3f56
call_graph:  mmu_get_region_size --&gt; arm64_vectors
call_graph:  click mmu_get_region_size href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L785&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
err=Err(EXCEPTION)
PC=0x40280d60

Disable PSCI
https://gist.github.com/lupyuen/36e3cc1211b919344e0cac8d3a9dc649
Runs forever yay!
hook_block:  address=0x402818c0, size=08, gic_validate_redist_version, arch/arm64/src/common/arm64_gicv3.c:934:21
call_graph:  tasklist_initialize --&gt; gic_validate_redist_version
call_graph:  click tasklist_initialize href &quot;https://github.com/apache/nuttx/blob/master/sched/init/nx_start.c#L313&quot; &quot;sched/init/nx_start.c &quot; _blank
hook_block:  address=0x40281514, size=32, arm64_syscall, arch/arm64/src/common/arm64_syscall.c:299:32
call_graph:  gic_validate_redist_version --&gt; arm64_syscall</code></pre></div><h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>14 What‚Äôs Next</h1>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-starpro64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for StarPro64 EIC7700X‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Other Project: ‚ÄúNuttX for Oz64 SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>Older Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/unicorn3.md"><strong>lupyuen.org/src/unicorn3.md</strong></a></p>
<h1 id="appendix-simplified-nuttx-for-qemu"><a class="doc-anchor" href="#appendix-simplified-nuttx-for-qemu">¬ß</a>15 Appendix: Simplified NuttX for QEMU</h1>
<p>TODO: Simpler for debugging</p>
<p>(Could one of these changes, contribute to Unicorn Non-Crashing? It‚Äôs possible)</p>
<p>Why did we simplify? So we can be as close to MMU Demo as possible. And isolate the crashing problem.</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Simplified NuttX for QEMU Arm64 (Kernel Build)
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch unicorn-qemu-before
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch /unicorn-qemu
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## NuttX boots OK on QEMU.
## NSH Shell won&#39;t appear yet because we haven&#39;t compiled the NuttX Apps.
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx

## But NuttX crashes in Unicorn Emulator
git clone https://github.com/lupyuen/pinephone-emulator --branch qemu \
  $HOME/pinephone-emulator
cp nuttx.bin nuttx.S \
  $HOME/pinephone-emulator/nuttx/
cd $HOME/pinephone-emulator
cargo run

## err=Err(EXCEPTION)
## PC=0x402805f0
## call_graph:  setup_page_tables --&gt; ***_HALT_***
## call_graph:  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L546&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot; _blank
## env.exception={syndrome:2248146949, fsr:517, vaddress:1344798719, target_el:1}</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/103/files">PR for Unicorn QEMU: Before Fix</a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/102/files">PR for Unicorn QEMU: After Fix</a></p>
<p>For Unicorn Emulator: Don‚Äôt enable <strong>MMU Logging</strong>: <a href="TODO">arch/arm64/src/common/arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable MMU Logging
#define CONFIG_MMU_ASSERT   1
#define CONFIG_MMU_DEBUG    1
#define CONFIG_MMU_DUMP_PTE 1
#define trace_printf _info
#undef  sinfo
#define sinfo _info</code></pre></div>
    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>