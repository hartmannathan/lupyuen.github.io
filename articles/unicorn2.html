<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>(Clickable) Call Graph for Apache NuttX Real-Time Operating System</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="(Clickable) Call Graph for Apache NuttX Real-Time Operating System"
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">(Clickable) Call Graph for Apache NuttX Real-Time Operating System</h1>
    <nav id="TOC"><ul>
<li><a href="#intercept-code-execution-in-unicorn">1 Intercept Code Execution in Unicorn</a><ul></ul></li>
<li><a href="#map-address-to-function">2 Map Address to Function</a><ul></ul></li>
<li><a href="#dwarf-debug-symbols">3 DWARF Debug Symbols</a><ul></ul></li>
<li><a href="#mermaid-flowchart">4 Mermaid Flowchart</a><ul></ul></li>
<li><a href="#generate-call-graph">5 Generate Call Graph</a><ul></ul></li>
<li><a href="#pinephone-boots-nuttx">6 PinePhone Boots NuttX</a><ul>
<li><a href="#arm64-header">6.1 Arm64 Header</a><ul></ul></li>
<li><a href="#init-el1">6.2 Init EL1</a><ul></ul></li>
<li><a href="#primary-routine">6.3 Primary Routine</a><ul></ul></li>
<li><a href="#boot-chip">6.4 Boot Chip</a><ul></ul></li></ul></li>
<li><a href="#pinephone-continues-booting-nuttx">7 PinePhone Continues Booting NuttX</a><ul>
<li><a href="#after-boot-chip">7.1 After Boot Chip</a><ul></ul></li>
<li><a href="#after-primary-routine">7.2 After Primary Routine</a><ul></ul></li></ul></li>
<li><a href="#automated-daily-build-and-test">8 Automated Daily Build and Test</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-parse-dwarf-debug-symbols">10 Appendix: Parse DWARF Debug Symbols</a><ul></ul></li></ul></nav><p>üìù <em>10 Mar 2023</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn2-title.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<p>Last week we ran <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX Real-Time Operating System</strong></a> (RTOS) on <a href="https://www.unicorn-engine.org/"><strong>Unicorn Emulator</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn"><strong>‚Äú(Possibly) Emulate PinePhone with Unicorn Emulator‚Äù</strong></a></li>
</ul>
<p>And we hit a baffling <a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>Arm64 Exception</strong></a> in the (Emulated) <strong>Memory Management Unit</strong>.</p>
<p>In this article we‚Äôll create some tools  to <strong>troubleshoot the Arm64 Exception</strong> in NuttX‚Ä¶</p>
<ul>
<li>
<p>Render the <a href="https://en.wikipedia.org/wiki/Call_graph"><strong>Dynamic Call Graph</strong></a> for Apache NuttX RTOS, to understand how it boots (pic above)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Make it Clickable</strong></a>, so we can browse the <strong>NuttX Source Code</strong> as we explore the Call Graph</p>
</li>
<li>
<p>We‚Äôll use a <strong>Block Execution Hook</strong> in Unicorn Emulator to generate the Call Graph with Rust</p>
</li>
<li>
<p>And call the Rust Libraries <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> to map the Code Addresses to NuttX Kernel Functions</p>
</li>
<li>
<p>Thanks to the (Clickable) Call Graph, we‚Äôll describe the complete <strong>Boot Process</strong> of NuttX RTOS on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a></p>
</li>
<li>
<p>And explain how we might do <strong>Automated Daily Build and Test</strong> for NuttX on PinePhone</p>
</li>
</ul>
<p>CPU Emulators (like Unicorn) can be super helpful for understanding the internals of <strong>complex embedded programs</strong>‚Ä¶ Like Apache NuttX RTOS!</p>
<p>Let‚Äôs dive in and learn how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code4.png" alt="Running Apache NuttX RTOS in Unicorn" /></p>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn"><em>Running Apache NuttX RTOS in Unicorn</em></a></p>
<h1 id="intercept-code-execution-in-unicorn"><a href="#intercept-code-execution-in-unicorn">1 Intercept Code Execution in Unicorn</a></h1>
<p><em>What‚Äôs Unicorn? How does it work with Apache NuttX RTOS?</em></p>
<p><a href="https://www.unicorn-engine.org/"><strong>Unicorn</strong></a> is a lightweight <strong>CPU Emulator Framework</strong> based on <a href="http://www.qemu.org/"><strong>QEMU Emulator</strong></a>.</p>
<p>In the <a href="https://lupyuen.github.io/articles/unicorn"><strong>last article</strong></a> we called Unicorn (in Rust) to run the <strong>Arm64 Machine Code</strong> for Apache NuttX RTOS‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Arm64 Machine Code for Apache NuttX RTOS
</span><span class="kw">let </span>arm64_code = <span class="macro">include_bytes!</span>(<span class="string">&quot;../nuttx/nuttx.bin&quot;</span>);

<span class="comment">// Init Unicorn Emulator in Arm64 mode
</span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
  Arch::ARM64,
  Mode::LITTLE_ENDIAN
).expect(<span class="string">&quot;failed to init Unicorn&quot;</span>);

<span class="comment">// Magical horse mutates to bird
</span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;

<span class="comment">// Omitted: Map Executable Memory and I/O Memory in Unicorn
</span>...

<span class="comment">// Boot NuttX RTOS in Unicorn Emulator
</span><span class="kw">let </span>err = emu.emu_start(
  <span class="number">0x4008_0000</span>,  <span class="comment">// Begin Address
  </span><span class="number">0x4008_0000 </span>+ arm64_code.len() <span class="kw">as </span>u64,  <span class="comment">// End Address
  </span><span class="number">0</span>,  <span class="comment">// No Timeout
  </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
</span>);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn">(Source)</a></p>
<p>And NuttX starts booting in the Unicorn Emulator!</p>
<p><em>So Unicorn works like QEMU Emulator?</em></p>
<p>Yes but with a fun new twist: Unicorn lets us <strong>intercept the Execution</strong> of Emulated Code by attaching a <strong>Hook Function</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add Unicorn Hook that will intercept
// every Block of Arm64 Instructions
</span><span class="kw">let _ </span>= emu.add_block_hook(hook_block)
  .expect(<span class="string">&quot;failed to add block hook&quot;</span>);</code></pre></div>
<p>So we can <strong>trace the flow</strong> of the Emulated Code.</p>
<p>Here‚Äôs the <strong>Hook Function</strong> that will be called whenever Unicorn emulates a Block of Arm64 Instructions‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="comment">// TODO: Trace the flow of emulated code
  </span><span class="macro">println!</span>(<span class="string">&quot;hook_block:  address={address:#010x}, size={size:02}&quot;</span>);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/unicorn#block-execution-hook">(Source)</a></p>
<p>Unicorn Emulator calls our Hook Function, passing the‚Ä¶</p>
<ul>
<li>
<p><strong>Address</strong> of the Arm64 Code Block being emulated</p>
</li>
<li>
<p><strong>Size</strong> of the Arm64 Code Block being emulated</p>
</li>
</ul>
<p>Let‚Äôs modify the Hook Function to tell us what code it‚Äôs emulating‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#what-is-a-block-of-arm64-instructions">(What‚Äôs an Arm64 Code Block?)</a></p>
<h1 id="map-address-to-function"><a href="#map-address-to-function">2 Map Address to Function</a></h1>
<p><em>How do we use a Hook Function‚Ä¶</em></p>
<p><em>To tell us what code Unicorn is emulating?</em></p>
<p>Earlier we saw that Unicorn calls our Hook Function with the <strong>Address of the Arm64 Code</strong> that‚Äôs being emulated.</p>
<p>Let‚Äôs lookup the Arm64 Code Address to find the <strong>Name of the Function</strong> that‚Äôs running right now‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  
  address=0x40080920
  arm64_chip_boot

hook_block:  
  address=0x40080e50
  arm64_mmu_init
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p><em>How will we map the Arm64 Address to the Function Name?</em></p>
<p>Let‚Äôs pretend we‚Äôre a Debugger (like GDB). The best way to map an Arm64 Address to the Function Name would be‚Ä¶</p>
<p>The <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Debug Symbols</strong></a> in the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF File</strong></a>!</p>
<p>Assuming we can <strong>parse the Debug Symbols</strong> (from our ELF File), our Hook Function will translate the Arm64 Address to Function Name like so: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L158">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="macro">print!</span>(<span class="string">&quot;hook_block:  address={address:#010x}, size={size:02}&quot;</span>);

  <span class="comment">// Print the Function Name for the Arm64 Address
  </span><span class="kw">let </span>function = map_address_to_function(address);
  <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref </span>name) = function {  <span class="comment">// If we find the Function Name...
    </span><span class="macro">print!</span>(<span class="string">&quot;, {name}&quot;</span>);
  }

  <span class="comment">// Print the Source Filename, Line Number
  // and Column Number for the Arm64 Address
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  <span class="kw">let </span>(<span class="kw-2">ref </span>file, line, col) = loc;
  <span class="kw">let </span>file = file.clone().unwrap_or(<span class="string">&quot;&quot;</span>.to_string());  <span class="comment">// Default filename is &quot;&quot;
  </span><span class="kw">let </span>line = line.unwrap_or(<span class="number">0</span>);  <span class="comment">// Default line is 0
  </span><span class="kw">let </span>col  = col.unwrap_or(<span class="number">0</span>);   <span class="comment">// Default column is 0
  </span><span class="macro">println!</span>(<span class="string">&quot;, {file}:{line}:{col}&quot;</span>);
}</code></pre></div>
<p><em>The Debug Symbols will tell us the Source Filename?</em></p>
<p>Yep the <strong>Source Filename, Line Number and Column Number</strong> are in the DWARF Debug Symbols too!</p>
<p>Later we‚Äôll print them to make the Call Graph clickable.</p>
<p>But first we look inside <strong>map_address_to_function</strong> and <strong>map_address_to_location</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-dwarf.png" alt="DWARF Debugging Format" /></p>
<p><a href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf"><em>DWARF Debugging Format</em></a></p>
<h1 id="dwarf-debug-symbols"><a href="#dwarf-debug-symbols">3 DWARF Debug Symbols</a></h1>
<p><em>How will we load the Debug Symbols from our ELF File?</em></p>
<p>Our ELF File contains the Debug Symbols in <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Format</strong></a>.</p>
<p>The Rust Crates <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> will parse the DWARF Debug Symbols in our ELF File.</p>
<p>This is how we call the crates to map an <strong>Arm64 Address to Function Name</strong>:  <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L174-L193">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Function Name 
/// by looking up the DWARF Debug Symbols
</span><span class="kw">fn </span>map_address_to_function(
  address: u64         <span class="comment">// Arm64 Code Address
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;String&gt; {  <span class="comment">// Return the Function Name

  // Lookup the DWARF Frame for the Arm64 Code Address
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span><span class="kw-2">mut </span>frames = context.find_frames(address)
    .expect(<span class="string">&quot;failed to find frames&quot;</span>);

  <span class="comment">// Return the Function Name
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(frame) = frames.next().unwrap() {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(func) = frame.function {
      <span class="kw">if let </span><span class="prelude-val">Ok</span>(name) = func.raw_name() {
        <span class="kw">let </span>s = String::from(name);
        <span class="kw">return </span><span class="prelude-val">Some</span>(s);
      }
    }    
  }

  <span class="comment">// Function Name not found.
  // Probably an Arm64 Assembly Routine.
  </span><span class="prelude-val">None
</span>}</code></pre></div>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong>. In the code above, we‚Ä¶</p>
<ul>
<li>
<p>Lookup the Parsed Debug Symbols to find the <strong>DWARF Frame</strong> that matches the Arm64 Code Address</p>
</li>
<li>
<p>Extract the <strong>Function Name</strong> from the DWARF Frame</p>
</li>
</ul>
<p>(We‚Äôll come back to <strong>ELF_CONTEXT</strong>)</p>
<p>This is how we map an <strong>Arm64 Address to Source Filename</strong>: 
<a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L195-L221">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Source Filename,
/// Line Number and Column Number
</span><span class="kw">fn </span>map_address_to_location(
  address: u64     <span class="comment">// Arm64 Code Address
</span>) -&gt; (             <span class="comment">// Return the...
  </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line Number
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column Number
</span>) {
  <span class="comment">// Lookup the Source Location for the Arm64 Code Address
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span>loc = context.find_location(address)
    .expect(<span class="string">&quot;failed to find location&quot;</span>);

  <span class="comment">// Return the Source Filename, Line and Column
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(loc) = loc {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(file) = loc.file {

      <span class="comment">// Shorten the path
      </span><span class="kw">let </span>s = String::from(file)
        .replace(<span class="string">&quot;/private/tmp/nuttx/nuttx/&quot;</span>, <span class="string">&quot;&quot;</span>)
        .replace(<span class="string">&quot;arch/arm64/src/chip&quot;</span>, <span class="string">&quot;arch/arm64/src/a64&quot;</span>);  <span class="comment">// TODO: Handle other chips
      </span>(<span class="prelude-val">Some</span>(s), loc.line, loc.column)
    } <span class="kw">else </span>{
      <span class="comment">// If Filename is missing, return the Line and Column
      </span>(<span class="prelude-val">None</span>, loc.line, loc.column)
    }
  } <span class="kw">else </span>{
    <span class="comment">// Filename, Line and Column are missing
    </span>(<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>)
  }
}</code></pre></div>
<p>In the code above, we‚Ä¶</p>
<ul>
<li>
<p>Lookup the Parsed Debug Symbols to find the <strong>DWARF Location</strong> that matches the Arm64 Code Address</p>
</li>
<li>
<p>Extract the <strong>Source Filename, Line and Column</strong> from the DWARF Location</p>
</li>
</ul>
<p>Now that we‚Äôve extracted the <strong>Function Name and Source Filename</strong> from our ELF File, our <a href="https://lupyuen.github.io/articles/unicorn2#map-address-to-function"><strong>Hook Function</strong></a> will print meaningful traces of our Emulated Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:
  address=0x40080920
  size=12
  arm64_chip_boot
  arch/arm64/src/chip/a64_boot.c:82:1

hook_block:  
  address=0x40080e50
  size=28
  arm64_mmu_init
  arch/arm64/src/common/arm64_mmu.c:584:1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p>Which are super helpful for figuring out what‚Äôs happening inside Unicorn Emulator!</p>
<p><em>What‚Äôs ELF_CONTEXT?</em></p>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong> from our ELF File.</p>
<p>Here‚Äôs how we call the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> libraries to parse the Debug Symbols‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2#appendix-parse-dwarf-debug-symbols"><strong>‚ÄúParse DWARF Debug Symbols‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-title.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<h1 id="mermaid-flowchart"><a href="#mermaid-flowchart">4 Mermaid Flowchart</a></h1>
<p>TODO</p>
<p>Which produces this <a href="https://mermaid.js.org/syntax/flowchart.html">Mermaid Flowchart</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run | grep call_graph | cut -c 12- 

  flowchart TD

  arm64_boot_el1_init --&gt; arm64_isb
  click arm64_boot_el1_init href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L137&quot; &quot;arch/arm64/src/common/arm64_boot.c &quot;

  arm64_isb --&gt; arm64_boot_el1_init
  click arm64_isb href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/barriers.h#L57&quot; &quot;arch/arm64/src/common/barriers.h &quot;
  ...

  setup_page_tables --&gt; enable_mmu_el1
  click setup_page_tables href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L515&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot;

  enable_mmu_el1 --&gt; ***_HALT_***
  click enable_mmu_el1 href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L542&quot; &quot;arch/arm64/src/common/arm64_mmu.c &quot;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(Source)</a></p>
<p>The Call Graph is generated by our Block Execution Hook like so‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L159">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Hook Function for Block Emulation.
/// Called once for each Basic Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
<span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="comment">// Get the Function Name for the Arm64 Address
  </span><span class="kw">let </span>function = map_address_to_function(address);
  ...

  <span class="comment">// Get the Source Filename for the Arm64 Address
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  ...

  <span class="comment">// Print the Call Graph
  </span>call_graph(address, size, function, loc);
}</code></pre></div>
<h1 id="generate-call-graph"><a href="#generate-call-graph">5 Generate Call Graph</a></h1>
<p>TODO</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>‚ÄúCall Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p><code>call_graph</code> prints the Call Graph by looking up the Block Address in the ELF Context‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L222-L265">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Print the Mermaid Call Graph for this Function Call:
/// cargo run | grep call_graph | cut -c 12-
</span><span class="kw">fn </span>call_graph(
  _address: u64,  <span class="comment">// Code Address
  </span>_size: u32,     <span class="comment">// Size of Code Block
  </span>function: <span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Function Name
  </span>loc: (               <span class="comment">// Source Location
    </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
    </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line
    </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column
  </span>)
) {
  <span class="comment">// Get the Function Name
  </span><span class="kw">let </span>fname = <span class="kw">match </span>function {
    <span class="prelude-val">Some</span>(fname) =&gt; fname,
    <span class="prelude-val">None </span>=&gt; map_location_to_function(<span class="kw-2">&amp;</span>loc)
  };

  <span class="comment">// Skip if we are still in the same Function
  </span><span class="kw">let </span><span class="kw-2">mut </span>last_fname = LAST_FNAME.lock().unwrap();
  <span class="kw">let </span><span class="kw-2">mut </span>last_loc = LAST_LOC.lock().unwrap();
  <span class="kw">if </span>fname.eq(last_fname.as_str()) { <span class="kw">return</span>; }</code></pre></div>
<p>TODO</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// If this function has not been shown too often...
  </span><span class="kw">if </span>can_show_function(<span class="kw-2">&amp;</span>fname) {
    <span class="comment">// Print the Call Flow
    </span><span class="kw">if </span>last_fname.is_empty() {            
      <span class="macro">println!</span>(<span class="string">&quot;call_graph:  flowchart TD&quot;</span>);  <span class="comment">// Top-Down Flowchart
      </span><span class="macro">println!</span>(<span class="string">&quot;call_graph:  START --&gt; {fname}&quot;</span>);</code></pre></div>
<p>TODO</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    } <span class="kw">else </span>{
      <span class="comment">// URL looks like https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L541
      </span><span class="kw">let </span>(file, line, <span class="kw">_</span>) = last_loc.clone();
      <span class="kw">let </span>file = file.unwrap_or(<span class="string">&quot;&quot;</span>.to_string());
      <span class="kw">let </span>line = line.unwrap_or(<span class="number">1</span>) - <span class="number">1</span>;
      <span class="kw">let </span>url = <span class="macro">format!</span>(<span class="string">&quot;https://github.com/apache/nuttx/blob/master/{file}#L{line}&quot;</span>);
      <span class="macro">println!</span>(<span class="string">&quot;call_graph:  {last_fname} --&gt; {fname}&quot;</span>);
      <span class="macro">println!</span>(<span class="string">&quot;call_graph:  click {last_fname} href \&quot;{url}\&quot; \&quot;{file} \&quot;&quot;</span>);
    }
  }

  <span class="comment">// Remember the Function Name and Source Location
  </span><span class="kw-2">*</span>last_fname = fname;
  <span class="kw-2">*</span>last_loc = loc;
}</code></pre></div>
<p>We generated the Call Graph with this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo run | grep call_graph | cut -c 12-
</code></pre></div>
<p>(<code>cut</code> command removes columns 1 to 11)</p>
<h1 id="pinephone-boots-nuttx"><a href="#pinephone-boots-nuttx">6 PinePhone Boots NuttX</a></h1>
<p>TODO</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>‚ÄúCall Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<h2 id="arm64-header"><a href="#arm64-header">6.1 Arm64 Header</a></h2>
<p>TODO</p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L78-L227">arm64_head</a></p>
<ul>
<li>
<p>Calls <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L132-L162">arm64_boot_el1_init</a></p>
</li>
<li>
<p>And <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L181">arm64_boot_primary_c_routine</a></p>
</li>
</ul>
<h2 id="init-el1"><a href="#init-el1">6.2 Init EL1</a></h2>
<p>TODO</p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L132-L162">arm64_boot_el1_init</a></p>
<ul>
<li>
<p>Sets the EL1 Vector Table <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L135-L140">vbar_el1</a></p>
</li>
<li>
<p>Sets <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L140-L147">cpacr_el1</a></p>
</li>
<li>
<p>Sets <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L147-L153">sctlr_el1</a></p>
</li>
<li>
<p>Sets <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L153-L155">cntv_cval_el0</a></p>
</li>
</ul>
<h2 id="primary-routine"><a href="#primary-routine">6.3 Primary Routine</a></h2>
<p>TODO</p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L179-L184">arm64_boot_primary_c_routine</a></p>
<ul>
<li>
<p>Calls <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L164-L177">boot_early_memset</a></p>
<p>And <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_boot.c#L73-L105">arm64_chip_boot</a></p>
</li>
</ul>
<h2 id="boot-chip"><a href="#boot-chip">6.4 Boot Chip</a></h2>
<p>TODO</p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_boot.c#L73-L105">arm64_chip_boot</a></p>
<ul>
<li>
<p>Calls <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L577-L628">arm64_mmu_init</a></p>
</li>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L485-L524">setup_page_tables</a></p>
</li>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L526-L552">enable_mmu_el1</a></p>
</li>
<li>
<p>Which fails with MMU Fault</p>
</li>
</ul>
<h1 id="pinephone-continues-booting-nuttx"><a href="#pinephone-continues-booting-nuttx">7 PinePhone Continues Booting NuttX</a></h1>
<p>TODO: After fault</p>
<h2 id="after-boot-chip"><a href="#after-boot-chip">7.1 After Boot Chip</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_boot.c#L73-L105">arm64_chip_boot</a></p>
<ul>
<li>
<p>Calls <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_boardinit.c#L59-L85">a64_board_initialize</a></p>
</li>
<li>
<p>And <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_serial.c#L590-L619">a64_earlyserialinit</a></p>
</li>
</ul>
<h2 id="after-primary-routine"><a href="#after-primary-routine">7.2 After Primary Routine</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_boot.c#L179-L184">arm64_boot_primary_c_routine</a></p>
<ul>
<li>Calls nx_start</li>
</ul>
<h1 id="automated-daily-build-and-test"><a href="#automated-daily-build-and-test">8 Automated Daily Build and Test</a></h1>
<p>TODO</p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>This has been a fun educational exercise. Now we have a way to run <strong>Automated Daily Tests</strong> for Apache NuttX RTOS on PinePhone‚Ä¶ Kudos to the <strong>Maintainers of Unicorn Emulator</strong>!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/unicorn2.md"><strong>lupyuen.github.io/src/unicorn2.md</strong></a></p>
<h1 id="appendix-parse-dwarf-debug-symbols"><a href="#appendix-parse-dwarf-debug-symbols">10 Appendix: Parse DWARF Debug Symbols</a></h1>
<p>TODO</p>
<p>To run this, we need the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a>, <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> and <a href="https://crates.io/crates/once_cell"><strong>once_cell</strong></a> crates: <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/Cargo.toml#L8-L12">Cargo.toml</a></p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
addr2line = &quot;0.19.0&quot;
gimli = &quot;0.27.2&quot;
once_cell = &quot;1.17.1&quot;
unicorn-engine = &quot;2.0.0&quot;
</code></pre></div>
<p>At startup, we load the <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx/nuttx"><strong>NuttX ELF File</strong></a> into <strong>ELF_CONTEXT</strong> as a <a href="https://docs.rs/once_cell/latest/once_cell/"><strong>Lazy Static</strong></a>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L288-L322">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::rc::Rc;
<span class="kw">use </span>std::cell::RefCell;
<span class="kw">use </span>once_cell::sync::Lazy;

<span class="doccomment">/// ELF File for mapping Addresses to Function Names and Filenames
</span><span class="kw">const </span>ELF_FILENAME: <span class="kw-2">&amp;</span>str = <span class="string">&quot;nuttx/nuttx&quot;</span>;

<span class="doccomment">/// ELF Context for mapping Addresses to Function Names and Filenames
</span><span class="kw">static </span>ELF_CONTEXT: Lazy&lt;ElfContext&gt; = Lazy::new(|| {
  <span class="comment">// Open the ELF File
  </span><span class="kw">let </span>path = std::path::PathBuf::from(ELF_FILENAME);
  <span class="kw">let </span>file_data = std::fs::read(path)
    .expect(<span class="string">&quot;failed to read ELF&quot;</span>);
  <span class="kw">let </span>slice = file_data.as_slice();

  <span class="comment">// Parse the ELF File
  </span><span class="kw">let </span>obj = addr2line::object::read::File::parse(slice)
    .expect(<span class="string">&quot;failed to parse ELF&quot;</span>);
  <span class="kw">let </span>context = addr2line::Context::new(<span class="kw-2">&amp;</span>obj)
    .expect(<span class="string">&quot;failed to parse debug info&quot;</span>);

  <span class="comment">// Set the ELF Context
  </span>ElfContext {
    context: RefCell::new(context),
  }
});

<span class="doccomment">/// Wrapper for ELF Context. Needed for `Lazy`
</span><span class="kw">struct </span>ElfContext {
  context: RefCell&lt;
    addr2line::Context&lt;
      gimli::EndianReader&lt;
        gimli::RunTimeEndian, 
        Rc&lt;[u8]&gt;  <span class="comment">// Doesn&#39;t implement Send / Sync
      </span>&gt;
    &gt;
  &gt;
}

<span class="doccomment">/// Send and Sync for ELF Context. Needed for `Lazy`
</span><span class="kw">unsafe impl </span>Send <span class="kw">for </span>ElfContext {}
<span class="kw">unsafe impl </span>Sync <span class="kw">for </span>ElfContext {}</code></pre></div>

    
</body>
</html>