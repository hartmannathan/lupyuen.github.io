<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>(Clickable) Call Graph for Apache NuttX Real-Time Operating System</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="(Clickable) Call Graph for Apache NuttX Real-Time Operating System"
    data-rh="true">
<meta property="og:description" 
    content="Here's how Apache NuttX RTOS boots on Pine64 PinePhone... Visualised as a Call Graph with Unicorn Emulator and Rust"
    data-rh="true">
<meta name="description" 
    content="Here's how Apache NuttX RTOS boots on Pine64 PinePhone... Visualised as a Call Graph with Unicorn Emulator and Rust">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">(Clickable) Call Graph for Apache NuttX Real-Time Operating System</h1>
    <nav id="TOC"><ul>
<li><a href="#intercept-code-execution-in-unicorn">1 Intercept Code Execution in Unicorn</a><ul></ul></li>
<li><a href="#map-address-to-function">2 Map Address to Function</a><ul></ul></li>
<li><a href="#dwarf-debug-symbols">3 DWARF Debug Symbols</a><ul></ul></li>
<li><a href="#clickable-mermaid-flowchart">4 Clickable Mermaid Flowchart</a><ul></ul></li>
<li><a href="#generate-call-graph">5 Generate Call Graph</a><ul></ul></li>
<li><a href="#pinephone-boots-nuttx">6 PinePhone Boots NuttX</a><ul>
<li><a href="#arm64-header">6.1 Arm64 Header</a><ul></ul></li>
<li><a href="#initialise-el1">6.2 Initialise EL1</a><ul></ul></li>
<li><a href="#primary-routine">6.3 Primary Routine</a><ul></ul></li>
<li><a href="#boot-chip">6.4 Boot Chip</a><ul></ul></li></ul></li>
<li><a href="#pinephone-continues-booting-nuttx">7 PinePhone Continues Booting NuttX</a><ul>
<li><a href="#after-boot-chip">7.1 After Boot Chip</a><ul></ul></li>
<li><a href="#after-primary-routine">7.2 After Primary Routine</a><ul></ul></li>
<li><a href="#pinephone-drivers">7.3 PinePhone Drivers</a><ul></ul></li></ul></li>
<li><a href="#arm64-memory-management-fault">8 Arm64 Memory Management Fault</a><ul></ul></li>
<li><a href="#automated-daily-build-and-test">9 Automated Daily Build and Test</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-start-nsh-shell">11 Appendix: Start NSH Shell</a><ul></ul></li>
<li><a href="#appendix-parse-dwarf-debug-symbols">12 Appendix: Parse DWARF Debug Symbols</a><ul></ul></li></ul></nav><p>üìù <em>5 Mar 2023</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn2-title.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<p>Last week we ran <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX Real-Time Operating System</strong></a> (RTOS) on <a href="https://www.unicorn-engine.org/"><strong>Unicorn Emulator</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn"><strong>‚Äú(Possibly) Emulate PinePhone with Unicorn Emulator‚Äù</strong></a></li>
</ul>
<p>And we hit a baffling <a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>Arm64 Exception</strong></a> in the Unicorn Emulator while booting NuttX.</p>
<p>In this article we‚Äôll create some tools  to <strong>troubleshoot the Arm64 Exception</strong> in NuttX‚Ä¶</p>
<ul>
<li>
<p>Render the <a href="https://en.wikipedia.org/wiki/Call_graph"><strong>Dynamic Call Graph</strong></a> for Apache NuttX RTOS, to understand how it boots (pic above)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Make it Clickable</strong></a>, so we can browse the <strong>NuttX Source Code</strong> as we explore the Call Graph</p>
</li>
<li>
<p>We‚Äôll use a <strong>Block Execution Hook</strong> in Unicorn Emulator to generate the Call Graph with Rust</p>
</li>
<li>
<p>And call the Rust Libraries <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> to map the Code Addresses to NuttX Kernel Functions</p>
</li>
<li>
<p>Thanks to the (Clickable) Call Graph, we‚Äôll describe the complete <strong>Boot Sequence</strong> of NuttX RTOS on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a></p>
</li>
<li>
<p>And explain how we might do <strong>Automated Daily Build and Test</strong> for NuttX on PinePhone</p>
</li>
</ul>
<p>CPU Emulators (like Unicorn) can be super helpful for understanding the internals of <strong>complex embedded programs</strong>‚Ä¶ Like Apache NuttX RTOS!</p>
<p>Let‚Äôs dive in and learn how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code4.png" alt="Running Apache NuttX RTOS in Unicorn" /></p>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn"><em>Running Apache NuttX RTOS in Unicorn</em></a></p>
<h1 id="intercept-code-execution-in-unicorn"><a class="doc-anchor" href="#intercept-code-execution-in-unicorn">¬ß</a>1 Intercept Code Execution in Unicorn</h1>
<p><em>What‚Äôs Unicorn? How does it work with Apache NuttX RTOS?</em></p>
<p><a href="https://www.unicorn-engine.org/"><strong>Unicorn</strong></a> is a lightweight <strong>CPU Emulator Framework</strong> based on <a href="http://www.qemu.org/"><strong>QEMU Emulator</strong></a>.</p>
<p>In the <a href="https://lupyuen.github.io/articles/unicorn"><strong>last article</strong></a> we called Unicorn (in Rust) to run the <strong>Arm64 Machine Code</strong> for Apache NuttX RTOS‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Arm64 Machine Code for Apache NuttX RTOS
</span><span class="kw">let </span>arm64_code = <span class="macro">include_bytes!</span>(<span class="string">"../nuttx/nuttx.bin"</span>);

<span class="comment">// Init Unicorn Emulator in Arm64 mode
</span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
  Arch::ARM64,
  Mode::LITTLE_ENDIAN
).expect(<span class="string">"failed to init Unicorn"</span>);

<span class="comment">// Magical horse mutates to bird
</span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;

<span class="comment">// Omitted: Map Executable Memory and I/O Memory in Unicorn
</span>...

<span class="comment">// Boot NuttX RTOS in Unicorn Emulator
</span><span class="kw">let </span>err = emu.emu_start(
  <span class="number">0x4008_0000</span>,  <span class="comment">// Begin Address
  </span><span class="number">0x4008_0000 </span>+ arm64_code.len() <span class="kw">as </span>u64,  <span class="comment">// End Address
  </span><span class="number">0</span>,  <span class="comment">// No Timeout
  </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
</span>);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn">(Source)</a></p>
<p>When we run this, NuttX starts booting in the Unicorn Emulator!</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run 

- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
</code></pre></div>
<p><em>So Unicorn works like QEMU Emulator?</em></p>
<p>Yes but with a fun new twist: Unicorn lets us <strong>intercept the Execution</strong> of Emulated Code by attaching a <strong>Hook Function</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add Unicorn Hook that will intercept
// every Block of Arm64 Instructions
</span><span class="kw">let _ </span>= emu.add_block_hook(hook_block)
  .expect(<span class="string">"failed to add block hook"</span>);</code></pre></div>
<p>So we can <strong>trace the flow</strong> of the Emulated Code.</p>
<p>Here‚Äôs the <strong>Hook Function</strong> that will be called whenever Unicorn emulates a Block of Arm64 Instructions‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="comment">// TODO: Trace the flow of emulated code
  </span><span class="macro">println!</span>(<span class="string">"hook_block:  address={address:#010x}, size={size:02}"</span>);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/unicorn#block-execution-hook">(Source)</a></p>
<p>Unicorn Emulator calls our Hook Function, passing the‚Ä¶</p>
<ul>
<li>
<p><strong>Address</strong> of the Arm64 Code Block being emulated</p>
</li>
<li>
<p><strong>Size</strong> of the Arm64 Code Block being emulated</p>
</li>
</ul>
<p>Let‚Äôs modify the Hook Function to tell us what code it‚Äôs emulating‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#what-is-a-block-of-arm64-instructions">(What‚Äôs an Arm64 Code Block?)</a></p>
<h1 id="map-address-to-function"><a class="doc-anchor" href="#map-address-to-function">¬ß</a>2 Map Address to Function</h1>
<p><em>How do we use a Hook Function‚Ä¶</em></p>
<p><em>To tell us what code Unicorn is emulating?</em></p>
<p>Earlier we saw that Unicorn calls our Hook Function with the <strong>Address of the Arm64 Code</strong> that‚Äôs being emulated.</p>
<p>Let‚Äôs lookup the Arm64 Code Address to find the <strong>Name of the Function</strong> that‚Äôs running right now‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run

hook_block:  
  address=0x40080920
  arm64_chip_boot

hook_block:  
  address=0x40080e50
  arm64_mmu_init
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p><em>How will we map the Arm64 Address to the Function Name?</em></p>
<p>Pretend we‚Äôre a Debugger (like GDB). The best way to map an Arm64 Address to the Function Name would be‚Ä¶</p>
<p>The <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Debug Symbols</strong></a> in the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF File</strong></a>!</p>
<p>Assuming we can <strong>parse the Debug Symbols</strong> (from our ELF File), our Hook Function will translate the Arm64 Address to Function Name like so: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L158">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="macro">print!</span>(<span class="string">"hook_block:  address={address:#010x}, size={size:02}"</span>);

  <span class="comment">// Print the Function Name for the Arm64 Address
  </span><span class="kw">let </span>function = map_address_to_function(address);
  <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref </span>name) = function {  <span class="comment">// If we find the Function Name...
    </span><span class="macro">print!</span>(<span class="string">", {name}"</span>);
  }

  <span class="comment">// Print the Source Filename, Line Number
  // and Column Number for the Arm64 Address
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  <span class="kw">let </span>(<span class="kw-2">ref </span>file, line, col) = loc;
  <span class="kw">let </span>file = file.clone().unwrap_or(<span class="string">""</span>.to_string());  <span class="comment">// Default filename is ""
  </span><span class="kw">let </span>line = line.unwrap_or(<span class="number">0</span>);  <span class="comment">// Default line is 0
  </span><span class="kw">let </span>col  = col.unwrap_or(<span class="number">0</span>);   <span class="comment">// Default column is 0
  </span><span class="macro">println!</span>(<span class="string">", {file}:{line}:{col}"</span>);
}</code></pre></div>
<p><em>The Debug Symbols will tell us the Source Filename?</em></p>
<p>Yep the <strong>Source Filename, Line Number and Column Number</strong> are in the DWARF Debug Symbols too!</p>
<p>Later we‚Äôll print them to make the Call Graph clickable.</p>
<p>But first we look inside <strong>map_address_to_function</strong> and <strong>map_address_to_location</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-dwarf.png" alt="DWARF Debugging Format" /></p>
<p><a href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf"><em>DWARF Debugging Format</em></a></p>
<h1 id="dwarf-debug-symbols"><a class="doc-anchor" href="#dwarf-debug-symbols">¬ß</a>3 DWARF Debug Symbols</h1>
<p><em>How will we load the Debug Symbols from our ELF File?</em></p>
<p>Our ELF File contains the Debug Symbols in <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Format</strong></a>.</p>
<p>The Rust Crates <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> will parse the DWARF Debug Symbols in our ELF File.</p>
<p>This is how we call the crates to map an <strong>Arm64 Address to Function Name</strong>:  <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L174-L193">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Function Name 
/// by looking up the DWARF Debug Symbols
</span><span class="kw">fn </span>map_address_to_function(
  address: u64         <span class="comment">// Arm64 Code Address
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;String&gt; {  <span class="comment">// Return the Function Name

  // Lookup the DWARF Frame for the Arm64 Code Address
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span><span class="kw-2">mut </span>frames = context.find_frames(address)
    .expect(<span class="string">"failed to find frames"</span>);

  <span class="comment">// Return the Function Name
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(frame) = frames.next().unwrap() {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(func) = frame.function {
      <span class="kw">if let </span><span class="prelude-val">Ok</span>(name) = func.raw_name() {
        <span class="kw">let </span>s = String::from(name);
        <span class="kw">return </span><span class="prelude-val">Some</span>(s);
      }
    }    
  }

  <span class="comment">// Function Name not found.
  // Probably an Arm64 Assembly Routine.
  </span><span class="prelude-val">None
</span>}</code></pre></div>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong>. In the code above, we‚Ä¶</p>
<ul>
<li>
<p>Lookup the Parsed Debug Symbols to find the <strong>DWARF Frame</strong> that matches the Arm64 Code Address</p>
</li>
<li>
<p>Extract the <strong>Function Name</strong> from the DWARF Frame</p>
</li>
</ul>
<p>(We‚Äôll come back to <strong>ELF_CONTEXT</strong>)</p>
<p>This is how we map an <strong>Arm64 Address to Source Filename</strong>: 
<a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L195-L221">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Source Filename,
/// Line Number and Column Number
</span><span class="kw">fn </span>map_address_to_location(
  address: u64     <span class="comment">// Arm64 Code Address
</span>) -&gt; (             <span class="comment">// Return the...
  </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line Number
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column Number
</span>) {
  <span class="comment">// Lookup the Source Location for the Arm64 Code Address
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span>loc = context.find_location(address)
    .expect(<span class="string">"failed to find location"</span>);

  <span class="comment">// Return the Source Filename, Line and Column
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(loc) = loc {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(file) = loc.file {

      <span class="comment">// Shorten the path
      </span><span class="kw">let </span>s = String::from(file)
        .replace(<span class="string">"/private/tmp/nuttx/nuttx/"</span>, <span class="string">""</span>)
        .replace(<span class="string">"arch/arm64/src/chip"</span>, <span class="string">"arch/arm64/src/a64"</span>);  <span class="comment">// TODO: Handle other chips
      </span>(<span class="prelude-val">Some</span>(s), loc.line, loc.column)
    } <span class="kw">else </span>{
      <span class="comment">// If Filename is missing, return the Line and Column
      </span>(<span class="prelude-val">None</span>, loc.line, loc.column)
    }
  } <span class="kw">else </span>{
    <span class="comment">// Filename, Line and Column are missing
    </span>(<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>)
  }
}</code></pre></div>
<p>In the code above, we‚Ä¶</p>
<ul>
<li>
<p>Lookup the Parsed Debug Symbols to find the <strong>DWARF Location</strong> that matches the Arm64 Code Address</p>
</li>
<li>
<p>Extract the <strong>Source Filename, Line and Column</strong> from the DWARF Location</p>
</li>
</ul>
<p>Now that we‚Äôve extracted the <strong>Function Name and Source Filename</strong> from our ELF File, our <a href="https://lupyuen.github.io/articles/unicorn2#map-address-to-function"><strong>Hook Function</strong></a> will print meaningful traces of our Emulated Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run 

hook_block:
  address=0x40080920
  size=12
  arm64_chip_boot
  arch/arm64/src/chip/a64_boot.c:82:1

hook_block:  
  address=0x40080e50
  size=28
  arm64_mmu_init
  arch/arm64/src/common/arm64_mmu.c:584:1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p>Which are super helpful for figuring out what‚Äôs happening inside Unicorn Emulator!</p>
<p><em>What‚Äôs ELF_CONTEXT?</em></p>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong> from our ELF File.</p>
<p>Here‚Äôs how we call the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> libraries to parse the Debug Symbols‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2#appendix-parse-dwarf-debug-symbols"><strong>‚ÄúParse DWARF Debug Symbols‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-title.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<h1 id="clickable-mermaid-flowchart"><a class="doc-anchor" href="#clickable-mermaid-flowchart">¬ß</a>4 Clickable Mermaid Flowchart</h1>
<p><em>As Unicorn Emulator runs, it prints a long list of Function Names‚Ä¶</em></p>
<p><em>How can we make sense of the Function Names?</em></p>
<p>Let‚Äôs transform the long list of <a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a"><strong>Function Names</strong></a>‚Ä¶</p>
<p>Into a <a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Clickable Call Graph</strong></a> that shows exactly how the functions are called!</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos">(Like this)</a></p>
<p><em>Whoa! We need a special diagramming tool?</em></p>
<p>Actually we can render a <a href="https://mermaid.js.org/syntax/flowchart.html"><strong>Mermaid Flowchart</strong></a> by simply printing this in <a href="https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams"><strong>Markdown Format</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>```mermaid
flowchart TD
START --&gt; arm64_head
arm64_head --&gt; a64_lowputc
arm64_head --&gt; arm64_boot_primary_c_routine
...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(Source)</a></p>
<p>(<strong>TD</strong> means Top-Down Flowchart)</p>
<p>To make a <a href="https://mermaid.js.org/syntax/flowchart.html#interaction"><strong>Clickable Mermaid Flowchart</strong></a>, we print the URLs like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>click arm64_head href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L104&quot; &quot;arch/arm64/src/common/arm64_head.S&quot; _blank
</code></pre></div>
<p>This jumps to the <strong>NuttX Source Code</strong> when we click the Function Name.</p>
<p>(Second part of <strong>href</strong> is the Mouseover Tooltip)</p>
<p>To <strong>preview the flowchart</strong> and check the hyperlinks, we use this handy web tool‚Ä¶</p>
<ul>
<li><a href="https://mermaid.live/edit#pako:eNrtmstuozAUhl8FeXZVGsKdsBipUhez6Gqa1SgSMo4bULnJGDWZqu8-xmlKCCQpbWgh40UrIL_d7z_Hx3aKnwFKFhg4QJIewuQJ-ZBQaXY7jyXpfnbzeyZdX_-UIIlM3fUxXBTPy7vNh-yGtUxziopPURigx12NT_CDNAc-pWnmyPIyoH7ujVESyTCFyMdynFO6kr0w8eQIZhQTGRLky7wLOSNIZtooieWyz_H9jztlos8B6_e0lok4dsnZYOoVe0fzeW7Wm7zTY0Ft2E3QNeEWuR-RtqwBRtq2hhdpdWqLSItIi0iLSItIi0iLSH8g0nvY_NZLEuriUHGDOKADwK_w7vgIMm-fvio9s42i8zFiO0Dt9A5wo63YYLjvTUIhPRu8BwkJMMnGPttwHyMvhf0Ov278T-FvKt6UBBEkaxe5JMlpEOOhVHENnDuLcJRh2jiY6g26GlX2pN2o2kC3yMxrgw_wh4GXFb-QnFESxMvi2t10x9HNTUKOyt6bi40A-UHKVd-dFOUjpf5Gv-MoivLGWi-159tlbPGb6auqCvgWknOztOWpm8Ildin0Qpzto7-pzxx91m9Bb9jayeBz6auFGi93UQC6qxDSmom6vhsf-nTSysc-MbeBYIhy9gy7KfsJ4gVelU5qLToyolitjDQwn0hJU4tuvKi6-fmkFJALnCGXrlP89enQ26WjQsv5Y_zE5lIMwzBBG9bSRFXdURI0vZWDOu-J8dTQoBsnmmVfSI1r56nxA6XR3wKvV8fRdPSxPPo931qfLxC2YnNQ9rfRIw9_7yfdOvLpXcl-g44yMtUuZMoyTLEtuaRtyeFE9HHW7W9dWKpYysVSLpbyM01UF7MAXsCiISbdQexELqXKh1UcYkwNYUwJH8KH8HHUx6HXTz3dVw3_H-wXkohGG8dy0dPN4YH3HVkaBodrvLfvPJqwKzMWh91z09ioo-xMFFEswsb32mg-xIBjXhrFgQscKl9_hMFQjFYuqryHzuztqTpC19rNudXDeocC36tzeg3Rvrq6cn_d3M1cdvHVAdfbBByMQIRJBIMFcMBzgToH1McRngOHXS4geSxkL0wHc5rcr2MEHEpyPAJ5umBfWm8DuCQwAs4DDDP2NIXxnySJtiJ2C5xnsAKObowVbTpRpgYbEvrEHoE1cBR1bKi6PVUN1TJt1TS0lxH4y9sr44liqIqtT01NVU1NsV_-AeJmZMs"><strong>Mermaid Live Editor</strong></a></li>
</ul>
<p><em>How will we generate the Clickable Call Graph?</em></p>
<p>Remember our <a href="https://lupyuen.github.io/articles/unicorn2#intercept-code-execution-in-unicorn"><strong>Hook Function</strong></a> that intercepts every Block of Arm64 Instructions emulated by Unicorn?</p>
<p>Let‚Äôs <strong>print the Call Graph</strong> inside our Hook Function: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L159">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="comment">// Get the Function Name for the Arm64 Address
  </span><span class="kw">let </span>function = map_address_to_function(address);
  ...

  <span class="comment">// Get the Source Filename for the Arm64 Address
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  ...

  <span class="comment">// Print the Call Graph
  </span>call_graph(address, size, function, loc);
}</code></pre></div>
<p>Now we look inside the <strong>call_graph</strong> function‚Ä¶</p>
<h1 id="generate-call-graph"><a class="doc-anchor" href="#generate-call-graph">¬ß</a>5 Generate Call Graph</h1>
<p><em>Our Hook Function calls <strong>call_graph</strong> to print the Call Graph‚Ä¶</em></p>
<p><em>What‚Äôs inside <strong>call_graph</strong>?</em></p>
<p>Earlier we said that we‚Äôre generating this <strong>Clickable Call Graph</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>‚ÄúCall Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>Which needs a <strong>Mermaid Flowchart</strong> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>```mermaid
flowchart TD
START --&gt; arm64_head
arm64_head --&gt; a64_lowputc
click arm64_head href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L104&quot; &quot;arch/arm64/src/common/arm64_head.S&quot; _blank
...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(Source)</a></p>
<p>Our <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L159"><strong>Hook Function</strong></a> calls <strong>call_graph</strong>, which prints the Mermaid Flowchart (line by line) like so: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L222-L265">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Print the Mermaid Call Graph for this Function Call:
/// cargo run | grep call_graph | cut -c 12-
</span><span class="kw">fn </span>call_graph(
  _address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>_size: u32,     <span class="comment">// Size of Arm64 Code Block
  </span>function: <span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Function Name
  </span>loc: (             <span class="comment">// Source Location
    </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
    </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line
    </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column
  </span>)
) {
  <span class="comment">// Get the Function Name
  </span><span class="kw">let </span>fname = <span class="kw">match </span>function {
    <span class="prelude-val">Some</span>(fname) =&gt; fname,
    <span class="prelude-val">None </span>=&gt; map_location_to_function(<span class="kw-2">&amp;</span>loc)
  };

  <span class="comment">// Skip if we are still in the same Function
  </span><span class="kw">let </span><span class="kw-2">mut </span>last_fname = LAST_FNAME.lock().unwrap();
  <span class="kw">let </span><span class="kw-2">mut </span>last_loc = LAST_LOC.lock().unwrap();
  <span class="kw">if </span>fname.eq(last_fname.as_str()) { <span class="kw">return</span>; }</code></pre></div>
<p><strong>call_graph</strong> receives the Function Name and Source Filename, which we have <a href="https://lupyuen.github.io/articles/unicorn2#map-address-to-function"><strong>loaded from the ELF File</strong></a>.</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L267-L280">(<strong>map_location_to_function</strong> is defined here)</a></p>
<p><em>What are last_fname and last_loc?</em></p>
<p>We remember the Previous Function Name (<strong>last_fname</strong>) and Previous Filename (<strong>last_loc</strong>)‚Ä¶</p>
<p>So we can connect the <strong>Calling Function</strong> with the <strong>Called Function</strong> in our Call Graph.</p>
<p>(OK this doesn‚Äôt always work‚Ä¶ But it‚Äôs good enough!)</p>
<p>This is how we <strong>start the Call Graph</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// GitHub won't render Mermaid Markdown that's too long.
  // If this function has not been shown too often...
  </span><span class="kw">if </span>can_show_function(<span class="kw-2">&amp;</span>fname) {
    <span class="comment">// Print the Call Flow
    </span><span class="kw">if </span>last_fname.is_empty() {            
      <span class="macro">println!</span>(<span class="string">"call_graph:  flowchart TD"</span>);  <span class="comment">// Top-Down Flowchart
      </span><span class="macro">println!</span>(<span class="string">"call_graph:  START --&gt; {fname}"</span>);</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L282-L295">(<strong>can_show_function</strong> is defined here)</a></p>
<p>And this is how we <strong>connect the Calling Function</strong> with the Called Function‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    } <span class="kw">else </span>{
      <span class="comment">// URL looks like https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L541
      </span><span class="kw">let </span>(file, line, <span class="kw">_</span>) = last_loc.clone();
      <span class="kw">let </span>file = file.unwrap_or(<span class="string">""</span>.to_string());
      <span class="kw">let </span>line = line.unwrap_or(<span class="number">1</span>) - <span class="number">1</span>;
      <span class="kw">let </span>url = <span class="macro">format!</span>(<span class="string">"https://github.com/apache/nuttx/blob/master/{file}#L{line}"</span>);
      <span class="macro">println!</span>(<span class="string">"call_graph:  {last_fname} --&gt; {fname}"</span>);
      <span class="macro">println!</span>(<span class="string">"call_graph:  click {last_fname} href \"{url}\" \"{file} \""</span>);
    }
  }

  <span class="comment">// Remember the Function Name and Source Location
  </span><span class="kw-2">*</span>last_fname = fname;
  <span class="kw-2">*</span>last_loc = loc;
}</code></pre></div>
<p>To <strong>generate the Call Graph</strong> (via Unicorn Emulator), we run this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo run \
  | grep call_graph \
  | cut -c 12-
</code></pre></div>
<p>(<strong>cut</strong> removes columns 1 to 11)</p>
<p>Unicorn Emulator runs our Arm64 Machine Code, intercepts every Arm64 Instruction and generates the Call Graph.</p>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(See the output)</a></p>
<p>Thus finally we get our super-informative <a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Clickable Call Graph</strong></a>‚Ä¶ That tells us how every function gets called!</p>
<p>Now we analyse the Call Graph for NuttX RTOS‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph2.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<h1 id="pinephone-boots-nuttx"><a class="doc-anchor" href="#pinephone-boots-nuttx">¬ß</a>6 PinePhone Boots NuttX</h1>
<p><em>NuttX halts with a Memory Management Fault when it boots‚Ä¶</em></p>
<p><em>What can the Call Graph tell us about the fault?</em></p>
<p>We click and walk through the <a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Call Graph</strong></a> to find out what went wrong, from <strong>START</strong> to <strong>HALT</strong> (pic above)‚Ä¶</p>
<ol>
<li>
<p>NuttX starts at <a href="https://lupyuen.github.io/articles/unicorn2#arm64-header"><strong>arm64_head</strong></a></p>
<p>(To prepare Arm64 Exception Levels 1 and 2)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#primary-routine"><strong>arm64_boot_primary_c_routine</strong></a></p>
<p>(To start the NuttX Kernel)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a></p>
<p>(To configure the Arm64 CPU)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_mmu_init</strong></a></p>
<p>(To initialise the Arm64 Memory Management Unit)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>setup_page_tables</strong></a></p>
<p>(To set up the Arm64 Memory Page Tables)</p>
</li>
<li>
<p>And calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>enable_mmu_el1</strong></a></p>
<p>(To enable the Arm64 Memory Management Unit)</p>
</li>
<li>
<p>Which halts with an Arm64 <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>Memory Management Fault</strong></a></p>
</li>
</ol>
<p>To understand what‚Äôs really happening, we dive into each of the above functions.</p>
<p><em>How is this relevant to PinePhone?</em></p>
<p>Unicorn Emulator runs the exact same Arm64 Machine Code as <strong>NuttX for PinePhone</strong>‚Ä¶</p>
<p>Whatever happens in Unicorn Emulator‚Ä¶ Will happen in PinePhone too!</p>
<p>Hence along the way we‚Äôll learn how exactly NuttX boots on PinePhone.</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph3.jpg" alt="Arm64 Header" /></p>
<h2 id="arm64-header"><a class="doc-anchor" href="#arm64-header">¬ß</a>6.1 Arm64 Header</h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_head.S#L78-L227"><strong>arm64_head</strong></a> is the first thing that runs when NuttX boots on Unicorn Emulator. (And PinePhone)</p>
<p>(It looks like a <a href="https://lupyuen.github.io/articles/uboot#linux-kernel-header"><strong>Linux Kernel Header</strong></a>, hence the name)</p>
<p>The assembly code calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#initialise-el1"><strong>arm64_boot_el1_init</strong></a> to prepare <strong>Arm64 Exception Level 1</strong></p>
<p><a href="https://lupyuen.github.io/articles/interrupt#exception-levels">(What‚Äôs an Arm64 Exception Level?)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#primary-routine"><strong>arm64_boot_primary_c_routine</strong></a> to boot the <strong>NuttX Kernel</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph4.jpg" alt="Initialise EL1" /></p>
<h2 id="initialise-el1"><a class="doc-anchor" href="#initialise-el1">¬ß</a>6.2 Initialise EL1</h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L132-L162"><strong>arm64_boot_el1_init</strong></a> prepares <a href="https://lupyuen.github.io/articles/interrupt#exception-levels"><strong>Arm64 Exception Level 1 (EL1)</strong></a> for booting NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L135-L140"><strong>VBAR EL1</strong></a>: Set the <strong>EL1 Vector Table</strong> in the Arm64 Vector Base Address Register</p>
<p><a href="https://lupyuen.github.io/articles/interrupt#arm64-vector-table-is-wrong">(More about <strong>VBAR EL1</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L140-L147"><strong>CPACR EL1</strong></a>: Set the Arm64 Architectural Feature Access Control Register </p>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-03/AArch64-Registers/CPACR-EL1--Architectural-Feature-Access-Control-Register">(More about <strong>CPACR EL1</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L147-L153"><strong>SCTLR EL1</strong></a>: Set the Arm64 System Control Register</p>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/SCTLR-EL1--System-Control-Register--EL1-">(More about <strong>SCTLR EL1</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L153-L155"><strong>CNTV CVAL EL0</strong></a>: Set the Arm64 Counter-Timer Virtual Timer Compare-Value Register</p>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-12/AArch64-Registers/CNTV-CVAL-EL0--Counter-timer-Virtual-Timer-CompareValue-register">(More about <strong>CNTV CVAL EL0</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph5.jpg" alt="Primary Routine" /></p>
<h2 id="primary-routine"><a class="doc-anchor" href="#primary-routine">¬ß</a>6.3 Primary Routine</h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L179-L184"><strong>arm64_boot_primary_c_routine</strong></a> starts the NuttX Kernel. It calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L164-L177"><strong>boot_early_memset</strong></a> to fill the <a href="https://en.wikipedia.org/wiki/.bss"><strong>BSS Section</strong></a> with 0</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a> to configure the Arm64 CPU</p>
</li>
</ul>
<p>And more‚Ä¶ We‚Äôll come back to the Primary Routine in the next chapter.</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph6.jpg" alt="Boot Chip" /></p>
<h2 id="boot-chip"><a class="doc-anchor" href="#boot-chip">¬ß</a>6.4 Boot Chip</h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/a64/a64_boot.c#L73-L105"><strong>arm64_chip_boot</strong></a> configures the Arm64 CPU. It calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L577-L628"><strong>arm64_mmu_init</strong></a>: To initialise the Arm64 Memory Management Unit for Exception Level 1</p>
</li>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L485-L524"><strong>setup_page_tables</strong></a>: To set up the Arm64 Memory Translation Tables</p>
</li>
<li>
<p>And calls <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L526-L552"><strong>enable_mmu_el1</strong></a>: To enable the Arm64 Memory Management Unit and Data Cache for Exception Level 1</p>
</li>
<li>
<p>Which halts with an Arm64 <a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>Memory Management Fault</strong></a>: Invalid Arm64 Address Translation or Caching at <code>0x400C</code> <code>3FFF</code></p>
</li>
</ul>
<p><em>What caused the Arm64 Memory Management Fault?</em></p>
<p>The fault happens <strong>only in Unicorn Emulator</strong>, not on PinePhone. So it might be caused by our configuration of Unicorn Emulator.</p>
<p>We‚Äôll come back to this in a while. First we talk about the rest of the NuttX Boot Sequence‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-title.jpg" alt="NuttX Terminal on PinePhone" /></p>
<h1 id="pinephone-continues-booting-nuttx"><a class="doc-anchor" href="#pinephone-continues-booting-nuttx">¬ß</a>7 PinePhone Continues Booting NuttX</h1>
<p><em>Suppose we fix the Arm64 Memory Management Fault‚Ä¶</em></p>
<p><em>What will happen next?</em></p>
<p>Right now we have an Arm64 <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>Memory Management Fault</strong></a> that gets tripped inside <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a>.</p>
<p>(Only in <strong>Unicorn Emulator</strong>, not on PinePhone)</p>
<p>When we fix the fault, we expect NuttX to boot successfully to the <strong>NSH Command Prompt</strong>.</p>
<p>(Just like on PinePhone, pic above)</p>
<p><em>But what happens between arm64_chip_boot and NSH Command Prompt?</em></p>
<p>Let‚Äôs trace the <strong>NuttX Boot Sequence</strong> after <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a>, so that we understand completely how PinePhone boots to the NSH Command Prompt‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph5.jpg" alt="Primary Routine" /></p>
<h2 id="after-boot-chip"><a class="doc-anchor" href="#after-boot-chip">¬ß</a>7.1 After Boot Chip</h2>
<p>Earlier we saw that <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a> initialises the Arm64 Memory Management Unit. After that, it calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/boards/arm64/a64/pinephone/src/pinephone_boardinit.c#L59-L85"><strong>a64_board_initialize</strong></a>: To initialise the PinePhone ‚ÄúBoard‚Äù (for LEDs)</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/a64/a64_serial.c#L590-L619"><strong>a64_earlyserialinit</strong></a>: To configure the PinePhone Allwinner A64 UART Port (for Console Input / Output)</p>
</li>
</ul>
<p>And returns to <a href="https://lupyuen.github.io/articles/unicorn2#primary-routine"><strong>arm64_boot_primary_c_routine</strong></a>‚Ä¶</p>
<h2 id="after-primary-routine"><a class="doc-anchor" href="#after-primary-routine">¬ß</a>7.2 After Primary Routine</h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L179-L184"><strong>arm64_boot_primary_c_routine</strong></a> continues to boot NuttX Kernel and calls <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_start.c#L297-L699"><strong>nx_start</strong></a>, which initialises a whole bunch of things‚Ä¶</p>
<ul>
<li>
<p>Task Control Block (Idle Task)</p>
</li>
<li>
<p>Semaphore Facility</p>
</li>
<li>
<p>Memory Manager / Extra Heap</p>
</li>
<li>
<p>Input / Output Buffering</p>
</li>
<li>
<p>Unique Process IDs / Idle Group / Tasking Data Structures</p>
</li>
<li>
<p>File System</p>
</li>
<li>
<p>Interrupt Handling Subsystem</p>
</li>
<li>
<p>POSIX Timer Facility / Signal Facility</p>
</li>
<li>
<p>Named Message Queue Facility / System V Message Queue Facility</p>
</li>
<li>
<p>Networking System / Binary Loader System</p>
</li>
<li>
<p>Arm64 Hardware <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_initialize.c#L156-L222">(<strong>up_initialize</strong>)</a></p>
</li>
<li>
<p>Common Drivers / Early Board Initialisation</p>
</li>
</ul>
<p>Then <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_start.c#L297-L699"><strong>nx_start</strong></a> runs the NuttX Tasks‚Ä¶</p>
<ul>
<li>
<p>Start the remaining CPUs</p>
</li>
<li>
<p>Create the Initial Tasks</p>
</li>
<li>
<p>Bring Up the System <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L373-L458">(<strong>nx_bringup</strong>)</a></p>
</li>
<li>
<p>Enter the Idle Loop</p>
</li>
</ul>
<p>And the <strong>NSH Command Prompt</strong> appears. We‚Äôve just completed the entire Boot Sequence for NuttX on PinePhone!</p>
<p>(Hopefully we‚Äôll generate the complete Call Graph someday!)</p>
<p><em>How does nx_bringup start the NSH Shell?</em></p>
<p>Check out the details here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2#appendix-start-nsh-shell"><strong>‚ÄúStart NSH Shell‚Äù</strong></a></li>
</ul>
<h2 id="pinephone-drivers"><a class="doc-anchor" href="#pinephone-drivers">¬ß</a>7.3 PinePhone Drivers</h2>
<p><em>But wait‚Ä¶ Who starts the other PinePhone Drivers?</em></p>
<p><em>Like the drivers for LCD Display, Touch Panel, Accelerometer, ‚Ä¶</em></p>
<p>Ah this sounds surprising, but the other PinePhone Drivers are started by <strong>NSH Shell</strong>!</p>
<p><a href="https://github.com/apache/nuttx-apps/blob/dd2c3b3f6aff797241fe0f02e02cb1fa082dcdbb/nshlib/nsh_init.c#L143-L169"><strong>nsh_initialize</strong></a> does this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Perform architecture-specific initialization (if configured)
boardctl(BOARDIOC_INIT, 0);

// Perform architecture-specific final-initialization (if configured)
boardctl(BOARDIOC_FINALINIT, 0);
</code></pre></div>
<ul>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/master/boards/boardctl.c#L281-L353"><strong>boardctl</strong></a>‚Ä¶</p>
</li>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_appinit.c#L35-L72"><strong>board_app_initialize</strong></a>‚Ä¶</p>
</li>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L61-L209"><strong>pinephone_bringup</strong></a>‚Ä¶</p>
</li>
<li>
<p>Which starts the <strong>PinePhone Drivers</strong></p>
</li>
</ul>
<p>Alternatively, the PinePhone Drivers may be started in <strong>Auto-Launch Apps</strong> like <a href="https://lupyuen.github.io/articles/terminal"><strong>LVGL Terminal</strong></a>.</p>
<p><a href="https://github.com/apache/nuttx-apps/blob/master/examples/lvglterm/lvglterm.c#L541-L556">(See <strong>lvglterm_main</strong>)</a></p>
<p>Let‚Äôs head back to Unicorn Emulator and fix our Arm64 Exception‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph7.jpg" alt="Arm64 Memory Management Fault" /></p>
<h1 id="arm64-memory-management-fault"><a class="doc-anchor" href="#arm64-memory-management-fault">¬ß</a>8 Arm64 Memory Management Fault</h1>
<p><em>Now that we understand how NuttX boots on PinePhone‚Ä¶</em></p>
<p><em>Can we fix the Arm64 Memory Management Fault on Unicorn?</em></p>
<p>Based on our earlier investigation with Unicorn Emulator‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>‚ÄúEmulator Halts with MMU Fault‚Äù</strong></a></li>
</ul>
<p>We deduced that the <strong>Arm64 Address Translation</strong> (or Caching) has failed in our Emulated Arm64 <strong>Memory Management Unit</strong> for <a href="https://lupyuen.github.io/articles/interrupt#exception-levels"><strong>Exception Level 1</strong></a>.</p>
<p>(Invalid Arm64 Address Translation or Caching at <code>0x400C</code> <code>3FFF</code>)</p>
<p>From the Call Graph above, these are the functions involved in the Arm64 <strong>Address Translation Tables</strong> (and are probably sus)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L485-L524"><strong>setup_page_tables</strong></a>: Setup Arm64 Page Tables</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L415-L483"><strong>init_xlat_tables</strong></a>: Initialise Arm64 Translation Tables</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L288-L368"><strong>set_pte_block_desc</strong></a>: Set Private Block Descriptor</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L238-L273"><strong>calculate_pte_index</strong></a>: Calculate Private Index</p>
</li>
</ul>
<p>To fix the fault, we‚Äôll sprinkle some Debug Logs into the above functions. Stay tuned for updates!</p>
<p>(I might have missed a <a href="https://lupyuen.github.io/articles/unicorn#unmapped-memory"><strong>Memory Mapping</strong></a> at <code>0x400C</code> <code>3FFF</code>)</p>
<p><img src="https://lupyuen.github.io/images/auto2-box.jpg" alt="Without Emulation: Boxful of gadgets for auto-testing" /></p>
<p><a href="https://lupyuen.github.io/articles/auto2"><em>Without Emulation: Boxful of gadgets for auto-testing</em></a></p>
<h1 id="automated-daily-build-and-test"><a class="doc-anchor" href="#automated-daily-build-and-test">¬ß</a>9 Automated Daily Build and Test</h1>
<p><em>Why would we need Daily Build and Test?</em></p>
<p>NuttX RTOS for PinePhone is still evolving, with <a href="https://github.com/apache/nuttx/commits/master/arch/arm64"><strong>frequent code changes</strong></a>.</p>
<p>That‚Äôs why it‚Äôs good to run an <strong>Automated Build and Test every day</strong>, to be sure that NuttX boots OK on PinePhone.</p>
<p><em>We need an actual PinePhone to run Daily Tests?</em></p>
<p>Hopefully not! It might get awfully messy to <strong>wire up a PinePhone</strong> with Sensors and Actuators to test the Touchscreen.</p>
<p>We tried <strong>Automated Daily Testing</strong> for a simpler microcontroller gadget (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/auto2"><strong>‚Äú(Mostly) Automated Testing of Apache NuttX RTOS on PineDio Stack BL604 RISC-V Board‚Äù</strong></a></li>
</ul>
<p>But for PinePhone we‚Äôll do Automated Daily Testing the gadgetless way‚Ä¶ With <a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn"><strong>Unicorn Emulator</strong></a>!</p>
<p><em>How will we auto-build and test NuttX for PinePhone every day?</em></p>
<p>Our grand plan is to have <strong>GitHub Actions</strong> trigger these tasks every day‚Ä¶</p>
<ol>
<li>
<p>Do a complete <strong>NuttX Build</strong> for PinePhone</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/.github/workflows/pinephone.yml">(See the <strong>GitHub Actions Workflow</strong>)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx">(As explained here)</a></p>
</li>
<li>
<p>Run the built NuttX Image with <strong>Unicorn Emulator</strong></p>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn">(Like this)</a></p>
</li>
<li>
<p>Generate the NuttX <strong>Call Graph</strong> in Rust</p>
<p><a href="https://lupyuen.github.io/articles/unicorn2#generate-call-graph">(Like this)</a></p>
</li>
<li>
<p><strong>Match the Call Graph</strong> with some pattern</p>
<p>(With a Graph Matching algo?)</p>
</li>
<li>
<p><strong>Publish the NuttX Image</strong>, Emulator Log and Clickable Call Graph</p>
<p>(As a GitHub Release)</p>
</li>
</ol>
<p>Or maybe I‚Äôll switch on my SBC every day to run all these. We‚Äôll talk more in the next article!</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>10 What‚Äôs Next</h1>
<p>We‚Äôve done so much today‚Ä¶</p>
<ul>
<li>
<p>Render the <a href="https://lupyuen.github.io/articles/unicorn2#generate-call-graph"><strong>Clickable Call Graph</strong></a> for Apache NuttX RTOS, to understand how it boots‚Ä¶</p>
</li>
<li>
<p>By integrating <a href="https://lupyuen.github.io/articles/unicorn2#intercept-code-execution-in-unicorn"><strong>Unicorn Emulator</strong></a> with the Rust Libraries <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a>, to map the Code Addresses to NuttX Kernel Functions</p>
</li>
<li>
<p>Thanks to the Call Graph, we walked through the complete <a href="https://lupyuen.github.io/articles/unicorn2#pinephone-boots-nuttx"><strong>Boot Sequence</strong></a> of NuttX for PinePhone</p>
</li>
<li>
<p>Unicorn might be helpful for <a href="https://lupyuen.github.io/articles/unicorn2#automated-daily-build-and-test"><strong>Automated Daily Build and Test</strong></a> of NuttX for PinePhone</p>
</li>
</ul>
<p>I hope you‚Äôll join me in the next article as we implement the <strong>Automated Daily Build and Test</strong> of NuttX for PinePhone.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/rust/comments/11in9qe/clickable_call_graph_for_apache_nuttx_realtime/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=35026869"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/unicorn2.md"><strong>lupyuen.github.io/src/unicorn2.md</strong></a></p>
<h1 id="appendix-start-nsh-shell"><a class="doc-anchor" href="#appendix-start-nsh-shell">¬ß</a>11 Appendix: Start NSH Shell</h1>
<p><em>How does NuttX start the NSH Shell?</em></p>
<p>Earlier we stepped through the <strong>Boot Sequence</strong> for NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#pinephone-boots-nuttx"><strong>‚ÄúPinePhone Boots NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#pinephone-continues-booting-nuttx"><strong>‚ÄúPinePhone Continues Booting NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>Right after that, <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L373-L458"><strong>nx_bringup</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L330-L367"><strong>nx_create_initthread</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L212C1-L302"><strong>nx_start_application</strong></a>, which starts a <strong>NuttX Task</strong> for‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L264-L273"><strong>CONFIG_INIT_ENTRYNAME</strong></a></p>
</li>
</ul>
<p><em>What‚Äôs CONFIG_INIT_ENTRYNAME?</em></p>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L264-L273"><strong>CONFIG_INIT_ENTRYNAME</strong></a> defines the Application Function that will be called at NuttX Startup.</p>
<p><em>How to configure CONFIG_INIT_ENTRYNAME?</em></p>
<p>In ‚Äú<strong>make menuconfig</strong> &gt; <strong>RTOS Features</strong> &gt; <strong>Tasks and Scheduling</strong>‚Äù‚Ä¶</p>
<p>We normally set <strong>‚ÄúApplication Entry Name‚Äù</strong> to <strong><code>nsh_main</code></strong></p>
<p>Which configures <strong>CONFIG_INIT_ENTRYNAME</strong> as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_INIT_ENTRYNAME=&quot;nsh_main&quot;
</code></pre></div>
<p><a href="https://github.com/apache/nuttx-apps/blob/dd2c3b3f6aff797241fe0f02e02cb1fa082dcdbb/system/nsh/nsh_main.c#L41-L85"><strong>nsh_main</strong></a> is the function that runs the NSH Shell.</p>
<p>Eventually <a href="https://github.com/apache/nuttx-apps/blob/dd2c3b3f6aff797241fe0f02e02cb1fa082dcdbb/system/nsh/nsh_main.c#L41-L85"><strong>nsh_main</strong></a> will initialise the PinePhone Drivers‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2#pinephone-drivers"><strong>‚ÄúPinePhone Drivers‚Äù</strong></a></li>
</ul>
<p><em>Can we configure NuttX to start another app?</em></p>
<p>Yep we may set <strong>CONFIG_INIT_ENTRYNAME</strong> to another function like‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_INIT_ENTRYNAME=&quot;lvgldemo_main&quot;
</code></pre></div>
<p>NuttX will start our <a href="https://lupyuen.github.io/articles/lvgl2#boot-to-lvgl"><strong>LVGL Demo App</strong></a> when it boots.</p>
<p>(<a href="https://github.com/apache/nuttx-apps/blob/master/examples/lvgldemo/lvgldemo.c#L208-L220"><strong>lvgldemo_main</strong></a> will also initialise the <a href="https://lupyuen.github.io/articles/unicorn2#pinephone-drivers"><strong>PinePhone Drivers</strong></a>)</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-dwarf.png" alt="DWARF Debugging Format" /></p>
<p><a href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf"><em>DWARF Debugging Format</em></a></p>
<h1 id="appendix-parse-dwarf-debug-symbols"><a class="doc-anchor" href="#appendix-parse-dwarf-debug-symbols">¬ß</a>12 Appendix: Parse DWARF Debug Symbols</h1>
<p>Earlier we talked about parsing the <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Debug Symbols</strong></a> in the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF File</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#map-address-to-function"><strong>‚ÄúAddress to Function‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#dwarf-debug-symbols"><strong>‚ÄúDWARF Debug Symbols‚Äù</strong></a></p>
</li>
</ul>
<p>So that we can print the <strong>Function Names and Source Filenames</strong> for the Arm64 Code Addresses‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>‚Üí cargo run 

hook_block:
  address=0x40080920
  size=12
  arm64_chip_boot
  arch/arm64/src/chip/a64_boot.c:82:1

hook_block:  
  address=0x40080e50
  size=28
  arm64_mmu_init
  arch/arm64/src/common/arm64_mmu.c:584:1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p>Which we implemented like this: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L173-L220">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Get the ELF Context
</span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();

<span class="comment">// Lookup the DWARF Frame for the Arm64 Code Address
</span><span class="kw">let </span><span class="kw-2">mut </span>frames = context.find_frames(address)
  .expect(<span class="string">"failed to find frames"</span>);

<span class="comment">// Lookup the Source Location for the Arm64 Code Address
</span><span class="kw">let </span>loc = context.find_location(address)
  .expect(<span class="string">"failed to find location"</span>);</code></pre></div>
<p><em>What‚Äôs ELF_CONTEXT?</em></p>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong> from our ELF File.</p>
<p>To parse the Debug Symbols, we call the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a>, <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> and <a href="https://crates.io/crates/once_cell"><strong>once_cell</strong></a> crates: <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/Cargo.toml#L8-L12">Cargo.toml</a></p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
addr2line = &quot;0.19.0&quot;
gimli = &quot;0.27.2&quot;
once_cell = &quot;1.17.1&quot;
unicorn-engine = &quot;2.0.0&quot;
</code></pre></div>
<p>At startup, this is how we load the Debug Symbols from our <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx/nuttx"><strong>NuttX ELF File</strong></a> into <strong>ELF_CONTEXT</strong> as a <a href="https://docs.rs/once_cell/latest/once_cell/"><strong>Lazy Static</strong></a>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L297-L346">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::rc::Rc;
<span class="kw">use </span>std::cell::RefCell;
<span class="kw">use </span>once_cell::sync::Lazy;

<span class="doccomment">/// ELF File for mapping Addresses to Function Names and Filenames
</span><span class="kw">const </span>ELF_FILENAME: <span class="kw-2">&amp;</span>str = <span class="string">"nuttx/nuttx"</span>;

<span class="doccomment">/// ELF Context for mapping Addresses to Function Names and Filenames
</span><span class="kw">static </span>ELF_CONTEXT: Lazy&lt;ElfContext&gt; = Lazy::new(|| {
  <span class="comment">// Open the ELF File
  </span><span class="kw">let </span>path = std::path::PathBuf::from(ELF_FILENAME);
  <span class="kw">let </span>file_data = std::fs::read(path)
    .expect(<span class="string">"failed to read ELF"</span>);
  <span class="kw">let </span>slice = file_data.as_slice();

  <span class="comment">// Parse the ELF File
  </span><span class="kw">let </span>obj = addr2line::object::read::File::parse(slice)
    .expect(<span class="string">"failed to parse ELF"</span>);
  <span class="kw">let </span>context = addr2line::Context::new(<span class="kw-2">&amp;</span>obj)
    .expect(<span class="string">"failed to parse debug info"</span>);

  <span class="comment">// Set the ELF Context
  </span>ElfContext {
    context: RefCell::new(context),
  }
});

<span class="doccomment">/// Wrapper for ELF Context. Needed for `Lazy`
</span><span class="kw">struct </span>ElfContext {
  context: RefCell&lt;
    addr2line::Context&lt;
      gimli::EndianReader&lt;
        gimli::RunTimeEndian, 
        Rc&lt;[u8]&gt;  <span class="comment">// Doesn't implement Send / Sync
      </span>&gt;
    &gt;
  &gt;
}

<span class="doccomment">/// Send and Sync for ELF Context. Needed for `Lazy`
</span><span class="kw">unsafe impl </span>Send <span class="kw">for </span>ElfContext {}
<span class="kw">unsafe impl </span>Sync <span class="kw">for </span>ElfContext {}</code></pre></div>
<p><em>Why is ELF_CONTEXT a Global Static? Can‚Äôt we load it in the Main Function and pass it to Unicorn?</em></p>
<p>Yep that‚Äôs the cleaner way‚Ä¶ But then we would have to pass <strong>ELF_CONTEXT</strong> to <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L157"><strong>hook_block</strong></a>, which is a Callback Function. And it gets complicated.</p>
<p>We might pass our context to the Callback Function via a <a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html"><strong>Rust Closure</strong></a> like this‚Ä¶</p>
<ul>
<li><a href="https://github.com/unicorn-engine/unicorn/blob/master/tests/rust-tests/main.rs#L175-L207"><strong>x86_code_callback</strong></a></li>
</ul>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>