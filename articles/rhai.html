<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on RISC-V BL602: Rhai Scripting</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on RISC-V BL602: Rhai Scripting" 
    data-rh="true">
<meta property="og:description" 
    content="Can we drag-and-drop Rhai Scripts... And run them on WebAssembly and BL602 RISC-V SoC?"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rhai-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on RISC-V BL602: Rhai Scripting</h1>
    <nav id="TOC"><ul>
<li><a href="#bestest-outcome">1 Bestest Outcome</a><ul></ul></li>
<li><a href="#rhai-scripts">2 Rhai Scripts</a><ul>
<li><a href="#variables-and-expressions">2.1 Variables and Expressions</a><ul></ul></li>
<li><a href="#loops-and-conditionals">2.2 Loops and Conditionals</a><ul></ul></li>
<li><a href="#rust-functions-and-modules">2.3 Rust Functions and Modules</a><ul></ul></li></ul></li>
<li><a href="#add-rhai-scripting-to-simulator">3 Add Rhai Scripting to Simulator</a><ul>
<li><a href="#register-function">3.1 Register Function</a><ul></ul></li>
<li><a href="#register-module">3.2 Register Module</a><ul></ul></li></ul></li>
<li><a href="#convert-rhai-to-ulisp">4 Convert Rhai to uLisp</a><ul>
<li><a href="#abstract-syntax-tree">4.1 Abstract Syntax Tree</a><ul></ul></li>
<li><a href="#rhai-transcoder">4.2 Rhai Transcoder</a><ul></ul></li>
<li><a href="#transcode-statement">4.3 Transcode Statement</a><ul></ul></li>
<li><a href="#transcode-block">4.4 Transcode Block</a><ul></ul></li>
<li><a href="#transcode-expression">4.5 Transcode Expression</a><ul></ul></li>
<li><a href="#transcoder-scope">4.6 Transcoder Scope</a><ul></ul></li></ul></li>
<li><a href="#run-the-transcoded-ulisp">5 Run the Transcoded uLisp</a><ul></ul></li>
<li><a href="#drag-and-drop-rhai-scripting">6 Drag-and-Drop Rhai Scripting</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li>
<li><a href="#appendix-add-c-functions-to-ulisp">9 Appendix: Add C Functions to uLisp</a><ul></ul></li>
<li><a href="#appendix-customise-blockly-for-rhai">10 Appendix: Customise Blockly for Rhai</a><ul>
<li><a href="#code-generator-for-rhai">10.1 Code Generator for Rhai</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>4 Sep 2021</em></p>
<p><em>What is Rhai?</em></p>
<p><a href="https://rhai.rs/book/"><strong>Rhai</strong></a> is a <strong>Rust-like Scripting Language</strong>, implemented in Rust.</p>
<p><em>Can we use Rhai for coding microcontrollers <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">the REPL way</a>?</em></p>
<p><em>Like on the <a href="https://lupyuen.github.io/articles/pinecone">BL602 / BL604 RISC-V + WiFi + Bluetooth LE SoC</a>?</em></p>
<p><img src="https://lupyuen.github.io/images/rhai-rust2.jpg" alt="Rhai Script vs Rust Firmware" /></p>
<p>Sadly the Rhai Scripting Engine <strong>might be too heavy</strong> for most microcontrollers (like BL602 and BL604).</p>
<p><em><a href="https://lupyuen.github.io/articles/lisp"><strong>uLisp</strong></a> runs OK on microcontrollers. Why don‚Äôt we auto-convert Rhai Scripts to uLisp?</em></p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode4.jpg" alt="Rhai Script transcoded to uLisp" /></p>
<p><strong>Transpile Rhai to uLisp</strong>‚Ä¶ What an intriguing idea! Which we shall explore in this article.</p>
<p><em>Let‚Äôs make Rhai Scripting more fun for learners‚Ä¶</em></p>
<p><em>Can we drag-and-drop Rhai Scripts (the Scratch way) and run them on BL602?</em></p>
<p><img src="https://lupyuen.github.io/images/rhai-title.jpg" alt="Drag-and-drop scripting with Blockly and Rhai" /></p>
<p>Yep it sounds feasible, let‚Äôs explore that too.</p>
<p><em>One more thing‚Ä¶ Can we run Rhai Scripts in a Web Browser? Like on a Simulated BL602?</em></p>
<p>Yes we can‚Ä¶ Because we‚Äôve implemented a <strong>BL602 Simulator in WebAssembly</strong>!</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rustsim">‚ÄúRust on RISC-V BL602: Simulated with WebAssembly‚Äù</a></li>
</ul>
<p>So today we shall explore‚Ä¶</p>
<ol>
<li>
<p>Running <strong>Rhai Scripts on BL602</strong></p>
<p>(The REPL way)</p>
</li>
<li>
<p>By <strong>Auto-Converting Rhai Scripts to uLisp</strong></p>
<p>(Because Rhai can‚Äôt run directly on BL602 yet)</p>
</li>
<li>
<p>With <strong>Drag-and-Drop Rhai Scripting</strong></p>
<p>(The Scratch way)</p>
</li>
<li>
<p>That also runs <strong>Rhai Scripts in a Web Browser</strong></p>
<p>(With BL602 simulated in WebAssembly)</p>
</li>
</ol>
<h1 id="bestest-outcome"><a href="#bestest-outcome">1 Bestest Outcome</a></h1>
<p><em>Why are we doing ALL this? (Waving hands)</em></p>
<p><em>What challenges are BL602 (and BL604) Firmware Developers facing?</em></p>
<p>Most developers code BL602 (and BL604) Firmware in <strong>C with the BL602 IoT SDK</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome2.jpg" alt="C Firmware for BL602" /></p>
<p>I introduced <strong>Rust</strong> as an option for coding BL602 Firmware, by creating a <a href="https://lupyuen.github.io/articles/adc#rust-wrapper-for-bl602-iot-sdk"><strong>Rust Wrapper for BL602 IoT SDK</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome5.jpg" alt="Rust Firmware for BL602" /></p>
<p>But flashing the C (or Rust) Firmware to BL602 over USB UART (and flipping a jumper) <strong>feels cumbersome</strong>.</p>
<p>(Especially when we keep fixing the code and reflashing to BL602)</p>
<p>Thus we created the <a href="https://lupyuen.github.io/articles/rustsim"><strong>WebAssembly Simulator for BL602</strong></a> that runs BL602 Rust Firmware in a Web Browser, for <strong>quicker testing, debugging and fixing</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome.jpg" alt="WebAssembly Simulator for BL602" /></p>
<p><em>But what about the learners?</em></p>
<p>Scripted REPL platforms for microcontrollers like uLisp and MicroPython are popular with learners.</p>
<p>Since we have a WebAssembly Simulator for BL602, we can run REPL Scripts too‚Ä¶ With <strong>Rhai, the Drag-and-Drop Way!</strong></p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome4.jpg" alt="Drag-and-Drop Rhai Scripts" /></p>
<p>And to run Rhai Scripts on actual BL602 Hardware, we need to <strong>convert Rhai Scripts to uLisp</strong>‚Ä¶</p>
<p>(Because Rhai Scripting Engine seems to be too heavy for BL602)</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome3.jpg" alt="Convert Rhai Scripts to uLisp" /></p>
<p>Which is perfectly OK, because we can <strong>do the conversion in WebAssembly!</strong></p>
<p>(And transmit the converted uLisp code to BL602 via the <strong>Web Serial API</strong>)</p>
<p>In this article we‚Äôll learn how this grand scheme is implemented with these 3 repos‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/transcode"><strong><code>bl602-simulator</code></strong> (<code>transcode</code> branch)</a>: WebAssembly Simulator for BL602 and BL604</p>
<p>(Includes Rhai Scripting Engine and Rhai-To-uLisp Transcoder)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/blockly-bl602"><strong><code>blockly-bl602</code></strong></a>: Blockly Drag-and-Drop Scripting for BL602 and BL604</p>
<p>(Works like Scratch)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/tree/sdk"><strong><code>ulisp-bl602</code></strong> (<code>sdk</code> branch)</a>: uLisp for BL602 and BL604</p>
<p>(Integrated with BL602 / BL604 IoT SDK)</p>
</li>
</ul>
<h1 id="rhai-scripts"><a href="#rhai-scripts">2 Rhai Scripts</a></h1>
<p>Let‚Äôs look at the <strong>Rhai Scripts</strong> that will‚Ä¶</p>
<ol>
<li>
<p>Run OK on our BL602 Simulator and</p>
</li>
<li>
<p>Convert correctly to uLisp for execution on BL602</p>
</li>
</ol>
<h2 id="variables-and-expressions"><a href="#variables-and-expressions">2.1 Variables and Expressions</a></h2>
<p>This Rhai Script evaluates to the value 42‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Rhai Variables and Expression
</span><span class="kw">let </span>a = <span class="number">40</span>; 
<span class="kw">let </span>b = <span class="number">2</span>;
a + b </code></pre></div>
<h2 id="loops-and-conditionals"><a href="#loops-and-conditionals">2.2 Loops and Conditionals</a></h2>
<p><strong><code>loop</code></strong>, <strong><code>break</code></strong>, <strong><code>print</code></strong> and <strong><code>if</code></strong> (simple conditionals) shall be supported‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Rhai Loop and Conditional
</span><span class="kw">loop </span>{ 
  <span class="kw">let </span>a = <span class="number">1</span>;
  print(a);
  <span class="kw">if </span>a == <span class="number">1 </span>{ <span class="kw">break</span>; }
}</code></pre></div>
<p>See the next section for another loop that we shall support: <code>for i in range(0, 10)</code></p>
<h2 id="rust-functions-and-modules"><a href="#rust-functions-and-modules">2.3 Rust Functions and Modules</a></h2>
<p>This Rhai Script blinks the LED on BL602‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Rhai Blinky: Blink the LED connected on BL602 GPIO 11
</span><span class="kw">let </span>LED_GPIO = <span class="number">11</span>;

<span class="comment">//  Configure the LED GPIO for output (instead of input)
</span>gpio::enable_output(LED_GPIO, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">//  Blink the LED 5 times
</span><span class="kw">for </span>i <span class="kw">in </span>range(<span class="number">0</span>, <span class="number">10</span>) {

  <span class="comment">//  Toggle the LED GPIO between 0 (on) and 1 (off)
  </span>gpio::output_set(
    LED_GPIO, 
    i % <span class="number">2
  </span>);

  <span class="comment">//  Sleep 1 second
  </span>time_delay(<span class="number">1000</span>);
}</code></pre></div>
<p><strong><code>time_delay</code></strong> is a <strong>Rust Function</strong> that we shall import into the Rhai Scripting Engine.</p>
<p><strong><code>gpio</code></strong> is a <strong>Rust Module</strong> that we shall import into Rhai.</p>
<p>The <code>gpio</code> module has two functions: <strong><code>enable_output</code></strong> and <strong><code>output_set</code></strong>.</p>
<h1 id="add-rhai-scripting-to-simulator"><a href="#add-rhai-scripting-to-simulator">3 Add Rhai Scripting to Simulator</a></h1>
<p>We begin by adding the Rhai Scripting Engine to our <strong>WebAssembly Simulator</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This function will be called by 
/// WebAssembly to run a script
</span><span class="attr">#[no_mangle]  </span><span class="comment">//  Don't mangle the function name
</span><span class="kw">extern </span><span class="string">"C"    </span><span class="comment">//  Declare `extern "C"` because it will be called by Emscripten
</span><span class="kw">fn </span>rust_script( ... ) {

  <span class="comment">//  Init the Rhai script engine
  </span><span class="kw">let </span><span class="kw-2">mut </span>engine = Engine::new();

  <span class="comment">//  Rhai Script to be evaluated
  </span><span class="kw">let </span>script = <span class="string">r#" 
    //  Evaluate an expression
    let a = 40; 
    let b = 2;
    a + b 
  "#</span>;

  <span class="comment">//  Evaluate the Rhai Script
  </span><span class="kw">let </span>result = engine.eval::&lt;i32&gt;(script)
    .unwrap() <span class="kw">as </span>isize;

  <span class="comment">//  Display the result
  </span><span class="macro">println!</span>(<span class="string">"{}"</span>, result);
}</code></pre></div>
<p>This code <strong>initialises the Rhai engine</strong> and evaluates a Rhai Script that returns an integer result‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>42
</code></pre></div>
<p><a href="https://rhai.rs/book/engine/hello-world.html">(More about Rhai Scripting Engine)</a></p>
<h2 id="register-function"><a href="#register-function">3.1 Register Function</a></h2>
<p>To <strong>register a Rust Function</strong> that will be called by the Rhai Script, we do this: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Init the Rhai script engine
</span><span class="kw">let </span><span class="kw-2">mut </span>engine = Engine::new();

<span class="comment">//  Register our functions with Rhai
</span>engine.register_fn(<span class="string">"time_delay"</span>, time_delay);

<span class="comment">//  Rhai Script to be evaluated
</span><span class="kw">let </span>script = <span class="string">r#" 
  //  Sleep 1 second
  time_delay(1000);

  //  Return 0
  0
"#</span>;

<span class="comment">//  Evaluate the Rhai Script (returns 0)
</span><span class="kw">let </span>result = engine.eval::&lt;i32&gt;(script)
  .unwrap() <span class="kw">as </span>isize;</code></pre></div>
<p><strong><code>time_delay</code></strong> is defined like so: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L146-L161"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Rhai Shim for Time Delay
/// TODO: Modified parameter from u32 to i32
</span><span class="kw">pub fn </span>time_delay(
    ticks: i32  <span class="comment">//  Number of ticks to sleep
</span>) {
  <span class="kw">extern </span><span class="string">"C" </span>{  <span class="comment">//  Import C Function
    </span><span class="doccomment">/// Sleep for the specified number of system ticks (from NimBLE Porting Layer)
    </span><span class="kw">fn </span>ble_npl_time_delay(ticks: u32);
  }

  <span class="comment">//  Call the C function
  </span><span class="kw">unsafe </span>{  <span class="comment">//  Flag this code as unsafe because we're calling a C function
    </span>ble_npl_time_delay(ticks <span class="kw">as </span>u32);
  }
}</code></pre></div>
<p><strong><code>time_delay</code></strong> is a Rust Shim Function that calls out to the C function <strong><code>ble_npl_time_delay</code></strong> which we have defined in our WebAssembly Simulator.</p>
<p><a href="https://lupyuen.github.io/articles/rustsim#json-stream-of-simulation-events">(More about <code>time_delay</code>)</a></p>
<p><em>Why not register <code>ble_npl_time_delay</code> with Rhai and rename it as <code>time_delay</code>?</em></p>
<p>Because <code>ble_npl_time_delay</code> is ‚Äú<code>extern C</code>‚Äù and it accepts a parameter of type <strong><code>u32</code></strong>, but our Rhai engine is configured for <a href="https://rhai.rs/book/start/features.html"><strong><code>only_i32</code></strong></a>.</p>
<p><a href="https://rhai.rs/book/rust/functions.html">(More about calling Rust Functions from Rhai)</a></p>
<h2 id="register-module"><a href="#register-module">3.2 Register Module</a></h2>
<p>Now we register the <strong><code>gpio</code></strong> module with Rhai: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Init the Rhai script engine
</span><span class="kw">let </span><span class="kw-2">mut </span>engine = Engine::new();

<span class="comment">//  Create a Rhai module from the plugin module
</span><span class="kw">let </span>module = <span class="macro">exported_module!</span>(gpio);

<span class="comment">//  Register our module as a Static Module
</span>engine.register_static_module(<span class="string">"gpio"</span>, module.into());</code></pre></div>
<p><strong><code>gpio</code></strong> is a Rust Module that exports the functions <strong><code>enable_output</code></strong> and <strong><code>output_set</code></strong>, which may be called like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Rhai Script to be evaluated
</span><span class="kw">let </span>script = <span class="string">r#" 
  //  Blink the LED connected on BL602 GPIO 11
  let LED_GPIO = 11;

  //  Configure the LED GPIO for output (instead of input)
  gpio::enable_output(LED_GPIO, 0, 0);

  //  Blink the LED 5 times
  for i in range(0, 10) {

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    gpio::output_set(
      LED_GPIO, 
      i % 2
    );

    //  Sleep 1 second
    time_delay(1000);
  }

  //  Return 0
  0
"#</span>;

<span class="comment">//  Evaluate the Rhai Script (returns 0)
</span><span class="kw">let </span>result = engine.eval::&lt;i32&gt;(script)
  .unwrap() <span class="kw">as </span>isize;</code></pre></div>
<p>Below is the definition of the <strong><code>gpio</code></strong> module: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L100-L144"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// GPIO Module will be exported to Rhai as a Static Module
</span><span class="attr">#[export_module]
</span><span class="kw">mod </span>gpio {
  <span class="doccomment">/// Rhai Shim for Enable GPIO Output
  /// TODO: Modified parameters from u8 to i32
  </span><span class="kw">pub fn </span>enable_output(pin: i32, pullup: i32, pulldown: i32) {
    <span class="kw">extern </span><span class="string">"C" </span>{
      <span class="kw">pub fn </span>bl_gpio_enable_output(pin: u8, pullup: u8, pulldown: u8) -&gt; i32;
    }
    <span class="kw">unsafe </span>{
      <span class="kw">let </span>_res = bl_gpio_enable_output(pin <span class="kw">as </span>u8, pullup <span class="kw">as </span>u8, pulldown <span class="kw">as </span>u8);
      <span class="comment">//  TODO: Throw exception if result is non-zero
    </span>}
  }

  <span class="doccomment">/// Rhai Shim for Set GPIO Output
  /// TODO: Modified parameters from u8 to i32
  </span><span class="kw">pub fn </span>output_set(pin: i32, value: i32) {
    <span class="kw">extern </span><span class="string">"C" </span>{
      <span class="kw">pub fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; i32;
    }
    <span class="kw">unsafe </span>{
      <span class="kw">let </span>_res = bl_gpio_output_set(pin <span class="kw">as </span>u8, value <span class="kw">as </span>u8);
      <span class="comment">//  TODO: Throw exception if result is non-zero
    </span>}
  }
}</code></pre></div>
<p><em>So <code>gpio</code> module is also a Rust Shim?</em></p>
<p>Yep. Maybe someday we‚Äôll use a Rust Procedural Macro to <strong>generate the shims</strong>, similar to this‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/adc#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">‚ÄúGenerating the Rust Wrapper for BL602 IoT SDK‚Äù</a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/rustsim#json-stream-of-simulation-events">(More about <code>enable_output</code> and <code>output_set</code>)</a></p>
<p><a href="https://rhai.rs/book/plugins/module.html">(More about calling Rust Modules from Rhai)</a></p>
<p><img src="https://lupyuen.github.io/images/rhai-module.png" alt="Register Rhai Module" /></p>
<h1 id="convert-rhai-to-ulisp"><a href="#convert-rhai-to-ulisp">4 Convert Rhai to uLisp</a></h1>
<p>Yep the Rhai Blinky Script runs OK in the <strong>BL602 WebAssembly Simulator</strong>, blinking the simulated LED.</p>
<p>Now let‚Äôs <strong>auto-convert the Rhai Script to uLisp</strong>, and run it on a real BL602 board (and blink a real LED)!</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode4.jpg" alt="Rhai Script transcoded to uLisp" /></p>
<p>We do the same as earlier‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise</strong> the Rhai script engine</p>
</li>
<li>
<p><strong>Register <code>gpio</code> module</strong> with Rhai</p>
</li>
<li>
<p><strong>Register <code>time_delay</code> function</strong> with Rhai</p>
</li>
</ol>
<p>From <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a> ‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Init the Rhai script engine
</span><span class="kw">let </span><span class="kw-2">mut </span>engine = Engine::new();

<span class="comment">//  Omitted: Create a Rhai module from the plugin module
//  Omitted: Register `gpio` module as a Static Module
//  Omitted: Register `time_delay` function with Rhai
</span>...</code></pre></div>
<p>Below is the kitchen-sink <strong>Rhai Script</strong> that will be converted to uLisp‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Rhai Script to be parsed
</span><span class="kw">let </span>script = <span class="string">r#" 
  //  Rhai Loop and Conditional
  loop { 
    let a = 1;
    print(a);
    if a == 1 { break; }
  }

  //  Rhai Blinky: Blink the LED connected on BL602 GPIO 11
  let LED_GPIO = 11;

  //  Configure the LED GPIO for output (instead of input)
  gpio::enable_output(LED_GPIO, 0, 0);

  //  Blink the LED 5 times
  for i in range(0, 10) {

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    gpio::output_set(
      LED_GPIO, 
      i % 2
    );

    //  Sleep 1 second
    time_delay(1000);
  }

  //  Rhai Variables and Expression
  let a = 40; 
  let b = 2;
  a + b 
"#</span>;</code></pre></div>
<p>Now comes the interesting part: Rhai lets us <strong>compile our script</strong> into an <strong>Abstract Syntax Tree</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Compile the Rhai Script into
//  an Abstract Syntax Tree
</span><span class="kw">let </span>ast = engine.compile(script)
  .unwrap();</code></pre></div>
<p>(More about the Abstract Syntax Tree in a while)</p>
<p>We may <strong>walk the Abstract Syntax Tree</strong> and <strong>convert each node</strong> to uLisp‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Transcode the Rhai Abstract 
//  Syntax Tree to uLisp
</span>transcode::transcode(<span class="kw-2">&amp;</span>ast);</code></pre></div>
<p>(More about <code>transcode</code> later)</p>
<p>FYI: This is how we <strong>evaluate the compiled Rhai Script</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Evaluate the compiled Rhai Script (returns 42)
</span><span class="kw">let </span>result: i32 = engine.eval_ast(<span class="kw-2">&amp;</span>ast)
  .unwrap();</code></pre></div>
<p>Let‚Äôs learn about the Abstract Syntax Tree‚Ä¶</p>
<h2 id="abstract-syntax-tree"><a href="#abstract-syntax-tree">4.1 Abstract Syntax Tree</a></h2>
<p><em>What is an Abstract Syntax Tree?</em></p>
<p>The Rhai Scripting Engine <strong>parses our Rhai Script</strong> and produces a <strong>tree of syntax elements</strong>‚Ä¶ That‚Äôs the <strong>Abstract Syntax Tree</strong>.</p>
<p>This Rhai Script‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>LED_GPIO = <span class="number">11</span>;
gpio::enable_output(LED_GPIO, <span class="number">0</span>, <span class="number">0</span>);</code></pre></div>
<p>Generates this <strong>Abstract Syntax Tree</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L227-L252"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Var(
  <span class="number">11 </span>@ <span class="number">11</span>:<span class="number">24</span>,
  <span class="string">"LED_GPIO" </span>@ <span class="number">11</span>:<span class="number">13</span>,
  (),
  <span class="number">11</span>:<span class="number">9</span>,
),
FnCall(
  FnCallExpr {
    namespace: <span class="prelude-val">Some</span>(
      gpio,
    ),
    hashes: <span class="number">12987214658708294900</span>,
    args: [
      Variable(LED_GPIO #<span class="number">1</span>) @ <span class="number">14</span>:<span class="number">29</span>,
      StackSlot(<span class="number">0</span>) @ <span class="number">14</span>:<span class="number">39</span>,
      StackSlot(<span class="number">1</span>) @ <span class="number">14</span>:<span class="number">42</span>,
    ],
    constants: [
      <span class="number">0</span>,
      <span class="number">0</span>,
    ],
    name: <span class="string">"enable_output"</span>,
    capture: <span class="bool-val">false</span>,
  },
  <span class="number">14</span>:<span class="number">15</span>,
)</code></pre></div>
<p>(<code>StackSlot</code> refers to the values in the <code>constants</code> array)</p>
<p>Let‚Äôs match the two‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-ast2.jpg" alt="Rhai Script vs Abstract Syntax Tree" /></p>
<p>Yep Abstract Syntax Trees can get <strong>deeply nested</strong>, like this <strong><code>for</code></strong> loop‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-ast.jpg" alt="Abstract Syntax Tree for for loop" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L177-L344">(See the complete Abstract Syntax Tree)</a></p>
<p>But Abstract Syntax Trees are actually <strong>perfect for converting Rhai to uLisp</strong>.</p>
<p>Lisp is a recursive language and the <strong>Lisp parentheses match the nodes</strong> in the Abstract Syntax Tree quite closely.</p>
<p>Let‚Äôs talk about the Rhai to uLisp conversion‚Ä¶</p>
<p><a href="https://rhai.rs/book/engine/compile.html">(More about Rhai Abstract Syntax Tree)</a></p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode6.png" alt="Converting the Abstract Syntax Tree to uLisp" /></p>
<h2 id="rhai-transcoder"><a href="#rhai-transcoder">4.2 Rhai Transcoder</a></h2>
<p>(Since we‚Äôre converting Rhai Code to uLisp Code, let‚Äôs call it <strong>‚Äútranscoding‚Äù</strong> instead of ‚Äútranspiling‚Äù)</p>
<p>To transcode the compiled Rhai Code to uLisp, we <strong>walk the Abstract Syntax Tree</strong> and <strong>transcode each node to uLisp</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L15-L27"><code>bl602-script/transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Transcode the compiled Rhai Script 
/// (Abstract Syntax Tree) to uLisp
</span><span class="kw">pub fn </span>transcode(ast: <span class="kw-2">&amp;</span>AST) -&gt; String {
  <span class="comment">//  Start the first uLisp Scope
  </span><span class="kw">let </span>scope_index = scope::begin_scope(<span class="string">"let* ()"</span>);

  <span class="comment">//  Walk the nodes in the Rhai Abstract Syntax Tree
  </span>ast.walk(<span class="kw-2">&amp;mut </span>transcode_node);

  <span class="comment">//  End the first uLisp Scope and get the uLisp S-Expression for the scope
  </span><span class="kw">let </span>output = scope::end_scope(scope_index);

  <span class="comment">//  Return the transcoded uLisp S-Expression
  </span>output
}</code></pre></div>
<p>(More about <code>scope</code> in a while)</p>
<p><strong><code>ast.walk</code></strong> calls <strong><code>transcode_node</code></strong> to transcode each node in the Abstract Syntax Tree: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L29-L59"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Transcode the Rhai AST Node to uLisp
</span><span class="kw">fn </span>transcode_node(nodes: <span class="kw-2">&amp;</span>[ASTNode]) -&gt; bool {
  <span class="comment">//  We take the root node, ignore the subnodes
  </span><span class="kw">let </span>node = <span class="kw-2">&amp;</span>nodes[<span class="number">0</span>];

  <span class="comment">//  Get the source code position
  </span><span class="kw">let </span>pos = <span class="kw">match </span>node {
    ASTNode::Stmt(stmt) =&gt; stmt.position(),
    ASTNode::Expr(expr) =&gt; expr.position(),
  };

  <span class="comment">//  Skip this node if we've already handled it
  </span><span class="kw">unsafe </span>{
    <span class="kw">static </span><span class="kw-2">mut </span>LAST_POSITION: Position = Position::NONE;
    <span class="kw">if </span>LAST_POSITION == pos { <span class="kw">return </span><span class="bool-val">true</span>; }
    LAST_POSITION = pos;
  }

  <span class="comment">//  Transcode the Node: Statement or Expression
  </span><span class="kw">let </span>output = <span class="kw">match </span>node {
    ASTNode::Stmt(stmt) =&gt; transcode_stmt(stmt),
    ASTNode::Expr(expr) =&gt; transcode_expr(expr),
  };

  <span class="comment">//  Add the transcoded uLisp S-Expression to the current scope
  </span>scope::add_to_scope(<span class="kw-2">&amp;</span>output);

  <span class="comment">//  Return true to walk the next node in the tree
  </span><span class="bool-val">true
</span>}</code></pre></div>
<p>Each node is either a Rhai <strong>Statement or Expression</strong>. We call‚Ä¶</p>
<ul>
<li>
<p><strong><code>transcode_stmt</code></strong> to transcode a Rhai Statement</p>
</li>
<li>
<p><strong><code>transcode_expr</code></strong> to transcode a Rhai Expression</p>
</li>
</ul>
<p>Let‚Äôs look into each of these functions‚Ä¶</p>
<p><a href="https://docs.rs/rhai/1.0.4/rhai/enum.ASTNode.html">(More about AST Node)</a></p>
<h2 id="transcode-statement"><a href="#transcode-statement">4.3 Transcode Statement</a></h2>
<p>We start with the <strong><code>let</code></strong> Statement that declares a variable‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>LED_GPIO = <span class="number">11</span></code></pre></div>
<p>This will be transcoded to uLisp like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( let* 
  (( LED_GPIO 11 ))
  ...
)
</code></pre></div>
<p>Watch how we transcode the <strong><code>let</code></strong> Statement: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L61-L89"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Transcode a Rhai Statement to uLisp
</span><span class="kw">fn </span>transcode_stmt(stmt: <span class="kw-2">&amp;</span>Stmt) -&gt; String {
  <span class="kw">match </span>stmt {
    <span class="comment">//  Let or Const Statement: `let LED_GPIO = 11`
    </span>Stmt::Var(expr, ident, <span class="kw">_</span>, <span class="kw">_</span>) =&gt; {
      <span class="comment">//  Begin a new uLisp Scope
      </span>scope::begin_scope(
        <span class="macro">format!</span>(
          <span class="string">"let* (( {} {} ))"</span>,    <span class="comment">//  `let* (( LED_GPIO 11 ))`
          </span>ident.name,            <span class="comment">//  `LED_GPIO`
          </span>transcode_expr(expr),  <span class="comment">//  `11`
        </span>).as_str()
      );

      <span class="comment">//  Scope will end when the parent scope ends
      </span><span class="string">""</span>.to_string()
    }</code></pre></div>
<p><em>Why do we need uLisp Scopes?</em></p>
<p>Hint: The transcoded uLisp will look like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( let* 
  (( LED_GPIO 11 ))
  ...
)
</code></pre></div>
<p>Where <strong>‚Äú<code>...</code>‚Äù</strong> refers to the <strong>uLisp Scope</strong> of the statements that will be transcoded after the <strong><code>let</code></strong> statement.</p>
<p>(More about uLisp Scopes in a while)</p>
<p>Next: <strong><code>for</code></strong> Statements like this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>i <span class="kw">in </span>range(<span class="number">0</span>, <span class="number">10</span>) { ... }</code></pre></div>
<p>Shall be transcoded to uLisp like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( dotimes (i 10)
  ...
)
</code></pre></div>
<p>This is how we transcode the <strong><code>for</code></strong> Statement: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L91-L142"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="kw">match </span>stmt {
    ...
    <span class="comment">//  For Statement: `for i in range(0, 10) { ... }`
    </span>Stmt::For(expr, id_counter, <span class="kw">_</span>) =&gt; {
      <span class="comment">//  TODO: Support `for` counter
      </span><span class="kw">let </span>id    = <span class="kw-2">&amp;</span>id_counter.<span class="number">0</span>;  <span class="comment">//  `i`
      </span><span class="kw">let </span>stmts = <span class="kw-2">&amp;</span>id_counter.<span class="number">2</span>;  <span class="comment">//  `{ ... }`

      //  Get the `for` range, e.g. `[0, 10]`
      </span><span class="kw">let </span>range = get_range(expr);  <span class="comment">//  `[0, 10]`
      </span><span class="kw">let </span>lower_limit = range[<span class="number">0</span>];   <span class="comment">//  `0`
      </span><span class="kw">let </span>upper_limit = range[<span class="number">1</span>];   <span class="comment">//  `10`
      </span><span class="macro">assert!</span>(lower_limit == <span class="number">0</span>);    <span class="comment">//  TODO: Allow Lower Limit to be non-zero

      //  Begin a new uLisp Scope
      </span><span class="kw">let </span>scope_index = scope::begin_scope(
        <span class="macro">format!</span>(
          <span class="string">"dotimes ({} {})"</span>,  <span class="comment">//  `dotimes (i 10)`
          </span>id.name,            <span class="comment">//  `i`
          </span>upper_limit,        <span class="comment">//  `10`
        </span>).as_str()
      );

      <span class="comment">//  Transcode the Statement Block: `{ ... }`
      </span>transcode_block(stmts);

      <span class="comment">//  End the uLisp Scope and add the transcoded uLisp S-Expression to the parent scope
      </span>scope::end_scope(scope_index)
    }        </code></pre></div>
<p><strong><code>transcode_block</code></strong> transcodes the block of statements in the body of a <strong><code>for</code></strong> loop.</p>
<p>(Coming up in the next section)</p>
<p><strong><code>get_range</code></strong> is defined here: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L345-L391"><code>transcode.rs</code></a></p>
<p><strong>Function Calls</strong> are transcoded as a special kind of Expression: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L91-L142"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="kw">match </span>stmt {
    ...
    <span class="comment">//  Function Call: `gpio::enable_output(LED_GPIO, 0, 0)`
    </span>Stmt::FnCall(expr, <span class="kw">_</span>) =&gt; <span class="macro">format!</span>(
      <span class="string">"{}"</span>,
      transcode_fncall(expr)
    ),</code></pre></div>
<p>(We‚Äôll meet <code>transcode_fncall</code> in a while)</p>
<p>Check out the source code to see how we transcode these statements‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L144-L194"><strong><code>loop</code></strong> Statement</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L241-L243"><strong><code>break</code></strong> Statement</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L196-L239"><strong><code>if</code></strong> Statement</a></p>
</li>
</ul>
<p><a href="https://docs.rs/rhai/1.0.4/rhai/enum.Stmt.html">(More about Rhai Statements)</a></p>
<h2 id="transcode-block"><a href="#transcode-block">4.4 Transcode Block</a></h2>
<p>Our transcoder calls <strong><code>transcode_block</code></strong> to transcode a block of statements (<code>for</code>, <code>loop</code>, <code>if</code>, ‚Ä¶)</p>
<p>From <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L324-L333"><code>transcode.rs</code></a> ‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Transcode the Statement Block and 
/// the transcoded uLisp S-Expression 
/// into the current scope
</span><span class="kw">fn </span>transcode_block(stmts: <span class="kw-2">&amp;</span>StmtBlock) {  
  <span class="comment">//  Iterate through each Statement in the block...
  </span>stmts.clone().statements_mut().iter().for_each(|stmt| {
    <span class="comment">//  Transcode each Statement
    </span><span class="kw">let </span>output = transcode_stmt(stmt);

    <span class="comment">//  Add the transcoded uLisp S-Expression to the current scope
    </span>scope::add_to_scope(<span class="kw-2">&amp;</span>output);
  });
}</code></pre></div>
<p>This code transcodes every statement in the block.</p>
<p><a href="https://docs.rs/rhai/1.0.4/rhai/struct.StmtBlock.html">(More about Rhai Blocks)</a></p>
<h2 id="transcode-expression"><a href="#transcode-expression">4.5 Transcode Expression</a></h2>
<p><strong><code>transcode_expr</code></strong> transcodes an Expression from Rhai to uLisp: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L255-L269"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Transcode a Rhai Expression to uLisp
</span><span class="kw">fn </span>transcode_expr(expr: <span class="kw-2">&amp;</span>Expr) -&gt; String {
  <span class="kw">match </span>expr {
    <span class="comment">//  Integers become themselves, e.g. `1`
    </span>Expr::IntegerConstant(i, <span class="kw">_</span>) =&gt; <span class="macro">format!</span>(<span class="string">"{}"</span>, i),

    <span class="comment">//  Variables become their names, e.g. `a`
    </span>Expr::Variable(<span class="kw">_</span>, <span class="kw">_</span>, var) =&gt; <span class="macro">format!</span>(<span class="string">"{}"</span>, var.<span class="number">2</span>),

    <span class="comment">//  Function Call: `gpio::enable_output(LED_GPIO, 0, 0)`
    </span>Expr::FnCall(expr, <span class="kw">_</span>) =&gt; transcode_fncall(expr),

    <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">"Unknown expr: {:#?}"</span>, expr)
  }
}</code></pre></div>
<p>Which means that‚Ä¶</p>
<ul>
<li>
<p><strong><code>1</code></strong> is transcoded as <strong><code>1</code></strong></p>
</li>
<li>
<p><strong><code>a</code></strong> is transcoded as <strong><code>a</code></strong></p>
</li>
</ul>
<p>Now for <strong>Function Calls</strong>: We shall transcode‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>gpio::enable_output(LED_GPIO, <span class="number">0</span>, <span class="number">0</span>)</code></pre></div>
<p>To‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>( bl_gpio_enable_output LED_GPIO 0 0 )
</code></pre></div>
<p>Here‚Äôs how: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L271-L322"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Transcode a Rhai Function Call to uLisp:
/// `gpio::enable_output(LED_GPIO, 0, 0)`
</span><span class="kw">fn </span>transcode_fncall(expr: <span class="kw-2">&amp;</span>FnCallExpr) -&gt; String {
  <span class="comment">//  Compose namespace e.g. `bl_gpio_` or ``
  </span><span class="kw">let </span>namespace = <span class="kw">match </span><span class="kw-2">&amp;</span>expr.namespace {
    <span class="prelude-val">Some</span>(ns) =&gt; <span class="macro">format!</span>(<span class="string">"bl_{:#?}_"</span>, ns),  <span class="comment">//  TODO
    </span><span class="prelude-val">None </span>=&gt; <span class="string">""</span>.to_string()
  };</code></pre></div>
<p><strong><code>transcode_fncall</code></strong> begins by converting the Rhai Namespace (like <strong>‚Äú<code>gpio::</code>‚Äù</strong>) to its uLisp equivalent (like <strong>‚Äú<code>bl_gpio_</code>‚Äù</strong>)</p>
<p>Next it composes the <strong>list of arguments</strong> for the function call‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Compose arguments e.g. `LED_GPIO 0 0 `
  </span><span class="kw">let </span>args = expr.args.iter().map(|arg| {
    <span class="comment">//  Transcode each argument
    </span><span class="kw">let </span>val = <span class="kw">match </span>arg {
      <span class="comment">//  Transcode a StackSlot by looking up the constants
      </span>Expr::Stack(i, <span class="kw">_</span>) =&gt; <span class="macro">format!</span>(<span class="string">"{}"</span>, expr.constants[<span class="kw-2">*</span>i]),

      <span class="comment">//  Transcode other expressions
      </span><span class="kw">_ </span>=&gt; transcode_expr(<span class="kw-2">&amp;</span>arg)
    };
    val + <span class="string">" "
  </span>});</code></pre></div>
<p>And concatenates everything into a <strong>uLisp Function Call</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Transcode to uLisp Function Call:
  //  `( bl_gpio_enable_output LED_GPIO 0 0 )`
  </span><span class="macro">format!</span>(
    <span class="string">"( {}{} {})"</span>,
    namespace,                             <span class="comment">//  `bl_gpio_` or ``
    </span>rename_function(<span class="kw-2">&amp;</span>expr.name.as_str()),  <span class="comment">//  `enable_output`, `+` or `mod`
    </span>args.collect::&lt;String&gt;()               <span class="comment">//  `LED_GPIO 0 0 `
  </span>)
}</code></pre></div>
<p><em>What‚Äôs <code>rename_function</code>?</em></p>
<p><strong>Rhai Operators</strong> are parsed as Function Calls‚Ä¶</p>
<p><strong>‚Äú<code>a % b</code>‚Äù</strong> is represented in the Abstract Syntax Tree as <strong>‚Äú<code>% (a, b)</code>‚Äù</strong></p>
<p>We call <strong><code>rename_function</code></strong> to convert the Rhai Operator to its uLisp equivalent: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L335-L343"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Rename a Rhai Function or Operator Name to uLisp:
/// `%` becomes `mod`, `==` becomes `eq`
</span><span class="kw">fn </span>rename_function(name: <span class="kw-2">&amp;</span>str) -&gt; String {
  <span class="kw">match </span>name {
    <span class="string">"%"  </span>=&gt; <span class="string">"mod"</span>,  <span class="comment">//  `%` becomes `mod`
    </span><span class="string">"==" </span>=&gt; <span class="string">"eq"</span>,   <span class="comment">//  `==` becomes `eq`
    </span><span class="kw">_    </span>=&gt; name    <span class="comment">//  Else pass through
  </span>}.to_string()
}</code></pre></div>
<p>This means that <strong>‚Äú<code>a % b</code>‚Äù</strong> in Rhai is rewritten as <strong>‚Äú<code>( mod a b )</code>‚Äù</strong> in uLisp.</p>
<p><a href="https://docs.rs/rhai/1.0.4/rhai/enum.Expr.html">(More about Rhai Expressions)</a></p>
<p><a href="https://docs.rs/rhai/1.0.4/rhai/struct.FnCallExpr.html">(More about Rhai Function Calls)</a></p>
<h2 id="transcoder-scope"><a href="#transcoder-scope">4.6 Transcoder Scope</a></h2>
<p><em>Why do we need uLisp Scopes when transcoding Rhai to uLisp?</em></p>
<p>Watch what happens when we transcode Rhai to uLisp <strong>without using scopes</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode3.jpg" alt="Transcode Rhai to uLisp without scopes" /></p>
<p>We see that the transcoded uLisp code ought to be <strong>nested inside each other</strong>.</p>
<p>To fix this we introduce <strong>uLisp Scopes</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/scope.rs"><code>bl602-script/scope.rs</code></a></p>
<p><img src="https://lupyuen.github.io/images/rhai-scope.png" alt="uLisp Scopes" /></p>
<p>With uLisp Scopes, our transcoded uLisp code becomes <strong>correctly nested</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode4.jpg" alt="Rhai Script transcoded to uLisp" /></p>
<h1 id="run-the-transcoded-ulisp"><a href="#run-the-transcoded-ulisp">5 Run the Transcoded uLisp</a></h1>
<p>Remember our <a href="https://lupyuen.github.io/articles/rhai#convert-rhai-to-ulisp"><strong>kitchen-sink Rhai Script</strong></a> from earlier?</p>
<p>Below is the uLisp Code <strong>generated by our Rhai Transcoder</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L550-L571"><code>bl602-script/lib.rs</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>( let* () 
  ( loop 
    ( let* (( a 1 )) 
      ( print a )
      ( if ( eq a 1 ) 
        ( return )
      )
    )
  )
  ( let* (( LED_GPIO 11 )) 
    ( bl_gpio_enable_output LED_GPIO 0 0 )
    ( dotimes (i 10) 
      ( bl_gpio_output_set LED_GPIO ( mod i 2 ) )
      ( time_delay 1000 )
    )
    ( let* (( a 40 )) 
      ( let* (( b 2 )) 
        ( + a b )
      )
    )
  )
)
</code></pre></div>
<p>Yep it looks like proper uLisp!</p>
<p>Just that we need to <strong>define these BL602 Functions</strong> in uLisp‚Ä¶</p>
<ul>
<li>
<p><strong><code>bl_gpio_enable_output</code></strong>: Configure a GPIO Pin for output</p>
</li>
<li>
<p><strong><code>bl_gpio_output_set</code></strong>: Set the output value of a GPIO Pin</p>
</li>
<li>
<p><strong><code>time_delay</code></strong>: Delay for a specified number of milliseconds</p>
</li>
</ul>
<p>Fortunately uLisp lets us <strong>extend its interpreter</strong> by adding the above  functions in C.</p>
<p>(Details in the Appendix)</p>
<p>And the output from our Rhai Transcoder <strong>runs OK on uLisp</strong>!</p>
<p><img src="https://lupyuen.github.io/images/rhai-run.png" alt="Running the Transcoded uLisp" /></p>
<h1 id="drag-and-drop-rhai-scripting"><a href="#drag-and-drop-rhai-scripting">6 Drag-and-Drop Rhai Scripting</a></h1>
<p>We wrap up today‚Äôs show-and-tell‚Ä¶ With some <strong>Drag-and-Drop Rhai Scripting</strong> in your Web Browser!</p>
<p><img src="https://lupyuen.github.io/images/rhai-title.jpg" alt="Drag-and-drop scripting with Blockly and Rhai" /></p>
<ol>
<li>
<p>Click this link to run the customised <strong>Blockly Web Editor</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen2.github.io/blockly-bl602/demos/code/"><strong>Blockly for Rhai Script and BL602 / BL604</strong></a></li>
</ul>
<p>This link points to plain HTML and JavaScript, no server-side code.</p>
<p><a href="https://github.com/lupyuen2/blockly-bl602/tree/master/demos/code">(See this)</a></p>
</li>
<li>
<p><strong>Drag and drop the blocks</strong> to create a program that blinks the LED‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-blockly.png" alt="Blockly for Rhai Script and BL602 / BL604" /></p>
<ul>
<li>
<p><strong><code>forever</code></strong> comes from <strong><code>Loops</code></strong> in the left bar</p>
</li>
<li>
<p><strong><code>digital write</code></strong> comes from <strong><code>GPIO</code></strong> in the left bar</p>
</li>
<li>
<p><strong><code>wait</code></strong> comes from <strong><code>Loops</code></strong> in the left bar</p>
</li>
</ul>
</li>
<li>
<p><strong>Update the block settings</strong> for the <strong><code>digital write</code></strong> and <strong><code>wait</code></strong> blocks</p>
<p>(See pic above)</p>
</li>
<li>
<p>Click the <strong><code>Rhai</code></strong> tab at the top.</p>
<p>We should see this <strong>Rhai Script generated by Blockly</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Loop forever
</span><span class="kw">loop </span>{
    <span class="comment">//  Configure GPIO 11 for Output
    </span>gpio::enable_output(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>);

    <span class="comment">//  Set GPIO 11 to Low
    </span>gpio::output_set(<span class="number">11</span>, <span class="number">0</span>);

    <span class="comment">//  Wait 1 second
    </span>time_delay(<span class="number">1000</span>);

    <span class="comment">//  Configure GPIO 11 for Output
    </span>gpio::enable_output(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>);

    <span class="comment">//  Set GPIO 11 to High
    </span>gpio::output_set(<span class="number">11</span>, <span class="number">1</span>);

    <span class="comment">//  Wait 1 second
    </span>time_delay(<span class="number">1000</span>);
}</code></pre></div>
<p>(Yeah the Rhai code generator needs improving)</p>
<p><img src="https://lupyuen.github.io/images/rhai-blockly2.png" alt="Rhai Script generated by Blockly" /></p>
</li>
</ol>
<p><em>How did we do this?</em></p>
<p>We <strong>customised Blockly for Rhai and BL602</strong> by‚Ä¶</p>
<ol>
<li>
<p>Adding <strong>Custom Blocks</strong> like <strong><code>forever</code></strong>, <strong><code>digital write</code></strong> and <strong><code>wait</code></strong></p>
</li>
<li>
<p>Creating a <strong>Code Generator</strong> that generates Rhai code</p>
</li>
</ol>
<p>Eventually we shall‚Ä¶</p>
<ol>
<li>
<p><strong>Run the generated Rhai code</strong> in the Web Browser with our <a href="https://lupyuen.github.io/articles/rustsim"><strong>BL602 WebAssembly Simulator</strong></a></p>
</li>
<li>
<p><strong>Transcode Rhai to uLisp</strong> by calling our Rhai-To-uLisp Transcoder in WebAssembly</p>
</li>
<li>
<p><strong>Transfer the uLisp code to BL602</strong> and run it via the <a href="https://lupyuen.github.io/articles/lisp#web-browser-controls-bl602-with-web-serial-api"><strong>Web Serial API</strong></a></p>
</li>
</ol>
<p>(More details in the Appendix)</p>
<h1 id="whats-next"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>Today we have explored the Bestest Outcome for <strong>learners to code and test Rhai Scripts</strong> on BL602 and BL604‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome3.jpg" alt="Convert Rhai Scripts to uLisp" /></p>
<p>Soon we shall test all this on <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604 with LoRa SX1262</strong></a>‚Ä¶ As we explore whether it‚Äôs feasible to teach <strong>Rhai (and Rust) as a Safer Way</strong> to create firmware for BL602 and BL604.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/rust/comments/phm2a5/rust_on_riscv_bl602_rhai_scripting/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rhai.md"><code>lupyuen.github.io/src/rhai.md</code></a></p>
<h1 id="notes"><a href="#notes">8 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1427758328004759552">this Twitter Thread</a></p>
</li>
<li>
<p>In our Rhai Script, why did we write‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>LED_GPIO = <span class="number">11</span>;</code></pre></div>
<p>Instead of this?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>LED_GPIO = <span class="number">11</span>;</code></pre></div>
<p>Because I‚Äôm targeting Rhai Scripting for learners who are new to coding microcontrollers.</p>
<p>I‚Äôm pondering whether we should teach them <strong><code>let</code></strong> vs <strong><code>const</code></strong>. Or maybe start with <strong><code>let</code></strong> and teach <strong><code>const</code></strong> later?</p>
<p><a href="https://github.com/lupyuen2/blockly-bl602/issues/1">(See this)</a></p>
</li>
<li>
<p><a href="https://github.com/schungx"><code>schungx</code></a> has an excellent suggestion about creating a <strong>minimal Rhai Scripting Language</strong> for learners‚Ä¶</p>
<blockquote>
<p>For a minimal language you might also want to disable keywords like continue, break, switch, while, do etc. and especially eval if you don‚Äôt intend your users to touch them yet‚Ä¶ since they would also need to be transcoded into uLisp</p>
</blockquote>
<p><a href="https://github.com/lupyuen2/blockly-bl602/issues/1#issuecomment-912899645">(See this)</a></p>
</li>
<li>
<p>What happens when we run the <strong>Rhai Scripting Engine on BL602</strong> (configured for the smallest feature set)?</p>
<p>It seems to crash with a <strong>Stack Overflow</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/sdk_app_rust_script">(See this)</a></p>
<p>We‚Äôll try LTO Optimisation to reduce the size of the Rust binaries.</p>
<p>It‚Äôs possible that the default FreeRTOS configuration on BL602 severely limits the usable Stack Space. (Sadly I‚Äôm no expert in FreeRTOS though)</p>
</li>
<li>
<p>There‚Äôs a minor quirk when building Rhai with <strong>AST support on WebAssembly</strong> (since we‚Äôre running our Rhai Transcoder on WebAssembly)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>unresolved import `ast::FloatWrapper`
--&gt; rhai-1.0.2/src/lib.rs:230:44
</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/transcode#build-bl602--bl604-rust-firmware-for-webassembly">Here is the workaround</a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/rhai-run.png" alt="Running the Transcoded uLisp" /></p>
<h1 id="appendix-add-c-functions-to-ulisp"><a href="#appendix-add-c-functions-to-ulisp">9 Appendix: Add C Functions to uLisp</a></h1>
<p>To run the transcoded uLisp, we need to <strong>define these BL602 Functions</strong> in uLisp‚Ä¶</p>
<ul>
<li>
<p><strong><code>bl_gpio_enable_output</code></strong>: Configure a GPIO Pin for output</p>
</li>
<li>
<p><strong><code>bl_gpio_output_set</code></strong>: Set the output value of a GPIO Pin</p>
</li>
<li>
<p><strong><code>time_delay</code></strong>: Delay for a specified number of milliseconds</p>
</li>
</ul>
<p>This is how we <strong>extend the uLisp Interpreter</strong> by adding the above  functions in C‚Ä¶</p>
<p>First we define the <strong>uLisp Shim Function</strong> in C: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4136-L4163"><code>ulisp.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Expose the C function `bl_gpio_enable_output` to uLisp:
//  `int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown)`
object *fn_bl_gpio_enable_output(object *args, object *env) {
  //  Fetch the `pin` parameter from uLisp
  assert(args != NULL);
  int pin = checkinteger(BL_GPIO_ENABLE_OUTPUT, car(args));
  args = cdr(args);

  //  Fetch the `pullup` parameter from uLisp
  assert(args != NULL);
  int pullup = checkinteger(BL_GPIO_ENABLE_OUTPUT, car(args));
  args = cdr(args);

  //  Fetch the `pulldown` parameter from uLisp
  assert(args != NULL);
  int pulldown = checkinteger(BL_GPIO_ENABLE_OUTPUT, car(args));
  args = cdr(args);

  //  No more parameters
  assert(args == NULL);
  printf(&quot;bl_gpio_enable_output: pin=%d, pullup=%d, pulldown=%d\r\n&quot;, pin, pullup, pulldown);

  //  Call the C function `bl_gpio_enable_output`
  int result = bl_gpio_enable_output(pin, pullup, pulldown);

  //  Return the result to uLisp
  //  TODO: Throw an exception if the result is non-zero
  return number(result);
}
</code></pre></div>
<p>Next we extend the <strong>Function Enum</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L196-L200"><code>ulisp.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>enum function {
  ...
  //  Begin User Functions
  BL_GPIO_ENABLE_OUTPUT,
  BL_GPIO_OUTPUT_SET,
  TIME_DELAY,
  //  End User Functions
</code></pre></div>
<p>Then we define the <strong>uLisp Function Name</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4434-L4438"><code>ulisp.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>// Insert your own function names here
const char str_bl_gpio_enable_output[] PROGMEM = &quot;bl_gpio_enable_output&quot;;
const char str_bl_gpio_output_set[]    PROGMEM = &quot;bl_gpio_output_set&quot;;
const char str_time_delay[]            PROGMEM = &quot;time_delay&quot;;
</code></pre></div>
<p>Finally we add the uLisp Shim Function to the <strong>Symbol Lookup Table</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4667-L4671"><code>ulisp.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>// Built-in symbol lookup table
const tbl_entry_t lookup_table[] PROGMEM = {
  ...
  // Insert your own table entries here
  { str_bl_gpio_enable_output, fn_bl_gpio_enable_output, 0x33 },
  { str_bl_gpio_output_set,    fn_bl_gpio_output_set,    0x22 },
  { str_time_delay,            fn_time_delay,            0x11 },
</code></pre></div>
<p><em>What is <code>0x33</code>?</em></p>
<p><strong><code>0x33</code></strong> means that our uLisp Function accepts</p>
<ul>
<li>
<p><strong>Minimum</strong> of 3 parameters, and</p>
</li>
<li>
<p><strong>Maximum</strong> of 3 parameters</p>
</li>
</ul>
<p><a href="http://www.ulisp.com/show?19Q4">(More about extending uLisp)</a></p>
<p><img src="https://lupyuen.github.io/images/rhai-title.jpg" alt="Drag-and-drop scripting with Blockly and Rhai" /></p>
<h1 id="appendix-customise-blockly-for-rhai"><a href="#appendix-customise-blockly-for-rhai">10 Appendix: Customise Blockly for Rhai</a></h1>
<p><em>How did we customise Blockly for Rhai and BL602?</em></p>
<ol>
<li>
<p>We added <strong>Custom Blocks</strong> like <strong><code>forever</code></strong>, <strong><code>digital write</code></strong> and <strong><code>wait</code></strong></p>
</li>
<li>
<p>We created a <strong>Code Generator</strong> that generates Rhai code.</p>
</li>
</ol>
<p>Eventually we shall..</p>
<ol>
<li>
<p><strong>Run the generated Rhai code</strong> in the Web Browser with our <a href="https://lupyuen.github.io/articles/rustsim"><strong>BL602 WebAssembly Simulator</strong></a></p>
</li>
<li>
<p><strong>Transcode Rhai to uLisp</strong> in Blockly by calling our Rhai-to-uLisp Transcoder</p>
</li>
<li>
<p><strong>Transfer the uLisp code to BL602</strong> and run it via the Web Serial API</p>
</li>
</ol>
<p><a href="https://lupyuen.github.io/articles/lisp#web-browser-controls-bl602-with-web-serial-api">(More about Web Serial API)</a></p>
<p><em>Which Blockly source files were modified?</em></p>
<p>We modified these Blockly source files to load the Custom Blocks and generate Rhai code‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/blockly-bl602/blob/master/demos/code/index.html"><strong>demos/code/index.html</strong></a> </p>
<p>This is the <strong>HTML source file</strong> for the Blockly Web Editor. (See pic above)</p>
<p><a href="https://github.com/lupyuen2/blockly-bl602/pull/2/files#diff-dcf2ffe98d7d8b4a0dd7b9f769557dbe8c9e0e726236ef229def25c956a43d8f">(See changes)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/blockly-bl602/blob/master/demos/code/code.js"><strong>demos/code/code.js</strong></a></p>
<p>This is the main <strong>JavaScript source file</strong> for the Blockly Web Editor.</p>
<p><a href="https://github.com/lupyuen2/blockly-bl602/pull/2/files#diff-d72873b861dee958e5d443c919726dd856de594bd56b1e73d8948a7719163553">(See changes)</a></p>
</li>
</ul>
<p><em>How did we create the Custom Blocks?</em></p>
<p>We used the <strong>Block Exporter</strong> from Blockly to create the Custom Blocks‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_library.xml"><strong>generators/rhai/ rhai_library.xml</strong></a>: XML for Custom Blocks</li>
</ul>
<p>With Block Explorer and the Custom Blocks XML file, we generated this JavaScript file containing our Custom Blocks‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_blocks.js"><strong>generators/rhai/ rhai_blocks.js</strong></a>: JavaScript for Custom Blocks</li>
</ul>
<p>Block Exporter and Custom Blocks are explained here‚Ä¶</p>
<ul>
<li>
<p><a href="https://developers.google.com/blockly/guides/create-custom-blocks/overview"><strong>‚ÄúCustom Blocks‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://developers.google.com/blockly/guides/create-custom-blocks/blockly-developer-tools"><strong>‚ÄúBlockly Developer Tools‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://developers.google.com/blockly/guides/create-custom-blocks/define-blocks"><strong>‚ÄúDefine Blocks‚Äù</strong></a></p>
</li>
</ul>
<p><em>Can we do this through a Desktop App? (Instead of Web Browser)</em></p>
<p>Possibly, if we wrap the Web Browser Interface into a <strong>Desktop App with Tauri</strong>.</p>
<p><a href="https://tauri.studio/en/">(More about Tauri)</a></p>
<p><em>Does Blockly work on Mobile Web Browsers?</em></p>
<p>Yes but the Web Serial API won‚Äôt work for transferring the generated uLisp code to BL602. (Because we can‚Äôt connect BL602 as a USB Serial device)</p>
<p>In future we could use the <a href="https://web.dev/bluetooth/"><strong>Web Bluetooth API</strong></a> instead to transfer the uLisp code to BL602. (Since BL602 supports Bluetooth LE)</p>
<p>This is how it looks on a Mobile Web Browser (from our earlier Blockly uLisp project)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-mobile.png" alt="Blockly on Mobile" /></p>
<p><em>What were we thinking when we designed the Custom Blocks: <code>forever</code>, <code>on_start</code>, <code>digital write</code>, <code>wait</code>, ‚Ä¶</em></p>
<p>The custom blocks were inspired by <strong>MakeCode for BBC micro:bit</strong>‚Ä¶</p>
<ul>
<li><a href="https://makecode.microbit.org/"><strong>MakeCode</strong></a></li>
</ul>
<h2 id="code-generator-for-rhai"><a href="#code-generator-for-rhai">10.1 Code Generator for Rhai</a></h2>
<p><em>How did we generate Rhai code in Blockly?</em></p>
<p>We created <strong>Code Generators</strong> for Rhai. Our Code Generators are JavaScript Functions that emit Rhai code for each type of Block‚Ä¶</p>
<ul>
<li><a href="https://developers.google.com/blockly/guides/create-custom-blocks/generating-code"><strong>‚ÄúGenerating Code‚Äù</strong></a></li>
</ul>
<p>We started by <strong>copying the Code Generators</strong> from Dart to Rhai into this Blockly folder‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/blockly-bl602/tree/master/generators/rhai"><strong>generators/rhai</strong></a>: Code Generators for Rhai</li>
</ul>
<p>Then we added this <strong>Code Generator Interface</strong> for Rhai‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai.js"><strong>generators/rhai.js</strong></a>: Interface for Rhai Code Generator</li>
</ul>
<p><em>Which Blocks are supported by the Rhai Code Generator?</em></p>
<p>The Rhai Code Generator is <strong>incomplete</strong>.</p>
<p>The only Blocks supported are‚Ä¶</p>
<ul>
<li>
<p><strong><code>forever</code></strong> <a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_functions.js#L40-L50">(See this)</a></p>
</li>
<li>
<p><strong><code>wait</code></strong> <a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_functions.js#L52-L60">(See this)</a></p>
</li>
<li>
<p><strong><code>digital write</code></strong> <a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_functions.js#L81-L94">(See this)</a></p>
</li>
</ul>
<p><em>How do we define a Rhai Code Generator?</em></p>
<p>We define the <strong><code>forever</code> Code Generator</strong> like so: <a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_functions.js#L40-L50"><code>rhai_functions.js</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Emit Rhai code for the &quot;forever&quot; block. 
//  Inspired by MakeCode &quot;forever&quot; and Arduino &quot;loop&quot;.
Blockly.Rhai[&#39;forever&#39;] = function(block) {
  var statements_stmts = Blockly.Rhai.statementToCode(block, &#39;STMTS&#39;);
  var code = statements_stmts;
  code = [
    `//  Loop forever`,
    `loop {`,
    code + `}`,
  ].join(&#39;\n&#39;);
  return code;
};
</code></pre></div>
<p>This JavaScript function emits a <strong>Rhai loop</strong> that wraps the code inside the <strong><code>forever</code></strong> block like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>//  Loop forever
loop {
    ...Code inside the loop block...
}
</code></pre></div>
<p>And below is the <strong><code>digital write</code> Code Generator</strong>: <a href="https://github.com/lupyuen2/blockly-bl602/blob/master/generators/rhai/rhai_functions.js#L81-L94"><code>rhai_functions.js</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Emit Rhai code for the &quot;digtial write&quot; block. 
Blockly.Rhai[&#39;digital_write_pin&#39;] = function(block) {
  var dropdown_pin = block.getFieldValue(&#39;PIN&#39;);
  var dropdown_value = block.getFieldValue(&#39;VALUE&#39;);
  //  TODO: Call gpio::enable_output only once
  var code = [
    `//  Configure GPIO ${dropdown_pin} for Output`,
    `gpio::enable_output(${dropdown_pin}, 0, 0);`,
    ``,
    `//  Set GPIO ${dropdown_pin} to ${dropdown_value == 0 ? &#39;Low&#39; : &#39;High&#39; }`,
    `gpio::output_set(${dropdown_pin}, ${dropdown_value});`,
    ``
  ].join(&#39;\n&#39;);  
  return code;
};
</code></pre></div>
<p>This JavaScript function emits Rhai code that <strong>sets the GPIO Pin mode and output value</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>//  Configure GPIO 11 for Output
gpio::enable_output(11, 0, 0);

//  Set GPIO 11 to High
gpio::output_set(11, 1);
</code></pre></div>
<p><em>What about the missing Rhai Code Generators?</em></p>
<p>If the <strong>Community could help</strong> to fill in the <strong>missing Rhai Code Generators</strong>‚Ä¶ That would be incredibly awesome! üôè üëç üòÄ</p>

    
</body>
</html>