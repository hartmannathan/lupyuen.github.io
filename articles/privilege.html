<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Star64 JH7110 + NuttX RTOS: RISC-V Privilege Levels and UART Registers</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Star64 JH7110 + NuttX RTOS: RISC-V Privilege Levels and UART Registers" 
    data-rh="true">
<meta property="og:description" 
    content="We're porting Apache NuttX RTOS to Pine64's Star64 JH7110 RISC-V SBC... And we see interesting issues with RISC-V Privilege Levels and 16550 UART Registers"
    data-rh="true">
<meta name="description" 
    content="We're porting Apache NuttX RTOS to Pine64's Star64 JH7110 RISC-V SBC... And we see interesting issues with RISC-V Privilege Levels and 16550 UART Registers">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/privilege-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Star64 JH7110 + NuttX RTOS: RISC-V Privilege Levels and UART Registers</h1>
    <nav id="TOC"><ul>
<li><a href="#wait-forever-in-uart-transmit">1 Wait Forever in UART Transmit</a><ul></ul></li>
<li><a href="#uart-registers-are-spaced-differently">2 UART Registers are Spaced Differently</a><ul></ul></li>
<li><a href="#critical-section-doesnt-return">3 Critical Section Doesn‚Äôt Return</a><ul></ul></li>
<li><a href="#risc-v-privilege-levels">4 RISC-V Privilege Levels</a><ul></ul></li>
<li><a href="#risc-v-machine-mode-becomes-supervisor-mode">5 RISC-V Machine Mode becomes Supervisor Mode</a><ul></ul></li>
<li><a href="#nuttx-flat-mode-becomes-kernel-mode">6 NuttX Flat Mode becomes Kernel Mode</a><ul></ul></li>
<li><a href="#initialise-risc-v-supervisor-mode">7 Initialise RISC-V Supervisor Mode</a><ul></ul></li>
<li><a href="#other-risc-v-ports-of-nuttx">8 Other RISC-V Ports of NuttX</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>23 Jul 2023</em></p>
<p><img src="https://lupyuen.github.io/images/privilege-title.jpg" alt="RISC-V Privilege Levels on Star64 JH7110 SBC" /></p>
<p>We‚Äôre in the super-early stage of porting <a href="https://lupyuen.github.io/articles/nuttx2"><strong>Apache NuttX Real-Time Operating System (RTOS)</strong></a> to the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> 64-bit RISC-V Single-Board Computer.</p>
<p>(Based on <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p>In this article we‚Äôll talk about the interesting things that we learnt about <strong>RISC-V and Star64 JH7110</strong>‚Ä¶</p>
<ul>
<li>
<p>What are <strong>RISC-V Privilege Levels</strong> (pic above)</p>
<p>(And why they make our OS a little more complicated)</p>
</li>
<li>
<p>What is <strong>NuttX Kernel Mode</strong></p>
<p>(And how it differs from Flat Mode)</p>
</li>
<li>
<p>All about <strong>JH7110‚Äôs UART Registers</strong></p>
<p>(And how they are different from other 16550 UARTs)</p>
</li>
<li>
<p>Why (naively) porting NuttX from <strong>QEMU to Star64</strong> might become really challenging!</p>
<p>(Thankfully we have the LiteX Arty-A7 and MPFS ICICLE ports)</p>
</li>
</ul>
<p>We begin with the simpler topic: UART‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Star64 JH7110 SBC with Woodpecker USB Serial Adapter" /></p>
<p><a href="https://lupyuen.github.io/articles/linux#serial-console-on-star64"><em>Star64 JH7110 SBC with Woodpecker USB Serial Adapter</em></a></p>
<h1 id="wait-forever-in-uart-transmit"><a href="#wait-forever-in-uart-transmit">1 Wait Forever in UART Transmit</a></h1>
<p>Here‚Äôs a fun quiz‚Ä¶</p>
<p>This NuttX Kernel Code prints a character to the UART Port. Guess why it <strong>waits forever on Star64 JH7110</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Print a character to UART Port
static void u16550_putc(
  FAR struct u16550_s *priv,  // UART Struct
  int ch                      // Character to be printed
) {
  // Wait for UART Port to be ready to transmit.
  // TODO: This will get stuck!
  while (
    (
      u16550_serialin(   // Read UART Register...
        priv,            //   From UART Base Address...
        UART_LSR_OFFSET  //   At offset of Line Status Register.
      ) &amp; UART_LSR_THRE  // If THRE Flag (Transmit Holding Register Empty)...
    ) == 0               //   Says that Transmit Register is Not Empty...
  );                     //   Then loop until it&#39;s empty.

  // Write the character
  u16550_serialout(priv, UART_THR_OFFSET, (uart_datawidth_t)ch);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/drivers/serial/uart_16550.c#L1622-L1638">(Source)</a></p>
<p><em>Is the UART Base Address correct?</em></p>
<p>It‚Äôs correct, actually. Previously we validated the <strong>16550 UART Base Address</strong> for JH7110‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#uart-controller-on-star64"><strong>‚ÄúUART Controller on Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#boot-nuttx-on-star64"><strong>‚ÄúBoot NuttX on Star64‚Äù</strong></a></p>
</li>
</ul>
<p>And we successfully printed to UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `A` to the UART Port at
// Base Address 0x1000 0000
*(volatile uint8_t *) 0x10000000 = &#39;A&#39;;
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L94-L159">(Source)</a></p>
<p>But strangely it loops forever waiting for the UART Port to be ready!</p>
<p><em>What‚Äôs inside u16550_serialin?</em></p>
<p>Remember we call <strong>u16550_serialin</strong> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>u16550_serialin(   // Read UART Register...
  priv,            // From UART Base Address...
  UART_LSR_OFFSET  // At offset of Line Status Register
)
</code></pre></div>
<p>Inside <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/drivers/serial/uart_16550.c#L596-L611"><strong>u16550_serialin</strong></a>, we read a UART Register at the Offset‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>*((FAR volatile uart_datawidth_t *)
  priv-&gt;uartbase +  // UART Base Address
  offset);          // Offset of UART Register
</code></pre></div>
<p><em>What‚Äôs the UART Register Offset?</em></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/include/nuttx/serial/uart_16550.h#L172-L200"><strong>UART_LSR_OFFSET</strong></a> (Offset of Line Status Register) is‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// UART Line Status Register
// is Register #5
#define UART_LSR_INCR 5

// Offset of Line Status Register
// is 16550_REGINCR * 5
#define UART_LSR_OFFSET \
  (CONFIG_16550_REGINCR * UART_LSR_INCR)
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/drivers/serial/Kconfig-16550#L501-L520"><strong>16550_REGINCR</strong></a> defaults to 1‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config 16550_REGINCR
  int &quot;Address increment between 16550 registers&quot;
  default 1
  ---help---
    The address increment between 16550 registers.
    Options are 1, 2, or 4.
    Default: 1
</code></pre></div>
<p>Which we copied from <a href="https://lupyuen.github.io/articles/riscv"><strong>NuttX for QEMU Emulator</strong></a>.</p>
<p><em>Ah but is 16550_REGINCR correct for Star64?</em></p>
<p>Let‚Äôs find out‚Ä¶</p>
<h1 id="uart-registers-are-spaced-differently"><a href="#uart-registers-are-spaced-differently">2 UART Registers are Spaced Differently</a></h1>
<p>Earlier we talked about the Address Increment between 16550 UART Registers (<strong>16550_REGINCR</strong>), which defaults to 1‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config 16550_REGINCR
  int &quot;Address increment between 16550 registers&quot;
  default 1
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/drivers/serial/Kconfig-16550#L501-L520">(Source)</a></p>
<p>Which means that the 16550 UART Registers are spaced <strong>1 byte apart</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: left">Register</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>0x1000</code> <code>0000</code></td><td style="text-align: left">Transmit Holding Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0001</code></td><td style="text-align: left">Interrupt Enable Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0002</code></td><td style="text-align: left">Interrupt ID Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0003</code></td><td style="text-align: left">Line Control Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0004</code></td><td style="text-align: left">Modem Control Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0005</code></td><td style="text-align: left">Line Status Register</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><em>But is it the same for Star64 JH7110?</em></p>
<p>JH7110 (oddly) doesn‚Äôt document the UART Registers, so we follow the trial of JH7110 Docs‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/Datasheet/JH7110_DS/uart.html"><strong>JH7110 UART Datasheet</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/function_layer.html"><strong>JH7110 UART Developing Guide</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html"><strong>JH7110 UART Device Tree</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/source_code_structure_uart.html"><strong>JH7110 UART Source Code</strong></a></p>
</li>
</ul>
<p>From the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html"><strong>JH7110 UART Device Tree</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>reg = &lt;0x0 0x10000000 0x0 0xl0000&gt;;
reg-io-width = &lt;4&gt;;
reg-shift = &lt;2&gt;;
</code></pre></div>
<p>We see that <strong>regshift</strong> is 2.</p>
<p><em>What‚Äôs regshift?</em></p>
<p>According to the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/source_code_structure_uart.html"><strong>JH7110 UART Source Code</strong></a>, this is how we write to a UART Register: <a href="https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c#L159-L169">8250_dw.c</a></p>
<div class="example-wrap"><pre class="language-text"><code>// Linux Kernel Driver: Write to 8250 UART Register
static void dw8250_serial_out(struct uart_port *p, int offset, int value) {
  ...
  // Write to UART Register
  writeb(
    value,                     // Register Value
    p-&gt;membase +               // UART Base Address plus...
      (offset &lt;&lt; p-&gt;regshift)  // Offset shifted by `regshift`
  );
</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/16550_UART">(<strong>8250 UART</strong> is compatible with 16550)</a></p>
<p>We see that the UART Register Offset is shifted by 2 (<strong>regshift</strong>).</p>
<p>Which means we <strong>multiply the UART Offset by 4!</strong></p>
<p>Thus the UART Registers are spaced <strong>4 bytes apart.</strong> And <strong>16550_REGINCR</strong> should be 4, not 1!</p>
<div><table><thead><tr><th style="text-align: center">Address</th><th style="text-align: left">Register</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>0x1000</code> <code>0000</code></td><td style="text-align: left">Transmit Holding Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0004</code></td><td style="text-align: left">Interrupt Enable Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0008</code></td><td style="text-align: left">Interrupt ID Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>000C</code></td><td style="text-align: left">Line Control Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0010</code></td><td style="text-align: left">Modem Control Register</td></tr>
<tr><td style="text-align: center"><code>0x1000</code> <code>0014</code></td><td style="text-align: left">Line Status Register</td></tr>
<tr><td style="text-align: center">¬†</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><em>How to fix 16550_REGINCR?</em></p>
<p>We fix the NuttX Configuration in ‚Äú<code>make</code> <code>menuconfig</code>‚Äù‚Ä¶</p>
<ul>
<li>Device Drivers &gt; Serial Driver Support &gt; 16550 UART Chip support &gt; Address Increment Between 16550 Registers</li>
</ul>
<p>And change it from 1 to 4: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/boards/risc-v/qemu-rv/rv-virt/configs/knsh64/defconfig#L11">knsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_REGINCR=4
</code></pre></div>
<p>Now UART Transmit works perfectly yay! (Pic below)</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
123067DFHBC
qemu_rv_kernel_mappings: map I/O regions
qemu_rv_kernel_mappings: map kernel text
qemu_rv_kernel_mappings: map kernel data
qemu_rv_kernel_mappings: connect the L1 and L2 page tables
qemu_rv_kernel_mappings: map the page pool
qemu_rv_mm_init: mmu_enable: satp=1077956608
nx_start: Entry
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64/blob/6f422cb3075f57e2acf312edcc21112fe42660e8/README.md#initialise-risc-v-supervisor-mode">(Source)</a></p>
<p><strong>Lesson Learnt:</strong> 8250 UARTs (and 16550) might work a little differently across Hardware Platforms! (Due to Word Alignment maybe?)</p>
<p>We move on to the tougher topic: Machine Mode vs Supervisor Mode‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/privilege-run1.png" alt="UART Transmit works perfectly yay" /></p>
<h1 id="critical-section-doesnt-return"><a href="#critical-section-doesnt-return">3 Critical Section Doesn‚Äôt Return</a></h1>
<p>We ran into another problem when printing to the UART Port‚Ä¶</p>
<p>NuttX on Star64 gets stuck when we enter a <strong>Critical Section</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/drivers/serial/uart_16550.c#L1712C1-L1748">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Print a character to the UART Port
int up_putc(int ch) {
  ...
  // Enter the Critical Section
  // TODO: This doesn&#39;t return!
  flags = enter_critical_section();

  // Print the character
  u16550_putc(priv, ch);

  // Exit the Critical Section
  leave_critical_section(flags);
</code></pre></div>
<p><em>What‚Äôs this Critical Section?</em></p>
<p>To prevent garbled output, NuttX stops mutiple threads (or interrupts) from printing to the UART Port simultaneously.</p>
<p>It uses a <a href="https://en.wikipedia.org/wiki/Critical_section"><strong>Critical Section</strong></a> to lock the chunk of code above, so only a single thread can print to UART at any time.</p>
<p>But the locking isn‚Äôt working‚Ä¶ It never returns!</p>
<p><em>How is it implemented?</em></p>
<p>When we browse the <strong>RISC-V Disassembly</strong> of NuttX, we see the implementation of the Critical Section: <a href="https://github.com/lupyuen/lupyuen.github.io/releases/download/nuttx-riscv64/nuttx.S">nuttx.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>int up_putc(int ch) {
  ...
up_irq_save():
nuttx/include/arch/irq.h:675
  __asm__ __volatile__
    40204598: 47a1      li    a5, 8
    4020459a: 3007b7f3  csrrc a5, mstatus, a5
up_putc():
nuttx/drivers/serial/uart_16550.c:1726
  flags = enter_critical_section();
</code></pre></div>
<p>Which has this curious <strong>RISC-V Instruction</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>// (Atomically) Read and Clear Bits
// in `mstatus` Register
csrrc a5, mstatus, a5
</code></pre></div>
<p>According to the <a href="https://five-embeddev.com/quickref/instructions.html#-csr--csr-instructions"><strong>RISC-V Spec</strong></a>, <strong><code>csrrc</code></strong> (Atomic Read and Clear Bits in CSR) will‚Ä¶</p>
<ul>
<li>
<p>Read the <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush"><strong><code>mstatus</code></strong></a> Register</p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-csr--csr-instructions">(Which is a <strong>CSR: Control and Status Register</strong>)</a></p>
</li>
<li>
<p>Clear the <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush"><strong><code>mstatus</code></strong></a> bits specified by Register <strong><code>a5</code></strong> (with value 8)</p>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush">(Which is the <strong>MIE Bit: Machine Interrupt Enable</strong>)</a></p>
</li>
<li>
<p>Return the initial value of <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush"><strong><code>mstatus</code></strong></a> in Register <strong><code>a5</code></strong></p>
<p>(Before clearing the bits)</p>
</li>
</ul>
<p>Effectively we‚Äôre <strong>disabling interrupts</strong>, so we won‚Äôt possibly switch to another thread.</p>
<p>But we have a problem: NuttX can‚Äôt modify the <strong><code>mstatus</code></strong> Register, because of its Privilege Level‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nuttx2-privilege.jpg" alt="RISC-V Privilege Levels" /></p>
<h1 id="risc-v-privilege-levels"><a href="#risc-v-privilege-levels">4 RISC-V Privilege Levels</a></h1>
<p><em>What‚Äôs this Privilege Level?</em></p>
<p>RISC-V Machine Code runs at three <strong>Privilege Levels</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>M: Machine Mode</strong> (Most powerful)</p>
</li>
<li>
<p><strong>S: Supervisor Mode</strong> (Less powerful)</p>
</li>
<li>
<p><strong>U: User Mode</strong> (Least powerful)</p>
</li>
</ul>
<p>NuttX on Star64 runs in <strong>Supervisor Mode</strong>. Which doesn‚Äôt allow write access to <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html"><strong>Machine-Mode CSR Registers</strong></a>. (Pic above)</p>
<p>Remember this?</p>
<div class="example-wrap"><pre class="language-text"><code>// (Atomically) Read and Clear Bits
// in `mstatus` Register
csrrc a5, mstatus, a5
</code></pre></div>
<p>The <strong>‚Äú<code>m</code>‚Äù</strong> in <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-status-registers-mstatus-and-mstatush"><strong><code>mstatus</code></strong></a> signifies that it‚Äôs a <strong>Machine-Mode Register</strong>.</p>
<p>That‚Äôs why NuttX failed to modify the <strong><code>mstatus</code></strong>!</p>
<p><em>What‚Äôs the equivalent of <code>mstatus</code> for Supervisor Mode?</em></p>
<p>NuttX should use the <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sstatus"><strong><code>sstatus</code></strong></a> Register instead.</p>
<p>(We should switch all Machine-Mode <strong><code>m</code></strong> Registers to Supervisor-Mode <strong><code>s</code></strong> Registers)</p>
<p><em>What runs in Machine Mode?</em></p>
<p><a href="https://lupyuen.github.io/articles/linux#opensbi-supervisor-binary-interface"><strong>OpenSBI (Supervisor Binary Interface)</strong></a> is the first thing that boots on Star64.</p>
<p>It runs in <strong>Machine Mode</strong> and starts the U-Boot Bootloader.</p>
<p><a href="https://lupyuen.github.io/articles/linux#opensbi-supervisor-binary-interface">(More about <strong>OpenSBI</strong>)</a></p>
<p><em>What about U-Boot Bootloader?</em></p>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a> runs in <strong>Supervisor Mode</strong>. And starts NuttX, also in Supervisor Mode.</p>
<p>Thus <strong>OpenSBI is the only thing</strong> that runs in Machine Mode. And can access the Machine-Mode Registers. (Pic above)</p>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64">(More about <strong>U-Boot</strong>)</a></p>
<p><em>QEMU doesn‚Äôt have this problem?</em></p>
<p>We (naively) copied the code above from <a href="https://lupyuen.github.io/articles/riscv"><strong>NuttX for QEMU Emulator</strong></a>.</p>
<p>But QEMU doesn‚Äôt have this problem, because it runs NuttX in (super-powerful) <strong>Machine Mode</strong>!</p>
<p><img src="https://lupyuen.github.io/images/nuttx2-privilege2.jpg" alt="NuttX QEMU runs in Machine Mode" /></p>
<p>Let‚Äôs make it work for Star64‚Ä¶</p>
<h1 id="risc-v-machine-mode-becomes-supervisor-mode"><a href="#risc-v-machine-mode-becomes-supervisor-mode">5 RISC-V Machine Mode becomes Supervisor Mode</a></h1>
<p><em>Earlier we saw the <code>csrrc</code> instruction‚Ä¶</em></p>
<p><em>From whence it came?</em></p>
<div class="example-wrap"><pre class="language-text"><code>// (Atomically) Read and Clear Bits
// in `mstatus` Register
csrrc a5, mstatus, a5
</code></pre></div>
<p>We saw the above RISC-V Assembly emitted by <a href="https://lupyuen.github.io/articles/privilege#critical-section-doesnt-return"><strong>up_putc</strong></a> and <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/include/nuttx/irq.h#L156-L191"><strong>enter_critical_section</strong></a>, let‚Äôs track it down.</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/include/nuttx/irq.h#L156-L191"><strong>enter_critical_section</strong></a> calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/include/irq.h#L660-L689"><strong>up_irq_save</strong></a>, which is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Disable interrupts
static inline irqstate_t up_irq_save(void) {
  ...
  // Read `mstatus` and clear 
  // Machine Interrupt Enable (MIE) in `mstatus`
  __asm__ __volatile__
  (
    &quot;csrrc %0, &quot; __XSTR(CSR_STATUS) &quot;, %1\n&quot;
    : &quot;=r&quot; (flags)
    : &quot;r&quot;(STATUS_IE)
    : &quot;memory&quot;
  );
</code></pre></div>
<p><em>Ah so CSR_STATUS maps to <code>mstatus</code>?</em></p>
<p>Yes indeed, <strong>CSR_STATUS</strong> becomes <strong><code>mstatus</code></strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/include/mode.h#L35-L103">mode.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// If NuttX runs in Supervisor Mode...
#ifdef CONFIG_ARCH_USE_S_MODE
  // Use Global Status Register 
  // for Supervisor Mode
  #define CSR_STATUS sstatus

#else  // If NuttX runs in Machine Mode...
  // Use Global Status Register 
  // for Machine Mode 
  #define CSR_STATUS mstatus
#endif
</code></pre></div>
<p>‚Ä¶BUT only if NuttX Configuration <strong>ARCH_USE_S_MODE</strong> is disabled!</p>
<p><em>So if ARCH_USE_S_MODE is enabled, NuttX will use <code>sstatus</code> instead?</em></p>
<p>Yep! We need to disable <strong>ARCH_USE_S_MODE</strong>, so that NuttX will use <strong><code>sstatus</code></strong> (instead of <strong><code>mstatus</code></strong>)‚Ä¶</p>
<p>Which is perfectly hunky dory for <strong>RISC-V Supervisor Mode</strong>!</p>
<p>We dig around for the elusive (but essential) <strong>ARCH_USE_S_MODE</strong>‚Ä¶</p>
<h1 id="nuttx-flat-mode-becomes-kernel-mode"><a href="#nuttx-flat-mode-becomes-kernel-mode">6 NuttX Flat Mode becomes Kernel Mode</a></h1>
<p><em>How to enable ARCH_USE_S_MODE in NuttX?</em></p>
<p>In the previous section we discovered that we should enable <strong>ARCH_USE_S_MODE</strong>, so that NuttX will run in <strong>RISC-V Supervisor Mode</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// If NuttX runs in Supervisor Mode...
#ifdef CONFIG_ARCH_USE_S_MODE
  // Use Global Status Register 
  // for Supervisor Mode
  #define CSR_STATUS sstatus

#else  // If NuttX runs in Machine Mode...
  // Use Global Status Register 
  // for Machine Mode 
  #define CSR_STATUS mstatus
#endif
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/privilege#risc-v-privilege-levels">(Because Star64 boots NuttX in Supervisor Mode)</a></p>
<p>Searching NuttX for <strong>ARCH_USE_S_MODE</strong> gives us this Build Configuration for <strong>NuttX Kernel Mode</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/knsh64/defconfig#L43">knsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_ARCH_USE_S_MODE=y
</code></pre></div>
<p><em>Perfect! Exactly what we need!</em></p>
<p>Thus we switch the NuttX Build Configuration from <strong>Flat Mode to Kernel Mode</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Configure NuttX for Kernel Mode and build NuttX
tools/configure.sh rv-virt:knsh64
make

## Previously: Configure NuttX for Flat Mode
## tools/configure.sh rv-virt:nsh64
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/tree/star64a/boards/risc-v/qemu-rv/rv-virt">(Complete Steps for <strong>Kernel Mode</strong>)</a></p>
<p><em>What‚Äôs this Kernel Mode?</em></p>
<p>According to the <a href="https://cwiki.apache.org/confluence/display/NUTTX/Memory+Configurations"><strong>NuttX Docs on Kernel Mode</strong></a>‚Ä¶</p>
<blockquote>
<p>‚ÄúAll of the code that executes within the Kernel executes in Privileged, Kernel Mode‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúAll User Applications are executed with their own private address environments in Unprivileged, User-Mode‚Äù</p>
</blockquote>
<p>Hence Kernel Mode is a lot more secure than the normal <strong>NuttX Flat Mode</strong>, which runs the Kernel and User Applications in the same Unprotected, Privileged Mode.</p>
<p><a href="https://cwiki.apache.org/confluence/display/NUTTX/NuttX+Protected+Build">(More about <strong>Kernel Mode</strong>)</a></p>
<p><em>Does it work?</em></p>
<p>When we <code>grep</code> for <strong><code>csr</code> Instructions</strong> in the rebuilt NuttX Disassembly <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/star64a-0.0.1/nuttx.S"><strong>nuttx.S</strong></a>‚Ä¶</p>
<p>We see (nearly) all Machine-Mode <strong><code>m</code></strong> Registers replaced by Supervisor-Mode <strong><code>s</code></strong> Registers.</p>
<p>No more problems with <a href="https://lupyuen.github.io/articles/privilege#critical-section-doesnt-return"><strong>Critical Section</strong></a> yay!</p>
<p>Let‚Äôs eliminate the remaining Machine-Mode Registers‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/privilege-run2.png" alt="NuttX crashes due to a Semihosting Problem" /></p>
<h1 id="initialise-risc-v-supervisor-mode"><a href="#initialise-risc-v-supervisor-mode">7 Initialise RISC-V Supervisor Mode</a></h1>
<p><em>We rebuilt NuttX from Flat Mode to Kernel Mode‚Ä¶</em></p>
<p><em>Why does it still need RISC-V Machine-Mode Registers?</em></p>
<p>NuttX accesses the RISC-V Machine-Mode Registers during <strong>NuttX Startup</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L183-L187"><strong>NuttX Boot Code</strong></a> calls <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L161-L235"><strong>qemu_rv_start</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/nuttx2#appendix-nuttx-in-supervisor-mode">(As explained here)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L161-L235"><strong>qemu_rv_start</strong></a> assumes it‚Äôs in <strong>Machine Mode</strong></p>
<p><a href="https://lupyuen.github.io/articles/privilege#risc-v-privilege-levels">(Because QEMU boots NuttX in Machine Mode)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L161-L235"><strong>qemu_rv_start</strong></a> initialises the <strong>Machine-Mode Registers</strong></p>
<p>(And some Supervisor-Mode Registers)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L161-L235"><strong>qemu_rv_start</strong></a> jumps to <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L94-L159"><strong>qemu_rv_start_s</strong></a> in <strong>Supervisor Mode</strong></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L94-L159"><strong>qemu_rv_start_s</strong></a> initialises the <strong>Supervisor-Mode Registers</strong></p>
<p>(And starts NuttX)</p>
</li>
</ol>
<p><em>So we need to remove the Machine-Mode Registers from qemu_rv_start?</em></p>
<p>Yep, because NuttX boots in <a href="https://lupyuen.github.io/articles/privilege#risc-v-privilege-levels"><strong>Supervisor Mode</strong></a> on Star64.</p>
<p>(And can‚Äôt access the Machine-Mode Registers)</p>
<p>This is how we patched <strong>qemu_rv_start</strong> to remove the Machine-Mode Registers: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L161-L235">qemu_rv_start.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>// Called by NuttX Boot Code
// to init System Registers
void qemu_rv_start(int mhartid) {

  // For the First CPU Core...
  if (0 == mhartid) {

    // Clear the BSS
    qemu_rv_clear_bss();

    // Initialize the per CPU areas
    riscv_percpu_add_hart(mhartid);
  }

  // Disable MMU and enable PMP
  WRITE_CSR(satp, 0x0);
  // Removed: pmpaddr0 and pmpcfg0

  // Set exception and interrupt delegation for S-mode
  // Removed: medeleg and mideleg

  // Allow to write satp from S-mode
  // Set mstatus to S-mode and enable SUM
  // Removed: mstatus

  // Set the trap vector for S-mode
  WRITE_CSR(stvec, (uintptr_t)__trap_vec);

  // Set the trap vector for M-mode
  // Removed: mtvec

  // TODO: up_mtimer_initialize();

  // Set mepc to the entry
  // Set a0 to mhartid explicitly and enter to S-mode
  // Removed: mepc

  // Added: Jump to S-Mode Init ourselves
  qemu_rv_start_s(mhartid);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L94-L159">(<strong>qemu_rv_start_s</strong> is defined here)</a></p>
<p>We‚Äôre not sure if this is entirely correct‚Ä¶ But it‚Äôs a good start!</p>
<p>(Yeah we‚Äôre naively copying code again sigh)</p>
<p>Now NuttX boots further!</p>
<div class="example-wrap"><pre class="language-text"><code>123067DFHBC
qemu_rv_kernel_mappings: map I/O regions
qemu_rv_kernel_mappings: map kernel text
qemu_rv_kernel_mappings: map kernel data
qemu_rv_kernel_mappings: connect the L1 and L2 page tables
qemu_rv_kernel_mappings: map the page pool
qemu_rv_mm_init: mmu_enable: satp=1077956608
Inx_start: Entry
elf_initialize: Registering ELF
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_application: Starting init task: /system/bin/init
load_absmodule: Loading /system/bin/init
elf_loadbinary: Loading file: /system/bin/init
elf_init: filename: /system/bin/init loadinfo: 0x404069e8
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64/blob/6f422cb3075f57e2acf312edcc21112fe42660e8/README.md#initialise-risc-v-supervisor-mode">(Source)</a></p>
<p>But NuttX crashes due to a Semihosting Problem. (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_exception: EXCEPTION: Breakpoint. MCAUSE: 0000000000000003, EPC: 0000000040200434, MTVAL: 0000000000000000
riscv_exception: PANIC!!! Exception = 0000000000000003
_assert: Current Version: NuttX  12.0.3 2261b80-dirty Jul 15 2023 20:38:57 risc-v
_assert: Assertion failed panic: at file: common/riscv_exception.c:85 task: Idle Task 0x40200ce6
up_dump_register: EPC: 0000000040200434
up_dump_register: A0: 0000000000000001 A1: 0000000040406778 A2: 0000000000000000 A3: 0000000000000001
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64/blob/6f422cb3075f57e2acf312edcc21112fe42660e8/README.md#initialise-risc-v-supervisor-mode">(Source)</a></p>
<p>We‚Äôll find out why in the next article!</p>
<p><strong>TODO:</strong> Port <strong>up_mtimer_initialize</strong> to Star64</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/32/files">(See the <strong>Modified Files</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64a-0.0.1">(See the <strong>Build Steps</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64a-0.0.1">(See the <strong>Build Outputs</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/privilege-semihosting.jpg" alt="Semihosting on RISC-V NuttX" /></p>
<p><a href="https://github.com/apache/nuttx/issues/9501"><em>Semihosting on RISC-V NuttX</em></a></p>
<h1 id="other-risc-v-ports-of-nuttx"><a href="#other-risc-v-ports-of-nuttx">8 Other RISC-V Ports of NuttX</a></h1>
<p><em>Porting NuttX from QEMU to Star64 looks challenging‚Ä¶</em></p>
<p><em>Are there other ports of NuttX for RISC-V?</em></p>
<p>We found the following NuttX Ports that run in <strong>RISC-V Supervisor Mode with OpenSBI</strong>.</p>
<p>(They might be good references for Star64 JH7110)</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/litex/index.html"><strong>LiteX Arty-A7</strong></a> boots from OpenSBI to NuttX (but doesn‚Äôt call back to OpenSBI)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/tree/star64/boards/risc-v/litex/arty_a7">litex/arty_a7</a></td><td style="text-align: left">RISC-V Board</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/litex/arty_a7/configs/knsh/defconfig#L34">knsh/defconfig</a></td><td style="text-align: left">Build Configuration</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/litex/litex_shead.S#L56">litex_shead.S</a></td><td style="text-align: left">Boot Code</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/litex/litex_start.c#L50">litex_start.c</a></td><td style="text-align: left">Startup Code</td></tr>
<tr><td style="text-align: left">¬†</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/tree/star64/boards/risc-v/mpfs/icicle"><strong>MPFS ICICLE</strong></a> runs a copy of OpenSBI inside NuttX (so it boots in Machine Mode before Supervisor Mode)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/tree/star64/boards/risc-v/mpfs/icicle">mpfs/icicle</a></td><td style="text-align: left">RISC-V Board</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64a/boards/risc-v/mpfs/icicle/configs/knsh/defconfig#L39">knsh/defconfig</a></td><td style="text-align: left">Build Configuration</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/mpfs/mpfs_shead.S#L62">mpfs_shead.S</a></td><td style="text-align: left">Boot Code</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/mpfs/mpfs_start.c#L52">mpfs_start.c</a></td><td style="text-align: left">Startup Code</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/mpfs/mpfs_opensbi.c#L602">mpfs_opensbi.c</a></td><td style="text-align: left">OpenSBI in NuttX</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/mpfs/mpfs_opensbi_utils.S#L62-L107">mpfs_opensbi_utils.S</a></td><td style="text-align: left">OpenSBI Helper</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/mpfs/mpfs_ihc_sbi.c#L570">mpfs_ihc_sbi.c</a></td><td style="text-align: left">OpenSBI Inter-Hart Comms</td></tr>
<tr><td style="text-align: left">¬†</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>I hope we learnt a bit more about <strong>RISC-V and Star64 JH7110 SBC</strong> today‚Ä¶</p>
<ul>
<li>
<p><strong>RISC-V Privilege Levels</strong></p>
<p>(Why they make our OS a little more complicated)</p>
</li>
<li>
<p><strong>NuttX Kernel Mode</strong></p>
<p>(How it differs from Flat Mode)</p>
</li>
<li>
<p><strong>JH7110‚Äôs UART Registers</strong></p>
<p>(How they are different from other 16550 UARTs)</p>
</li>
<li>
<p>Porting NuttX from <strong>QEMU to Star64</strong> might become really challenging!</p>
<p>(Thankfully we have the LiteX Arty-A7 and MPFS ICICLE ports)</p>
</li>
</ul>
<p>Please join me in the next article as we solve the <strong>RISC-V Semihosting Problem</strong>. (We might use an <strong>Initial RAM Disk</strong> with ROMFS)</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Other Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/privilege.md"><strong>lupyuen.github.io/src/privilege.md</strong></a></p>

    
</body>
</html>