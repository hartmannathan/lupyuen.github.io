<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Ox64 BL808 RISC-V SBC: Starting Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Ox64 BL808 RISC-V SBC: Starting Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content="Let's boot a tiny bit of Apache NuttX RTOS... On Pine64 Ox64 BL808 RISC-V SBC"
    data-rh="true">
<meta name="description" 
    content="Let's boot a tiny bit of Apache NuttX RTOS... On Pine64 Ox64 BL808 RISC-V SBC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/ox2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/ox2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Ox64 BL808 RISC-V SBC: Starting Apache NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#begin-with-star64-nuttx">1 Begin with Star64 NuttX</a><ul></ul></li>
<li><a href="#print-to-serial-console">2 Print to Serial Console</a><ul></ul></li>
<li><a href="#update-the-nuttx-boot-address">3 Update the NuttX Boot Address</a><ul></ul></li>
<li><a href="#fix-the-uart-driver">4 Fix the UART Driver</a><ul></ul></li>
<li><a href="#platform-level-interrupt-controller">5 Platform-Level Interrupt Controller</a><ul></ul></li>
<li><a href="#handle-risc-v-exceptions">6 Handle RISC-V Exceptions</a><ul></ul></li>
<li><a href="#add-plic-to-memory-map">7 Add PLIC to Memory Map</a><ul></ul></li>
<li><a href="#fail-to-load-initial-ram-disk">8 Fail to Load Initial RAM Disk</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>12 Nov 2023</em></p>
<p><img src="https://lupyuen.github.io/images/ox2-title.png" alt="Booting Apache NuttX RTOS on Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<p>Last week we booted Linux on the <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 64-bit RISC-V SBC</strong></a> (pic below), powered by <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Bouffalo Lab BL808 SoC</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/ox64"><strong>‚ÄúOx64 BL808 RISC-V SBC: Booting Linux and (maybe) Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>And we wondered whether a tiny 64-bit RTOS (Real-Time Operating System) like <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> might run more efficiently on Ox64.</p>
<p>(With only <strong>64 MB of RAM</strong>)</p>
<p>Let‚Äôs make it happen! In this article we‚Ä¶</p>
<ul>
<li>
<p>Begin with <strong>NuttX for Star64 JH7110</strong> RISC-V SBC</p>
</li>
<li>
<p>Boot it unmodified (!) on our <strong>Ox64 BL808</strong> RISC-V SBC</p>
</li>
<li>
<p>Add Debug Logs in <strong>RISC-V Assembly</strong></p>
</li>
<li>
<p>Tweak the <strong>NuttX UART Driver</strong> to print on Ox64</p>
</li>
<li>
<p>Fix the <strong>Platform-Level Interrupt Controller</strong></p>
</li>
<li>
<p>Track down why <strong>RISC-V Exceptions</strong> aren‚Äôt dumped correctly</p>
</li>
<li>
<p>And plan for the upcoming <strong>Initial RAM Disk</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/ox64-sbc.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="begin-with-star64-nuttx"><a href="#begin-with-star64-nuttx">1 Begin with Star64 NuttX</a></h1>
<p><em>We‚Äôre booting Star64 NuttX on Ox64? Unmodified?!</em></p>
<p>Yeah we have a hunch that NuttX might boot well <strong>across RISC-V SoCs</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/nuttx2">(We ported <strong>NuttX QEMU to Star64</strong> in only a few weeks!)</a></p>
<p><em>But Star64 runs on SiFive Cores. Ox64 uses T-Head Cores!</em></p>
<p>We‚Äôll find out if it really matters! This is how we download and build <strong>NuttX for Star64 JH7110</strong> RISC-V SBC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download WIP NuttX Source Code
git clone \
  --branch ox64 \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch ox64 \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Build NuttX for Star64
cd nuttx
tools/configure.sh star64:nsh
make
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prequisites and Toolchain</strong>)</a></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p>Then we do the <a href="https://lupyuen.github.io/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Overwrite the microSD Linux Image by the <strong>NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Export the Binary Image to nuttx.bin
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Copy and overwrite the `Image` file
## on the microSD for Ox64 Linux
cp nuttx.bin &quot;/Volumes/NO NAME/Image&quot;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <strong>microSD into Ox64</strong> and power up Ox64.</p>
<p>And we see‚Ä¶ Absolutely Nothing!</p>
<div class="example-wrap"><pre class="language-text"><code>Retrieving file: /extlinux/../Image
  append: root=PARTLABEL=rootfs rootwait rw rootfstype=ext4 console=ttyS0,2000000 loglevel=8 earlycon=sbi
Retrieving file: /extlinux/../bl808-pine64-ox64.dtb
  Flattened Device Tree blob at 51ff8000
  Booting using the fdt blob at 0x51ff8000
  Working FDT set to 51ff8000
  Loading Device Tree to 0000000053f22000, end 0000000053f25fab ... OK
  Working FDT set to 53f22000
Starting kernel ...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8134f17502db733ce87d6fa8b00eab55">(See the <strong>Complete Log</strong>)</a></p>
<p><em>Shouldn‚Äôt we see a Crash Dump?</em></p>
<p>Yeah we‚Äôre hoping that NuttX would crash and <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI (Supervisor Binary Interface)</strong></a> could dump a meaningful Stack Trace. But nope!</p>
<ul>
<li>
<p>We <strong>haven‚Äôt configured NuttX</strong> for Ox64 UART</p>
</li>
<li>
<p>NuttX was probably stuck in a loop <strong>waiting for Star64 UART</strong></p>
</li>
</ul>
<p>Let‚Äôs print something to the Serial Console‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox64-nuttx.png" alt="Apache NuttX RTOS boots a tiny bit on Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="print-to-serial-console"><a href="#print-to-serial-console">2 Print to Serial Console</a></h1>
<p><em>We have a strong hunch that NuttX is actually booting on Ox64‚Ä¶ How to prove it?</em></p>
<p>Let‚Äôs print something in the <strong>NuttX Boot Code</strong>. Which is in <strong>RISC-V Assembly</strong>!</p>
<p>When we compare these UARTs‚Ä¶</p>
<ul>
<li>
<p><strong>BL808 UART Hardware</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>BL808 Reference Manual</strong>, Page 402)</a></p>
</li>
<li>
<p><strong>BL602 UART Hardware</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf">(<strong>BL602 Reference Manual</strong>, Page 126)</a></p>
</li>
</ul>
<p>We discover that BL808 UART works the <strong>same way as BL602</strong>!</p>
<p>Thus we may seek guidance from the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c#L704-L725"><strong>NuttX Driver for BL602 UART</strong></a>.</p>
<p><em>So how do we print to BL808 UART?</em></p>
<p>This is how the <strong>BL602 UART Driver</strong> prints to the Serial Console: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c#L704-L725">bl602_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Output FIFO Offset is 0x88
#define BL602_UART_FIFO_WDATA_OFFSET 0x000088  /* uart_fifo_wdata */
#define BL602_UART_FIFO_WDATA(n) (BL602_UART_BASE(n) + BL602_UART_FIFO_WDATA_OFFSET)

// Write a character to UART
static void bl602_send(struct uart_dev_s *dev, int ch) {
  ...
  // Wait for FIFO to be empty
  while ((getreg32(BL602_UART_FIFO_CONFIG_1(uart_idx)) &amp; \
    UART_FIFO_CONFIG_1_TX_CNT_MASK) == 0);

  // Write character to Output FIFO
  putreg32(ch, BL602_UART_FIFO_WDATA(uart_idx));
}
</code></pre></div>
<p>So for BL808, we simply write the character to‚Ä¶</p>
<ul>
<li>
<p>UART3 Base Address: <strong><code>0x3000</code> <code>2000</code></strong></p>
<p><a href="https://lupyuen.github.io/articles/ox64#appendix-linux-device-tree">(From the <strong>Linux Device Tree</strong>)</a></p>
</li>
<li>
<p>Output FIFO Offset: <strong><code>0x88</code></strong></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/hardware/bl602_uart.h#L38-L58">(From above <strong>FIFO_WDATA_OFFSET</strong>)</a></p>
</li>
</ul>
<p>TODO</p>
<p><a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console">Based on Star64 Debug Code</a>, we code this in RISC-V Assembly‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load UART3 Base Address to Register t0 */
li  t0, 0x30002000

/* Load `1` to Register t1 */
li  t1, 0x31
/* Store byte from Register t1 to UART3 Base Address, Offset 0x88 */
sb  t1, 0x88(t0)

/* Load `2` to Register t1 */
li  t1, 0x32
/* Store byte from Register t1 to UART3 Base Address, Offset 0x88 */
sb  t1, 0x88(t0)

/* Load `3` to Register t1 */
li  t1, 0x33
/* Store byte from Register t1 to UART3 Base Address, Offset 0x88 */
sb  t1, 0x88(t0)
</code></pre></div>
<p>We insert the above code into the NuttX Boot Code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_head.S#L69-L87">jh7110_head.S</a></p>
<p>Now NuttX prints to the Serial Console yay! (Pic below)</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
123
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/1f895c9d57cb4e7294522ce27fea70fb">(Source)</a></p>
<p>OpenSBI boots on Ox64 with Hart ID 0 (instead of 1), so we remove this code‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code> /* We assume that OpenSBI has passed Hart ID (value 1) in Register a0.
   * But NuttX expects Hart ID to start at 0, so we subtract 1.
   */
  /* Previously: addi a0, a0, -1 */
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_head.S#L89-L93">(Source)</a></p>
<h1 id="update-the-nuttx-boot-address"><a href="#update-the-nuttx-boot-address">3 Update the NuttX Boot Address</a></h1>
<p>TODO</p>
<p><em>What is the Linux Boot Address for Ox64 BL808?</em></p>
<p>From the <a href="https://gist.github.com/lupyuen/30df5a965fabf719cc52bf733e945db7">U-Boot Settings</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>kernel_addr_r=0x50200000
</code></pre></div>
<p>Let‚Äôs update the Boot Address in NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L20-L27">ld.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>MEMORY
{
  kflash (rx) : ORIGIN = 0x50200000, LENGTH = 2048K   /* w/ cache */
  ksram (rwx) : ORIGIN = 0x50400000, LENGTH = 2048K   /* w/ cache */
  pgram (rwx) : ORIGIN = 0x50600000, LENGTH = 4096K   /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x50A00000, LENGTH = 6M   /* w/ cache */
}
</code></pre></div>
<p>TODO: Use up to 64 MB, the total RAM Size on Ox64</p>
<p>We make the same changes to the NuttX Config: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/configs/nsh/defconfig">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_START=0x50200000
CONFIG_RAM_SIZE=1048576
CONFIG_ARCH_PGPOOL_PBASE=0x50600000
CONFIG_ARCH_PGPOOL_VBASE=0x50600000
CONFIG_ARCH_PGPOOL_SIZE=4194304
</code></pre></div>
<p>And the Memory Mapping: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ba093f2477f011ec7c5351eaba0a3002add02d6b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L47-L50">jh7110_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Map the whole I/O memory with vaddr = paddr mappings */
#define MMU_IO_BASE     (0x00000000)
#define MMU_IO_SIZE     (0x50000000)
</code></pre></div>
<p>TODO: What‚Äôs the RAM Disk Address? It‚Äôs missing from <a href="https://gist.github.com/lupyuen/30df5a965fabf719cc52bf733e945db7">U-Boot Settings</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Ramdisk Load Address from U-Boot */
#define RAMDISK_ADDR_R  (0x46100000)
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_mm_init.c#L43-L45">(Source)</a></p>
<p>NuttX shows the same output as earlier, no change‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
123
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/1f895c9d57cb4e7294522ce27fea70fb">(Source)</a></p>
<p>Let‚Äôs fix the NuttX UART Driver‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox64-stack.png" alt="NuttX prints our very first Stack Dump on Ox64 yay!" /></p>
<h1 id="fix-the-uart-driver"><a href="#fix-the-uart-driver">4 Fix the UART Driver</a></h1>
<p>TODO</p>
<p><em>NuttX on Ox64 has been awfully quiet. How to fix the UART Driver so that NuttX can print things?</em></p>
<p>Ox64 is still running on the JH7110 UART Driver (16550). Let‚Äôs make a quick patch so that we will see something on the Ox64 Serial Console‚Ä¶</p>
<p>We hardcode the UART3 Base Address (from above) and FIFO Offset for now: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L1698-L1716">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Write one character to the UART (polled)
static void u16550_putc(FAR struct u16550_s *priv, int ch) {

  // Hardcode the UART3 Base Address and FIFO Offset
  *(volatile uint8_t *) 0x30002088 = ch; ////

  // Previously:
  // while ((u16550_serialin(priv, UART_LSR_OFFSET) &amp; UART_LSR_THRE) == 0);
  // u16550_serialout(priv, UART_THR_OFFSET, (uart_datawidth_t)ch);
}
</code></pre></div>
<p>(Yeah the UART Buffer might overflow, we‚Äôll fix later)</p>
<p>We skip the reading and writing of other UART Registers, because we‚Äôll patch them later: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L604-L632">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Read UART Register
static inline uart_datawidth_t u16550_serialin(FAR struct u16550_s *priv, int offset) {
  return 0; ////
  // Commented out the rest
}

// Write UART Register
static inline void u16550_serialout(FAR struct u16550_s *priv, int offset, uart_datawidth_t value) {
  // Commented out the rest
}
</code></pre></div>
<p>And we won‚Äôt wait for UART Ready, since we‚Äôre not accessing the Line Control Register: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L633-L670">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Wait until UART is not busy. This is needed before writing to Line Control Register.
// Otherwise we will get spurious interrupts on Synopsys DesignWare 8250.
static int u16550_wait(FAR struct u16550_s *priv) {
  // Nopez! No waiting for now
  return OK; ////
}
</code></pre></div>
<p>Now NuttX prints our very first Stack Dump on Ox64 yay!</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
123
ABC
riscv_exception: EXCEPTION: Load access fault. MCAUSE: 0000000000000005, EPC: 0000000050208086, MTVAL: 000000000c002104
riscv_exception: PANIC!!! Exception = 0000000000000005
_assert: Current Version: NuttX  12.0.3 93a92a7-dirty Nov  5 2023 11:27:46 risc-v
_assert: Assertion failed panic: at file: common/riscv_exception.c:85 task: Idle_Task process: Kernel 0x50200e28
up_dump_register: EPC: 0000000050208086
up_dump_register: A0: 000000000c002104 A1: ffffffffffffffff A2: 0000000000000001 A3: 0000000000000003
up_dump_register: A4: ffffffffffffffff A5: 8000000200046000 A6: 0000000000000000 A7: fffffffffffffff8
up_dump_register: T0: 00000000502000a8 T1: 0000000000000007 T2: 656d616e2d64746d T3: 0000000050407b10
up_dump_register: T4: 0000000050407b08 T5: 0000000053f23fff T6: 0000000053f33870
up_dump_register: S0: 0000000000000000 S1: 0000000050400140 S2: 0000000000000001 S3: 8000000200046002
up_dump_register: S4: 0000000050400070 S5: 00000000000001b6 S6: 0000000000000000 S7: 0000000000000000
up_dump_register: S8: 0000000053f7a15c S9: 0000000053fcf2e0 S10: 0000000000000001 S11: 0000000000000003
up_dump_register: SP: 0000000050407a00 FP: 0000000000000000 TP: 0000000000000000 RA: 0000000050204064
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/36b8c47abc2632063ca5cdebb958e3e8">(Source)</a></p>
<p>Let‚Äôs look up the RISC-V Exception Code Address 0x50208086 in our RISC-V Disassembly‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>EXCEPTION: Load access fault 
MCAUSE: 0000000000000005 
EPC:    0000000050208086 
MTVAL:  000000000c002104
</code></pre></div>
<p>And the offending Data Address 0xc002104. (Which looks very familiar!)</p>
<p><img src="https://lupyuen.github.io/images/plic-title.jpg" alt="Platform-Level Interrupt Controller for Star64 JH7110" /></p>
<p><a href="https://lupyuen.github.io/articles/plic"><em>Platform-Level Interrupt Controller for Star64 JH7110</em></a></p>
<h1 id="platform-level-interrupt-controller"><a href="#platform-level-interrupt-controller">5 Platform-Level Interrupt Controller</a></h1>
<p><em>What‚Äôs this Platform-Level Interrupt Controller?</em></p>
<p>TODO</p>
<p><em>Why did NuttX crash with this RISC-V Exception?</em></p>
<div class="example-wrap"><pre class="language-text"><code>EXCEPTION: Load access fault 
MCAUSE: 0000000000000005 
EPC:    0000000050208086 
MTVAL:  000000000c002104
</code></pre></div>
<p>NuttX crashed when it tried to access invalid Data Address 0xc002104 from Code Address 0x50208086.</p>
<p>We look up Code Address 0x50208086 in our NuttX Disassembly‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>000000005020807a &lt;modifyreg32&gt;:
up_irq_save():
/Users/Luppy/ox64/nuttx/include/arch/irq.h:689
    5020807a:	4789                	li	a5,2
    5020807c:	1007b7f3          	csrrc	a5,sstatus,a5
modifyreg32():
/Users/Luppy/ox64/nuttx/arch/risc-v/src/common/riscv_modifyreg32.c:52
{
  irqstate_t flags;
  uint32_t   regval;

  flags   = spin_lock_irqsave(NULL);
  regval  = getreg32(addr);
    50208080:	4118                	lw	a4,0(a0)
/Users/Luppy/ox64/nuttx/arch/risc-v/src/common/riscv_modifyreg32.c:53
  regval &amp;= ~clearbits;
    50208082:	fff5c593          	not	a1,a1
/Users/Luppy/ox64/nuttx/arch/risc-v/src/common/riscv_modifyreg32.c:52
  regval  = getreg32(addr);
    50208086:	2701                	sext.w	a4,a4
</code></pre></div>
<p>Which comes from here: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_modifyreg32.c#L38-L57">riscv_modifyreg32.c</a></p>
<div class="example-wrap"><pre class="language-c"><code> // Atomically modify the specified bits in a memory mapped register
void modifyreg32(uintptr_t addr, uint32_t clearbits, uint32_t setbits) {
  irqstate_t flags;
  uint32_t   regval;

  flags   = spin_lock_irqsave(NULL);
  // Crashes here because `addr` is invalid...
  regval  = getreg32(addr);
  regval &amp;= ~clearbits;
  regval |= setbits;
  putreg32(regval, addr);
  spin_unlock_irqrestore(NULL, flags);
}
</code></pre></div>
<p>It‚Äôs trying to modify a Memory-Mapped Register, and crashed.</p>
<p><em>But what Memory-Mapped Register?</em></p>
<p>The offending Data Address 0xc002104 actually comes from Star64 PLIC! (Platform-Level Interrupt Controller)</p>
<div class="example-wrap"><pre class="language-c"><code>// From https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/hardware/jh7110_memorymap.h#L30
#define JH7110_PLIC_BASE    0x0c000000

// From https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/hardware/jh7110_plic.h#L34-L49
/* Interrupt Priority */
#define JH7110_PLIC_PRIORITY  (JH7110_PLIC_BASE + 0x000000)

/* Hart 1 S-Mode Interrupt Enable */
#define JH7110_PLIC_ENABLE1   (JH7110_PLIC_BASE + 0x002100)
#define JH7110_PLIC_ENABLE2   (JH7110_PLIC_BASE + 0x002104)

/* Hart 1 S-Mode Priority Threshold */
#define JH7110_PLIC_THRESHOLD (JH7110_PLIC_BASE + 0x202000)

/* Hart 1 S-Mode Claim / Complete */
#define JH7110_PLIC_CLAIM     (JH7110_PLIC_BASE + 0x202004)
</code></pre></div>
<p>The PLIC Base Address is different for BL808, let‚Äôs change it.</p>
<p><em>What‚Äôs the PLIC Base Address in Ox64 BL808?</em></p>
<p>PLIC Base Address is 0xe0000000, according to the Linux Device Tree: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/bl808-pine64-ox64.dts#L129-L138">bl808-pine64-ox64.dts</a></p>
<div class="example-wrap"><pre class="language-text"><code>interrupt-controller@e0000000 {
  compatible = &quot;thead,c900-plic&quot;;
  reg = &lt;0xe0000000 0x4000000&gt;;
  interrupts-extended = &lt;0x06 0xffffffff 0x06 0x09&gt;;
  interrupt-controller;
  #address-cells = &lt;0x00&gt;;
  #interrupt-cells = &lt;0x02&gt;;
  riscv,ndev = &lt;0x40&gt;;
  phandle = &lt;0x01&gt;;
};
</code></pre></div>
<p>TODO: Why isn‚Äôt this documented in <a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">XuanTie OpenC906 User Manual</a>?</p>
<p>So we change the PLIC Base Address for Ox64: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/hardware/jh7110_memorymap.h#L30">jh7110_memorymap.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define JH7110_PLIC_BASE    0xe0000000
</code></pre></div>
<p>TODO: Enable Scheduler Debug</p>
<h1 id="handle-risc-v-exceptions"><a href="#handle-risc-v-exceptions">6 Handle RISC-V Exceptions</a></h1>
<p>TODO</p>
<p>Now NuttX crashes at a different place, with IRQ 15‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>123ABC
nx_start: Entry
up_irqinitialize: a
up_irqinitialize: b
up_irqinitialize: c
riscv_dispatch_irq: irq=15
irq_unexpected_isr: ERROR irq: 15
_assert: Current Version: NuttX  12.0.3 910bfca-dirty Nov  6 2023 15:23:11 risc-v
_assert: Assertion failed panic: at file: irq/irq_unexpectedisr.c:54 task: Idle_Task process: Kernel 0x50200e50
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/11b8d4221a150f10afa3aa5ab5e50a4c">(Source)</a></p>
<p><em>What‚Äôs IRQ 15?</em></p>
<p>From <a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">XuanTie OpenC906 User Manual</a> (Page 21):</p>
<blockquote>
<p>‚ÄúException Vector ID 15: A store/atomic instruction page error exception.‚Äù</p>
</blockquote>
<p>This RISC-V Exception says that we tried to write to an invalid Data Address. And failed.</p>
<p><em>Where did it crash?</em></p>
<p>Based on our log, NuttX crashes before setting the PLIC!</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/8f318c363c80e1d4f5788f3815009cb57b5ff298/arch/risc-v/src/jh7110/jh7110_irq.c#L42-L85">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the IRQs
void up_irqinitialize(void) {
  _info(&quot;a\n&quot;);////

  /* Disable S-Mode interrupts */
  _info(&quot;b\n&quot;);////
  up_irq_save();

  /* Disable all global interrupts */
  _info(&quot;c\n&quot;);////
  // Crashes here!
  putreg32(0x0, JH7110_PLIC_ENABLE1);
  putreg32(0x0, JH7110_PLIC_ENABLE2);

  /* Colorize the interrupt stack for debug purposes */
  ...

  /* Set irq threshold to 0 (permits all global interrupts) */
  _info(&quot;e\n&quot;);////
  putreg32(0, JH7110_PLIC_THRESHOLD);

  /* Attach the common interrupt handler */
  _info(&quot;f\n&quot;);////
  riscv_exception_attach();
</code></pre></div>
<p><em>But it‚Äôs a RISC-V Exception! Shouldn‚Äôt NuttX dump this as a proper exception?</em></p>
<p>See the <code>riscv_exception_attach()</code> above? It happens AFTER the crash! This means NuttX hasn‚Äôt properly initialised the Exception Handlers, when the crash happened.</p>
<p>Let‚Äôs init the Exception Handlers earlier: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/8f318c363c80e1d4f5788f3815009cb57b5ff298/arch/risc-v/src/jh7110/jh7110_irq.c#L42-L85">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the IRQs
void up_irqinitialize(void) {
  _info(&quot;a\n&quot;);////

  /* Disable S-Mode interrupts */
  _info(&quot;b\n&quot;);////
  up_irq_save();

  /* Attach the common interrupt handler */
  _info(&quot;f\n&quot;);////
  // Init the Exception Handlers here
  riscv_exception_attach();

  /* Disable all global interrupts */
  _info(&quot;c\n&quot;);////
  // Crashes here!
  putreg32(0x0, JH7110_PLIC_ENABLE1);
  putreg32(0x0, JH7110_PLIC_ENABLE2);
</code></pre></div>
<p><code>riscv_exception_attach()</code> will handle all RISC-V Exceptions, including Store/AMO Page Fault (IRQ 15): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_exception.c#L89-L142">riscv_exception.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Attach standard exception with suitable handler
void riscv_exception_attach(void) {
  // Handle Store/AMO Page Fault (IRQ 15)
  irq_attach(RISCV_IRQ_STOREPF, riscv_exception, NULL);
</code></pre></div>
<p>Now we see the Store/AMO Page Fault Exception!</p>
<div class="example-wrap"><pre class="language-text"><code>up_irqinitialize: c
riscv_dispatch_irq: irq=15
riscv_exception: 
EXCEPTION: Store/AMO page fault
MCAUSE: 000000000000000f
EPC:    0000000050207e6a
MTVAL:  00000000e0002100
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/85db0510712ba8c660e10f922d4564c9">(Source)</a></p>
<p>Code Address is 0x50207e6a, from our PLIC Code‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/Users/Luppy/ox64/nuttx/arch/risc-v/src/chip/jh7110_irq.c:62
  putreg32(0x0, JH7110_PLIC_ENABLE1);
    50207e64:	700017b7          	lui	a5,0x70001
    50207e68:	0786                	slli	a5,a5,0x1
    50207e6a:	1007a023          	sw	zero,256(a5) # 70001100 &lt;__ramdisk_end+0x1e601100&gt;
</code></pre></div>
<p>The offending Data Address is 0xe0002100. Which is our BL808 PLIC!</p>
<h1 id="add-plic-to-memory-map"><a href="#add-plic-to-memory-map">7 Add PLIC to Memory Map</a></h1>
<p>TODO</p>
<p><em>But is 0xe0002100 accessible?</em></p>
<p>Ah we forgot to add it to the I/O Memory Map! Let‚Äôs fix it: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/b244f85065ecc749599842088f35f1b190466429/arch/risc-v/src/jh7110/jh7110_mm_init.c#L47-L50">jh7110_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Map the whole I/O memory with vaddr = paddr mappings */
#define MMU_IO_BASE     (0x00000000)
#define MMU_IO_SIZE     (0xf0000000)
</code></pre></div>
<p>(Doesn‚Äôt look right, but we‚Äôll fix later)</p>
<p>Now NuttX boots further! And tries to register IRQ 57 for the Star64 UART Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>up_irqinitialize: c
up_irqinitialize: d
up_irqinitialize: e
up_irqinitialize: g
irq_attach: irq=17, isr=0x50207eee
up_enable_irq: irq=17
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
irq_attach: irq=57, isr=0x502041fe
up_enable_irq: irq=57
riscv_dispatch_irq: irq=5
riscv_exception: 
EXCEPTION: Load access fault
MCAUSE: 0000000000000005
EPC:    0000000050208342
MTVAL:  00000000e0002104
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ade5ff1433812fb675ff06f805f7339f">(Source)</a></p>
<p>But it crashes while accessing the PLIC at another address: 0xe0002104.</p>
<p><em>Are we tired of PLIC yet?</em></p>
<p>Yeah let‚Äôs fix PLIC later. The entire UART Driver will be revamped anyway, including the UART Interrupt.</p>
<p>Let‚Äôs disable the UART Interrupt for now: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L902-L958">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Attach the UART Interrupt for Star64
static int u16550_attach(struct uart_dev_s *dev) {
  // Don&#39;t attach the interrupt
  // Previously: ret = irq_attach(priv-&gt;irq, u16550_interrupt, dev);

  // Don&#39;t enable the interrupt
  // Previously: up_enable_irq(priv-&gt;irq);
</code></pre></div><h1 id="fail-to-load-initial-ram-disk"><a href="#fail-to-load-initial-ram-disk">8 Fail to Load Initial RAM Disk</a></h1>
<p>TODO</p>
<p>Now NuttX boots even further yay! But crashes in the NuttX Bringup‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>up_irqinitialize: c
up_irqinitialize: d
up_irqinitialize: e
up_irqinitialize: g
irq_attach: irq=17, isr=0x50207e64
up_enable_irq: irq=17
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
_assert: Current Version: NuttX  12.0.3 b244f85-dirty Nov  6 2023 17:35:34 risc-v
_assert: Assertion failed ret &gt;= 0: at file: init/nx_bringup.c:283 task: AppBringUp process: Kernel 0x5020107e
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ab640bcb3ba3a19834bcaa29e43baddf">(Source)</a></p>
<p>Because it couldn‚Äôt map the Initial RAM Disk: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_bringup.c#L276-L284">nx_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Mount the file system containing the init program. */
ret = nx_mount(CONFIG_INIT_MOUNT_SOURCE, CONFIG_INIT_MOUNT_TARGET,
  CONFIG_INIT_MOUNT_FSTYPE, CONFIG_INIT_MOUNT_FLAGS,
  CONFIG_INIT_MOUNT_DATA);
DEBUGASSERT(ret &gt;= 0);
</code></pre></div>
<p>That‚Äôs because we haven‚Äôt loaded the Initial RAM Disk! Let‚Äôs fix this later.</p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/ox2.md"><strong>lupyuen.github.io/src/ox2.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="My horrigible soldering of Ox64 BL808 üò¨" /></p>
<p><em>My horrigible soldering of Ox64 BL808</em> üò¨</p>

    
</body>
</html>