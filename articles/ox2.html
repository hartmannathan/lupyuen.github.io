<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Ox64 BL808 RISC-V SBC: Starting Apache NuttX Real-Time Operating System</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Ox64 BL808 RISC-V SBC: Starting Apache NuttX Real-Time Operating System" 
    data-rh="true">
<meta property="og:description" 
    content="Let's boot a tiny bit of Apache NuttX Real-Time Operating System... On Pine64 Ox64 BL808 RISC-V SBC"
    data-rh="true">
<meta name="description" 
    content="Let's boot a tiny bit of Apache NuttX Real-Time Operating System... On Pine64 Ox64 BL808 RISC-V SBC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/ox2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/ox2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Ox64 BL808 RISC-V SBC: Starting Apache NuttX Real-Time Operating System</h1>
    <nav id="TOC"><ul>
<li><a href="#begin-with-star64-nuttx">1 Begin with Star64 NuttX</a><ul></ul></li>
<li><a href="#print-to-serial-console">2 Print to Serial Console</a><ul></ul></li>
<li><a href="#update-the-boot-address">3 Update the Boot Address</a><ul></ul></li>
<li><a href="#fix-the-uart-driver">4 Fix the UART Driver</a><ul></ul></li>
<li><a href="#platform-level-interrupt-controller">5 Platform-Level Interrupt Controller</a><ul></ul></li>
<li><a href="#handle-risc-v-exceptions">6 Handle RISC-V Exceptions</a><ul></ul></li>
<li><a href="#add-plic-to-memory-map">7 Add PLIC to Memory Map</a><ul></ul></li>
<li><a href="#initial-ram-disk-is-missing">8 Initial RAM Disk is Missing</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-nuttx-boot-flow">10 Appendix: NuttX Boot Flow</a><ul></ul></li>
<li><a href="#appendix-memory-map-for-ox64">11 Appendix: Memory Map for Ox64</a><ul></ul></li>
<li><a href="#appendix-uart-driver-for-ox64">12 Appendix: UART Driver for Ox64</a><ul></ul></li>
<li><a href="#appendix-initial-ram-disk">13 Appendix: Initial RAM Disk</a><ul></ul></li></ul></nav><p>üìù <em>12 Nov 2023</em></p>
<p><img src="https://lupyuen.github.io/images/ox2-title.png" alt="Booting Apache NuttX RTOS on Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<p>Last week we booted Linux on the <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 64-bit RISC-V SBC</strong></a> (pic below), powered by <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Bouffalo Lab BL808 SoC</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/ox64"><strong>‚ÄúOx64 BL808 RISC-V SBC: Booting Linux and (maybe) Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>And we wondered if a tiny 64-bit RTOS (Real-Time Operating System) like <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> might run more efficiently on Ox64.</p>
<p>(With only <strong>64 MB of RAM</strong>)</p>
<p>Let‚Äôs make it happen! In this article we‚Ä¶</p>
<ul>
<li>
<p>Begin with <strong>NuttX for Star64 JH7110</strong> RISC-V SBC</p>
</li>
<li>
<p>Boot it unmodified (!) on our <strong>Ox64 BL808</strong> RISC-V SBC</p>
</li>
<li>
<p>Add Debug Logs in <strong>RISC-V Assembly</strong></p>
</li>
<li>
<p>Tweak the <strong>NuttX UART Driver</strong> to print on Ox64</p>
</li>
<li>
<p>Fix the <strong>Platform-Level Interrupt Controller</strong></p>
</li>
<li>
<p>Track down why <strong>RISC-V Exceptions</strong> aren‚Äôt dumped correctly</p>
</li>
<li>
<p>And plan for the upcoming <strong>Initial RAM Disk</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/ox64-sbc.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="begin-with-star64-nuttx"><a href="#begin-with-star64-nuttx">1 Begin with Star64 NuttX</a></h1>
<p><em>We‚Äôre booting Star64 NuttX on Ox64? Unmodified?!</em></p>
<p>Yeah it feels like we‚Äôre Shredding a Toaster inside a Blender (with plenty of Smoke and Noise)‚Ä¶</p>
<p>But we‚Äôre starting with <a href="https://lupyuen.github.io/articles/nuttx2"><strong>NuttX for Star64 JH7110</strong></a> anyway! That‚Äôs because we have a very strong hunch (or just plainly stubborn) that NuttX will boot well <strong>across RISC-V SoCs</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/nuttx2">(We ported <strong>NuttX QEMU to Star64</strong> in only a few weeks!)</a></p>
<p><em>But Star64 runs on SiFive Cores. Ox64 uses T-Head Cores!</em></p>
<p>If RISC-V ain‚Äôt RISC-V on SiFive vs T-Head: We‚Äôll find out!</p>
<p>This is how we download and build <a href="https://lupyuen.github.io/articles/nuttx2"><strong>NuttX for Star64 JH7110</strong></a> RISC-V SBC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download WIP NuttX Source Code
git clone \
  --branch ox64 \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch ox64 \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Build NuttX for Star64
cd nuttx
tools/configure.sh star64:nsh
make

## Dump the RISC-V Disassembly for NuttX Kernel
riscv64-unknown-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu">(And enable <strong>Scheduler Info Output</strong>)</a></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot">(Remember to flash <strong>OpenSBI and U-Boot Bootloader</strong>)</a></p>
<p>Then we do the <a href="https://lupyuen.github.io/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Overwrite the microSD Linux Image by the <strong>NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Export the NuttX Binary Image
## to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Overwrite the Linux Image
## on Ox64 microSD
cp nuttx.bin \
  &quot;/Volumes/NO NAME/Image&quot;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <a href="https://lupyuen.github.io/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
<p>Ox64 boots <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI</strong></a>, which starts <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>, which starts <strong>NuttX Kernel</strong>.</p>
<p>And we see‚Ä¶ Absolutely Nothing!</p>
<div class="example-wrap"><pre class="language-text"><code>Retrieving file: /extlinux/../Image
  append: root=PARTLABEL=rootfs rootwait rw rootfstype=ext4 console=ttyS0,2000000 loglevel=8 earlycon=sbi
Retrieving file: /extlinux/../bl808-pine64-ox64.dtb
  Flattened Device Tree blob at 51ff8000
  Booting using the fdt blob at 0x51ff8000
  Working FDT set to 51ff8000
  Loading Device Tree to 0000000053f22000, end 0000000053f25fab ... OK
  Working FDT set to 53f22000
Starting kernel...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8134f17502db733ce87d6fa8b00eab55#file-ox64-nuttx-log-L104-L114">(See the <strong>Complete Log</strong>)</a></p>
<p><em>Shouldn‚Äôt we see a Crash Dump?</em></p>
<p>Yeah we‚Äôre hoping that NuttX would crash and <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI (Supervisor Binary Interface)</strong></a> could dump a meaningful Stack Trace. But nope!</p>
<ul>
<li>
<p>We <a href="https://lupyuen.github.io/articles/ox2#appendix-uart-driver-for-ox64"><strong>haven‚Äôt configured NuttX</strong></a> for Ox64 UART and‚Ä¶</p>
</li>
<li>
<p>NuttX is probably stuck in a loop <a href="https://lupyuen.github.io/articles/plic#serial-output-in-nuttx-qemu"><strong>waiting for Star64 UART</strong></a></p>
</li>
</ul>
<p>Is NuttX alive? We can check‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox64-nuttx.png" alt="Apache NuttX RTOS boots a tiny bit on Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="print-to-serial-console"><a href="#print-to-serial-console">2 Print to Serial Console</a></h1>
<p><em>We have a strong hunch that NuttX is actually booting on Ox64‚Ä¶ How to prove it?</em></p>
<p>We‚Äôll print something in the <strong>NuttX Boot Code</strong>. Which is in <strong>RISC-V Assembly</strong>!</p>
<p>Ox64‚Äôs BL808 UART looks super familiar. When we compare these UARTs‚Ä¶</p>
<ul>
<li>
<p><strong>BL808 UART Controller</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>BL808 Reference Manual</strong>, Page 402)</a></p>
</li>
<li>
<p><strong>BL602 UART Controller</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf">(<strong>BL602 Reference Manual</strong>, Page 126)</a></p>
</li>
</ul>
<p>We discover that BL808 UART works the <strong>same way as BL602</strong>!</p>
<p>Thus we seek guidance from the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c#L704-L725"><strong>NuttX Driver for BL602 UART</strong></a>.</p>
<p><em>Thanks! But how do we print to BL808 UART?</em></p>
<p><strong>BL602 UART Driver</strong> prints to the Serial Console like so: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c#L704-L725">bl602_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Output FIFO Offset is 0x88
#define BL602_UART_FIFO_WDATA_OFFSET 0x000088
#define BL602_UART_FIFO_WDATA(n) (BL602_UART_BASE(n) + BL602_UART_FIFO_WDATA_OFFSET)

// Write a character to UART
void bl602_send(struct uart_dev_s *dev, int ch) {
  ...
  // Wait for FIFO to be empty
  while ((getreg32(BL602_UART_FIFO_CONFIG_1(uart_idx)) &amp; \
    UART_FIFO_CONFIG_1_TX_CNT_MASK) == 0);

  // Write character to Output FIFO
  putreg32(ch, BL602_UART_FIFO_WDATA(uart_idx));
}
</code></pre></div>
<p>For BL808: We do the same. We simply write the character to‚Ä¶</p>
<ul>
<li>
<p><strong>UART3 Base Address: <code>0x3000</code> <code>2000</code></strong></p>
<p><a href="https://lupyuen.github.io/articles/ox64#appendix-linux-device-tree">(From the <strong>Linux Device Tree</strong>)</a></p>
</li>
<li>
<p><strong>Output FIFO Offset: <code>0x88</code></strong></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/hardware/bl602_uart.h#L38-L58">(From above <strong>FIFO_WDATA_OFFSET</strong>)</a></p>
</li>
</ul>
<p>Based on our <a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console"><strong>Star64 Debug Code</strong></a>, we write this in <strong>RISC-V Assembly</strong> to print ‚Äú<strong><code>123</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load UART3 Base Address to Register t0 */
li  t0, 0x30002000

/* Load `1` to Register t1 */
li  t1, 0x31
/* Store byte from Register t1 to UART3 Base Address, Offset 0x88 */
sb  t1, 0x88(t0)

/* Load `2` to Register t1 */
li  t1, 0x32
/* Store byte from Register t1 to UART3 Base Address, Offset 0x88 */
sb  t1, 0x88(t0)

/* Load `3` to Register t1 */
li  t1, 0x33
/* Store byte from Register t1 to UART3 Base Address, Offset 0x88 */
sb  t1, 0x88(t0)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#other-instructions">(<strong><code>li</code></strong> loads a Value into a Register)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--load-and-store-instructions">(<strong><code>sb</code></strong> stores a byte from a Register into an Address Offset)</a></p>
<p>We insert the code above into our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_head.S#L69-L87"><strong>NuttX Boot Code:</strong> jh7110_head.S</a></p>
<p>And we see (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel...
123
</code></pre></div>
<p>Our hunch is 100% correct, <strong>NuttX is ALIVE on Ox64</strong> yay!</p>
<p><a href="https://gist.github.com/lupyuen/1f895c9d57cb4e7294522ce27fea70fb#file-ox64-nuttx2-log-L112-L115">(See the <strong>Complete Log</strong>)</a></p>
<p><em>Anything else we changed in the NuttX Boot Code?</em></p>
<p>OpenSBI boots on Ox64 with <a href="https://gist.github.com/lupyuen/1f895c9d57cb4e7294522ce27fea70fb#file-ox64-nuttx2-log-L57"><strong>Hart ID 0</strong></a> (instead of 1). Which means we remove this adjustment for Hart ID: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_head.S#L89-L93">jh7110_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* We assume that OpenSBI has passed Hart ID (value 1) in Register a0.
 * But NuttX expects Hart ID to start at 0, so we subtract 1.
 * Previously: addi a0, a0, -1 */
</code></pre></div><h1 id="update-the-boot-address"><a href="#update-the-boot-address">3 Update the Boot Address</a></h1>
<p><em>Surely Ox64 boots at a different RAM Address from Star64?</em></p>
<p>Yep! Next we fix the <strong>NuttX Boot Address</strong> for Ox64.</p>
<p>From the <a href="https://gist.github.com/lupyuen/30df5a965fabf719cc52bf733e945db7#file-ox64-uboot-log-L193-L220"><strong>U-Boot Bootloader</strong></a> we see that Ox64 boots Linux at this address‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ printenv
kernel_addr_r=0x50200000
</code></pre></div>
<p>Based on the Boot Address, we define these <strong>Memory Regions</strong> for NuttX‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Memory Region</th><th style="text-align: center">Start Address</th><th style="text-align: left">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_mm_init.c#L46-L51"><strong>I/O Region</strong></a></td><td style="text-align: center"><strong><code>0x0000</code> <code>0000</code></strong></td><td style="text-align: left"><strong><code>0x5000</code> <code>0000</code></strong></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L23"><strong>Kernel Code</strong></a></td><td style="text-align: center"><strong><code>0x5020</code> <code>0000</code></strong></td><td style="text-align: left">2 MB</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L24"><strong>Kernel Data</strong></a></td><td style="text-align: center"><strong><code>0x5040</code> <code>0000</code></strong></td><td style="text-align: left">2 MB</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L25"><strong>Page Pool</strong></a></td><td style="text-align: center"><strong><code>0x5060</code> <code>0000</code></strong></td><td style="text-align: left">4 MB</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L26"><strong>RAM Disk</strong></a></td><td style="text-align: center"><strong><code>0x5060</code> <code>0000</code></strong></td><td style="text-align: left">16 MB</td></tr>
</tbody></table>
</div>
<p>(<strong>Page Pool</strong> will be used by NuttX Apps)</p>
<p>(<strong>RAM Disk</strong> will contain the NuttX Shell and Apps)</p>
<p>We update the Memory Regions in the <strong>NuttX Linker Script</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L20-L27">ld.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY
{
  kflash (rx) :   ORIGIN = 0x50200000, LENGTH = 2048K /* w/ cache */
  ksram (rwx) :   ORIGIN = 0x50400000, LENGTH = 2048K /* w/ cache */
  pgram (rwx) :   ORIGIN = 0x50600000, LENGTH = 4096K /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x50A00000, LENGTH = 16M   /* w/ cache */
} /* TODO: Use up the entire 64 MB RAM */
</code></pre></div>
<p>We make the same changes to the <strong>NuttX Build Configuration</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/configs/nsh/defconfig#L31-L77">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_START=0x50200000
CONFIG_RAM_SIZE=1048576
CONFIG_ARCH_PGPOOL_PBASE=0x50600000
CONFIG_ARCH_PGPOOL_VBASE=0x50600000
CONFIG_ARCH_PGPOOL_SIZE=4194304
</code></pre></div>
<p>And we update the <strong>NuttX Memory Map</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ba093f2477f011ec7c5351eaba0a3002add02d6b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L47-L50">jh7110_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Map the whole I/O Memory
// with Virtual Address = Physical Address
#define MMU_IO_BASE (0x00000000)
#define MMU_IO_SIZE (0x50000000)
</code></pre></div>
<p><em>What‚Äôs this Memory Map?</em></p>
<p>Inside the BL808 SoC is the <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:sv39"><strong>Sv39 Memory Management Unit (MMU)</strong></a>. (Same for Star64 JH7110)</p>
<p>The MMU maps <strong>Virtual Memory Addresses</strong> to <strong>Physical Memory Addresses</strong>. And stops the NuttX Kernel from accessing Invalid Addresses.</p>
<p>At startup, NuttX configures the MMU with the <strong>Memory Map</strong>, the Range of Memory Addresses that the NuttX Kernel is allowed to access.</p>
<p>The code above says that NuttX is allowed to access any address from <strong><code>0x0000</code> <code>0000</code></strong> to <strong><code>0x5000</code> <code>0000</code></strong>. (Because of Memory-Mapped I/O)</p>
<p>Time to make NuttX talk‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-memory-map-for-ox64">(More about <strong>Memory Map</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/ox64-stack.png" alt="NuttX prints our very first Stack Dump on Ox64 yay!" /></p>
<h1 id="fix-the-uart-driver"><a href="#fix-the-uart-driver">4 Fix the UART Driver</a></h1>
<p><em>NuttX on Ox64 has been awfully quiet‚Ä¶</em></p>
<p><em>How to fix the UART Driver so that NuttX can print things?</em></p>
<p>NuttX is still running the JH7110 UART Driver (16550).</p>
<p>To print to the Ox64 Serial Console, we make a quick patch to the <strong>NuttX UART Driver</strong>.</p>
<p>For now, we hardcode the <strong>UART3 Base Address</strong> (from above) and Output FIFO Offset: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L1698-L1716">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Write one character to the UART
void u16550_putc(FAR struct u16550_s *priv, int ch) {

  // Hardcode the UART3 Base Address and Output FIFO Offset
  *(volatile uint8_t *) 0x30002088 = ch;

  // Previously:
  // while ((u16550_serialin(priv, UART_LSR_OFFSET) &amp; UART_LSR_THRE) == 0);
  // u16550_serialout(priv, UART_THR_OFFSET, (uart_datawidth_t)ch);
}
</code></pre></div>
<p>(Yeah the UART Buffer might overflow, we‚Äôll fix later)</p>
<p><strong>For Other UART Registers</strong>: We skip the reading and writing of the registers, because we‚Äôll patch them later: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L604-L632">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Read from UART Register
uart_datawidth_t u16550_serialin(FAR struct u16550_s *priv, int offset) {
  return 0;
  // Commented out the rest
}

// Write to UART Register
void u16550_serialout(FAR struct u16550_s *priv, int offset, uart_datawidth_t value) {
  // Commented out the rest
}
</code></pre></div>
<p>And we won‚Äôt wait for <strong>UART Ready</strong>, since we don‚Äôt access the Line Control Register: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L633-L670">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Wait until UART is not busy. This is needed before writing to Line Control Register.
// Otherwise we will get spurious interrupts on Synopsys DesignWare 8250.
int u16550_wait(FAR struct u16550_s *priv) {
  // Nopez! No waiting for now
  return OK;
}
</code></pre></div>
<p>After these fixes, NuttX prints our very first <strong>Crash Dump</strong> on Ox64 yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel...
123ABC
riscv_exception: 
  EXCEPTION: Load access fault
  MCAUSE: 5
  EPC:    50208086
  MTVAL:  0c002104
riscv_exception: PANIC!!! Exception = 0000000000000005
_assert: Current Version: NuttX  12.0.3 93a92a7-dirty Nov  5 2023 11:27:46 risc-v
_assert: Assertion failed panic: at file: common/riscv_exception.c:85 task: Idle_Task process: Kernel 0x50200e28
up_dump_register: EPC: 0000000050208086
up_dump_register: A0: 000000000c002104 A1: ffffffffffffffff A2: 0000000000000001 A3: 0000000000000003
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/36b8c47abc2632063ca5cdebb958e3e8#file-ox64-nuttx3-log-L111-L149">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-trap-value-register-mtval"><strong>MTVAL (Machine Trap Value)</strong></a> says that NuttX has crashed while reading the <strong>Invalid Data Address <code>0x0C00</code> <code>2104</code></strong>. (Hence the ‚ÄúLoad Access Fault‚Äù)</p>
<p>Why is Data Address <strong><code>0x0C00</code> <code>2104</code></strong> causing unhappiness? First we learn about RISC-V Interrupts‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/plic-title.jpg" alt="Platform-Level Interrupt Controller for Star64 JH7110" /></p>
<p><a href="https://lupyuen.github.io/articles/plic"><em>Platform-Level Interrupt Controller for Star64 JH7110</em></a></p>
<h1 id="platform-level-interrupt-controller"><a href="#platform-level-interrupt-controller">5 Platform-Level Interrupt Controller</a></h1>
<p><em>What‚Äôs this Platform-Level Interrupt Controller?</em></p>
<p>Inside our BL808 SoC, the <a href="https://lupyuen.github.io/articles/plic"><strong>Platform-Level Interrupt Controller (PLIC)</strong></a> is the hardware that receives <strong>External Interrupts</strong> and forwards them to our RISC-V CPU.</p>
<p>(Like for <strong>UART Interrupts</strong>, pic above)</p>
<p>Earlier we saw NuttX crashing with this <strong>RISC-V Exception</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>EXCEPTION: Load access fault
MCAUSE: 5
EPC:    50208086
MTVAL:  0c002104
</code></pre></div>
<p>This says that NuttX crashed when it tried to access Invalid Data Address <strong><code>0x0C00</code> <code>2104</code></strong> from Code Address <strong><code>0x5020</code> <code>8086</code></strong>.</p>
<p>We look up Code Address <strong><code>0x5020</code> <code>8086</code></strong> in our <strong>RISC-V Disassembly for NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/common/riscv_modifyreg32.c:52
  regval  = getreg32(addr);
    50208086: 2701  sext.w a4,a4
</code></pre></div>
<p>Which points to this: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_modifyreg32.c#L38-L57">riscv_modifyreg32.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Atomically modify the specified bits
// in a Memory-Mapped Register
void modifyreg32(uintptr_t addr, uint32_t clearbits, uint32_t setbits) {
  irqstate_t flags = spin_lock_irqsave(NULL);
  // Crashes here because `addr` is invalid...
  uint32_t regval = getreg32(addr);
  regval &amp;= ~clearbits;
  regval |= setbits;
  putreg32(regval, addr);
  spin_unlock_irqrestore(NULL, flags);
}
</code></pre></div>
<p>Hence NuttX tried to modify a <strong>Memory-Mapped Register</strong> that doesn‚Äôt exist, and crashed.</p>
<p><em>But what Memory-Mapped Register?</em></p>
<p>The offending Data Address <strong><code>0x0C00</code> <code>2104</code></strong> actually comes from the <strong>Star64 PLIC</strong>! (Platform-Level Interrupt Controller)</p>
<div class="example-wrap"><pre class="language-c"><code>// Star64 PLIC Base Address
// From https://github.com/apache/nuttx/blob/master/arch/risc-v/src/jh7110/hardware/jh7110_memorymap.h#L30
#define JH7110_PLIC_BASE 0x0c000000

// Star64 S-Mode Interrupt Enable
// From https://github.com/apache/nuttx/blob/master/arch/risc-v/src/jh7110/hardware/jh7110_plic.h#L34-L49
#define JH7110_PLIC_ENABLE2 (JH7110_PLIC_BASE + 0x002104)
</code></pre></div>
<p>PLIC for Ox64 is in a different place, let‚Äôs change it.</p>
<p><em>What‚Äôs the PLIC Base Address for Ox64?</em></p>
<p>For Ox64, PLIC Base Address is <strong><code>0xE000</code> <code>0000</code></strong>, according to the Linux Device Tree: <a href="https://github.com/lupyuen/nuttx-ox64/blob/main/bl808-pine64-ox64.dts#L129-L138">bl808-pine64-ox64.dts</a></p>
<div class="example-wrap"><pre class="language-text"><code>interrupt-controller@e0000000 {
  compatible = &quot;thead,c900-plic&quot;;
  reg = &lt;0xe0000000 0x4000000&gt;;
  interrupts-extended = &lt;0x06 0xffffffff 0x06 0x09&gt;;
  interrupt-controller;
  #address-cells = &lt;0x00&gt;;
  #interrupt-cells = &lt;0x02&gt;;
  riscv,ndev = &lt;0x40&gt;;
  phandle = &lt;0x01&gt;;
};
</code></pre></div>
<p>Based on the above, we change the <strong>PLIC Base Address</strong> for Ox64: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/hardware/jh7110_memorymap.h#L30">jh7110_memorymap.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define JH7110_PLIC_BASE 0xe0000000
</code></pre></div>
<p><a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">(PLIC Offsets are in <strong>XuanTie OpenC906 User Manual</strong>, Page 77)</a></p>
<p>NuttX now crashes at a different place, with IRQ 15 (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>123ABC
nx_start: Entry
up_irqinitialize: a, b, c
riscv_dispatch_irq: irq=15
irq_unexpected_isr: ERROR irq: 15
_assert: Current Version: NuttX  12.0.3 910bfca-dirty Nov  6 2023 15:23:11 risc-v
_assert: Assertion failed panic: at file: irq/irq_unexpectedisr.c:54 task: Idle_Task process: Kernel 0x50200e50
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/11b8d4221a150f10afa3aa5ab5e50a4c#file-ox64-nuttx4-log-L111-L121">(See the <strong>Complete Log</strong>)</a></p>
<p>But there‚Äôs something exceptional about IRQ 15‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox2-irq.png" alt="NuttX crashes with IRQ 15" /></p>
<h1 id="handle-risc-v-exceptions"><a href="#handle-risc-v-exceptions">6 Handle RISC-V Exceptions</a></h1>
<p><em>What is IRQ 15? Who‚Äôs causing it? (Pic above)</em></p>
<p>From the <a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf"><strong>XuanTie OpenC906 User Manual</strong></a> (Page 21)‚Ä¶</p>
<blockquote>
<p>‚Äú<strong>Exception Vector ID 15:</strong> A Store / Atomic Instruction page error exception‚Äù</p>
</blockquote>
<p>This says that NuttX tried to write to an <strong>Invalid Data Address</strong>.</p>
<p>And it failed due to an ‚ÄúUnexpected Interrupt‚Äù.</p>
<p><em>Something special about IRQ 15?</em></p>
<p>IRQ 15 is actually a <strong>RISC-V Exception</strong>!</p>
<p>Rightfully, NuttX should print a helpful <strong>RISC-V Exception Crash Dump</strong> with the offending Data Address. <a href="https://lupyuen.github.io/articles/ox2#fix-the-uart-driver">(Like this)</a></p>
<p>But NuttX wasn‚Äôt terribly helpful for this RISC-V Exception. Very odd!</p>
<p><em>Where did it crash?</em></p>
<p>Based on our <a href="https://gist.github.com/lupyuen/11b8d4221a150f10afa3aa5ab5e50a4c#file-ox64-nuttx4-log-L111-L121"><strong>Debug Log</strong></a>, NuttX crashes right just setting the PLIC: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/8f318c363c80e1d4f5788f3815009cb57b5ff298/arch/risc-v/src/jh7110/jh7110_irq.c#L42-L85">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the Interrupts
void up_irqinitialize(void) {
  ...
  // Disable S-Mode Interrupts
  _info(&quot;b\n&quot;);
  up_irq_save();

  // Disable all Global Interrupts
  _info(&quot;c\n&quot;);
  // Crashes here!
  putreg32(0x0, JH7110_PLIC_ENABLE1);
  putreg32(0x0, JH7110_PLIC_ENABLE2);
  ...
  // Attach the RISC-V Exception Handlers
  _info(&quot;f\n&quot;);
  riscv_exception_attach();
</code></pre></div>
<p><em>Something doesn‚Äôt look right‚Ä¶</em></p>
<p>Yeah in the code above, we attach the RISC-V Exception Handlers (<strong>riscv_exception_attach</strong>)‚Ä¶</p>
<p>After the code has crashed! (<strong>putreg32</strong>)</p>
<p>Hence we <strong>attach the Exception Handlers</strong> earlier: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_irq.c#L42-L85">jh7110_irq.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the Interrupts
void up_irqinitialize(void) {
  ...
  // Disable S-Mode Interrupts
  _info(&quot;b\n&quot;);
  up_irq_save();

  // Moved Here: Attach the RISC-V Exception Handlers
  _info(&quot;f\n&quot;);
  riscv_exception_attach();

  // Disable all Global Interrupts
  _info(&quot;c\n&quot;);
  // Crashes here!
  putreg32(0x0, JH7110_PLIC_ENABLE1);
  putreg32(0x0, JH7110_PLIC_ENABLE2);
</code></pre></div>
<p>Then <strong>riscv_exception_attach</strong> will handle all RISC-V Exceptions correctly, including IRQ 15: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_exception.c#L89-L142">riscv_exception.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Attach the RISC-V Exception Handlers
void riscv_exception_attach(void) {
  ...
  // IRQ 15: Store / AMO Page Fault
  irq_attach(RISCV_IRQ_STOREPF, riscv_exception, NULL);
</code></pre></div>
<p><em>Does it work?</em></p>
<p>Yep we see the <strong>Store / AMO Page Fault Exception</strong>! (Pic below)</p>
<div class="example-wrap"><pre class="language-text"><code>up_irqinitialize: c
riscv_dispatch_irq: irq=15
riscv_exception: 
EXCEPTION: Store/AMO page fault
MCAUSE: f
EPC:    50207e6a
MTVAL:  e0002100
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/85db0510712ba8c660e10f922d4564c9#file-ox64-nuttx5-log-L136-L161">(See the <strong>Complete Log</strong>)</a></p>
<p>When we look up the NuttX Kernel Disassembly, the Exception Code Address <strong><code>0x5020</code> <code>7E6A</code></strong> (EPC) comes from our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_irq.c#L58-L64"><strong>PLIC Code</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/jh7110_irq.c:62
  putreg32(0x0, JH7110_PLIC_ENABLE1);
    50207e64: 700017b7  lui  a5,0x70001
    50207e68: 0786      slli a5,a5,0x1
    50207e6a: 1007a023  sw   zero,256(a5) # 70001100 &lt;__ramdisk_end+0x1e601100&gt;
</code></pre></div>
<p>The offending Data Address (MTVAL) is <strong><code>0xE000</code> <code>2100</code></strong>.</p>
<p>Which is our <strong>Ox64 PLIC</strong>! We scrutinise PLIC again‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox2-exception.png" alt="Store / AMO Page Fault Exception" /></p>
<h1 id="add-plic-to-memory-map"><a href="#add-plic-to-memory-map">7 Add PLIC to Memory Map</a></h1>
<p><em>But is 0xE000 2100 accessible?</em></p>
<p>Ah we forgot to add the Platform-Level Interrupt Controller (PLIC) to the <strong>Memory Map</strong>. This is how we fix it: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/b244f85065ecc749599842088f35f1b190466429/arch/risc-v/src/jh7110/jh7110_mm_init.c#L47-L50">jh7110_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Map the whole I/O Memory
// with Virtual Address = Physical Address
// (Includes PLIC)
#define MMU_IO_BASE (0x00000000)
#define MMU_IO_SIZE (0xf0000000)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-memory-map-for-ox64">(<strong>Memory Map</strong> doesn‚Äôt look right)</a></p>
<p>NuttX boots even further. And tries to register IRQ 57 for the <strong>Star64 UART Interrupt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>up_irqinitialize: c, d, e, g
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
irq_attach: irq=57
up_enable_irq: irq=57
riscv_exception: 
EXCEPTION: Load access fault
MCAUSE: 5
EPC:    50208342
MTVAL:  e0002104
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ade5ff1433812fb675ff06f805f7339f#file-ox64-nuttx6-log-L135-L181">(See the <strong>Complete Log</strong>)</a></p>
<p>But it crashes while accessing the PLIC at another <strong>Invalid Data Address: <code>0xE000</code> <code>2104</code></strong>. (Sigh)</p>
<p><em>Ack! Enough with the PLIC already‚Ä¶</em></p>
<p>Yeah we‚Äôll fix PLIC later. The entire <a href="https://lupyuen.github.io/articles/ox2#appendix-uart-driver-for-ox64"><strong>UART Driver will be revamped</strong></a> anyway, including the UART Interrupt.</p>
<p>For now, we <strong>disable the UART Interrupt</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L902-L958">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Attach the UART Interrupt for Star64
int u16550_attach(struct uart_dev_s *dev) {
  // Don&#39;t attach the interrupt
  // Previously:
  // ret = irq_attach(priv-&gt;irq, u16550_interrupt, dev);

  // Don&#39;t enable the interrupt
  // Previously:
  // up_enable_irq(priv-&gt;irq);
</code></pre></div>
<p>NuttX hits another roadblock‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/semihost-title.jpg" alt="Initial RAM Disk for Star64 JH7110" /></p>
<p><a href="https://lupyuen.github.io/articles/semihost"><em>Initial RAM Disk for Star64 JH7110</em></a></p>
<h1 id="initial-ram-disk-is-missing"><a href="#initial-ram-disk-is-missing">8 Initial RAM Disk is Missing</a></h1>
<p><em>We disabled the UART Interrupts. What happens now?</em></p>
<p>NuttX boots much further, but crashes in the <strong>NuttX Bringup</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>up_irqinitialize: c, d, e, g
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
_assert: Current Version: NuttX  12.0.3 b244f85-dirty Nov  6 2023 17:35:34 risc-v
_assert: Assertion failed ret &gt;= 0: at file: init/nx_bringup.c:283 task: AppBringUp process: Kernel 0x5020107e
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ab640bcb3ba3a19834bcaa29e43baddf#file-ox64-nuttx7-log-L136-L177">(See the <strong>Complete Log</strong>)</a></p>
<p>That‚Äôs because NuttX couldn‚Äôt mount the <strong>Initial RAM Disk</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_bringup.c#L276-L284">nx_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Mount the File System containing
// the NuttX Shell (NSH)
ret = nx_mount(CONFIG_INIT_MOUNT_SOURCE, CONFIG_INIT_MOUNT_TARGET,
  CONFIG_INIT_MOUNT_FSTYPE, CONFIG_INIT_MOUNT_FLAGS,
  CONFIG_INIT_MOUNT_DATA);

// Fails here
DEBUGASSERT(ret &gt;= 0);
</code></pre></div>
<p>That contains the Executable Binaries for <strong>NuttX Shell</strong> (NSH) and the NuttX Apps.</p>
<p><a href="https://lupyuen.github.io/articles/semihost">(More about <strong>Initial RAM Disk</strong>)</a></p>
<p><em>Why is the Initial RAM Disk missing?</em></p>
<p>That‚Äôs because we <strong>haven‚Äôt loaded the Initial RAM Disk</strong> into RAM!</p>
<p>We‚Äôll modify the NuttX Kernel Image (or U-Boot Script) on the microSD Card, so that U-Boot Bootloader will load our Initial RAM Disk before starting NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-initial-ram-disk">(Upcoming work for <strong>Initial RAM Disk</strong>)</a></p>
<p><em>Are we done yet?</em></p>
<p>That‚Äôs all for today! NuttX has booted so much code on Ox64. Here‚Äôs the flow of the <strong>NuttX Code that boots on Ox64</strong> (pic below)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow"><strong>‚ÄúNuttX Boot Flow‚Äù</strong></a></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#nuttx-boot-flow-for-ox64-bl808">(See the <strong>Clickable Diagram</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/ox2-flow.jpg" alt="NuttX Boot Flow for Ox64 BL808" /></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#nuttx-boot-flow-for-ox64-bl808"><em>Clickable Version of NuttX Boot Flow</em></a></p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO: This week we made plenty of progress starting <strong>Apache NuttX RTOS</strong> on the tiny <strong>Ox64 BL808 RISC-V SBC</strong>‚Ä¶</p>
<p>We booted NuttX on Ox64 BL808 RISC-V SBC through sheer tenacity or desperation or lots of luck</p>
<p>We‚Äôll do much more for <strong>NuttX on Ox64 BL808</strong>, stay tuned for updates!</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-memory-map-for-ox64"><strong>‚ÄúMemory Map for Ox64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-uart-driver-for-ox64"><strong>‚ÄúUART Driver for Ox64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-initial-ram-disk"><strong>‚ÄúInitial RAM Disk‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/ox2.md"><strong>lupyuen.github.io/src/ox2.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="My soldering of Ox64 BL808 looks horrigible‚Ä¶ But it boots NuttX!" /></p>
<p><em>My soldering of Ox64 BL808 looks horrigible‚Ä¶ But it boots NuttX!</em></p>
<h1 id="appendix-nuttx-boot-flow"><a href="#appendix-nuttx-boot-flow">10 Appendix: NuttX Boot Flow</a></h1>
<p><em>What happens exactly when NuttX boots on Ox64?</em></p>
<p>In this article, NuttX has booted plenty of code on Ox64. Here‚Äôs the flow of the <strong>NuttX Code that boots on Ox64</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox2-flow.jpg" alt="NuttX Boot Flow for Ox64 BL808" /></p>
<p><a href="https://github.com/lupyuen/nuttx-ox64#nuttx-boot-flow-for-ox64-bl808"><em>Clickable Version of NuttX Boot Flow</em></a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_head.S#L41-L156"><strong>NuttX Boot Code: jh7110_head</strong></a> prints ‚Äú123‚Äù and calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_start.c#L129-L159"><strong>NuttX Start Code: jh7110_start</strong></a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_start.c#L82-L129"><strong>Start Supervisor Mode: jh7110_start_s</strong></a> which prints ‚ÄúABC‚Äù and calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_start.c#L159-L164"><strong>Early Serial Init: riscv_earlyserialinit</strong></a> (see below) and‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_mm_init.c#L259-L284"><strong>Memory Mgmt Init: jh7110_mm_init</strong></a> (to map the Memory Mgmt Unit) and‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_start.c#L298-L713"><strong>Start NuttX: nx_start</strong></a> (see below)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_start.c#L159-L164"><strong>Early Serial Init: riscv_earlyserialinit</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L1722-L1747"><strong>UART Early Init: u16550_earlyserialinit</strong></a></p>
<p>(To setup the UART)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_start.c#L298-L713"><strong>Start NuttX: nx_start</strong></a> does <a href="https://lupyuen.github.io/articles/unicorn2#after-primary-routine"><strong>many things</strong></a> and calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_irq.c#L41C1-L103"><strong>IRQ Init: up_irqinitialize</strong></a> (see below) and‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_bringup.c#L373-L462"><strong>Bringup NuttX: nx_bringup</strong></a> (see below)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_irq.c#L41C1-L103"><strong>IRQ Init: up_irqinitialize</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_exception.c#L89-L142"><strong>Attach RISC-V Exceptions: riscv_exception_attach</strong></a> (to attach the RISC-V Exception Handlers) and‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_initialize.c#L70-L132"><strong>Init NuttX: up_initialize</strong></a> (see below)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/common/riscv_initialize.c#L70-L132"><strong>Init NuttX: up_initialize</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_start.c#L164-L168"><strong>Serial Init: riscv_serialinit</strong></a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/drivers/serial/uart_16550.c#L1747-L1775"><strong>UART Init: u16550_serialinit</strong></a></p>
<p>(To register ‚Äú/dev/console‚Äù and ‚Äú/dev/ttyS0‚Äù)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_bringup.c#L373-L462"><strong>Bringup NuttX: nx_bringup</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_bringup.c#L330-L369"><strong>Create Init Thread: nx_create_initthread</strong></a> (to create ‚ÄúAppBringUp‚Äù thread) which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/sched/init/nx_bringup.c#L212-L304"><strong>Start Application: nx_start_application</strong></a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/fs/mount/fs_mount.c#L260-L514"><strong>Mount RAM Disk: nx_mount</strong></a></p>
<p>(Which fails because our Initial RAM Disk is missing)</p>
<p>(Which prevents NuttX Shell from starting)</p>
</li>
</ul>
<p>Therefore we expect NuttX to <strong>boot completely on Ox64</strong> when we‚Äôve implemented‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-initial-ram-disk"><strong>Initial RAM Disk</strong></a> for Ox64</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-uart-driver-for-ox64"><strong>UART Driver and UART Interrupts</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/ox2#appendix-memory-map-for-ox64"><strong>Memory Map</strong></a> might need fixing too</p>
</li>
</ul>
<h1 id="appendix-memory-map-for-ox64"><a href="#appendix-memory-map-for-ox64">11 Appendix: Memory Map for Ox64</a></h1>
<p><em>What‚Äôs this Memory Map?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Map the whole I/O Memory
// with Virtual Address = Physical Address
#define MMU_IO_BASE (0x00000000)
#define MMU_IO_SIZE (0x50000000)
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ba093f2477f011ec7c5351eaba0a3002add02d6b/arch/risc-v/src/jh7110/jh7110_mm_init.c#L47-L50">(Source)</a></p>
<p>Inside the BL808 SoC is the <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:sv39"><strong>Sv39 Memory Management Unit (MMU)</strong></a> with 128 / 256 / 512 TLB table entries. (Same for Star64 JH7110)</p>
<p>The MMU maps <strong>Virtual Memory Addresses</strong> to <strong>Physical Memory Addresses</strong>. And stops the NuttX Kernel from accessing Invalid Addresses.</p>
<p>At startup, NuttX configures the MMU with the <strong>Memory Map</strong>, the Range of Memory Addresses that the NuttX Kernel is allowed to access.</p>
<p>The code above says that NuttX is allowed to access any address from <strong><code>0x0000</code> <code>0000</code></strong> to <strong><code>0x5000</code> <code>0000</code></strong>. (Because of Memory-Mapped I/O)</p>
<p><a href="https://occ-intl-prod.oss-ap-southeast-1.aliyuncs.com/resource/XuanTie-OpenC906-UserManual.pdf">(MMU appears in <strong>OpenC906 User Manual</strong>, Page 50)</a></p>
<p><em>But we forgot to add the PLIC to the Memory Map!</em></p>
<p>The <a href="https://lupyuen.github.io/articles/ox2#platform-level-interrupt-controller"><strong>Platform-Level Interrupt Controller (PLIC)</strong></a> is at <a href="https://lupyuen.github.io/articles/ox2#platform-level-interrupt-controller"><strong><code>0xE000</code> <code>0000</code></strong></a>.</p>
<p>Let‚Äôs add the PLIC to the Memory Map: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/b244f85065ecc749599842088f35f1b190466429/arch/risc-v/src/jh7110/jh7110_mm_init.c#L47-L50">jh7110_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Map the whole I/O Memory
// with Virtual Address = Physical Address
// (Includes PLIC)
#define MMU_IO_BASE (0x00000000)
#define MMU_IO_SIZE (0xf0000000)
</code></pre></div>
<p><em>This doesn‚Äôt look right‚Ä¶</em></p>
<p>Yeah when we substitute the above <strong>MMU_IO_BASE</strong> and <strong>MMU_IO_SIZE</strong> into the <strong>Memory Map</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_mm_init.c#L212-L259">jh7110_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Set up the Kernel MMU Memory Map
void jh7110_kernel_mappings(void) {
  ...
  // Map I/O Region, use enough large page tables for the I/O region
  // MMU_IO_BASE is 0x00000000
  // MMU_IO_SIZE is 0xf0000000
  mmu_ln_map_region(1, PGT_L1_VBASE, MMU_IO_BASE, MMU_IO_BASE, MMU_IO_SIZE, MMU_IO_FLAGS);

  // Map the Kernel Code for L2/L3
  // From https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L20-L27
  // KFLASH_START is 0x50200000
  // KFLASH_SIZE  is 2 MB
  map_region(KFLASH_START, KFLASH_START, KFLASH_SIZE, MMU_KTEXT_FLAGS);

  // Map the Kernel Data for L2/L3
  // From https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L20-L27
  // KSRAM_START is 0x50400000
  // KSRAM_SIZE  is 2 MB
  map_region(KSRAM_START, KSRAM_START, KSRAM_SIZE, MMU_KDATA_FLAGS);

  // Connect the L1 and L2 page tables for the kernel text and data
  mmu_ln_setentry(1, PGT_L1_VBASE, PGT_L2_PBASE, KFLASH_START, PTE_G);

  // Map the Page Pool for NuttX Apps
  // From https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L20-L27
  // PGPOOL_START is 0x50600000
  // PGPOOL_SIZE  is 4 MB + 16 MB (including RAM Disk)
  mmu_ln_map_region(2, PGT_L2_VBASE, PGPOOL_START, PGPOOL_START, PGPOOL_SIZE, MMU_KDATA_FLAGS);
}
</code></pre></div>
<p>We see a problem with the <strong>Memory Map</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Memory Region</th><th style="text-align: center">Start Address</th><th style="text-align: left">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/arch/risc-v/src/jh7110/jh7110_mm_init.c#L46-L51"><strong>I/O Region</strong></a></td><td style="text-align: center"><strong><code>0x0000</code> <code>0000</code></strong></td><td style="text-align: left"><strong><code>0xF000</code> <code>0000</code></strong></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L23"><strong>Kernel Code</strong></a></td><td style="text-align: center"><strong><code>0x5020</code> <code>0000</code></strong></td><td style="text-align: left">2 MB</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L24"><strong>Kernel Data</strong></a></td><td style="text-align: center"><strong><code>0x5040</code> <code>0000</code></strong></td><td style="text-align: left">2 MB</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L25-L26"><strong>Page Pool</strong></a></td><td style="text-align: center"><strong><code>0x5060</code> <code>0000</code></strong></td><td style="text-align: left">20 MB</td></tr>
</tbody></table>
</div>
<p>(<strong>Page Pool</strong> includes RAM Disk)</p>
<p>The <strong>I/O Region overlaps</strong> with the Kernel Code, Data and Page Pool!</p>
<p>This happens because the PLIC is located at <a href="https://lupyuen.github.io/articles/ox2#platform-level-interrupt-controller"><strong><code>0xE000</code> <code>0000</code></strong></a>. Which is <strong>AFTER the RAM Region</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Memory Region</th><th style="text-align: center">Start Address</th><th style="text-align: left">Size</th></tr></thead><tbody>
<tr><td style="text-align: left">I/O Region</td><td style="text-align: center"><strong><code>0x0000</code> <code>0000</code></strong></td><td style="text-align: left"><strong><code>0x5000</code> <code>0000</code></strong></td></tr>
<tr><td style="text-align: left">RAM</td><td style="text-align: center"><strong><code>0x5000</code> <code>0000</code></strong></td><td style="text-align: left">64 MB</td></tr>
<tr><td style="text-align: left">PLIC</td><td style="text-align: center"><strong><code>0xE000</code> <code>0000</code></strong></td><td style="text-align: left">???</td></tr>
</tbody></table>
</div>
<p>Thus we might introduce another Memory Region, just to <strong>map the PLIC</strong>.</p>
<p>The <a href="https://gist.github.com/lupyuen/ab640bcb3ba3a19834bcaa29e43baddf#file-ox64-nuttx7-log-L52-L66"><strong>OpenSBI Log</strong></a> might offer some hints on the Memory Map‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Firmware Base       : 0x3ef80000
Firmware Size       : 200 KB
Domain0 Region00    : 0xe4008000-0xe400bfff (I)
Domain0 Region01    : 0xe4000000-0xe4007fff (I)
Domain0 Region02    : 0x3ef80000-0x3efbffff ()
Domain0 Region03    : 0x00000000-0xffffffffffffffff (R,W,X)
Domain0 Next Address: 0x50000000
Domain0 Next Arg1   : 0x51ff8000
</code></pre></div>
<p>(<strong><code>0x3EF8</code> <code>0000</code></strong> is probably protected because it contains the OpenSBI Firmware)</p>
<p><a href="https://github.com/riscv-software-src/opensbi/blob/master/docs/domain_support.md">(More about <strong>OpenSBI Domains</strong>)</a></p>
<p><strong>TODO:</strong> What is ‚Äú<strong><code>(I)</code></strong>‚Äù for Domain Permission?</p>
<h1 id="appendix-uart-driver-for-ox64"><a href="#appendix-uart-driver-for-ox64">12 Appendix: UART Driver for Ox64</a></h1>
<p><em>How will we create the NuttX UART Driver for Ox64 BL808?</em></p>
<p>Today NuttX supports the 32-bit predecessor of BL808: <a href="https://github.com/apache/nuttx/tree/master/arch/risc-v/src/bl602"><strong>Bouffalo Lab BL602</strong></a>.</p>
<p>When we compare these UARTs‚Ä¶</p>
<ul>
<li>
<p><strong>BL808 UART Controller</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<strong>BL808 Reference Manual</strong>, Page 402)</a></p>
</li>
<li>
<p><strong>BL602 UART Controller</strong></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf">(<strong>BL602 Reference Manual</strong>, Page 126)</a></p>
</li>
</ul>
<p>We discover that BL808 UART works the <strong>same way as BL602</strong>!</p>
<p>Thus we‚Äôll simply copy the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c"><strong>NuttX Driver for BL602 UART</strong></a> to Ox64.</p>
<p><strong>UART Interrupts</strong> are mandatory: If UART Interrupts aren‚Äôt implemented, NuttX Shell (NSH) and NuttX Apps <a href="https://lupyuen.github.io/articles/plic#serial-output-in-nuttx-qemu"><strong>won‚Äôt print anything</strong></a>.</p>
<p>BL602 UART Driver has just been <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64a/arch/risc-v/src/jh7110/bl602_serial.c"><strong>ported to Ox64</strong></a>! (Minus the UART Interrupts) Check the progress here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-ox64#nuttx-uart-driver-for-ox64-bl808"><strong>‚ÄúNuttX UART Driver for Ox64 BL808‚Äù</strong></a></li>
</ul>
<p><em>What about other drivers: BL808 vs BL602?</em></p>
<p>The controllers below look highly similar on BL808 vs BL602. Which means we have plenty of NuttX Drivers to <strong>copy from BL602 to BL808!</strong></p>
<div><table><thead><tr><th style="text-align: left">Controller</th><th style="text-align: center">BL808 RM</th><th style="text-align: center">BL602 RM</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c"><strong>I2C</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 430</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 142</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c"><strong>SPI</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 387</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 115</strong></a></td></tr>
<tr><td style="text-align: left"><strong>ADC</strong></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 169</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 45</strong></a></td></tr>
<tr><td style="text-align: left"><strong>DAC</strong></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 180</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 66</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_dma.c"><strong>DMA</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 187</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 70</strong></a></td></tr>
<tr><td style="text-align: left"><strong>Infrared</strong></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 372</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 100</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_pwm_lowerhalf.c"><strong>PWM</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 447</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 157</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_tim.c"><strong>Timer</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>Page 474</strong></a></td><td style="text-align: center"><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>Page 174</strong></a></td></tr>
</tbody></table>
</div>
<p>Our <a href="https://lupyuen.github.io/articles/book"><strong>earlier experiments with BL602 NuttX</strong></a> proved that the drivers above work well. So we‚Äôre all set for BL808!</p>
<p><a href="https://lupyuen.github.io/articles/auto">(BL602 NuttX is tested on <strong>Real Hardware</strong> every day)</a></p>
<p><a href="https://github.com/lupyuen/nuttx/tags">(Still <strong>going strong</strong>!)</a></p>
<p><em>What about the drivers missing from BL602 NuttX?</em></p>
<p>We‚Äôll port the missing BL808 Drivers from Bouffalo Lab‚Äôs <a href="https://github.com/bouffalolab/bouffalo_sdk"><strong>BouffaloSDK</strong></a> to NuttX.</p>
<p><a href="https://github.com/bouffalolab/bouffalo_sdk/blob/master/LICENSE">(BouffaloSDK is <strong>Apache 2.0 Licensed</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/semihost-title.jpg" alt="Initial RAM Disk for Star64 JH7110" /></p>
<p><a href="https://lupyuen.github.io/articles/semihost"><em>Initial RAM Disk for Star64 JH7110</em></a></p>
<h1 id="appendix-initial-ram-disk"><a href="#appendix-initial-ram-disk">13 Appendix: Initial RAM Disk</a></h1>
<p><em>What‚Äôs this Initial RAM Disk?</em></p>
<p>The <strong>Initial RAM Disk</strong> contains the Executable Binaries for <strong>NuttX Shell</strong> (NSH) and NuttX Apps.</p>
<p>At startup, NuttX loads the Initial RAM Disk into RAM and mounts the File System, so that the NuttX Shell (and NuttX Apps) can be started later.</p>
<p><a href="https://lupyuen.github.io/articles/semihost">(More about <strong>Initial RAM Disk</strong>)</a></p>
<p><em>Why is the Initial RAM Disk missing from Ox64?</em></p>
<p>That‚Äôs because we <strong>haven‚Äôt loaded the Initial RAM Disk</strong> into RAM!</p>
<p>Two ways we can load the Initial RAM Disk‚Ä¶</p>
<ol>
<li>
<p>Load the Initial RAM Disk from a <strong>Separate File: initrd</strong> (similar to Star64)</p>
<p>This means we need to modify the <a href="https://github.com/openbouffalo/buildroot_bouffalo/blob/main/board/pine64/ox64/boot-pine64.cmd"><strong>U-Boot Script: boot-pine64.scr</strong></a></p>
<p>And make it <a href="https://lupyuen.github.io/articles/semihost#appendix-boot-nuttx-over-tftp-with-initial-ram-disk"><strong>load the initrd</strong></a> file into RAM.</p>
<p>(Which is good for separating the NuttX Kernel and NuttX Apps)</p>
<p>OR‚Ä¶</p>
</li>
<li>
<p>Append the Initial RAM Disk to the <strong>NuttX Kernel Image</strong></p>
<p>So the U-Boot Bootloader will load (one-shot into RAM) the NuttX Kernel + Initial RAM Disk.</p>
<p>And we reuse the existing <strong>U-Boot Config</strong> on the microSD Card: <a href="https://github.com/openbouffalo/buildroot_bouffalo/blob/main/board/pine64/ox64/rootfs-overlay/boot/extlinux/extlinux.conf"><strong>extlinux/extlinux.conf</strong></a></p>
<p>(Which might be more efficient for our Limited RAM)</p>
<p><a href="https://github.com/openbouffalo/buildroot_bouffalo/wiki/U-Boot-Bootflow">(See the <strong>U-Boot Boot Flow</strong>)</a></p>
<p><strong>TODO:</strong> Can we mount the File System directly from the <strong>NuttX Kernel Image in RAM</strong>? Without copying to the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ox64/boards/risc-v/jh7110/star64/scripts/ld.script#L26"><strong>RAM Disk Memory Region</strong></a>?</p>
</li>
</ol>
<p>We‚Äôll probably adopt the Second Method, since we are low on RAM. Like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Export the NuttX Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Insert 32 KB of zeroes after NuttX Binary Image for Kernel Stack
head -c 32768 /dev/zero &gt;/tmp/nuttx.zero

## Append the Initial RAM Disk to the NuttX Binary Image
cat nuttx.bin /tmp/nuttx.zero initrd \
  &gt;Image

## Overwrite the Linux Image on Ox64 microSD
cp Image &quot;/Volumes/NO NAME/&quot;
</code></pre></div>
<p>Check out the progress here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-ox64#initial-ram-disk-for-ox64-bl808"><strong>‚ÄúInitial RAM Disk for Ox64 BL808‚Äù</strong></a></li>
</ul>

    
</body>
</html>