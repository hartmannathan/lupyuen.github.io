<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Emulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Emulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tinyemu2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/tinyemu2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Emulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#install-tinyemu-emulator">1 Install TinyEMU Emulator</a><ul></ul></li>
<li><a href="#change-risc-v-addresses-in-tinyemu">2 Change RISC-V Addresses in TinyEMU</a><ul></ul></li>
<li><a href="#run-tinyemu-emulator">3 Run TinyEMU Emulator</a><ul></ul></li>
<li><a href="#uart-registers-for-bl808-soc">4 UART Registers for BL808 SoC</a><ul></ul></li>
<li><a href="#intercept-uart-registers-for-ox64-bl808-emulator">5 Intercept UART Registers for Ox64 BL808 Emulator</a><ul></ul></li>
<li><a href="#nuttx-exception-in-ox64-bl808-emulator">6 NuttX Exception in Ox64 BL808 Emulator</a><ul></ul></li>
<li><a href="#emulate-ox64-bl808-in-web-browser">7 Emulate Ox64 BL808 in Web Browser</a><ul></ul></li>
<li><a href="#emulate-ox64-bl808-sbc-with-tinyemu">8 Emulate Ox64 BL808 SBC with TinyEMU</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>31 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-title.png" alt="Ox64 BL808 Emulator with TinyEMU RISC-V Emulator and Apache NuttX RTOS" /></p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><em>(Live Demo of Ox64 BL808 Emulator)</em></a></p>
<p>TODO: <a href="https://youtu.be/KYrdwzIsgeQ"><em>(Watch on YouTube)</em></a></p>
<p><em>In olden times we had Computer Games (plus Operating Systems) on 5.25-inch <strong>Floppy Disks</strong>. And we‚Äôd boot the Floppy Disks (clakety-clack) on <strong>Apple II Computers</strong> with 64 KB RAM.</em></p>
<p>Today (40 years later) we boot <strong>microSD Cards</strong> (clickety-click) on <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Ox64 BL808</strong></a> RISC-V Single-Board Computers with 64 MB RAM. (Pic below)</p>
<p><em>What if we could turn it into a</em> <a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><strong>Virtual Ox64 SBC</strong></a> <em>that boots in our</em> <a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><strong>Web Browser</strong></a>? <em>(Pic above) Exactly like an</em> <a href="https://www.scullinsteel.com/apple2/#dos33master"><strong>Emulated Apple II</strong></a>!</p>
<p>In this article we‚Ä¶</p>
<ul>
<li>
<p>Take <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> precompiled for Ox64</p>
<p>(Without any modifications!)</p>
</li>
<li>
<p>Boot it on the <a href="https://github.com/fernandotcl/TinyEMU"><strong>TinyEMU RISC-V Emulator</strong></a></p>
<p><a href="https://www.barebox.org/jsbarebox/?graphic=1">(Which runs in a <strong>Web Browser</strong>)</a></p>
</li>
<li>
<p>Create our own <a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><strong>Emulator for Ox64 SBC</strong></a></p>
<p>(With minor tweaks to TinyEMU)</p>
</li>
<li>
<p>And run everything in our <strong>Web Browser</strong>!</p>
<p>(Thanks to WebAssembly)</p>
</li>
</ul>
<p><em>Why NuttX?</em></p>
<p><a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> is a tiny operating system for <a href="https://lupyuen.github.io/articles/riscv"><strong>64-bit RISC-V Machines</strong></a> and many other platforms. (Arm, x64, ESP32, ‚Ä¶)</p>
<p>TODO: Simpler to troubleshoot</p>
<p><img src="https://lupyuen.github.io/images/ox64-sd.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="install-tinyemu-emulator"><a href="#install-tinyemu-emulator">1 Install TinyEMU Emulator</a></h1>
<p><em>What‚Äôs this TinyEMU?</em></p>
<p><a href="https://github.com/fernandotcl/TinyEMU"><strong>TinyEMU</strong></a> is a barebones <strong>64-bit RISC-V Emulator</strong>.</p>
<p>It doesn‚Äôt have all the features of QEMU Emulator. But TinyEMU runs in a <a href="https://www.barebox.org/jsbarebox/?graphic=1"><strong>Web Browser</strong></a> and it‚Äôs much simpler for modding!</p>
<p>We begin by installing (our modded) <strong>TinyEMU for the Command Line</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download TinyEMU modded for Ox64
git clone https://github.com/lupyuen/ox64-tinyemu
cd ox64-tinyemu

## For Ubuntu:
sudo apt install libcurl4-openssl-dev libssl-dev zlib1g-dev libsdl2-dev
make

## For macOS:
brew install openssl sdl2
make CFLAGS=-I$(brew --prefix)/opt/openssl/include LDFLAGS=-L$(brew --prefix)/opt/openssl/lib CONFIG_MACOS=y
</code></pre></div>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/.github/workflows/ci.yml">(See the <strong>Build Script</strong>)</a></p>
<p><em>What about TinyEMU for the Web Browser?</em></p>
<p>No Worries! Everything that runs in <strong>Command Line</strong> TinyEMU‚Ä¶ Will also run in <strong>Web Browser</strong> TinyEMU!</p>
<p>We tweak TinyEMU for Ox64‚Ä¶</p>
<h1 id="change-risc-v-addresses-in-tinyemu"><a href="#change-risc-v-addresses-in-tinyemu">2 Change RISC-V Addresses in TinyEMU</a></h1>
<p><em>TinyEMU needs to emulate our Ox64 BL808 SBC. What shall we tweak?</em></p>
<p>TinyEMU is hardcoded to run at <strong>Fixed RISC-V Addresses</strong>. (Yep it‚Äôs really barebones!)</p>
<p>We tweak the RISC-V Addresses in TinyEMU, so that they match the <strong>Bouffalo Lab BL808 SoC</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L66-L82">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// RISC-V Addresses for TinyEMU (modded for Ox64 BL808)
#define LOW_RAM_SIZE    0x00010000ul  // 64 KB of Boot Code at Address 0x0
#define RAM_BASE_ADDR   0x50200000ul  // Our Kernel boots here
#define PLIC_BASE_ADDR  0xe0000000ul  // Platform-Level Interrupt Controller (PLIC)
#define PLIC_SIZE       0x00400000ul  // Address Range of PLIC
#define CLINT_BASE_ADDR 0x02000000ul  // TODO: CLINT is Unused
#define CLINT_SIZE      0x000c0000ul  // TODO: CLINT is Unused
...
#define PLIC_HART_BASE  0x201000  // Hart 0 S-Mode Priority Threshold in PLIC
#define PLIC_HART_SIZE  0x1000    // Address Range of Hart 0 PLIC
</code></pre></div>
<p>TODO: Where did we get the addresses?</p>
<p><em>What‚Äôs this Boot Code?</em></p>
<p>TinyEMU needs a tiny chunk of <strong>RISC-V Machine Code</strong> that will jump to our <strong>Kernel Image</strong> (and pass the Device Tree): <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L862-L872">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At TinyEMU Startup: Init the Emulated RAM...
static void copy_bios(...) {
  ...
  // Init the TinyEMU Boot Code at Address 0x1000 (ram_ptr is 0x0)
  uint32_t *q = (uint32_t *)(ram_ptr + 0x1000);

  // Load into Register T0 the RAM_BASE_ADDR (0x5020_0000)
  // Load into Register A1 the Binary Device Tree
  q[0] = 0x297 + RAM_BASE_ADDR - 0x1000;    // auipc t0, jump_addr
  q[1] = 0x597;                             // auipc a1, dtb
  q[2] = 0x58593 + ((fdt_addr - 4) &lt;&lt; 20);  // addi  a1, a1, dtb

  // Load into Register A0 the Hart ID (RISC-V CPU ID: 0)
  // Jump to Register T0: Our Kernel at RAM_BASE_ADDR (0x5020_0000)
  q[3] = 0xf1402573;  // csrr a0, mhartid
  q[4] = 0x00028067;  // jalr zero, t0, jump_addr
</code></pre></div>
<p>And that‚Äôs our barebones Ox64 Emulator! Let‚Äôs run it‚Ä¶</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/ff10a3065701d049f079ee5f1f6246e47a8345d6">(Remember to enable <strong>Exception Logging</strong>)</a></p>
<h1 id="run-tinyemu-emulator"><a href="#run-tinyemu-emulator">3 Run TinyEMU Emulator</a></h1>
<p><em>We modded TinyEMU to emulate Ox64. What happens when we run it?</em></p>
<p>We see signs of life‚Ä¶ <strong>NuttX Kernel</strong> is actually booting in our Ox64 Emulator!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the TinyEMU Config and NuttX Kernel Image
$ wget https://raw.githubusercontent.com/lupyuen/nuttx-tinyemu/main/docs/ox64/root-riscv64.cfg
$ wget https://github.com/lupyuen/nuttx-tinyemu/raw/main/docs/ox64/Image

## Boot TinyEMU with NuttX Kernel
$ temu root-riscv64.cfg | more

csr_write: csr=0x104 val=0x0
csr_write: csr=0x105 val=0x50200090
csr_write: csr=0x100 val=0x200000000
csr_write: csr=0x140 val=0x50400cd0
csr_write: csr=0x180 val=0x0
csr_write: csr=0x105 val=0x50200090
csr_write: csr=0x100 val=0x200002000
csr_write: csr=0x003 val=0x0
csr_write: csr=0x100 val=0x8000000200006000

target_read_slow:
  invalid physical address
  0x30002084
target_write_slow: 
  invalid physical address 
  0x30002088
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6dafe6052eef7c30450a30e4ce1f94fb">(See the <strong>Complete Log</strong>)</a></p>
<p><em>What‚Äôs root-riscv64.cfg?</em></p>
<p>It‚Äôs the <strong>TinyEMU Config</strong> that will boot NuttX Kernel in our Ox64 Emulator: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/ox64/root-riscv64.cfg">root-riscv64.cfg</a></p>
<div class="example-wrap"><pre class="language-json"><code>/* VM configuration file */
{
  version: 1,
  machine: &quot;riscv64&quot;,
  memory_size: 256,
  bios: &quot;Image&quot;,
}
</code></pre></div>
<p><strong><code>Image</code></strong> is the <strong>NuttX Kernel Image</strong> comes from a typical <a href="https://github.com/lupyuen/nuttx-ox64/releases"><strong>NuttX Build for Ox64</strong></a>.</p>
<p><em>What are the CSR Writes?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>csr_write: csr=0x104 val=0x0
csr_write: csr=0x105 val=0x50200090
csr_write: csr=0x100 val=0x200000000
</code></pre></div>
<p>CSR refers to <a href="https://five-embeddev.com/quickref/csrs.html"><strong>Control and Status Registers</strong></a>. They‚Äôre the System Registers in our RISC-V SoC (BL808)‚Ä¶</p>
<ul>
<li>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><strong>CSR <code>0x104</code></strong></a>: <strong>Supervisor-Mode Interrupt Enable</strong></p>
<p>(Enable or Disable Interrupts)</p>
</li>
<li>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><strong>CSR <code>0x105</code></strong></a>: <strong>Supervisor-Mode Trap Vector Base Address</strong></p>
<p>(Set the Interrupt Vector Table)</p>
</li>
<li>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sstatus"><strong>CSR <code>0x100</code></strong></a>: <strong>Supervisor-Mode Status</strong></p>
<p>TODO: (Set the Status)</p>
<p>(Why Supervisor-Mode? We‚Äôll find out later)</p>
</li>
</ul>
<p><em>Why is it writing to CSR Registers?</em></p>
<p>This comes from our <strong>NuttX Boot Code</strong></p>
<p>TODO: NuttX Boot Code</p>
<p>TODO: BL808 UART Registers</p>
<h1 id="uart-registers-for-bl808-soc"><a href="#uart-registers-for-bl808-soc">4 UART Registers for BL808 SoC</a></h1>
<p><em>What are 0x3000_2084 and 0x3000_2088? Why are they invalid?</em></p>
<div class="example-wrap"><pre class="language-yaml"><code>target_read_slow:
  invalid physical address
  0x30002084
target_write_slow: 
  invalid physical address 
  0x30002088
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6dafe6052eef7c30450a30e4ce1f94fb">(See the <strong>Complete Log</strong>)</a></p>
<p>We dig around the <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>BL808 Reference Manual</strong></a> (pic above) and we discover‚Ä¶</p>
<p>TODO</p>
<p>From our <a href="https://lupyuen.github.io/articles/ox2#print-to-serial-console">BL808 UART Docs</a>‚Ä¶</p>
<ul>
<li>
<p>0x3000_2088 (uart_fifo_wdata) means NuttX is writing to the UART Output Register. It‚Äôs printing something to the console! <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(BL808 Reference Manual, Page 428)</a></p>
</li>
<li>
<p>0x3000_2084 (uart_fifo_config_1) means NuttX is checking if UART Transmit is ready. <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(BL808 Reference Manual, Page 427)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_serial.c#L594-L615">(<code>*0x30002084 &amp; 0x3f</code> must be non-zero to indicate that UART Transmit is ready)</a></p>
</li>
<li>
<p>That‚Äôs why we always see ‚Äúread 0x3000_2084‚Äù before ‚Äúwrite 0x3000_2088‚Äù.</p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_serial.c#L594-L615">(See <code>bl808_send</code>)</a></p>
</li>
</ul>
<p>Note that we‚Äôre still booting in RISC-V Machine Mode! This will cause problems later, because NuttX Ox64 expects to boot in RISC-V Supervisor Mode. (Due to OpenSBI)</p>
<p>TODO: NuttX Code</p>
<h1 id="intercept-uart-registers-for-ox64-bl808-emulator"><a href="#intercept-uart-registers-for-ox64-bl808-emulator">5 Intercept UART Registers for Ox64 BL808 Emulator</a></h1>
<p>TODO</p>
<p>Let‚Äôs intercept the ‚Äúread 0x3000_2084‚Äù and ‚Äúwrite 0x3000_2088‚Äù in TinyEMU Emulator for Ox64 BL808, so we can print the UART Output.</p>
<p>We handle all ‚Äúread 0x3000_2084‚Äù (uart_fifo_config_1) by returning 32 (TX FIFO Available Count), to tell NuttX that the UART Port is always ready to transmit: <a href="https://github.com/lupyuen/ox64-tinyemu/commit/14badbc271f6dfe9602b889e4636c855833874d3">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* return 0 if OK, != 0 if exception */
int target_read_slow(RISCVCPUState *s, mem_uint_t *pval, target_ulong addr, int size_log2) {
...        
  pr = get_phys_mem_range(s-&gt;mem_map, paddr);
  if (!pr) {
    //// Begin Test: Intercept Memory-Mapped I/O
    switch(paddr &amp; 0xfffffffffffful) {  // TODO: Why does NuttX read from 0x4000000030002084?
    case 0x30002084:     // uart_fifo_config_1: Is UART Ready?
      ret = 32; break; // UART TX is always ready, default TX FIFO Available is 32

    default:  // Unknown Memory-Mapped I/O
#ifdef DUMP_INVALID_MEM_ACCESS
      printf(&quot;target_read_slow: invalid physical address 0x&quot;);
      print_target_ulong(paddr);
      printf(&quot;\n&quot;);
#endif
      return 0;
    }
    //// End Test
</code></pre></div>
<p>We handle all ‚Äúwrite 0x3000_2088‚Äù (uart_fifo_wdata) by printing the character to the UART Output Register: <a href="https://github.com/lupyuen/ox64-tinyemu/commit/14badbc271f6dfe9602b889e4636c855833874d3">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* return 0 if OK, != 0 if exception */
int target_write_slow(RISCVCPUState *s, target_ulong addr, mem_uint_t val, int size_log2) {
...
  pr = get_phys_mem_range(s-&gt;mem_map, paddr);
  if (!pr) {
    //// Begin Test: Intercept Memory-Mapped I/O
    switch(paddr &amp; 0xfffffffffffful) {  // TODO: Why does NuttX write to 0x4000000030002088?
    case 0x30002088:  // uart_fifo_wdata: UART Output
      putchar(val); break;  // Print the character

    default:  // Unknown Memory-Mapped I/O
#ifdef DUMP_INVALID_MEM_ACCESS
      printf(&quot;target_write_slow: invalid physical address 0x&quot;);
      print_target_ulong(paddr);
      printf(&quot;\n&quot;);
#endif                
    }
    //// End Test
</code></pre></div>
<p>Here‚Äôs the <a href="https://gist.github.com/lupyuen/efb6750b317f52b629c115ac16635177">TinyEMU Log for Intercepted UART Registers</a>. We see NuttX booting on TinyEMU yay!</p>
<div class="example-wrap"><pre class="language-text"><code>$ temu root-riscv64.cfg | more
virtio_console_init
ABCnx_start: Entry
mm_initialize: Heap: name=Kmem, start=0x50407c00 size=2065408
mm_addregion: [Kmem] Region 1: base=0x50407ea8 size=2064720
mm_malloc: Allocated 0x50407ed0, size 704
mm_malloc: Allocated 0x50408190, size 48
...
uart_register: Registering /dev/console
target_read_slow: invalid physical address 0x0000000030002024
target_write_slow: invalid physical address 0x0000000030002024
work_start_lowpri kernel worker thread(s)
uart_register: Registering /dev/console
target_read_slow: invalid physical address 0x0000000030002024
target_write_slow: invalid physical address 0x0000000030002024
work_start_lowpri: Starting low-priority kernel worker thread(s)
nx_start_applicaystem/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Fa: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
mm_initialize: Heap: name=(null), start=0x80200000 size=528384
mm_addregion: [(null)] Region 1: base=0x802002a8 size=527696
mm_initialize: Heap: name=(null), start=0x80200000 size=528384
mm_addregion: [(null)] Region 1: base=0x802002a8 size=527696
up_exit: TCB=0x504098d0 exiting
raise_exception2: cause=8, tval=0x0
pc =00000000800019c6 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a0006806
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
raise_exception2: cause=2, tval=0x0
raise_exception2: cause=2, tval=0x0
...
raise_exception2: cause=2, tval=0x0
up_exit: TCB=0x504098d0 exiting
raise_exception2: cause=8, tval=0x0
pc =00000000800019c6 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =00000000000001 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a00040021 cycles=82846806
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
raise_exception2: cause=2, tval=0x0
raise_exception2: cause=2, tval=0x0
</code></pre></div>
<p>TODO: Why does NuttX read from 0x4000000030002084? Probably due to T-Head C906 MMU Flags</p>
<p>TODO: What is <code>raise_exception2: cause=2, tval=0x0</code>?</p>
<p>TODO: Why is NuttX Shell started twice? Because it failed? (<code>/system/bin/init</code>)</p>
<h1 id="nuttx-exception-in-ox64-bl808-emulator"><a href="#nuttx-exception-in-ox64-bl808-emulator">6 NuttX Exception in Ox64 BL808 Emulator</a></h1>
<p>TODO</p>
<p><em>What is <code>raise_exception2: cause=8</code>?</em></p>
<p>From the <a href="https://gist.github.com/lupyuen/efb6750b317f52b629c115ac16635177">TinyEMU Log for Intercepted UART Registers</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>up_exit: TCB=0x504098d0 exiting
raise_exception2: cause=8, tval=0x0
pc =00000000800019c6 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a0006806
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
raise_exception2: cause=2, tval=0x0
</code></pre></div>
<p>We look up the offending Code Address: <code>pc=8000_19c6</code>. This address comes from the NuttX App Virtual Memory: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/heapcrash/boards/risc-v/bl808/ox64/configs/nsh/defconfig#L17-L30">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_ARCH_TEXT_VBASE=0x80000000
CONFIG_ARCH_TEXT_NPAGES=128
CONFIG_ARCH_DATA_VBASE=0x80100000
CONFIG_ARCH_DATA_NPAGES=128
CONFIG_ARCH_HEAP_VBASE=0x80200000
CONFIG_ARCH_HEAP_NPAGES=128
</code></pre></div>
<p>The only NuttX App we‚Äôre running is the NuttX Shell. So we look up the RISC-V Disassembly for the NuttX Shell: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/ox64/init.S#L45327-L45358">init.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/syscall/proxies/PROXY_sched_getparam.c:8
int sched_getparam(pid_t parm1, FAR struct sched_param * parm2) {
...
00000000000019c6 &lt;.LVL4&gt;:
nuttx/include/arch/syscall.h:229
  asm volatile
    19c6:	00000073          	ecall
</code></pre></div>
<p>0x19c6 is an ECALL from NuttX App (RISC-V User Mode) to NuttX Kernel (RISC-V Supervisor Mode). Our NuttX Shell is making a System Call to NuttX Kernel!</p>
<p>Which fails because everything runs in RISC-V Machine Mode right now. We will need to start TinyEMU in RISC-V Supervisor Mode (instead of Machine Mode).</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/9da5b066c9fe29ef46b93ff8174662d5e6858038">(We quit if mcause=2, otherwise it will loop forever)</a></p>
<h1 id="emulate-ox64-bl808-in-web-browser"><a href="#emulate-ox64-bl808-in-web-browser">7 Emulate Ox64 BL808 in Web Browser</a></h1>
<p>TODO</p>
<p><em>Will our Ox64 BL808 Emulator run in the Web Browser?</em></p>
<p>Let‚Äôs find out! First we fix the <a href="https://github.com/lupyuen/ox64-tinyemu/commit/170abb06b58a58328efa8a1874795f1daac0b7a7">TinyEMU Build for Emscripten</a>.</p>
<p>Print to Device Console instead of JavaScript Console:</p>
<p>https://github.com/lupyuen/ox64-tinyemu/commit/41383b85be0f0a16369d2661338487dd28a56a75</p>
<p>And it runs OK in Web Browser yay!</p>
<p>https://lupyuen.github.io/nuttx-tinyemu/ox64/</p>
<p>TODO: Emulate BL808 GPIO to Blink an LED</p>
<h1 id="emulate-ox64-bl808-sbc-with-tinyemu"><a href="#emulate-ox64-bl808-sbc-with-tinyemu">8 Emulate Ox64 BL808 SBC with TinyEMU</a></h1>
<p>TODO</p>
<p>Objective: Take the NuttX Kernel built for <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358">Ox64 BL808 SBC</a>. And boot it on TinyEMU RISC-V Emulator in the Web Browser!</p>
<ol>
<li>
<p>Fix these RISC-V Addresses in TinyEMU to follow BL808 Memory Map: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L66-L82">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define LOW_RAM_SIZE   0x00010000 /* 64KB */
#define RAM_BASE_ADDR  0x80000000
#define CLINT_BASE_ADDR 0x02000000
#define CLINT_SIZE      0x000c0000
#define DEFAULT_HTIF_BASE_ADDR 0x40008000
#define VIRTIO_BASE_ADDR 0x40010000
#define VIRTIO_SIZE      0x1000
#define VIRTIO_IRQ       1
#define PLIC_BASE_ADDR 0x40100000
#define PLIC_SIZE      0x00400000
#define FRAMEBUFFER_BASE_ADDR 0x41000000

#define RTC_FREQ 10000000
#define RTC_FREQ_DIV 16 /* arbitrary, relative to CPU freq to have a
                          10 MHz frequency */
</code></pre></div></li>
<li>
<p>Start TinyEMU in RISC-V Supervisor Mode (instead of Machine Mode)</p>
<p>(So we don‚Äôt need OpenSBI and U-Boot Bootloader)</p>
</li>
<li>
<p>Emulate <a href="https://lupyuen.github.io/articles/nim#appendix-opensbi-timer-for-nuttx">OpenSBI Timer</a></p>
<p>(Intercept the Supervisor-To-Machine Mode ECALL)</p>
</li>
<li>
<p>Emulate BL808 UART I/O (Memory Mapped I/O and PLIC Interrupts)</p>
<p>(So we can run NuttX Shell)</p>
</li>
<li>
<p>Emulate BL808 GPIO Output (Memory Mapped I/O)</p>
<p>(So we can test Nim Blinky)</p>
</li>
</ol>
<p>Let‚Äôs try booting NuttX Ox64 on TinyEMU‚Ä¶</p>
<p>TODO: Wrap TinyEMU with Zig for Memory Safety and WebAssembly?</p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tinyemu2.md"><strong>lupyuen.github.io/src/tinyemu2.md</strong></a></p>

    
</body>
</html>