<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Run Rust RISC-V Firmware with BL602 IoT SDK</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Run Rust RISC-V Firmware with BL602 IoT SDK" 
    data-rh="true">
<meta property="og:description" 
    content="How we build, flash and run Rust firmware on BL602 RISC-V SoC... With the BL602 IoT SDK"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Run Rust RISC-V Firmware with BL602 IoT SDK</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-blinky-in-c">1 BL602 Blinky in C</a><ul></ul></li>
<li><a href="#bl602-blinky-in-rust">2 BL602 Blinky in Rust</a><ul></ul></li>
<li><a href="#import-bl602-iot-sdk-into-rust">3 Import BL602 IoT SDK into Rust</a><ul>
<li><a href="#pass-strings-from-rust-to-c">3.1 Pass Strings from Rust to C</a><ul></ul></li>
<li><a href="#autogenerate-wrapper-functions">3.2 Autogenerate Wrapper Functions</a><ul></ul></li></ul></li>
<li><a href="#rust-on-bl602-iot-sdk">4 Rust on BL602 IoT SDK</a><ul></ul></li>
<li><a href="#build-the-bl602-rust-firmware">5 Build the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#flash-the-bl602-rust-firmware">6 Flash the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#run-the-bl602-rust-firmware">7 Run the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#rust-targets">8 Rust Targets</a><ul>
<li><a href="#bl602-supports-hardware-floating-point">8.1 BL602 supports Hardware Floating-Point</a><ul></ul></li>
<li><a href="#selecting-another-rust-target">8.2 Selecting another Rust Target</a><ul></ul></li></ul></li>
<li><a href="#custom-rust-target-for-bl602">9 Custom Rust Target for BL602</a><ul></ul></li>
<li><a href="#rust-on-bl602-two-more-ways">10 Rust On BL602: Two More Ways</a><ul></ul></li>
<li><a href="#apache-nuttx-on-bl602">11 Apache NuttX on BL602</a><ul>
<li><a href="#rust-on-apache-mynewt">11.1 Rust on Apache Mynewt</a><ul></ul></li>
<li><a href="#graphical-flow-programming">11.2 Graphical Flow Programming</a><ul></ul></li>
<li><a href="#but-why-c">11.3 But Why C?</a><ul></ul></li></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">13 Notes</a><ul></ul></li>
<li><a href="#appendix-build-script-for-bl602-rust-firmware">14 Appendix: Build Script for BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#appendix-stub-library-for-bl602-rust">15 Appendix: Stub Library for BL602 Rust</a><ul></ul></li>
<li><a href="#appendix-expose-inline-functions-to-rust">16 Appendix: Expose Inline Functions to Rust</a><ul></ul></li></ul></nav><p>üìù <em>21 Apr 2021</em></p>
<p><a href="https://lupyuen.github.io/articles/adc"><strong>UPDATE:</strong> Rust on BL602 is now simpler with Rust Wrapper for BL602 IoT SDK. Check out the new article</a></p>
<p>In the past 14 articles we‚Äôve done so much with <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 IoT SDK</strong></a>: <a href="https://lupyuen.github.io/articles/lora2">LoRa wireless transceivers</a>, <a href="https://lupyuen.github.io/articles/display">SPI LCD displays</a>, <a href="https://lupyuen.github.io/articles/uart">UART e-ink displays</a>, <a href="https://lupyuen.github.io/articles/i2c">I2C sensors</a>, ‚Ä¶</p>
<p><em>Can we do this in Rust? (Instead of C)</em></p>
<p><em>And flash our Rust firmware to BL602 over UART? (Instead of JTAG)</em></p>
<p>Let‚Äôs run some <strong>Rust code on top of BL602 IoT SDK</strong>, and understand how that‚Äôs possible.</p>
<p>Today we won‚Äôt be talking about the merits (and demerits) of Embedded Rust, we‚Äôll save that for the future.</p>
<p>But if you have the tiniest interest in coding <strong>Rust firmware for BL602</strong>‚Ä¶ Please read on!</p>
<p><img src="https://lupyuen.github.io/images/rust-title.jpg" alt="PineCone BL602 RISC-V Board" /></p>
<p><em>PineCone BL602 RISC-V Board</em></p>
<h1 id="bl602-blinky-in-c"><a href="#bl602-blinky-in-c">1 BL602 Blinky in C</a></h1>
<p>Before we do Rust, let‚Äôs look at the C code that blinks the LED on BL602 (by toggling the GPIO output): <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_blinky/sdk_app_blinky/demo.c"><code>sdk_app_blinky/demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;bl_gpio.h&gt;     //  For BL602 GPIO Hardware Abstraction Layer
#include &quot;nimble_npl.h&quot;  //  For NimBLE Porting Layer (mulitasking functions)

/// PineCone Blue LED is connected on BL602 GPIO 11
/// TODO: Change the LED GPIO Pin Number for your BL602 board
#define LED_GPIO 11

/// Blink the BL602 LED
void blinky(char *buf, int len, int argc, char **argv) {
    //  Show a message on the serial console
    puts(&quot;Hello from Blinky!&quot;);

    //  Configure the LED GPIO for output (instead of input)
    int rc = bl_gpio_enable_output(
        LED_GPIO,  //  GPIO pin number
        0,         //  No GPIO pullup
        0          //  No GPIO pulldown
    );
    assert(rc == 0);  //  Halt on error

    //  Blink the LED 5 times
    for (int i = 0; i &lt; 10; i++) {

        //  Toggle the LED GPIO between 0 (on) and 1 (off)
        rc = bl_gpio_output_set(  //  Set the GPIO output (from BL602 GPIO HAL)
            LED_GPIO,             //  GPIO pin number
            i % 2                 //  0 for low, 1 for high
        );
        assert(rc == 0);  //  Halt on error

        //  Sleep 1 second
        time_delay(                   //  Sleep by number of ticks (from NimBLE Porting Layer)
            time_ms_to_ticks32(1000)  //  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)
        );
    }

    //  Return to the BL602 command-line interface
}
</code></pre></div>
<p>Here we call two <strong>GPIO Functions</strong> from the BL602 IoT SDK (specifically, the BL602 <strong>GPIO Hardware Abstraction Layer</strong>)‚Ä¶</p>
<ul>
<li>
<p><strong><code>bl_gpio_enable_output</code></strong>: Configure a GPIO Pin for output (instead of input)</p>
</li>
<li>
<p><strong><code>bl_gpio_output_set</code></strong>: Set the GPIO Pin output to high or low</p>
</li>
</ul>
<p>Instead of calling the <strong>Multitasking Functions</strong> in FreeRTOS, we call the <strong>NimBLE Porting Layer</strong> (which wraps FreeRTOS into a simpler API)‚Ä¶</p>
<ul>
<li>
<p><strong><code>time_delay</code></strong>: Put the current FreeRTOS task to sleep (for a number of system ticks)</p>
</li>
<li>
<p><strong><code>time_ms_to_ticks32</code></strong>: Convert milliseconds to FreeRTOS system ticks</p>
</li>
</ul>
<p>Now let‚Äôs code-switch to Rust.</p>
<p><a href="https://lupyuen.github.io/articles/led#how-it-works-bl602-gpio">More about BL602 GPIO HAL</a></p>
<p><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer">More about NimBLE Porting Layer</a></p>
<h1 id="bl602-blinky-in-rust"><a href="#bl602-blinky-in-rust">2 BL602 Blinky in Rust</a></h1>
<p>Here‚Äôs our BL602 Blinky Firmware, coded in Rust: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/src/lib.rs#L1-L8"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">//!  Main Rust Application for BL602 Firmware
</span><span class="attr">#![no_std]  </span><span class="comment">//  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems

//  Import the Rust Core Library
</span><span class="kw">use </span>core::{
    panic::PanicInfo,  <span class="comment">//  For `PanicInfo` type used by `panic` function
    </span>str::FromStr,      <span class="comment">//  For converting `str` to `String`
</span>};</code></pre></div>
<p>First we tell the Rust Compiler to use the <strong>Rust Core Library</strong>.</p>
<p>(Instead of the Rust Standard Library, which is too heavy for microcontrollers)</p>
<p>We import <code>PanicInfo</code> and <code>FromStr</code> to handle Errors and String Conversion. (We‚Äôll see later)</p>
<p>Our Rust Blinky Function looks similar to the C version: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/src/lib.rs#L10-L44"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// `rust_main` will be called by the BL602 command-line interface
</span><span class="attr">#[no_mangle]              </span><span class="comment">//  Don&#39;t mangle the name `rust_main`
</span><span class="kw">extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>rust_main(  <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by BL602 firmware
    </span>_buf:  <span class="kw-2">*const </span>u8,        <span class="comment">//  Command line (char *)
    </span>_len:  i32,              <span class="comment">//  Length of command line (int)
    </span>_argc: i32,              <span class="comment">//  Number of command line args (int)
    </span>_argv: <span class="kw-2">*const *const </span>u8  <span class="comment">//  Array of command line args (char **)
</span>) {
    <span class="comment">//  Show a message on the serial console
    </span>puts(<span class="string">&quot;Hello from Rust!&quot;</span>);

    <span class="comment">//  PineCone Blue LED is connected on BL602 GPIO 11
    </span><span class="kw">const </span>LED_GPIO: u8 = <span class="number">11</span>;  <span class="comment">//  `u8` is 8-bit unsigned integer

    //  Configure the LED GPIO for output (instead of input)
    </span>bl_gpio_enable_output(LED_GPIO, <span class="number">0</span>, <span class="number">0</span>)      <span class="comment">//  No pullup, no pulldown
        </span>.expect(<span class="string">&quot;GPIO enable output failed&quot;</span>);  <span class="comment">//  Halt on error</span></code></pre></div>
<p>When <strong>code-switching from C to Rust</strong> we consciously‚Ä¶</p>
<ol>
<li>
<p><strong>Rename the Types:</strong> ‚Äú<code>int</code>‚Äù in C becomes ‚Äú<code>i32</code>‚Äù in Rust (32-bit signed integer)</p>
</li>
<li>
<p><strong>Flip the Declarations:</strong> ‚Äú<code>typename varname</code>‚Äù in C becomes ‚Äú<code>varname: typename</code>‚Äù in Rust</p>
</li>
<li>
<p><strong>Change Assertions to Expect:</strong> ‚Äú<code>assert</code>‚Äù in C becomes ‚Äú<code>expect</code>‚Äù in Rust. (More about this later)</p>
</li>
</ol>
<p>The rest of the Rust function looks similar to C‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">//  Blink the LED 5 times
    </span><span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{  <span class="comment">//  Iterates 10 times from 0 to 9 (`..` excludes 10)

        //  Toggle the LED GPIO between 0 (on) and 1 (off)
        </span>bl_gpio_output_set(  <span class="comment">//  Set the GPIO output (from BL602 GPIO HAL)
            </span>LED_GPIO,        <span class="comment">//  GPIO pin number
            </span>i % <span class="number">2            </span><span class="comment">//  0 for low, 1 for high
        </span>).expect(<span class="string">&quot;GPIO output failed&quot;</span>);  <span class="comment">//  Halt on error

        //  Sleep 1 second
        </span>time_delay(                   <span class="comment">//  Sleep by number of ticks (from NimBLE Porting Layer)
            </span>time_ms_to_ticks32(<span class="number">1000</span>)  <span class="comment">//  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)
        </span>);
    }

    <span class="comment">//  Return to the BL602 command-line interface
</span>}</code></pre></div>
<p>(Yep the <code>for</code> loop looks a little different in Rust)</p>
<p>For Embedded Rust we need to include a <strong>Panic Handler</strong> that will handle errors (like Expect / Assertion Failures): <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/src/lib.rs#L46-L57"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This function is called on panic, like an assertion failure
</span><span class="attr">#[panic_handler]
</span><span class="kw">fn </span>panic(_info: <span class="kw-2">&amp;</span>PanicInfo) -&gt; ! {  <span class="comment">//  `!` means that panic handler will never return
    //  TODO: Implement the complete panic handler like this:
    //  https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/rust/app/src/lib.rs#L115-L146

    //  For now we display a message
    </span>puts(<span class="string">&quot;TODO: Rust panic&quot;</span>); 

	<span class="comment">//  Loop forever, do not pass go, do not collect $200
    </span><span class="kw">loop </span>{}
}</code></pre></div>
<p>We‚Äôre not done with Rust yet! Let‚Äôs find out how we import the BL602 IoT SDK (and NimBLE Porting Library) into Rust.</p>
<p>Here‚Äôs our code switching from C to Rust so far‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust-codeswitch.png" alt="Code Switching from C to Rust" /></p>
<h1 id="import-bl602-iot-sdk-into-rust"><a href="#import-bl602-iot-sdk-into-rust">3 Import BL602 IoT SDK into Rust</a></h1>
<p><a href="https://lupyuen.github.io/articles/adc"><strong>UPDATE:</strong> Rust on BL602 is now simpler with Rust Wrapper for BL602 IoT SDK. Check out the new article</a></p>
<p>As we import the functions from BL602 IoT SDK into Rust, let‚Äôs create <strong>Wrapper Functions</strong> that will expose a cleaner, neater interface to our Rust callers.</p>
<p>We start with <strong><code>bl_gpio_output_set</code></strong>, the function from BL602 GPIO HAL (Hardware Abstraction Layer) that sets the GPIO Pin output: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/src/lib.rs#L118-L141"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Set the GPIO pin output to high or low.
</span><span class="kw">fn </span>bl_gpio_output_set(
    pin:   u8,  <span class="comment">//  GPIO pin number (uint8_t)
    </span>value: u8   <span class="comment">//  0 for low, 1 to high
</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), i32&gt; {  <span class="comment">//  Returns an error code (int)</span></code></pre></div>
<p><em>The C version of <code>bl_gpio_output_set</code> returns an <code>int</code> result code (0 for success, non-zero for error)‚Ä¶</em></p>
<p><em>Why does the Rust version return <code>Result&lt;(),i32&gt;</code>?</em></p>
<p>Because <strong><code>Result&lt;...&gt;</code></strong> lets us return a meaningful result to our Rust caller‚Ä¶</p>
<ul>
<li>
<p><strong><code>Ok</code>:</strong> For success</p>
</li>
<li>
<p><strong><code>Err</code>:</strong> For error code</p>
</li>
</ul>
<p>This makes the error handling easier (with <code>expect</code>). We‚Äôll see the returned result in a while.</p>
<p>Inside the wrapper, we <strong>import the C function</strong> like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{  <span class="comment">//  Import C Function
        </span><span class="doccomment">/// Set the GPIO pin output to high or low (from BL602 GPIO HAL)
        </span><span class="kw">fn </span>bl_gpio_output_set(pin: u8, value: u8) -&gt; i32;
    }</code></pre></div>
<p>Next our wrapper <strong>calls the imported C function</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">//  Call the C function
    </span><span class="kw">let </span>res = <span class="kw">unsafe </span>{  <span class="comment">//  Flag this code as unsafe because we&#39;re calling a C function
        </span>bl_gpio_output_set(pin, value)
    };</code></pre></div>
<p>Rust requires us to flag this code as <strong><code>unsafe</code></strong> because we‚Äôre calling a C function.</p>
<p>Finally we <strong>match the result</strong> returned by the C function: 0 for success, non-zero for error‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">//  Check the result code
    </span><span class="kw">match </span>res {
        <span class="number">0 </span>=&gt; <span class="prelude-val">Ok</span>(()),   <span class="comment">//  If no error, return OK
        </span><span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(res)  <span class="comment">//  Else return the result code as an error
    </span>}
}</code></pre></div>
<p>‚Äú<code>match</code>‚Äù works like ‚Äú<code>switch...case</code>‚Äù in C. (‚Äú<code>_</code>‚Äù matches anything, similar to ‚Äú<code>default</code>‚Äù in C)</p>
<p>Here we return <code>Ok</code> for success, or <code>Err</code> with an error code inside.</p>
<p>When our Rust caller receives <code>Err</code>, the <code>expect</code> error checking will fail with a panic.</p>
<h2 id="pass-strings-from-rust-to-c"><a href="#pass-strings-from-rust-to-c">3.1 Pass Strings from Rust to C</a></h2>
<p>Strings are terminated by null in C, but not in Rust.</p>
<p>(Rust strings have an internal field that remembers the string length)</p>
<p>To pass strings from C to Rust, our wrapper needs to <strong>copy the string and pad it with null</strong>.  Here‚Äôs how: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/src/lib.rs#L64-L90"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Print a message to the serial console.
/// `&amp;str` is a reference to a string slice, similar to `const char *` in C
</span><span class="kw">fn </span>puts(s: <span class="kw-2">&amp;</span>str) -&gt; i32 {</code></pre></div>
<p>Our wrapper for <code>puts</code> accepts a string and returns an <code>int</code>.</p>
<p>‚Äú<code>&amp;str</code>‚Äù is a <strong>Reference to a String Slice</strong>. It‚Äôs similar to ‚Äú<code>const char *</code>‚Äù in C.</p>
<p>We <strong>import the <code>puts</code> function</strong> from BL602 IoT SDK (<code>stdio</code> library)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{  <span class="comment">//  Import C Function
        </span><span class="doccomment">/// Print a message to the serial console (from C stdio library)
        </span><span class="kw">fn </span>puts(s: <span class="kw-2">*const </span>u8) -&gt; i32;
    }</code></pre></div>
<p>When importing ‚Äú<code>const char *</code>‚Äù from C, we rewrite it as ‚Äú<code>*const u8</code>‚Äù (const pointer to unsigned byte).</p>
<p>Next we make a <strong>copy of the input string</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">//  Convert `str` to `String`, which similar to `char [64]` in C
    </span><span class="kw">let </span><span class="kw-2">mut </span>s_with_null = String::from_str(s)  <span class="comment">//  `mut` because we will modify it
        </span>.expect(<span class="string">&quot;puts conversion failed&quot;</span>);     <span class="comment">//  If it exceeds 64 chars, halt with an error</span></code></pre></div>
<p>‚Äú<code>String</code>‚Äù is similar to ‚Äú<code>char[64]</code>‚Äù in C.</p>
<p>Here we create a ‚Äú<code>String</code>‚Äù (instead of ‚Äú<code>&amp;str</code>‚Äù) because ‚Äú<code>String</code>‚Äù will allocate storage (on the stack) to hold the copied string.</p>
<p>If our input string exceeds 64 characters, the copying fails with an error.</p>
<p>(More about ‚Äú<code>String</code>‚Äù in a while)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">//  Terminate the string with null, since we will be passing to C
    </span>s_with_null.push(<span class="string">&#39;\0&#39;</span>)
        .expect(<span class="string">&quot;puts overflow&quot;</span>);  <span class="comment">//  If we exceed 64 chars, halt with an error</span></code></pre></div>
<p>Here we <strong>pad the copied string with null</strong>.</p>
<p>This also fails with an error if the padded string exceeds 64 characters.</p>
<p>Finally we <strong>fetch the pointer</strong> to our null-terminated string, and pass it to the C function‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">//  Convert the null-terminated string to a pointer
    </span><span class="kw">let </span>p = s_with_null.as_str().as_ptr();

    <span class="comment">//  Call the C function
    </span><span class="kw">unsafe </span>{  <span class="comment">//  Flag this code as unsafe because we&#39;re calling a C function
        </span>puts(p)
    }

    <span class="comment">//  No semicolon `;` here, so the value returned by the C function will be passed to our caller
</span>}</code></pre></div>
<p><strong><code>String</code></strong> is a custom <strong>heapless string</strong> type that‚Äôs allocated on the stack or static memory. (Instead of heap memory)</p>
<p>We define <code>String</code> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/src/lib.rs#L179-L180"><code>lib.rs</code></a>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Limit Strings to 64 chars, similar to `char[64]` in C
</span><span class="kw">type </span>String = heapless::String::&lt;heapless::consts::U64&gt;;</code></pre></div>
<p>For safety, we limit our strings to <strong>64 characters</strong>.</p>
<p><code>String</code> uses the <strong>heapless library</strong>, as specified in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/Cargo.toml#L9-L11"><code>rust/Cargo.toml</code></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## External Rust libraries used by this module.  See crates.io.
[dependencies]
## `static` friendly data structures that don&#39;t require dynamic memory allocation: https://crates.io/crates/heapless
heapless = &quot;0.6.1&quot;
</code></pre></div>
<p><em>We‚Äôre copying the string just to pad it with null. Not so efficient no?</em></p>
<p>In future we might switch to <code>cstr</code> and eliminate the copying of strings. <a href="https://crates.io/crates/cstr">(See this)</a></p>
<h2 id="autogenerate-wrapper-functions"><a href="#autogenerate-wrapper-functions">3.2 Autogenerate Wrapper Functions</a></h2>
<p><a href="https://lupyuen.github.io/articles/adc"><strong>UPDATE:</strong> Rust on BL602 is now simpler with Rust Wrapper for BL602 IoT SDK. Check out the new article</a></p>
<p><em>Sure looks like a lot of repetitive work to create the Wrapper Functions‚Ä¶ When we import the entire BL602 IoT SDK?</em></p>
<p>Someday we shall <strong>automatically generate the Wrapper Functions</strong> for the entire BL602 IoT SDK.</p>
<p>We‚Äôll do that with the <strong><code>bindgen</code></strong> tool, helped by a <strong>Rust Procedural Macro</strong>.</p>
<p>We‚Äôve previously done this to import the LVGL graphics library and Apache Mynewt OS functions into Rust‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/watchface#advanced-topic-rust-bindings-for-lvgl"><strong>‚ÄúRust Bindings for LVGL‚Äù</strong></a></li>
</ul>
<p>In short: We shall run a script that will scan the <code>*.h</code> header files from the BL602 IoT SDK and create the wrapper functions we‚Äôve seen earlier. Yes it‚Äôs possible!</p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper">(Here‚Äôs a sneak peek of <code>bl602-rust-wrapper</code>)</a></p>
<h1 id="rust-on-bl602-iot-sdk"><a href="#rust-on-bl602-iot-sdk">4 Rust on BL602 IoT SDK</a></h1>
<p>Our Rust Firmware accesses the BL602 serial port, GPIO pin and system timer by calling the <strong>BL602 IoT SDK</strong>. (Imported from C into Rust)</p>
<p><img src="https://lupyuen.github.io/images/rust-arch.png" alt="Rust on BL602 IoT SDK" /></p>
<p>Strictly speaking this isn‚Äôt <a href="https://docs.rust-embedded.org/book/"><strong>Embedded Rust</strong></a>, because we‚Äôre not running Rust directly on Bare Metal (BL602 Hardware). </p>
<p>Instead we‚Äôre running <strong>Rust on top of an Embedded Operating System</strong> (BL602 IoT SDK + FreeRTOS). It‚Äôs similar to running Rust on Linux / macOS / Windows.</p>
<p>That‚Äôs why we compile our Rust code into a <strong>static library</strong> that will be linked into the BL602 Firmware. See <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/rust/Cargo.toml#L14-L18"><code>rust/Cargo.toml</code></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Build this module as a Rust library, 
## not a Rust application.  We will link 
## this library with the BL602 firmware.
[lib]
## Output will be named `libapp.a`
name       = &quot;app&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre></div>
<p>This produces a BL602 Rust Firmware file that we may <strong>flash to BL602 the conventional way</strong>: Over the BL602 Serial / UART Port.</p>
<p>(We‚Äôll talk later about Embedded Rust on Bare Metal BL602)</p>
<h1 id="build-the-bl602-rust-firmware"><a href="#build-the-bl602-rust-firmware">5 Build the BL602 Rust Firmware</a></h1>
<p><a href="https://lupyuen.github.io/articles/adc"><strong>UPDATE:</strong> Rust on BL602 is now simpler with Rust Wrapper for BL602 IoT SDK. Check out the new article</a></p>
<p>Here are the steps to build the BL602 Rust Firmware <code>sdk_app_rust.bin</code>‚Ä¶</p>
<ol>
<li>
<p>Install <strong><code>rustup</code>, <code>blflash</code> and <code>xpack-riscv-none-embed-gcc</code></strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/debug#install-gdb"><strong>‚ÄúInstall <code>xpack-riscv-none-embed-gcc</code>‚Äù</strong></a></p>
</li>
</ul>
</li>
<li>
<p>Download the <strong>source code</strong> for the BL602 Rust Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the master branch of lupyuen&#39;s bl_iot_sdk
git clone --recursive --branch master https://github.com/lupyuen/bl_iot_sdk
cd bl_iot_sdk/customer_app/sdk_app_rust
</code></pre></div></li>
<li>
<p>Edit the script <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh"><strong><code>run.sh</code></strong></a> in the <code>sdk_app_rust</code> folder.</p>
<p>This build script was created for macOS, but can be modified to run on Linux and Windows (with WSL).</p>
</li>
<li>
<p>In <code>run.sh</code>, set the following variables to the downloaded folders for <code>blflash</code> and <code>xpack-riscv-none-embed-gcc</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Where blflash is located
export BLFLASH_PATH=$PWD/../../../blflash

##  Where GCC is located
export GCC_PATH=$PWD/../../../xpack-riscv-none-embed-gcc
</code></pre></div>
<p>Save the changes into <code>run.sh</code></p>
</li>
<li>
<p>Build the firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>./run.sh
</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Building Rust app and BL602 firmware for riscv32imacf-unknown-none-elf / sdk_app_rust...

----- Build BL602 Firmware
+ make
...
LD build_out/sdk_app_rust.elf
Generating BIN File to build_out/sdk_app_rust.bin
...
Building Finish. To flash build output.
</code></pre></div>
<p>The script has built our firmware‚Ä¶ C only, no Rust yet.</p>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building BL602 firmware</a></p>
</li>
<li>
<p>Next the script <strong>compiles our Rust code</strong> into a static library: <code>libapp.a</code></p>
<div class="example-wrap"><pre class="language-text"><code>----- Build Rust Library
+ rustup default nightly

+ cargo build \
    --target ../riscv32imacf-unknown-none-elf.json \
    -Z build-std=core

Updating crates.io index
Compiling compiler_builtins v0.1.39
Compiling core v0.0.0
...
Compiling app v0.0.1
Finished dev [unoptimized + debuginfo] target(s) in 29.47s
</code></pre></div>
<p>Yep this command looks odd‚Ä¶ It‚Äôs compiling our Rust code with a JSON target file! (<code>riscv32imacf-unknown-none-elf.json</code>)</p>
<p>We‚Äôll learn why in a while.</p>
</li>
<li>
<p>The script <strong>overwrites the Stub Library</strong> in our firmware build (<code>librust-app.a</code>) by the Rust static library (<code>libapp.a</code>)</p>
<div class="example-wrap"><pre class="language-text"><code>+ cp rust/target/riscv32imacf-unknown-none-elf/debug/libapp.a \
    build_out/rust-app/librust-app.a
</code></pre></div></li>
<li>
<p>Finally the script <strong>links the Rust static library</strong> into our BL602 firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Link BL602 Firmware with Rust Library
+ make
use existing version.txt file
LD build_out/sdk_app_rust.elf
Generating BIN File to build_out/sdk_app_rust.bin
...
Building Finish. To flash build output.
</code></pre></div>
<p>Ignore the error from <code>blflash</code>, we‚Äôll fix this in a while.</p>
</li>
<li>
<p>Our <strong>BL602 Rust Firmware file</strong> has been generated at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>build_out/sdk_app_rust.bin
</code></pre></div>
<p>Let‚Äôs flash this to BL602 and run it!</p>
</li>
</ol>
<p>Check out the complete build log here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L135-L523"><strong>Build Log for BL602 Rust Firmware</strong></a></li>
</ul>
<p>(See the Appendix for more about <code>run.sh</code>)</p>
<h1 id="flash-the-bl602-rust-firmware"><a href="#flash-the-bl602-rust-firmware">6 Flash the BL602 Rust Firmware</a></h1>
<p>Here‚Äôs how we flash the Rust Firmware file <code>sdk_app_rust.bin</code> to BL602‚Ä¶</p>
<ol>
<li>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ul>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ul>
<p><strong>For BL10:</strong></p>
<ul>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ul>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ul>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ul>
</li>
<li>
<p><strong>For macOS:</strong></p>
<p>Enter this at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>./run.sh
</code></pre></div>
<p>The script should automatically flash the firmware after building‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Flash BL602 Firmware

+ blflash flash build_out/sdk_app_rust.bin \
    --port /dev/tty.usbserial-1410 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

Finished dev [unoptimized + debuginfo] target(s) in 0.97s
Running `target/debug/blflash flash sdk_app_rust.bin --port /dev/tty.usbserial-1410 --initial-baud-rate 230400 --baud-rate 230400`
Start connection...
5ms send count 115
handshake sent elapsed 145.949¬µs
Connection Succeed
Bootrom version: 1
Boot info: BootInfo { len: 14, bootrom_version: 1, otp_info: [0, 0, 0, 0, 3, 0, 0, 0, 61, 9d, c0, 5, b9, 18, 1d, 0] }
Sending eflash_loader...
Finished 1.6282326s 17.55KB/s
5ms send count 115
handshake sent elapsed 54.259¬µs
Entered eflash_loader
Skip segment addr: 0 size: 47504 sha256 matches
Skip segment addr: e000 size: 272 sha256 matches
Skip segment addr: f000 size: 272 sha256 matches
Erase flash addr: 10000 size: 118224
Program flash... bac8824299e4d6bb0cceb1f93323f43ae6f56500f39c827590eb011b057ec282
Program done 6.54650345s 17.64KB/s
Skip segment addr: 1f8000 size: 5671 sha256 matches
Success
</code></pre></div>
<p>(We might need to edit the script to use the right serial port)</p>
</li>
<li>
<p><strong>For Linux and Windows:</strong></p>
<p>Copy <code>build_out/sdk_app_rust.bin</code> to the <code>blflash</code> folder.</p>
<p>Then enter this at the command prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the downloaded blflash folder
cd blflash

## For Linux:
blflash flash build_out/sdk_app_lora.bin \
    --port /dev/ttyUSB0

## For Windows: Change COM5 to the BL602 Serial Port
blflash flash c:\blflash\sdk_app_lora.bin --port COM5
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
</li>
</ol>
<h1 id="run-the-bl602-rust-firmware"><a href="#run-the-bl602-rust-firmware">7 Run the BL602 Rust Firmware</a></h1>
<p>Finally we run the BL602 Rust Firmware‚Ä¶</p>
<ol>
<li>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ul>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ul>
<p><strong>For BL10:</strong></p>
<ul>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ul>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ul>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ul>
</li>
<li>
<p><strong>For macOS:</strong></p>
<p>The <code>run.sh</code> script should automatically launch CoolTerm after flashing‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Run BL602 Firmware
+ open -a CoolTerm
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More about CoolTerm</a></p>
</li>
<li>
<p><strong>For Linux:</strong></p>
<p>Connect to BL602‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div></li>
<li>
<p><strong>For Windows:</strong> </p>
<p>Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
</li>
<li>
<p><strong>Alternatively:</strong> </p>
<p>Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
</li>
<li>
<p>In the serial console, press Enter to reveal the command prompt.</p>
<p>Enter <code>help</code> to show the commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>help
====Build-in Commands====
====Support 4 cmds once, seperate by ; ====
help                     : print this
p                        : print memory
m                        : modify memory
echo                     : echo for command
exit                     : close CLI
devname                  : print device name
sysver                   : system version
reboot                   : reboot system
poweroff                 : poweroff system
reset                    : system reset
time                     : system time
ota                      : system ota
ps                       : thread dump
ls                       : file list
hexdump                  : dump file
cat                      : cat file

====User Commands====
rust_main                : Run Rust code
blogset                  : blog pri set level
blogdump                 : blog info dump
bl_sys_time_now          : sys time now
</code></pre></div></li>
<li>
<p>Enter <code>rust_main</code> to run our Rust code‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>rust_main
</code></pre></div>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Hello from Rust!
</code></pre></div>
<p>And the LED on our BL602 board blinks 5 times.</p>
<p>That‚Äôs how we build, flash and run Rust Firmware with BL602 IoT SDK!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/rust-coolterm.png" alt="Our BL602 Rust Firmware running with CoolTerm" /></p>
<p><em>Our BL602 Rust Firmware running with CoolTerm</em></p>
<h1 id="rust-targets"><a href="#rust-targets">8 Rust Targets</a></h1>
<p><em>Why did we compile our Rust Firmware with this unusual JSON target?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>cargo build \
    --target ../riscv32imacf-unknown-none-elf.json \
    -Z build-std=core
</code></pre></div>
<p>Watch what happens when we compile our Rust Firmware the conventional way for 32-bit RISC-V microcontrollers <a href="https://lupyuen.github.io/articles/porting-apache-mynewt-os-to-gigadevice-gd32-vf103-on-risc-v">(like GD32VF103)</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo build \
    --target riscv32imac-unknown-none-elf
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/debug#install-rust">(We‚Äôve previously used this for BL602)</a></p>
<p><strong><code>riscv32imac</code></strong> describes the capabilities of our RISC-V CPU‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Designation</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>rv32i</code></strong></td><td style="text-align: left">32-bit RISC-V with Base Integer Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>m</code></strong></td><td style="text-align: left">Integer Multiplication + Division</td></tr>
<tr><td style="text-align: center"><strong><code>a</code></strong></td><td style="text-align: left">Atomic Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>c</code></strong></td><td style="text-align: left">Compressed Instructions</td></tr>
</tbody></table>
</div>
<p><a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions">(Here‚Äôs the whole list)</a></p>
<p>When we link the compiled Rust code with BL602 IoT SDK, the GCC Linker fails with this error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Can&#39;t link soft-float modules with single-float modules
</code></pre></div>
<p><a href="https://twitter.com/MisterTechBlog/status/1383075111431938051">(See this)</a></p>
<p><em>Why?</em></p>
<h2 id="bl602-supports-hardware-floating-point"><a href="#bl602-supports-hardware-floating-point">8.1 BL602 supports Hardware Floating-Point</a></h2>
<p>That‚Äôs because the full designation of BL602 is actually <strong><code>riscv32-imacfx</code></strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust-target.png" alt="BL602 Target is riscv32-imacfx" /></p>
<p>Which means that BL602 supports <strong>Hardware Floating-Point</strong> (Single Precision)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust-riscv.png" alt="RISC-V ISA Base and Extensions" /></p>
<p>BL602 IoT SDK was compiled with this GCC command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gcc -march=rv32imfc -mabi=ilp32f ...
</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/make_scripts_riscv/project.mk#L223-L224">(See this)</a></p>
<p>UPDATE: NuttX BL602 was compiled with‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gcc -march=rv32imafc -mabi=ilp32f ...
</code></pre></div>
<p>(Note that it‚Äôs ‚Äú<code>imfc</code>‚Äù vs ‚Äú<code>imafc</code>‚Äù)</p>
<p>This produces binaries that contain RISC-V <strong>Floating-Point Instructions</strong>.</p>
<p>Which are not compatible with our Rust binaries, which use <strong>Software Floating-Point</strong>.</p>
<p>Hence we have a <strong>Software vs Hardware Floating-Point conflict</strong> between the compiled Rust code and the compiled BL602 IoT SDK.</p>
<h2 id="selecting-another-rust-target"><a href="#selecting-another-rust-target">8.2 Selecting another Rust Target</a></h2>
<p><em>Is there another Rust Target that we can use for BL602?</em></p>
<p>Let‚Äôs hunt for a Rust Target for <strong>32-bit RISC-V that supports Hardware Floating Point</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>rustc --print target-list
</code></pre></div>
<p>Here are the Rust Targets for RISC-V‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv32gc-unknown-linux-gnu
riscv32gc-unknown-linux-musl
riscv32i-unknown-none-elf
riscv32imac-unknown-none-elf
riscv32imc-unknown-none-elf
riscv64gc-unknown-linux-gnu
riscv64gc-unknown-linux-musl
riscv64gc-unknown-none-elf
riscv64imac-unknown-none-elf
</code></pre></div>
<p>Strike off the 64-bit RISC-V targets, and we get‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv32gc-unknown-linux-gnu
riscv32gc-unknown-linux-musl
riscv32i-unknown-none-elf
riscv32imac-unknown-none-elf
riscv32imc-unknown-none-elf
</code></pre></div>
<p>For embedded platforms we pick the targets that support <code>ELF</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv32i-unknown-none-elf
riscv32imac-unknown-none-elf
riscv32imc-unknown-none-elf
</code></pre></div>
<p>Bummer‚Ä¶ None of these Built-In Rust Targets support Hardware Floating-Point!</p>
<p>(They‚Äôre missing the <strong>‚Äú<code>f</code>‚Äù</strong> designator for Hardware Floating-Point)</p>
<p>Fortunately Rust lets us create <strong>Custom Rust Targets</strong>. Let‚Äôs create one for BL602!</p>
<p><a href="https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target">More about Built-In Rust Targets</a></p>
<h1 id="custom-rust-target-for-bl602"><a href="#custom-rust-target-for-bl602">9 Custom Rust Target for BL602</a></h1>
<p>We‚Äôre creating a <strong>Custom Rust Target</strong> for BL602 because‚Ä¶</p>
<ul>
<li>
<p>We can‚Äôt link Rust code (compiled for <strong>Software Floating-Point</strong>) with BL602 IoT SDK (compiled for <strong>Hardware Floating-Point</strong>)</p>
</li>
<li>
<p>Existing 32-bit RISC-V Rust Targets <strong>don‚Äôt support Hardware Floating-Point</strong></p>
</li>
</ul>
<p>Here‚Äôs how we create the Custom Rust Target for BL602: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/riscv32imacf-unknown-none-elf.json"><code>riscv32imacf-unknown-none-elf.json</code></a></p>
<ol>
<li>
<p>We <strong>export an existing Rust Target</strong> <code>riscv32imac-unknown-none-elf</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>rustc +nightly \
    -Z unstable-options \
    --print target-spec-json \
    --target riscv32imac-unknown-none-elf \
    &gt;riscv32imac-unknown-none-elf.json
</code></pre></div>
<p>Here‚Äôs the JSON Target File for <code>riscv32imac-unknown-none-elf</code>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/riscv32imac-unknown-none-elf.json">riscv32imac-unknown-none-elf.json: Software Floating-Point</a></li>
</ul>
</li>
<li>
<p>We <strong>modify the JSON Target File</strong> to support Hardware Floating-Point.</p>
<p>First we add ‚Äú<code>+f</code>‚Äù to ‚Äú<code>features</code>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>&quot;features&quot;: &quot;+m,+a,+c,+f&quot;,
</code></pre></div></li>
<li>
<p>We set the <strong>Application Binary Interface</strong> so that the Rust Compiler will produce binaries for Hardware Floating-Point‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>&quot;llvm-abiname&quot;: &quot;ilp32f&quot;,
</code></pre></div>
<p>We discovered this from the GCC command that compiles the BL602 IoT SDK‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gcc -march=rv32imfc -mabi=ilp32f ...
</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/make_scripts_riscv/project.mk#L223-L224">(See this)</a></p>
</li>
<li>
<p>We set <strong>‚Äú<code>is-builtin</code>‚Äù</strong> to false since this is a Custom Rust Target‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>&quot;is-builtin&quot;: false,
</code></pre></div></li>
<li>
<p>Save the modified JSON Target File as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv32imacf-unknown-none-elf.json
</code></pre></div>
<p>(Which has the ‚Äú<code>f</code>‚Äù designator for Hardware Floating-Point)</p>
</li>
<li>
<p>Now we may <strong>compile our Rust code</strong> with the Custom Rust Target‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo build \
    --target riscv32imacf-unknown-none-elf.json \
    -Z build-std=core
</code></pre></div>
<p>We specify ‚Äú<code>-Z build-std=core</code>‚Äù so that the Rust Compiler will <strong>rebuild the Rust Core Library</strong> for our Custom Rust Target.</p>
</li>
</ol>
<p>Here‚Äôs our Custom Rust Target for Hardware Floating-Point: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/riscv32imacf-unknown-none-elf.json"><code>riscv32imacf-unknown-none-elf.json</code></a></p>
<div class="example-wrap"><pre class="language-json"><code>{
  &quot;arch&quot;: &quot;riscv32&quot;,
  &quot;cpu&quot;: &quot;generic-rv32&quot;,
  &quot;data-layout&quot;: &quot;e-m:e-p:32:32-i64:64-n32-S128&quot;,
  &quot;eh-frame-header&quot;: false,
  &quot;emit-debug-gdb-scripts&quot;: false,
  &quot;executables&quot;: true,
  &quot;features&quot;: &quot;+m,+a,+c,+f&quot;,
  &quot;is-builtin&quot;: false,
  &quot;linker&quot;: &quot;rust-lld&quot;,
  &quot;linker-flavor&quot;: &quot;ld.lld&quot;,
  &quot;llvm-abiname&quot;: &quot;ilp32f&quot;,
  &quot;llvm-target&quot;: &quot;riscv32&quot;,
  &quot;max-atomic-width&quot;: 32,
  &quot;panic-strategy&quot;: &quot;abort&quot;,
  &quot;relocation-model&quot;: &quot;static&quot;,
  &quot;target-pointer-width&quot;: &quot;32&quot;
}
</code></pre></div>
<p><em>How did we figure out the changes for ‚Äú<code>features</code>‚Äù and ‚Äú<code>llvm-abiname</code>‚Äù?</em></p>
<p>By exporting and comparing the Rust Targets for <code>riscv32imac</code> (32-bit Software Floating-Point) and <code>riscv64gc-unknown-none-elf</code> (64-bit Hardware Floating-Point).</p>
<p><a href="https://docs.rust-embedded.org/embedonomicon/custom-target.html">More about Custom Rust Targets</a></p>
<h1 id="rust-on-bl602-two-more-ways"><a href="#rust-on-bl602-two-more-ways">10 Rust On BL602: Two More Ways</a></h1>
<p>Since Oct 2020 the Sipeed BL602 Community has started porting <strong>Embedded Rust to Bare Metal BL602</strong> (without BL602 IoT SDK)‚Ä¶</p>
<ul>
<li><a href="https://github.com/sipeed/bl602-rust-guide"><strong><code>sipeed/bl602-rust-guide</code></strong></a></li>
</ul>
<p>Embedded Rust on BL602 has its own <strong>Hardware Abstraction Layer</strong>, which is in <a href="https://github.com/sipeed/bl602-hal/commits/main">active development</a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/sipeed/bl602-hal"><strong><code>sipeed/bl602-hal</code></strong></a></li>
</ul>
<p>This version of Embedded Rust doesn‚Äôt run in XIP Flash Memory, instead it runs in <strong>Cache Memory</strong> (ITCM / DTCM, similar to RAM). <a href="https://github.com/sipeed/bl602-rust-guide/blob/main/memory.x">(See this)</a></p>
<p>Here‚Äôs how we use a <strong>JTAG Adapter</strong> (instead of flashing over UART) to run Embedded Rust on BL602 (from Dec 2020)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/debug"><strong>‚ÄúDebug Rust on PineCone BL602 with VSCode and GDB‚Äù</strong></a></li>
</ul>
<p>In Feb 2021 <a href="https://github.com/9names"><code>9names</code></a> created a new project that runs the Embedded Rust HAL in <strong>XIP Flash Memory</strong> and works with UART flashing‚Ä¶</p>
<ul>
<li><a href="https://github.com/9names/bl602-rust-example"><strong><code>9names/bl602-rust-example</code></strong></a></li>
</ul>
<p><code>9names</code> has also created an interesting Rust library that wraps the BL602 ROM functions‚Ä¶</p>
<ul>
<li><a href="https://github.com/9names/bl602-rom-wrapper"><strong><code>9names/bl602-rom-wrapper</code></strong></a></li>
</ul>
<h1 id="apache-nuttx-on-bl602"><a href="#apache-nuttx-on-bl602">11 Apache NuttX on BL602</a></h1>
<p><strong>Apache NuttX</strong> OS has been ported recently to BL602 (Jan 2021)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx"><strong>‚ÄúApache NuttX OS on RISC-V BL602 and BL604‚Äù</strong></a></li>
</ul>
<p>NuttX runs on Bare Metal BL602 in <strong>XIP Flash Memory</strong> (flashed over UART), without BL602 IoT SDK.</p>
<p>We might be seeing <strong>Rust on NuttX</strong>‚Ä¶</p>
<ul>
<li><a href="https://www.reddit.com/r/rust/comments/mbgujl/rust_integration_on_nuttx/"><strong>Rust on NuttX</strong></a></li>
</ul>
<p>If you‚Äôre keen to contribute, please sign up above!</p>
<h2 id="rust-on-apache-mynewt"><a href="#rust-on-apache-mynewt">11.1 Rust on Apache Mynewt</a></h2>
<p><em>What about Rust on Apache Mynewt for BL602?</em></p>
<p>We talked about Rust on Mynewt back in Jan 2021‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/gpio#but-why-mynewt"><strong>‚ÄúBut Why Mynewt?‚Äù</strong></a></li>
</ul>
<p>We planned to port Mynewt to BL602 by <strong>reusing a subset of the BL602 IoT SDK</strong>. (Specifically, the BL602 HALs.) We have integrated the BL602 GPIO HAL with Mynewt. <a href="https://lupyuen.github.io/articles/gpio">(See this)</a></p>
<p>Sadly there‚Äôs little interest in supporting Mynewt on BL602. (And we might have problems running Mynewt in XIP Flash)</p>
<p>That‚Äôs why today we‚Äôre running Rust on BL602 IoT SDK (with FreeRTOS inside).</p>
<h2 id="graphical-flow-programming"><a href="#graphical-flow-programming">11.2 Graphical Flow Programming</a></h2>
<p>When we have a stable implementation of Rust on BL602, perhaps we can do <strong>Graphical Flow Programming</strong> on BL602‚Ä¶</p>
<p><a href="https://twitter.com/MisterTechBlog/status/1380926479094059011?s=20">Check out this Twitter Thread</a></p>
<p><img src="https://lupyuen.github.io/images/rust-flow.png" alt="Graphical Flow Programming with Rete.js" /></p>
<h2 id="but-why-c"><a href="#but-why-c">11.3 But Why C?</a></h2>
<p><em>But seriously‚Ä¶ Why are we still coding BL602 Firmware in C? Why not code everything in Rust?</em></p>
<p>Because <strong>some BL602 features work better in C</strong> than in Rust. </p>
<p>Like <strong>SPI with DMA</strong>, which is useful for SPI displays that require high-bandwidth data transfer.</p>
<p><a href="https://lupyuen.github.io/articles/spi#spi-with-direct-memory-access">More about BL602 SPI with DMA</a></p>
<h1 id="whats-next"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>In our next BL602 article we shall head back to <strong>LoRaWAN, the low-power, long range IoT network</strong>. <a href="https://lupyuen.github.io/articles/lora2#whats-next">(See this)</a></p>
<p>Check out the new article on <strong>Rust Wrapper for BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/adc"><strong>‚ÄúRust on RISC-V BL602: Is It Sunny?‚Äù</strong></a></li>
</ul>
<p>Please drop me a note if you would like to see more <strong>Rust on BL602 IoT SDK</strong>!</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/mv83jl/run_rust_riscv_firmware_with_bl602_iot_sdk/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rust.md"><code>lupyuen.github.io/src/rust.md</code></a></p>
<p><img src="https://lupyuen.github.io/images/rust-wrapper.png" alt="Auto-generating Rust Wrappers for BL602 IoT SDK with bl602-rust-wrapper" /></p>
<p><em>Auto-generating Rust Wrappers for BL602 IoT SDK with <code>bl602-rust-wrapper</code></em></p>
<h1 id="notes"><a href="#notes">13 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1383219945308184578">this Twitter Thread</a></p>
</li>
<li>
<p>We‚Äôre using the demo-friendly command-line interface for our BL602 firmware, and <code>rust_main</code> looks like some kind of script‚Ä¶ But <code>rust_main</code> is actually compiled Rust code!</p>
<p>Our Rust firmware runs exactly the same way as C firmware, compiled into efficient RISC-V machine code. <a href="https://www.reddit.com/r/PINE64official/comments/mv858f/run_rust_riscv_firmware_with_bl602_iot_sdk/gvem3zy?utm_source=share&amp;utm_medium=web2x&amp;context=3">(More about this)</a></p>
</li>
</ol>
<h1 id="appendix-build-script-for-bl602-rust-firmware"><a href="#appendix-build-script-for-bl602-rust-firmware">14 Appendix: Build Script for BL602 Rust Firmware</a></h1>
<p>Let‚Äôs look inside the script that builds, flashes and runs our Rust Firmware for BL602: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L10-L23"><code>run.sh</code></a></p>
<ol>
<li>
<p>The script begins with the build and flash settings‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Name of app
export APP_NAME=sdk_app_rust

##  Build for BL602
export CONFIG_CHIP_NAME=BL602

##  Where BL602 IoT SDK is located
export BL60X_SDK_PATH=$PWD/../..

##  Where blflash is located
export BLFLASH_PATH=$PWD/../../../blflash

##  Where GCC is located
export GCC_PATH=$PWD/../../../xpack-riscv-none-embed-gcc
</code></pre></div>
<p>(Change BLFLASH_PATH and GCC_PATH for your machine)</p>
<p>The script was created for macOS, but should run on Linux and Windows (WSL) with minor tweaks.</p>
</li>
<li>
<p>Next we define the Custom Rust Target that supports Hardware Floating-Point‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L29-L33"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Rust target: Custom target for llvm-abiname=ilp32f
##  https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target
##  https://docs.rust-embedded.org/embedonomicon/custom-target.html
rust_build_target=$PWD/riscv32imacf-unknown-none-elf.json
rust_build_target_folder=riscv32imacf-unknown-none-elf
</code></pre></div></li>
<li>
<p>We remove the Stub Library and the Rust Library is they exist‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L61-L71"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Remove the Stub Library if it exists:
##  build_out/rust-app/librust-app.a
if [ -e $rust_app_dest ]; then
    rm $rust_app_dest
fi

##  Remove the Rust Library if it exists:
##  rust/target/riscv32imacf-unknown-none-elf/debug/libapp.a
if [ -e $rust_app_build ]; then
    rm $rust_app_build
fi
</code></pre></div>
<p>(More about Stub Library in the next section)</p>
</li>
<li>
<p>We build the BL602 firmware with the Stub Library‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L77-L78"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Build the firmware with the Stub Library
make
</code></pre></div>
<p>This build contains only C code, no Rust code.</p>
</li>
<li>
<p>We compile the Rust Library with our Custom Rust Target that supports Hardware Floating-Point‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L84-L88"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Build the Rust Library
pushd rust
rustup default nightly
cargo build $rust_build_options
popd
</code></pre></div>
<p>The Rust Compiler command looks like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo build \
    --target ../riscv32imacf-unknown-none-elf.json \
    -Z build-std=core
</code></pre></div></li>
<li>
<p>We overwrite the Stub Library by the compiled Rust Library‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L90-L94"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Replace the Stub Library by the compiled Rust Library
##  Stub Library: build_out/rust-app/librust-app.a
##  Rust Library: rust/target/riscv32imacf-unknown-none-elf/debug/libapp.a
cp $rust_app_build $rust_app_dest
</code></pre></div></li>
<li>
<p>We link the compiled Rust Library into the BL602 Firmware‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L100-L101"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Link the Rust Library to the firmware
make
</code></pre></div>
<p>This creates the BL602 Rust Firmware file‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>build_out/sdk_app_rust.bin
</code></pre></div></li>
<li>
<p>We copy the BL602 Rust Firmware file to the <code>blflash</code> folder and flash to BL602‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L110-L124"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Copy firmware to blflash
cp build_out/$APP_NAME.bin $BLFLASH_PATH

##  Flash the firmware
pushd $BLFLASH_PATH
blflash flash build_out/$APP_NAME.bin \
    --port /dev/tty.usbserial-14* \
    --initial-baud-rate 230400 \
    --baud-rate 230400
sleep 5
popd
</code></pre></div>
<p>The <code>cargo run flash</code> command needs to be modified for Linux and WSL.</p>
</li>
<li>
<p>Finally we launch CoolTerm to run the BL602 Rust Firmware‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L130-L131"><code>run.sh</code></a></p>
<div class="example-wrap"><pre class="language-bash"><code>##  Run the firmware
open -a CoolTerm
</code></pre></div>
<p>This needs to be modified for Linux and WSL.</p>
</li>
</ol>
<p>Check out the complete build log here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh#L135-L523"><strong>Build Log for BL602 Rust Firmware</strong></a></li>
</ul>
<h1 id="appendix-stub-library-for-bl602-rust"><a href="#appendix-stub-library-for-bl602-rust">15 Appendix: Stub Library for BL602 Rust</a></h1>
<p>The build script <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/run.sh"><code>run.sh</code></a> links the compiled Rust code into the BL602 firmware by overwriting the compiled <code>rust_app</code> Stub Library‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/3rdparty/rust-app"><code>rust-app</code>: BL602 Stub Library for Rust Application</a></li>
</ul>
<p>This library contains a stub function for <code>rust_main</code>‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/3rdparty/rust-app/src/rust-app.c"><code>rust-app.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main function in Rust.
/// TODO: Sync with customer_app/sdk_app_rust/sdk_app_rust/demo.c
void rust_main(char *buf, int len, int argc, char **argv) {
    printf(&quot;Build Error: components/3rdparty/rust-app not replaced by Rust compiled code\r\n&quot;);
}
</code></pre></div>
<p><em>Why do we need the stub function <code>rust_main</code>?</em></p>
<p>Because <code>rust_main</code> is referenced by our C code when defining the commands for our Command-Line Interface‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/sdk_app_rust/demo.c#L7-L16"><code>sdk_app_rust/demo.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  TODO: Sync with components/3rdparty/rust-app/src/rust-app.c
void rust_main(char *buf, int len, int argc, char **argv);

/// List of commands
const static struct cli_command cmds_user[] STATIC_CLI_CMD_ATTRIBUTE = {
    {
        &quot;rust_main&quot;,    
        &quot;Run Rust code&quot;,
        rust_main
    }
};
</code></pre></div>
<p>If we omit <code>rust_main</code> from our Stub Library, our GitHub Actions build will fail. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/.github/workflows/build.yml">(See this)</a></p>
<h1 id="appendix-expose-inline-functions-to-rust"><a href="#appendix-expose-inline-functions-to-rust">16 Appendix: Expose Inline Functions to Rust</a></h1>
<p>Many functions from the <a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer">NimBLE Porting Layer</a> are declared as ‚Äú<code>static inline</code>‚Äù‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/3rdparty/nimble-porting-layer/include/nimble_npl_os.h#L270-L274"><code>nimble_npl_os.h</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  static inline function
static inline void ble_npl_time_delay(ble_npl_time_t ticks) { ... }
</code></pre></div>
<p>This becomes a problem when we import <code>ble_npl_time_delay</code> into Rust‚Ä¶ <code>ble_npl_time_delay</code> isn‚Äôt really a C function, it has been inlined into the calling C function!</p>
<p>To work around this we disable the <code>static</code> and <code>inline</code> keyworks‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Disable static inline
#define static
#define inline
</code></pre></div>
<p>So the GCC Compiler compiles our static inline function as regular non-inline function‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void ble_npl_time_delay(ble_npl_time_t ticks) { ... }
</code></pre></div>
<p>(Yeah it‚Äôs sneaky)</p>
<p>Here‚Äôs how we implement this for our BL602 Rust Firmware‚Ä¶</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_rust/sdk_app_rust/nimble.c">From <code>sdk_app_rust/nimble.c</code></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Export the inline functions for NimBLE Porting Layer to Rust
//  TODO: Move this to nimble-porting-layer library

//  Include FreeRTOS before NPL, so that FreeRTOS will be inlined
#include &quot;FreeRTOS.h&quot;

//  Disable static inline so:
//    static inline void ble_npl_time_delay(ble_npl_time_t ticks) { ... }
//  Becomes:
//    void ble_npl_time_delay(ble_npl_time_t ticks) { ... }
#define static
#define inline

//  Define the functions like:
//    void ble_npl_time_delay(ble_npl_time_t ticks) { ... }
#include &quot;nimble_npl.h&quot;
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rust-crab.jpg" alt="PineCone BL602 RISC-V Board" /></p>

    
</body>
</html>