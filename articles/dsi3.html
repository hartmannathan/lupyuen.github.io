<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: MIPI Display Serial Interface</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: MIPI Display Serial Interface" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX Kernel has a driver for MIPI Display Interface... Here's how it will be called for rendering PinePhone's LCD Display"
    data-rh="true">
<meta name="description" 
    content="Apache NuttX Kernel has a driver for MIPI Display Interface... Here's how it will be called for rendering PinePhone's LCD Display">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/dsi3-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: MIPI Display Serial Interface</h1>
    <nav id="TOC"><ul>
<li><a href="#complete-display-driver-for-pinephone">1 Complete Display Driver for PinePhone</a><ul></ul></li>
<li><a href="#nuttx-driver-for-mipi-display-serial-interface">2 NuttX Driver for MIPI Display Serial Interface</a><ul></ul></li>
<li><a href="#send-mipi-dsi-packet">3 Send MIPI DSI Packet</a><ul></ul></li>
<li><a href="#enable-mipi-dsi-and-d-phy">4 Enable MIPI DSI and D-PHY</a><ul></ul></li>
<li><a href="#convert-zig-to-c">5 Convert Zig to C</a><ul></ul></li>
<li><a href="#test-mipi-dsi-driver">6 Test MIPI DSI Driver</a><ul>
<li><a href="#unit-testing">6.1 Unit Testing</a><ul></ul></li>
<li><a href="#local-testing">6.2 Local Testing</a><ul></ul></li></ul></li>
<li><a href="#upcoming-nuttx-drivers">7 Upcoming NuttX Drivers</a><ul></ul></li>
<li><a href="#why-zig">8 Why Zig</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-upcoming-nuttx-drivers">10 Appendix: Upcoming NuttX Drivers</a><ul>
<li><a href="#timing-controller-tcon0">10.1 Timing Controller (TCON0)</a><ul></ul></li>
<li><a href="#display-engine">10.2 Display Engine</a><ul></ul></li>
<li><a href="#backlight">10.3 Backlight</a><ul></ul></li>
<li><a href="#lcd-panel">10.4 LCD Panel</a><ul></ul></li>
<li><a href="#power-management-integrated-circuit">10.5 Power Management Integrated Circuit</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>18 Dec 2022</em></p>
<p><img src="https://lupyuen.github.io/images/dsi3-title.jpg" alt="Rendering graphics on PinePhone with Apache NuttX RTOS" /></p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> (pic above) will soon support the rendering of graphics on the LCD Display‚Ä¶ When we boot the official release of <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a>!</p>
<p>We‚Äôre building the <strong>NuttX Display Driver</strong> for PinePhone in small chunks, starting with the driver for <a href="https://lupyuen.github.io/articles/dsi"><strong>MIPI Display Serial Interface</strong></a>.</p>
<p>In this article we‚Äôll learn‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs needed to create a <strong>Complete Display Driver</strong> for PinePhone</p>
</li>
<li>
<p>How our driver for <strong>MIPI Display Serial Interface</strong> fits into the grand plan</p>
</li>
<li>
<p>How we‚Äôre building the <strong>missing pieces</strong> of the PinePhone Display Driver</p>
</li>
<li>
<p>Why most of the Display Driver is in the <a href="https://ziglang.org/"><strong>Zig Programming Language</strong></a></p>
</li>
</ul>
<p>Let‚Äôs continue the (super looong) journey from our <strong>NuttX Porting Journal</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/dsi3-steps.jpg" alt="Inside our Complete Display Driver for PinePhone" /></p>
<h1 id="complete-display-driver-for-pinephone"><a href="#complete-display-driver-for-pinephone">1 Complete Display Driver for PinePhone</a></h1>
<p><em>NuttX will render graphics on PinePhone‚Äôs LCD Display‚Ä¶</em></p>
<p><em>What‚Äôs inside the Display Driver for PinePhone?</em></p>
<p>Through <strong>Reverse Engineering</strong> (and plenty of experimenting), we discovered that these steps are needed to create a <strong>Complete Display Driver</strong> for PinePhone (pic above)‚Ä¶</p>
<ol>
<li>
<p>Turn on PinePhone‚Äôs <strong>Display Backlight</strong></p>
<p>(Through Programmable I/O and Pulse-Width Modulation)</p>
</li>
<li>
<p>Initialise Allwinner A64‚Äôs <strong>Timing Controller (TCON0)</strong></p>
<p>(Which will pump pixels continuously to the LCD Display)</p>
</li>
<li>
<p>Initialise PinePhone‚Äôs <strong>Power Management Integrated Circuit (PMIC)</strong></p>
<p>(To power on PinePhone‚Äôs LCD Panel)</p>
</li>
<li>
<p>Enable Allwinner A64‚Äôs <strong>MIPI Display Serial Interface (DSI)</strong></p>
<p>(So we can send MIPI DSI commands to the LCD Panel)</p>
</li>
<li>
<p>Enable Allwinner A64‚Äôs <strong>MIPI Display Physical Layer (D-PHY)</strong></p>
<p>(Which is the communications layer inside MIPI DSI)</p>
</li>
<li>
<p>Reset PinePhone‚Äôs <strong>LCD Panel</strong></p>
<p>(Prep it to receive MIPI DSI Commands)</p>
</li>
<li>
<p>Initialise PinePhone‚Äôs <strong>LCD Controller (Sitronix ST7703)</strong></p>
<p>(Send the Initialisation Commands over MIPI DSI)</p>
</li>
<li>
<p>Start Allwinner A64‚Äôs <strong>MIPI DSI in HSC and HSD Mode</strong></p>
<p>(High Speed Clock Mode with High Speed Data Transmission)</p>
</li>
<li>
<p>Initialise Allwinner A64‚Äôs <strong>Display Engine (DE)</strong></p>
<p>(Start pumping pixels from DE to Timing Controller TCON0)</p>
</li>
<li>
<p>Wait a while</p>
<p>(160 milliseconds)</p>
</li>
<li>
<p>Render Graphics with Allwinner A64‚Äôs <strong>Display Engine (DE)</strong></p>
<p>(Start pumping pixels from RAM Framebuffers to DE via Direct Memory Access)</p>
</li>
</ol>
<p>Let‚Äôs talk about each step and their NuttX Drivers‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi-title.jpg" alt="LCD Display on PinePhone Schematic (Page 2)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>LCD Display on PinePhone Schematic (Page 2)</em></a></p>
<h1 id="nuttx-driver-for-mipi-display-serial-interface"><a href="#nuttx-driver-for-mipi-display-serial-interface">2 NuttX Driver for MIPI Display Serial Interface</a></h1>
<p>The very first NuttX Driver we‚Äôve implemented is for <strong>MIPI Display Serial Interface (DSI)</strong>.</p>
<p><em>Why is MIPI DSI needed in PinePhone?</em></p>
<p>PinePhone talks to its LCD Panel (<a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>Xingbangda XBD599</strong></a>) via the <strong>MIPI DSI Bus</strong> on Allwinner A64 SoC.</p>
<p>That‚Äôs why we need a MIPI DSI Driver in the NuttX Kernel.</p>
<p><em>So our MIPI DSI Driver will render graphics on PinePhone‚Äôs LCD Display?</em></p>
<p>It gets complicated‚Ä¶</p>
<ul>
<li>
<p><strong>At Startup:</strong> Our driver sends MIPI DSI Commands to initialise PinePhone‚Äôs LCD Controller: <a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>Sitronix ST7703</strong></a></p>
<p>(ST7703 is inside the Xingbangda XBD599 LCD Panel)</p>
</li>
<li>
<p><strong>After Startup:</strong> Allwinner A64‚Äôs <a href="https://lupyuen.github.io/articles/de"><strong>Display Engine</strong></a> and <a href="https://lupyuen.github.io/articles/de#display-rendering-on-pinephone"><strong>Timing Controller (TCON0)</strong></a> pumps pixels continuously to the LCD Panel over MIPI DSI.</p>
<p>(Bypassing our MIPI DSI Driver)</p>
</li>
</ul>
<p>Thus our MIPI DSI Driver is called <strong>only at startup</strong> to initialise the LCD Controller (ST7703).</p>
<p><em>Sounds super complicated‚Ä¶</em></p>
<p>Yep but this rendering design is <strong>super efficient</strong>!</p>
<p>PinePhone doesn‚Äôt need to handle Interrupts while rendering the display‚Ä¶ Everything is <strong>done in Hardware!</strong> (Allwinner A64 SoC)</p>
<p>The pixel data is pumped from RAM Framebuffers via Direct Memory Access (DMA). Which is also done in Hardware.</p>
<p>Let‚Äôs dive inside our MIPI DSI Driver‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi3-code.png" alt="Composing a MIPI DSI Short Packet" /></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/mipi_dsi.c#L276-L387"><em>Composing a MIPI DSI Short Packet</em></a></p>
<h1 id="send-mipi-dsi-packet"><a href="#send-mipi-dsi-packet">3 Send MIPI DSI Packet</a></h1>
<p><em>How do we send MIPI DSI Commands to initialise PinePhone‚Äôs LCD Controller?</em></p>
<p>Let‚Äôs take one MIPI DSI Command that initialises the ST7703 LCD Controller: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test_a64_mipi_dsi.c#L52-L60">test_a64_mipi_dsi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Command #1 to init ST7703
const uint8_t cmd1[] = { 
  0xB9,  // SETEXTC (Page 131): Enable USER Command
  0xF1,  // Enable User command
  0x12,  // (Continued)
  0x83   // (Continued)
};

// Send the command to ST7703 over MIPI DSI
write_dcs(cmd1, sizeof(cmd1));</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi#appendix-initialise-lcd-controller">(ST7703 needs 20 Initialisation Commands)</a></p>
<p><strong>write_dcs</strong> sends our command to the MIPI DSI Bus in 3 <strong>DCS Formats</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>DCS Short Write:</strong> For commands with 1 Byte</p>
</li>
<li>
<p><strong>DCS Short Write with Parameter:</strong> For commands with 2 Bytes</p>
</li>
<li>
<p><strong>DCS Long Write:</strong> For commands with 3 Bytes or more</p>
</li>
</ul>
<p>(DCS means Display Command Set)</p>
<div class="example-wrap"><pre class="language-c"><code>/// Write the DCS Command to MIPI DSI
static int write_dcs(FAR const uint8_t *buf, size_t len) {
  // Do DCS Short Write or Long Write depending on command length.
  // A64_MIPI_DSI_VIRTUAL_CHANNEL is 0.
  switch (len) {
    // DCS Short Write (without parameter)
    case 1:
      a64_mipi_dsi_write(A64_MIPI_DSI_VIRTUAL_CHANNEL, 
        MIPI_DSI_DCS_SHORT_WRITE, 
        buf, len);
      break;

    // DCS Short Write (with parameter)
    case 2:
      a64_mipi_dsi_write(A64_MIPI_DSI_VIRTUAL_CHANNEL, 
        MIPI_DSI_DCS_SHORT_WRITE_PARAM, 
        buf, len);
      break;

    // DCS Long Write
    default:
      a64_mipi_dsi_write(A64_MIPI_DSI_VIRTUAL_CHANNEL, 
        MIPI_DSI_DCS_LONG_WRITE, 
        buf, len);
      break;
  };</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test_a64_mipi_dsi.c#L5-L41">(Source)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.h#L35-L39">(We talk to MIPI DSI Bus on Virtual Channel 0)</a></p>
<p><strong>a64_mipi_dsi_write</strong> comes from our NuttX MIPI DSI Driver: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L366-L526">a64_mipi_dsi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Transmit the payload data to the MIPI DSI Bus as a MIPI DSI Short or
// Long Packet. This function is called to initialize the LCD Controller.
// Assumes that the MIPI DSI Block has been enabled on the SoC.
// Returns the number of bytes transmitted.
ssize_t a64_mipi_dsi_write(
  uint8_t channel,      // Virtual Channel (0)
  enum mipi_dsi_e cmd,  // DCS Command (Data Type)
  FAR const uint8_t *txbuf,  // Payload data for the packet
  size_t txlen)  // Length of payload data (Max 65541 bytes)
{
  ...
  // Compose Short or Long Packet depending on DCS Command
  switch (cmd) {
    // For DCS Long Write:
    // Compose Long Packet
    case MIPI_DSI_DCS_LONG_WRITE:
      pktlen = mipi_dsi_long_packet(pkt, sizeof(pkt), channel, cmd, txbuf, txlen);
      break;

    // For DCS Short Write (with and without parameter):
    // Compose Short Packet
    case MIPI_DSI_DCS_SHORT_WRITE:
      pktlen = mipi_dsi_short_packet(pkt, sizeof(pkt), channel, cmd, txbuf, txlen);
      break;

    case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
      pktlen = mipi_dsi_short_packet(pkt, sizeof(pkt), channel, cmd, txbuf, txlen);
      break;
  };</code></pre></div>
<p>Our NuttX Driver calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/mipi_dsi.c#L276-L387"><strong>mipi_dsi_short_packet</strong></a>: Compose a MIPI DSI <a href="https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi"><strong>Short Packet</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi">(More about this)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/mipi_dsi.c#L147-L276"><strong>mipi_dsi_long_packet</strong></a>: Compose a MIPI DSI <a href="https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi"><strong>Long Packet</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi">(More about this)</a></p>
</li>
</ul>
<p>Then our NuttX Driver writes the Short or Long Packet to the <strong>MIPI DSI Registers</strong> of Allwinner A64: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L446-L526">a64_mipi_dsi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Write the packet to DSI Low Power Transmit Package Register
  // at DSI Offset 0x300 (A31 Page 856)
  addr = A64_DSI_ADDR + 0x300;
  for (i = 0; i &lt; pktlen; i += 4) {

    // Fetch the next 4 bytes, fill with 0 if not available
    const uint32_t b[4] = {
      pkt[i],
      (i + 1 &lt; pktlen) ? pkt[i + 1] : 0,
      (i + 2 &lt; pktlen) ? pkt[i + 2] : 0,
      (i + 3 &lt; pktlen) ? pkt[i + 3] : 0
    };

    // Merge the next 4 bytes into a 32-bit value
    const uint32_t v = b[0] + (b[1] &lt;&lt; 8) + (b[2] &lt;&lt; 16) + (b[3] &lt;&lt; 24);

    // Write the 32-bit value to DSI Low Power Transmit Package Register
    modreg32(v, 0xffffffff, addr);
    addr += 4;
  }

  // Omitted: Wait for DSI Transmission to complete</code></pre></div>
<p>And that‚Äôs how our MIPI DSI Packet gets transmitted to the ST7703 LCD Controller, over the MIPI DSI Bus!</p>
<p>We do this 20 times, to send 20 <strong>Initialisation Commands</strong> to the ST7703 LCD Controller‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-initialise-lcd-controller"><strong>‚ÄúInitialise LCD Controller‚Äù</strong></a></li>
</ul>
<p>But wait‚Ä¶ We haven‚Äôt enabled the MIPI DSI Hardware yet!</p>
<h1 id="enable-mipi-dsi-and-d-phy"><a href="#enable-mipi-dsi-and-d-phy">4 Enable MIPI DSI and D-PHY</a></h1>
<p><em>At startup we call the MIPI DSI Driver to send commands to the LCD Controller‚Ä¶</em></p>
<p><em>What about other MIPI DSI Operations?</em></p>
<p>Before sending MIPI DSI Packets, our NuttX Driver needs to enable 2 chunks of hardware on Allwinner A64 SoC‚Ä¶</p>
<ul>
<li>
<p>Enable Allwinner A64‚Äôs <strong>MIPI Display Serial Interface (DSI)</strong></p>
<p>So we can send MIPI DSI commands to the LCD Panel.</p>
<p><a href="https://lupyuen.github.io/articles/dsi#appendix-enable-mipi-dsi-block">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L526-L914">(Implemented as <strong>a64_mipi_dsi_enable</strong>)</a></p>
</li>
<li>
<p>Enable Allwinner A64‚Äôs <strong>MIPI Display Physical Layer (D-PHY)</strong></p>
<p>Which is the communications layer inside MIPI DSI.</p>
<p><a href="https://lupyuen.github.io/articles/dsi#appendix-enable-mipi-display-physical-layer-dphy">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dphy.c#L86-L162">(Implemented as <strong>a64_mipi_dphy_enable</strong>)</a></p>
</li>
</ul>
<p>And after sending the MIPI DSI Packets to initialise our LCD Controller, we need to‚Ä¶</p>
<ul>
<li>
<p>Start Allwinner A64‚Äôs <strong>MIPI DSI in HSC and HSD Mode</strong></p>
<p>That‚Äôs High Speed Clock Mode with High Speed Data Transmission. (Which are probably needed by the Timing Controller TCON0)</p>
<p><a href="https://lupyuen.github.io/articles/dsi#appendix-start-mipi-dsi-hsc-and-hsd">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L914-L993">(Implemented as <strong>a64_mipi_dsi_start</strong>)</a></p>
</li>
</ul>
<p><em>How did we create all this code for our NuttX Driver?</em></p>
<p>Our <strong>NuttX Driver for MIPI DSI</strong> (and MIPI D-PHY) lives in the NuttX Kernel as‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/mipi_dsi.c"><strong>mipi_dsi.c</strong></a>: Compose MIPI DSI Packets (Long, Short, Short with Parameter)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c"><strong>a64_mipi_dsi.c</strong></a>: MIPI Display Serial Interface (DSI) for Allwinner A64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dphy.c"><strong>a64_mipi_dphy.c</strong></a>: MIPI Display Physical Layer (D-PHY) for Allwinner A64</p>
</li>
</ul>
<p>We created the above NuttX Source Files by converting our <strong>Zig MIPI DSI Driver</strong> to C‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig"><strong>display.zig</strong></a>: Zig Driver for MIPI DSI</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/dphy.zig"><strong>dphy.zig</strong></a>: Zig Driver for MIPI D-PHY</p>
</li>
</ul>
<p>(Why Zig? We‚Äôll come back to this)</p>
<p>We created the Zig Drivers by <strong>Reverse-Engineering</strong> the logs that we captured from PinePhone‚Äôs p-boot Bootloader‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Why Reverse Engineer? Because a lot of details are missing from the official docs for Allwinner A64‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><strong>‚ÄúAllwinner A64 User Manual‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/A31_User_Manual_v1.3_20150510.pdf"><strong>‚ÄúAllwinner A31 User Manual‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>‚ÄúAllwinner Display Engine 2.0 Specification‚Äù</strong></a></p>
</li>
</ul>
<p>Let‚Äôs talk about the Zig-to-C Conversion‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi3-zig.jpg" alt="Converting Zig to C" /></p>
<h1 id="convert-zig-to-c"><a href="#convert-zig-to-c">5 Convert Zig to C</a></h1>
<p><em>Our NuttX Driver MIPI Driver was converted from Zig to C‚Ä¶</em></p>
<p><em>Was it difficult to convert Zig to C?</em></p>
<p>Not at all!</p>
<p>This is the <strong>Zig Code</strong> for our MIPI DSI Driver: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L115-L170">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Short Packet
fn composeShortPacket(
  pkt: []u8,    // Buffer for the returned packet
  channel: u8,  // Virtual Channel
  cmd: u8,      // DCS Command (Data Type)
  buf: [*c]const u8,  // Payload data for the packet
  len: usize          // Length of payload data (1 or 2 bytes)
) []const u8 {        // Returns the Short Packet
  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;

  // Data (2 bytes), fill with 0 if Second Byte is missing
  const data = [2]u8 {
    buf[0],                       // First Byte
    if (len == 2) buf[1] else 0,  // Second Byte
  };

  // Data Identifier + Data (3 bytes): For computing Error Correction Code (ECC)
  const di_data = [3]u8 { di, data[0], data[1] };

  // Compute Error Correction Code (ECC) for Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_data);

  // Packet Header (4 bytes):
  // - Data Identifier + Data + Error Correction Code
  const header = [4]u8 { di_data[0], di_data[1], di_data[2], ecc };

  // Packet:
  // - Packet Header (4 bytes)
  const pktlen = header.len;
  std.mem.copy(u8, pkt[0..header.len], &amp;header); // 4 bytes

  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>We manually converted the <strong>Zig code to C</strong> like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/mipi_dsi.c#L276-L387">mipi_dsi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Compose MIPI DSI Short Packet.
// Returns the Packet Length.
ssize_t mipi_dsi_short_packet(
  FAR uint8_t *pktbuf,  // Buffer for the returned packet
  size_t pktlen,        // Size of the packet buffer
  uint8_t channel,      // Virtual Channel
  enum mipi_dsi_e cmd,  // DCS Command (Data Type)
  FAR const uint8_t *txbuf,  // Payload data for the packet
  size_t txlen)              // Length of payload data (1 or 2 bytes)
{
  // Data Identifier (DI) (1 byte):
  // Virtual Channel Identifier (Bits 6 to 7)
  // Data Type (Bits 0 to 5)
  const uint8_t vc = channel;
  const uint8_t dt = cmd;
  const uint8_t di = (vc &lt;&lt; 6) | dt;

  // Data (2 bytes): Fill with 0 if Second Byte is missing
  const uint8_t data[2] = {
    txbuf[0],                     // First Byte
    (txlen == 2) ? txbuf[1] : 0,  // Second Byte
  };

  // Data Identifier + Data (3 bytes):
  // For computing Error Correction Code (ECC)
  const uint8_t di_data[3] = { di, data[0], data[1] };

  // Compute ECC for Data Identifier + Word Count
  const uint8_t ecc = compute_ecc(di_data, sizeof(di_data));

  // Packet Header (4 bytes):
  // Data Identifier + Data + Error Correction Code
  const uint8_t header[4] = { di_data[0], di_data[1], di_data[2], ecc };

  // Packet Length is Packet Header Size (4 bytes)
  const size_t len = sizeof(header);

  // Copy Packet Header to Packet Buffer
  memcpy(pktbuf, header, sizeof(header));  // 4 bytes

  // Return the Packet Length
  return len;
}</code></pre></div>
<p>The C Code looks highly similar to the original Zig Code! Thus manually converting Zig to C (line by line) is a piece of cake.</p>
<p>(According to <a href="https://www.linkedin.com/feed/update/urn:li:activity:7007500633717035008?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A7007500633717035008%2C7007787482456993792%29&amp;dashCommentUrn=urn%3Ali%3Afsd_comment%3A%287007787482456993792%2Curn%3Ali%3Aactivity%3A7007500633717035008%29"><strong>Matheus Catarino Fran√ßa</strong></a>, the Zig-to-C Auto-Translation might work too)</p>
<p><img src="https://lupyuen.github.io/images/dsi3-test.png" alt="Testing MIPI DSI Driver" /></p>
<h1 id="test-mipi-dsi-driver"><a href="#test-mipi-dsi-driver">6 Test MIPI DSI Driver</a></h1>
<p><em>Our NuttX Display Driver for PinePhone is incomplete‚Ä¶</em></p>
<p><em>How do we test the MIPI DSI Driver in the NuttX Kernel?</em></p>
<p>Right now we have implemented the following in the <strong>NuttX Kernel</strong>‚Ä¶</p>
<ul>
<li>Driver for MIPI Display Serial Interface (DSI)</li>
<li>Driver for MIPI Display Physical Layer (D-PHY)</li>
</ul>
<p>But to <a href="https://lupyuen.github.io/articles/dsi3#complete-display-driver-for-pinephone"><strong>render graphics on PinePhone</strong></a> we need the following drivers, which are still in Zig (pending conversion to C)‚Ä¶</p>
<ul>
<li>Driver for Display Backlight</li>
<li>Driver for Timing Controller TCON0</li>
<li>Driver for Power Management Integrated Circuit</li>
<li>Driver for LCD Panel</li>
<li>Driver for Display Engine</li>
</ul>
<p>Running an <strong>Integration Test</strong> across the C and Zig Drivers will be a little tricky. This is how we run the test‚Ä¶</p>
<p>We created this program in Zig that <strong>calls the C and Zig Drivers</strong>, in the right sequence: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig#L1146-L1182">render.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Main Function that will be called by NuttX
/// when we run the `hello` app
pub export fn hello_main(argc: c_int, argv: [*c]const [*c]u8) c_int {
  // Render graphics on PinePhone in Zig and C:

  // Turn on Display Backlight (in Zig)
  // Init Timing Controller TCON0 (in Zig)
  // Init PMIC (in Zig)

  backlight.backlight_enable(90);
  tcon.tcon0_init();
  pmic.display_board_init();

  // Enable MIPI DSI Block (in C)
  // Enable MIPI Display Physical Layer (in C)

  _ = a64_mipi_dsi_enable();
  _ = a64_mipi_dphy_enable();

  // Reset LCD Panel (in Zig)
  panel.panel_reset();

  // Init LCD Panel (in C)
  // Start MIPI DSI HSC and HSD (in C)

  _ = pinephone_panel_init();
  _ = a64_mipi_dsi_start();

  // Init Display Engine (in Zig)
  // Wait a while
  // Render Graphics with Display Engine (in Zig)

  de2_init();
  _ = c.usleep(160000);
  renderGraphics(3);  // Render 3 UI Channels</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test_a64_mipi_dsi.c#L42-L452">(<strong>pinephone_panel_init</strong> is defined here)</a></p>
<p>Then we <strong>compile our Zig Test Program</strong> (targeting PinePhone) and link it with NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>  #  Configure NuttX
  cd nuttx
  ./tools/configure.sh pinephone:nsh
  make menuconfig

  #  Select &quot;System Type &gt; Allwinner A64 Peripheral Selection &gt; MIPI DSI&quot;
  #  Select &quot;Build Setup &gt; Debug Options &gt; Graphics Debug Features &gt; Graphics Errors / Warnings / Informational Output&quot;
  #  Save and exit menuconfig

  #  Build NuttX
  make

  #  Download the Zig Test Program
  pushd $HOME
  git clone https://github.com/lupyuen/pinephone-nuttx
  cd pinephone-nuttx

  #  Compile the Zig App for PinePhone 
  #  (armv8-a with cortex-a53)
  #  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
  zig build-obj \
    --verbose-cimport \
    -target aarch64-freestanding-none \
    -mcpu cortex_a53 \
    -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
    -I &quot;$HOME/nuttx/apps/include&quot; \
    render.zig

  #  Copy the compiled app to NuttX and overwrite `hello.o`
  #  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
  cp render.o \
    $HOME/nuttx/apps/examples/hello/*hello.o  

  #  Return to the NuttX Folder
  popd

  #  Link the Compiled Zig App with NuttX
  make</code></pre></div>
<p>We boot NuttX on PinePhone and run the Zig Test Program (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-11.0.0-pinephone

nsh&gt; uname -a
NuttX 11.0.0-pinephone 2a1577a-dirty Dec  9 2022 13:57:47 arm64 pinephone

nsh&gt; hello 0</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f1a02068aeb0785278c482116a4eedc7">(Source)</a></p>
<p>Yep our Zig Test Program <strong>renders the Test Pattern</strong> successfully on PinePhone‚Äôs LCD Display! <a href="https://lupyuen.github.io/images/dsi3-title.jpg">(Like this)</a></p>
<p>Which means the NuttX Kernel Driver for MIPI DSI is working OK!</p>
<p>Here‚Äôs the <strong>Test Log</strong> for our Zig Test Program running on NuttX and PinePhone‚Ä¶</p>
<ul>
<li><a href="https://gist.github.com/lupyuen/f1a02068aeb0785278c482116a4eedc7"><strong>‚ÄúTest Log for NuttX MIPI DSI on PinePhone‚Äù</strong></a></li>
</ul>
<h2 id="unit-testing"><a href="#unit-testing">6.1 Unit Testing</a></h2>
<p><em>What about Unit Testing? Can we test the MIPI DSI Driver without Zig?</em></p>
<p>Yep! Our MIPI DSI Driver simply writes values to a bunch of A64 Hardware Registers, like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/arch/arm64/src/a64/a64_mipi_dsi.c#L633-L646">a64_mipi_dsi.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // DSI Configuration Register 1 (A31 Page 846)
  // Set Video_Start_Delay (Bits 4 to 16) to 1468 (Line Delay)
  // Set Video_Precision_Mode_Align (Bit 2) to 1 (Fill Mode)
  // Set Video_Frame_Start (Bit 1) to 1 (Precision Mode)
  // Set DSI_Mode (Bit 0) to 1 (Video Mode)
  #define DSI_BASIC_CTL1_REG (A64_DSI_ADDR + 0x14)
  #define DSI_MODE                   (1 &lt;&lt; 0)
  #define VIDEO_FRAME_START          (1 &lt;&lt; 1)
  #define VIDEO_PRECISION_MODE_ALIGN (1 &lt;&lt; 2)
  #define VIDEO_START_DELAY(n)       ((n) &lt;&lt; 4)

  dsi_basic_ctl1 = VIDEO_START_DELAY(1468) |
                   VIDEO_PRECISION_MODE_ALIGN |
                   VIDEO_FRAME_START |
                   DSI_MODE;
  putreg32(dsi_basic_ctl1, DSI_BASIC_CTL1_REG);

  // Include Test Code to verify Register Addresses and Written Values
  #include &quot;../../pinephone-nuttx/test/test_a64_mipi_dsi2.c&quot;</code></pre></div>
<p>So we only need to ensure that the <strong>Hardware Register Addresses</strong> and the Written Values are correct.</p>
<p>To do that, we use <strong>Assertion Checks</strong> to verify the Addresses and Values: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test_a64_mipi_dsi2.c#L34-L35">test_a64_mipi_dsi2.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Test Code to verify Register Addresses and Written Values
  DEBUGASSERT(DSI_BASIC_CTL1_REG == 0x1ca0014);
  DEBUGASSERT(dsi_basic_ctl1 == 0x5bc7);</code></pre></div>
<p>If the Addresses or Values are incorrect, our MIPI DSI Driver <strong>halts with an Assertion Failure</strong>.</p>
<p>(We remove the Assertion Checks in the final version of our driver)</p>
<p><em>What about a smaller, self-contained Unit Test for MIPI DSI?</em></p>
<p>This is the Unit Test that verifies our NuttX Driver <strong>correctly composes MIPI DSI Packets</strong> (Long / Short / Short with Parameter)‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test_mipi_dsi.c#L1-L109"><strong>mipi_dsi_test</strong></a>: Unit Test for MIPI DSI Packets</li>
</ul>
<h2 id="local-testing"><a href="#local-testing">6.2 Local Testing</a></h2>
<p><em>Can we test the MIPI DSI Driver on our Local Computer? Without running on PinePhone?</em></p>
<p>Most certainly! In fact we test the MIPI DSI Driver on our <strong>Local Computer first</strong> before testing on PinePhone. Here‚Äôs how‚Ä¶</p>
<p>Remember that our MIPI DSI Driver simply writes values to a bunch of <strong>A64 Hardware Registers</strong>. So we only need to ensure that the Hardware Register Addresses and the Written Values are correct.</p>
<p>We created a <strong>Test Scaffold</strong> that simulates the NuttX Build Environment: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test.c#L7-L53">test.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Simulate NuttX Build Environment
#include &lt;nuttx/arch.h&gt;
#include &quot;arm64_arch.h&quot;
#include &quot;mipi_dsi.h&quot;
#include &quot;a64_mipi_dsi.h&quot;
#include &quot;a64_mipi_dphy.h&quot;

// Test Scaffold for Local Testing
int main() {

  // Test: Enable MIPI DSI Block
  a64_mipi_dsi_enable();

  // Test: Enable MIPI Display Physical Layer (DPHY)
  a64_mipi_dphy_enable();

  // Test: Initialise LCD Controller (ST7703)
  pinephone_panel_init();

  // Test: Start MIPI DSI HSC and HSD
  a64_mipi_dsi_start();

  // Test: MIPI DSI Packets
  mipi_dsi_test();
}</code></pre></div>
<p>Then we <strong>compile the Test Scaffold</strong> and run it on our Local Computer: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/run.sh#L9-L36">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code># Compile Test Code for Local Testing
gcc \
  -o test \
  -I . \
  -I ../../nuttx/arch/arm64/src/a64 \
  test.c \
  ../../nuttx/arch/arm64/src/a64/a64_mipi_dphy.c \
  ../../nuttx/arch/arm64/src/a64/a64_mipi_dsi.c \
  ../../nuttx/arch/arm64/src/a64/mipi_dsi.c

# Run the Local Test
./test

# Capture the Actual Test Log
./test &gt;test.log

# Diff the Actual and Expected Test Logs
diff \
  --ignore-all-space \
  expected.log \
  test.log</code></pre></div>
<p>Note that we capture the <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test.log"><strong>Actual Test Log</strong></a> and we <code>diff</code> it with the <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/expected.log"><strong>Expected Test Log</strong></a>.</p>
<p>That‚Äôs how we detect discrepancies in the Register Addresses and the Written Values‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable MIPI DSI Bus
  *0x1c20060: clear 0x2, set 0x2
  *0x1c202c0: clear 0x2, set 0x2
Enable DSI Block
  *0x1ca0000 = 0x1
  *0x1ca0010 = 0x30000
  *0x1ca0060 = 0xa
  *0x1ca0078 = 0x0
Set Instructions
  *0x1ca0020 = 0x1f
  *0x1ca0024 = 0x10000001
  *0x1ca0028 = 0x20000010
  *0x1ca002c = 0x2000000f
  *0x1ca0030 = 0x30100001
  *0x1ca0034 = 0x40000010
  *0x1ca0038 = 0xf
  *0x1ca003c = 0x5000001f</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test.log#L4-L20">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/dsi3-steps.jpg" alt="Inside our Complete Display Driver for PinePhone" /></p>
<h1 id="upcoming-nuttx-drivers"><a href="#upcoming-nuttx-drivers">7 Upcoming NuttX Drivers</a></h1>
<p><em>What about the rest of our NuttX Display Driver?</em></p>
<p>We talked earlier about the Grand Plan for our <strong>NuttX Display Driver</strong> that‚Äôs layered like an Onion <a href="https://en.wikipedia.org/wiki/Kue_lapis">Kueh Lapis</a> (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi3#complete-display-driver-for-pinephone"><strong>‚ÄúComplete Display Driver for PinePhone‚Äù</strong></a></li>
</ul>
<p>Today we‚Äôve implemented the <strong>MIPI Display Serial Interface</strong> and <strong>MIPI Display Physical Layer</strong> for our NuttX Display Driver (lower part of pic above)‚Ä¶</p>
<ul>
<li>
<p>Enable Allwinner A64‚Äôs <strong>MIPI Display Serial Interface (DSI)</strong></p>
<p>(So we can send MIPI DSI commands to the LCD Panel)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L526-L914">(Implemented as <strong>a64_mipi_dsi_enable</strong>)</a></p>
</li>
<li>
<p>Enable Allwinner A64‚Äôs <strong>MIPI Display Physical Layer (D-PHY)</strong></p>
<p>(Which is the communications layer inside MIPI DSI)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dphy.c#L86-L162">(Implemented as <strong>a64_mipi_dphy_enable</strong>)</a></p>
</li>
<li>
<p>Initialise PinePhone‚Äôs <strong>LCD Controller (Sitronix ST7703)</strong></p>
<p>(Send the Initialisation Commands over MIPI DSI)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L366-L526">(Implemented as <strong>a64_mipi_dsi_write</strong>)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/test/test_a64_mipi_dsi.c#L42-L452">(And soon <strong>pinephone_panel_init</strong>)</a></p>
</li>
<li>
<p>Start Allwinner A64‚Äôs <strong>MIPI DSI in HSC and HSD Mode</strong></p>
<p>(High Speed Clock Mode with High Speed Data Transmission)</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi3/arch/arm64/src/a64/a64_mipi_dsi.c#L914-L993">(Implemented as <strong>a64_mipi_dsi_start</strong>)</a></p>
</li>
</ul>
<p>We‚Äôre now <strong>building the NuttX Drivers</strong> for the remaining features (upper part of pic above), converting our Zig code to C‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/de#display-rendering-on-pinephone"><strong>Timing Controller (TCON0)</strong></a>: To render PinePhone‚Äôs LCD Display, the MIPI DSI Controller on Allwinner A64 needs to receive a <strong>continuous stream of pixels</strong>‚Ä¶</p>
<p>Which will be provided by Allwinner A64‚Äôs <strong>Timing Controller (TCON0)</strong>.</p>
<p>(TCON0 will receive the pixel stream from A64‚Äôs Display Engine)</p>
<p>Our NuttX Driver shall program TCON0 to <strong>send the stream of pixels</strong> to the MIPI DSI Controller.</p>
<p>This will be implemented in our new <strong>Timing Controller (TCON0) Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/dsi3#timing-controller-tcon0">(Details in the Appendix)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>Display Engine (DE)</strong></a>: Allwinner A64‚Äôs Display Engine (DE) reads the <strong>Graphics Framebuffers</strong> in RAM <a href="https://lupyuen.github.io/images/de2-blender.jpg">(up to 3 Framebuffers)</a>‚Ä¶</p>
<p>And <strong>streams the Pixel Data</strong> to the Timing Controller (TCON0).</p>
<p>Our NuttX Driver shall configure DE to read the Framebuffers via <strong>Direct Memory Access</strong> (DMA).</p>
<p>With DMA, updates to the Framebuffers will be instantly visible on PinePhone‚Äôs LCD Display.</p>
<p>This will be implemented in our new <strong>Display Engine Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/dsi3#display-engine">(Details in the Appendix)</a></p>
</li>
<li>
<p><strong>Display Backlight</strong>: We won‚Äôt see anything on PinePhone‚Äôs LCD Display‚Ä¶ Until we switch on the <strong>Display Backlight!</strong></p>
<p>PinePhone‚Äôs Display Backlight is controlled by A64‚Äôs‚Ä¶</p>
<ul>
<li>
<p><strong>Programmable Input / Output (PIO)</strong>: Works like GPIO, implemented in <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c"><strong>a64_pio.c</strong></a></p>
</li>
<li>
<p><strong>Pulse-Width Modulation (PWM)</strong>: New Implementation</p>
</li>
</ul>
<p>To turn on the Display Backlight, we‚Äôll call PIO and PWM in our new <strong>Board LCD Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/dsi3#backlight">(Details in the Appendix)</a></p>
</li>
<li>
<p><strong>LCD Panel</strong>: Before sending <a href="https://lupyuen.github.io/articles/dsi3#send-mipi-dsi-packet"><strong>Initialisation Commands</strong></a> to the ST7703 LCD Controller, we need to <strong>reset the LCD Panel.</strong></p>
<p>We do this with Allwinner A64‚Äôs <strong>Programmable Input / Output (PIO)</strong>, implemented in <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c"><strong>a64_pio.c</strong></a>. (Works like GPIO)</p>
<p>To reset the LCD Panel, we‚Äôll call PIO in our new <strong>Board LCD Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/dsi3#lcd-panel">(Details in the Appendix)</a></p>
</li>
<li>
<p><strong>Power Management Integrated Circuit (PMIC)</strong>: To power on the LCD Display, we need to program PinePhone‚Äôs <strong>Power Management Integrated Circuit (PMIC)</strong>.</p>
<p>The <strong>AXP803 PMIC</strong> is connected on Allwinner A64‚Äôs <strong>Reduced Serial Bus (RSB)</strong>. (Works like I2C)</p>
<p>We‚Äôll control the PMIC over RSB in our new <strong>Board LCD Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/dsi3#power-management-integrated-circuit">(Details in the Appendix)</a></p>
</li>
</ol>
<p>Very soon the official NuttX Kernel will be rendering graphics on PinePhone‚Äôs LCD Display. Stay Tuned!</p>
<p><img src="https://lupyuen.github.io/images/dsi3-zig.jpg" alt="Converting Zig to C" /></p>
<h1 id="why-zig"><a href="#why-zig">8 Why Zig</a></h1>
<p><em>Why did we start with Zig? Why not code directly in C?</em></p>
<p>Building a NuttX Display Driver for PinePhone feels like a <strong>risky challenge</strong>‚Ä¶</p>
<ul>
<li>
<p>Allwinner A64‚Äôs Display Interfaces are <a href="https://lupyuen.github.io/articles/dsi3#enable-mipi-dsi-and-d-phy"><strong>poorly documented</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3#complete-display-driver-for-pinephone"><strong>11 Steps</strong></a> to be executed precisely, in the right sequence</p>
</li>
<li>
<p>We need an efficient way to <strong>Experiment, Backtrack and Redo things</strong> in our driver</p>
</li>
</ul>
<p><strong>Zig seems to work</strong> really well because‚Ä¶</p>
<ul>
<li>
<p>Our complete Display Driver Protoype was created in <a href="https://github.com/lupyuen/pinephone-nuttx/commits/main?after=68eb24e9de468872b93abd742c3d5099b311be23+69&amp;branch=main&amp;qualified_name=refs%2Fheads%2Fmain"><strong>9 Weeks</strong></a></p>
</li>
<li>
<p>Zig‚Äôs <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Safety Checks</strong></a> were super helpful for catching bugs</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3#convert-zig-to-c"><strong>Converting Zig to C</strong></a> was easy</p>
</li>
</ul>
<p>Along the way we created an <strong>Executable Specification</strong> of Allwinner A64‚Äôs Display Interfaces‚Ä¶ A huge bunch of <strong>Hardware Register Addresses</strong> and their Expected Values: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L1013-L1033">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Set Video Start Delay
// DSI_BASIC_CTL1_REG: DSI Offset 0x14 (A31 Page 846)
// Set Video_Start_Delay (Bits 4 to 16) to 1468 (Line Delay)
// Set Video_Precision_Mode_Align (Bit 2) to 1 (Fill Mode)
// Set Video_Frame_Start (Bit 1) to 1 (Precision Mode)
// Set DSI_Mode (Bit 0) to 1 (Video Mode)
// Note: Video_Start_Delay is actually 13 bits, not 8 bits as documented in the A31 User Manual

const DSI_BASIC_CTL1_REG = DSI_BASE_ADDRESS + 0x14;
comptime{ assert(DSI_BASIC_CTL1_REG == 0x1ca0014); }

const Video_Start_Delay:          u17 = 1468 &lt;&lt; 4;
const Video_Precision_Mode_Align: u3  = 1    &lt;&lt; 2;
const Video_Frame_Start:          u2  = 1    &lt;&lt; 1;
const DSI_Mode:                   u1  = 1    &lt;&lt; 0;
const DSI_BASIC_CTL1 = Video_Start_Delay
  | Video_Precision_Mode_Align
  | Video_Frame_Start
  | DSI_Mode;
comptime{ assert(DSI_BASIC_CTL1 == 0x5bc7); }
putreg32(DSI_BASIC_CTL1, DSI_BASIC_CTL1_REG);  // TODO: DMB</code></pre></div>
<p>Which is really neat because‚Ä¶</p>
<ul>
<li>
<p>Our Executable Spec describes Allwinner A64‚Äôs Display Interfaces in a <strong>concise and readable</strong> way</p>
</li>
<li>
<p>‚Äú<strong><code>comptime</code> <code>assert</code></strong>‚Äù will verify our Register Adresses and Values at <strong>Compile-Time</strong></p>
</li>
<li>
<p><strong>Less Ambiguity</strong>: Zig Integers won‚Äôt overflow, Zig Arrays are bounded</p>
</li>
<li>
<p>Can be translated into C or Rust for other Operating Systems</p>
</li>
</ul>
<p><em>Was it worth the effort? Would you do it again in Zig?</em></p>
<p>Yes and yes! Zig is excellent for prototyping new Device Drivers for Operating Systems.</p>
<p><em>Once again‚Ä¶ Why are we doing all this?</em></p>
<p>PinePhone is becoming popular as the <strong>Edgy, Alternative Smartphone</strong> for folks who love to tinker with their gadgets. (And it‚Äôs still in stock!)</p>
<p>The best way to understand what‚Äôs really inside PinePhone: Creating our own <strong>PinePhone Display Driver</strong>.</p>
<p>That‚Äôs why we‚Äôre doing all this PinePhone Reverse-Engineering to Zig and then to C!</p>
<p><em>What about other cool open-source Allwinner A64 gadgets like <a href="https://www.olimex.com/Products/DIY-Laptop/KITS/TERES-A64-BLACK/open-source-hardware">TERES-I</a>?</em></p>
<p>Someday we might! But first let‚Äôs uncover all the secrets inside PinePhone.</p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/dsi3.md"><strong>lupyuen.github.io/src/dsi3.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/dsi3-steps.jpg" alt="Inside our Complete Display Driver for PinePhone" /></p>
<h1 id="appendix-upcoming-nuttx-drivers"><a href="#appendix-upcoming-nuttx-drivers">10 Appendix: Upcoming NuttX Drivers</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/de-block1a.jpg" alt="Allwinner A64 Timing Controller (TCON0)" /></p>
<p><a href="https://lupyuen.github.io/articles/de#display-rendering-on-pinephone"><em>Allwinner A64 Timing Controller (TCON0)</em></a></p>
<h2 id="timing-controller-tcon0"><a href="#timing-controller-tcon0">10.1 Timing Controller (TCON0)</a></h2>
<p>TODO</p>
<p>To render PinePhone‚Äôs LCD Display, the MIPI DSI Controller on Allwinner A64 needs to receive a <strong>continuous stream of pixels</strong>‚Ä¶</p>
<p>Which will be provided by Allwinner A64‚Äôs <strong>Timing Controller (TCON0)</strong>.</p>
<p>(TCON0 will receive the pixel stream from A64‚Äôs Display Engine)</p>
<p>Our NuttX Driver shall program TCON0 to <strong>send the stream of pixels</strong> to the MIPI DSI Controller.</p>
<p>This will be implemented in our new <strong>Timing Controller (TCON0) Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/de#appendix-timing-controller-tcon0">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/tcon.zig">(Implemented here)</a></p>
<p>TODO: Allwinner A64 Timing Controller TCON0 Driver, convert from Zig to C</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/tcon.zig">tcon.zig</a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/de2-blender.jpg" alt="Allwinner A64 Display Engine" /></p>
<p><a href="https://lupyuen.github.io/articles/de2#configure-blender"><em>Allwinner A64 Display Engine</em></a></p>
<h2 id="display-engine"><a href="#display-engine">10.2 Display Engine</a></h2>
<p>TODO</p>
<p>Allwinner A64‚Äôs Display Engine (DE) reads the <strong>Graphics Framebuffers</strong> in RAM <a href="https://lupyuen.github.io/images/de2-blender.jpg">(up to 3 Framebuffers)</a>‚Ä¶</p>
<p>And <strong>streams the Pixel Data</strong> to the Timing Controller (TCON0).</p>
<p>Our NuttX Driver shall configure DE to read the Framebuffers via <strong>Direct Memory Access</strong> (DMA).</p>
<p>With DMA, updates to the Framebuffers will be instantly visible on PinePhone‚Äôs LCD Display.</p>
<p>This will be implemented in our new <strong>Display Engine Driver</strong> for NuttX.</p>
<p>Init</p>
<p><a href="https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig#L710-L1011">(Implemented here)</a></p>
<p>Render</p>
<p><a href="https://lupyuen.github.io/articles/de">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig#L69-L175">(Implemented here)</a></p>
<p>TODO: Allwinner A64 Display Engine Driver, convert from Zig to C</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig">render.zig</a></li>
</ul>
<p>Our Display Engine Driver will follow the design of STM32F7 Display Driver‚Ä¶</p>
<ol>
<li>
<p><code>stm32_bringup</code> calls <code>fb_register</code>‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32f7/stm32f746g-disco/src/stm32_bringup.c#L100">stm32_bringup.c</a></p>
</li>
<li>
<p><code>fb_register</code> calls <code>up_fbinitialize</code>‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/drivers/video/fb.c#L664">fb.c</a></p>
</li>
<li>
<p><code>up_fbinitialize</code> calls <code>stm32_ltdcinitialize</code>‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32f7/stm32f746g-disco/src/stm32_lcd.c#L72">stm32_lcd.c</a></p>
</li>
<li>
<p><code>stm32_ltdcinitialize</code> creates the NuttX Framebuffer‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/arch/arm/src/stm32f7/stm32_ltdc.c#L2971">stm32_ltdc.c</a></p>
</li>
<li>
<p>NuttX Framebuffer is here‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/arch/arm/src/stm32f7/stm32_ltdc.c#L864">stm32_ltdc.c</a></p>
</li>
</ol>
<h2 id="backlight"><a href="#backlight">10.3 Backlight</a></h2>
<p>TODO</p>
<p>We won‚Äôt see anything on PinePhone‚Äôs LCD Display‚Ä¶ Until we switch on the <strong>Display Backlight!</strong></p>
<p>PinePhone‚Äôs Display Backlight is controlled by A64‚Äôs‚Ä¶</p>
<ul>
<li>
<p><strong>Programmable Input / Output (PIO)</strong>: Works like GPIO, implemented in <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c"><strong>a64_pio.c</strong></a></p>
</li>
<li>
<p><strong>Pulse-Width Modulation (PWM)</strong>: New Implementation</p>
</li>
</ul>
<p>To turn on the Display Backlight, we‚Äôll call PIO and PWM in our new <strong>Board LCD Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/de#appendix-display-backlight">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/backlight.zig">(Implemented here)</a></p>
<p>TODO: PinePhone Backlight Driver, convert from Zig to C</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/backlight.zig">backlight.zig</a></li>
</ul>
<p>Our Backlight Driver will follow the design of the STM32 Backlight Driver: <code>stm32_backlight</code>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32/hymini-stm32v/src/stm32_ssd1289.c#L230">stm32_ssd1289.c</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32/viewtool-stm32f107/src/stm32_ssd1289.c#L298">stm32_ssd1289.c</a></p>
</li>
</ul>
<p>The code will go inside our Board LCD Source File, similar to this‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32f7/stm32f746g-disco/src/stm32_lcd.c">stm32_lcd.c</a></li>
</ul>
<h2 id="lcd-panel"><a href="#lcd-panel">10.4 LCD Panel</a></h2>
<p>TODO</p>
<p>Before sending <a href="https://lupyuen.github.io/articles/dsi3#send-mipi-dsi-packet"><strong>Initialisation Commands</strong></a> to the ST7703 LCD Controller, we need to <strong>reset the LCD Panel.</strong></p>
<p>We do this with Allwinner A64‚Äôs <strong>Programmable Input / Output (PIO)</strong>, implemented in <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c"><strong>a64_pio.c</strong></a>. (Works like GPIO)</p>
<p>To reset the LCD Panel, we‚Äôll call PIO in our new <strong>Board LCD Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/de#appendix-reset-lcd-panel">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/panel.zig">(Implemented here)</a></p>
<p>Initialise LCD Controller</p>
<p><a href="https://lupyuen.github.io/articles/dsi#appendix-initialise-lcd-controller">(Explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/dsi2#initialise-st7703-lcd-controller">(Implemented here)</a></p>
<p>TODO: PinePhone LCD Panel Driver, convert from Zig to C</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/panel.zig">panel.zig</a></li>
</ul>
<p>The code will go inside our Board LCD Source File, similar to this‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32f7/stm32f746g-disco/src/stm32_lcd.c">stm32_lcd.c</a></li>
</ul>
<h2 id="power-management-integrated-circuit"><a href="#power-management-integrated-circuit">10.5 Power Management Integrated Circuit</a></h2>
<p>TODO</p>
<p>To power on the LCD Display, we need to program PinePhone‚Äôs <strong>Power Management Integrated Circuit (PMIC)</strong>.</p>
<p>The <strong>AXP803 PMIC</strong> is connected on Allwinner A64‚Äôs <strong>Reduced Serial Bus (RSB)</strong>. (Works like I2C)</p>
<p>We‚Äôll control the PMIC over RSB in our new <strong>Board LCD Driver</strong> for NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/de#appendix-power-management-integrated-circuit">(Explained here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/pmic.zig">(Implemented here)</a></p>
<p>TODO: PinePhone PMIC, convert from Zig to C, needs more reverse engineering</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/pmic.zig">pmic.zig</a></li>
</ul>
<p>The code will go inside our Board LCD Source File, similar to this‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/dsi/boards/arm/stm32f7/stm32f746g-disco/src/stm32_lcd.c">stm32_lcd.c</a></li>
</ul>

    
</body>
</html>