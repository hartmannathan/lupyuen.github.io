<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/romfs-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/romfs.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)</h1>
    <nav id="TOC"><ul>
<li><a href="#c-compiler-in-our-web-browser">1 C Compiler in our Web Browser</a><ul></ul></li>
<li><a href="#file-access-for-webassembly">2 File Access for WebAssembly</a><ul></ul></li>
<li><a href="#rom-fs-filesystem">3 ROM FS Filesystem</a><ul></ul></li>
<li><a href="#nuttx-driver-for-rom-fs">4 NuttX Driver for ROM FS</a><ul>
<li><a href="#mount-the-filesystem">4.1 Mount the Filesystem</a><ul></ul></li>
<li><a href="#open-a-rom-fs-file">4.2 Open a ROM FS File</a><ul></ul></li>
<li><a href="#read-a-rom-fs-file">4.3 Read a ROM FS File</a><ul></ul></li></ul></li>
<li><a href="#inside-a-rom-fs-filesystem">5 Inside a ROM FS Filesystem</a><ul></ul></li>
<li><a href="#tcc-calls-rom-fs-driver">6 TCC calls ROM FS Driver</a><ul></ul></li>
<li><a href="#from-tcc-to-nuttx-emulator">7 From TCC to NuttX Emulator</a><ul></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-tcc-webassembly">9 Appendix: Build TCC WebAssembly</a><ul></ul></li>
<li><a href="#appendix-nuttx-rom-fs-driver">10 Appendix: NuttX ROM FS Driver</a><ul></ul></li>
<li><a href="#appendix-download-rom-fs">11 Appendix: Download ROM FS</a><ul></ul></li>
<li><a href="#appendix-print-via-nuttx-system-call">12 Appendix: Print via NuttX System Call</a><ul></ul></li>
<li><a href="#appendix-exit-via-nuttx-system-call">13 Appendix: Exit via NuttX System Call</a><ul></ul></li>
<li><a href="#appendix-patch-the-nuttx-emulator">14 Appendix: Patch the NuttX Emulator</a><ul></ul></li>
<li><a href="#appendix-rom-fs-filesystem">15 Appendix: ROM FS Filesystem</a><ul></ul></li></ul></nav><p>üìù <em>20 Feb 2024</em></p>
<p><img src="https://lupyuen.github.io/images/romfs-title.png" alt="Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs">(Try the <strong>Online Demo</strong>)</a></p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p>We‚Äôre building a <a href="https://lupyuen.github.io/articles/tcc"><strong>C Compiler for RISC-V</strong></a> that runs in the <strong>Web Browser</strong>. (With <a href="https://ziglang.org/"><strong>Zig Compiler</strong></a> and WebAssembly)</p>
<p>But our C Compiler is kinda boring if it doesn‚Äôt support <strong>C Header Files</strong> and Library Files.</p>
<p>In this article we add a <strong>Read-Only Filesystem</strong> to our Zig WebAssembly‚Ä¶</p>
<ul>
<li>
<p>We host the C Header Files in a <strong>ROM FS Filesystem</strong></p>
</li>
<li>
<p>Zig reads them with the ROM FS Driver from <a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX RTOS</strong></a></p>
</li>
<li>
<p>Zig emulates <strong>POSIX File Access</strong> for TCC Compiler</p>
</li>
<li>
<p>We test the Compiled Output with <strong>NuttX Emulator</strong></p>
</li>
<li>
<p>By making System Calls to <strong>NuttX Kernel</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/romfs-tcc.png" alt="TCC Compiler in WebAssembly with ROM FS" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><em>TCC Compiler in WebAssembly with ROM FS</em></a></p>
<h1 id="c-compiler-in-our-web-browser"><a href="#c-compiler-in-our-web-browser">1 C Compiler in our Web Browser</a></h1>
<p>Head over here to open <strong>TCC Compiler in our Web Browser</strong> (pic above)</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><strong>TCC RISC-V Compiler with ROM FS</strong></a></p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
</ul>
<p>This <strong>C Program</strong> appears‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p>Click the ‚Äú<strong>Compile</strong>‚Äù button. Our Web Browser calls TCC to compile the above program‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile to RISC-V ELF
tcc -c hello.c
</code></pre></div>
<p>And it downloads the compiled <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>RISC-V ELF <code>a.out</code></strong></a>.</p>
<p>To test the Compiled Output, we browse to the <strong>Emulator for Apache NuttX RTOS</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/nuttx-tinyemu/tcc/"><strong>NuttX Emulator for Ox64 RISC-V SBC</strong></a></li>
</ul>
<p>We run <strong><code>a.out</code></strong> in the NuttX Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TinyEMU Emulator for Ox64 BL808 RISC-V SBC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; a.out
Hello, World!!
</code></pre></div>
<p>And it works: Our Web Browser generates a RISC-V Executable, that runs in a RISC-V Emulator!</p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><em>Surely it‚Äôs a staged demo? Something server-side?</em></p>
<p>Everything runs entirely in our Web Browser. Try this‚Ä¶</p>
<ol>
<li>
<p>Browse to <a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><strong>TCC RISC-V Compiler</strong></a></p>
</li>
<li>
<p>Change the <em>‚ÄúHello World‚Äù</em> message</p>
</li>
<li>
<p>Click ‚Äú<strong>Compile</strong>‚Äù</p>
</li>
<li>
<p>Reload the browser for <a href="https://lupyuen.github.io/nuttx-tinyemu/tcc/"><strong>NuttX Emulator</strong></a></p>
</li>
<li>
<p>Run <strong><code>a.out</code></strong></p>
</li>
</ol>
<p>And the message changes! We discuss the internals‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tcc-posix.jpg" alt="TCC Compiler in WebAssembly needs POSIX Functions" /></p>
<h1 id="file-access-for-webassembly"><a href="#file-access-for-webassembly">2 File Access for WebAssembly</a></h1>
<p><em>Something oddly liberating about our demo‚Ä¶</em></p>
<p>TCC Compiler was created as a <strong>Command-Line App</strong> that calls the usual <a href="https://lupyuen.github.io/articles/tcc#posix-for-webassembly"><strong>POSIX Functions</strong></a> for File Access: <strong>open, read, write,</strong> ‚Ä¶</p>
<p>But WebAssembly runs in a Secure Sandbox. <a href="https://lupyuen.github.io/articles/tcc#file-input-and-output"><strong>No File Access</strong></a> allowed, sorry! (Like for C Header Files)</p>
<p><em>Huh! How did we get &lt;stdio.h&gt; and &lt;stdlib.h&gt;?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p><em>&lt;stdio.h&gt;</em> and <em>&lt;stdlib.h&gt;</em> come from the <strong>ROM FS Filesystem</strong> that‚Äôs bundled inside our TCC WebAssembly.</p>
<p>ROM FS works like a regular Filesystem (think FAT and EXT4). Just that it‚Äôs tiny, <strong>runs in memory</strong>. And bundles easily with WebAssembly.</p>
<p>(Coming up in the next section)</p>
<p><em>Hmmm sounds like a major makeover for TCC Compiler‚Ä¶</em></p>
<p>Previously TCC Compiler could access Header Files directly from the <strong>Local Filesystem</strong>‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/romfs-wasm2.jpg" alt="TCC Compiler accessing Header Files directly from the Local Filesystem" /></p>
</blockquote>
<p>Now TCC WebAssembly needs to hoop through our <a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Wrapper</strong></a> to read the <strong>ROM FS Filesystem</strong>‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/romfs-wasm.jpg" alt="TCC WebAssembly reading ROM FS Filesystem" /></p>
</blockquote>
<p>This is how we made it work‚Ä¶</p>
<h1 id="rom-fs-filesystem"><a href="#rom-fs-filesystem">3 ROM FS Filesystem</a></h1>
<p><em>What‚Äôs this ROM FS?</em></p>
<p><a href="https://docs.kernel.org/filesystems/romfs.html"><strong>ROM FS</strong></a> is a <strong>Read-Only Filesystem</strong> that runs entirely in memory.</p>
<p>ROM FS is <strong>a lot simpler</strong> than Read-Write Filesystems (like FAT and EXT4). That‚Äôs why we run it inside TCC WebAssembly to host our C Header Files.</p>
<p><em>How to bundle our files into ROM FS?</em></p>
<p><strong><code>genromfs</code></strong> will helpfully pack our C Header Files into a ROM FS Filesystem: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh#L182-L190">build.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu: Install `genromfs`
sudo apt install genromfs

## For macOS: Install `genromfs`
brew install genromfs

## Bundle the `romfs` folder into
## ROM FS Filesystem `romfs.bin`
## and label with this Volume Name
genromfs \
  -f romfs.bin \
  -d romfs \
  -V &quot;ROMFS&quot;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs">(<em>&lt;stdio.h&gt;</em> and <em>&lt;stdlib.h&gt;</em> are in the <strong>ROM FS Folder</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin">(Bundled into this <strong>ROM FS Filesystem</strong>)</a></p>
<p>We embed the <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin"><strong>ROM FS Filesystem <code>romfs.bin</code></strong></a> into our <a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Wrapper</strong></a>, so it will be accessible by TCC WebAssembly: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/c2146f65cc8f338b8a3aaa4c2e88e550e82514ec/zig/tcc-wasm.zig#L993-L997">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Embed the ROM FS Filesystem
// into our Zig Wrapper
const ROMFS_DATA = @embedFile(
  &quot;romfs.bin&quot;
);

// Later: Mount the ROM FS Filesystem
// from `ROMFS_DATA`
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#embedFile">(About <strong>@embedFile</strong>)</a></p>
<p><strong>For Easier Updates</strong>: We should download <a href="https://lupyuen.github.io/articles/romfs#appendix-download-rom-fs"><strong><code>romfs.bin</code> from our Web Server</strong></a>. (Pic below)</p>
<p><img src="https://lupyuen.github.io/images/romfs-flow.jpg" alt="NuttX Driver for ROM FS" /></p>
<h1 id="nuttx-driver-for-rom-fs"><a href="#nuttx-driver-for-rom-fs">4 NuttX Driver for ROM FS</a></h1>
<p><em>Is there a ROM FS Driver in Zig?</em></p>
<p>We looked around <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) and we found a <a href="https://github.com/apache/nuttx/blob/master/fs/romfs"><strong>ROM FS Driver</strong></a> (in C). It works well with Zig!</p>
<p>Let‚Äôs walk through the steps to call the <strong>NuttX ROM FS Driver</strong> from Zig (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>Mounting</strong> the ROM FS Filesystem</p>
</li>
<li>
<p><strong>Opening</strong> a ROM FS File</p>
</li>
<li>
<p><strong>Reading</strong> the ROM FS File</p>
</li>
<li>
<p>And <strong>Closing</strong> it</p>
</li>
</ul>
<h2 id="mount-the-filesystem"><a href="#mount-the-filesystem">4.1 Mount the Filesystem</a></h2>
<p>This is how we <strong>Mount our ROM FS Filesystem</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L11-L45">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the NuttX ROM FS Driver
const c = @cImport({
  @cInclude(&quot;zig_romfs.h&quot;);
});

/// Main Function of our Zig Wrapper
pub export fn compile_program(...) [*]const u8 {

  // Create the Memory Allocator for malloc
  memory_allocator = std.heap.FixedBufferAllocator
    .init(&amp;memory_buffer);

  // Mount the ROM FS Filesystem
  const ret = c.romfs_bind(
    c.romfs_blkdriver, // Block Driver for ROM FS
    null,              // No Data needed
    &amp;c.romfs_mountpt   // Returns the Mount Point
  );
  assert(ret &gt;= 0);

  // Prepare the Mount Inode.
  // We&#39;ll use it for opening files.
  romfs_inode = c.create_mount_inode(
    c.romfs_mountpt  // Mount Point
  );

  // Omitted: Call the TCC Compiler
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L160-L163">(<strong>romfs_inode</strong> is here)</a></p>
<p><em>What if the ROM FS Filesystem contains garbage?</em></p>
<p>Our ROM FS Driver will <strong>Fail the Mount Operation</strong>.</p>
<p>That‚Äôs because it searches for a <a href="https://lupyuen.github.io/articles/romfs#inside-a-rom-fs-filesystem"><strong>Magic Number</strong></a> at the top of the filesystem.</p>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L91-L98">(See the <strong>Mount Log</strong>)</a></p>
<p><a href="https://en.wikipedia.org/wiki/I-mode">(Not to be confused with <strong>i-mode</strong>)</a></p>
<h2 id="open-a-rom-fs-file"><a href="#open-a-rom-fs-file">4.2 Open a ROM FS File</a></h2>
<p>Next we <strong>Open a ROM FS File</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L127-L138">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Create the File Struct.
// Link to the Mount Inode.
var file = std.mem.zeroes(c.struct_file);
file.f_inode = romfs_inode;

// Open the ROM FS File
const ret2 = c.romfs_open(
  &amp;file,       // File Struct
  &quot;stdio.h&quot;,   // Pathname (&quot;/&quot; paths are OK)
  c.O_RDONLY,  // Read-Only
  0            // Mode (Unused for Read-Only Files)
);
assert(ret2 &gt;= 0);
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L99-L101">(See the <strong>Open Log</strong>)</a></p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/romfs-flow2.jpg" alt="POSIX Functions for ROM FS" /></p>
</blockquote>
<h2 id="read-a-rom-fs-file"><a href="#read-a-rom-fs-file">4.3 Read a ROM FS File</a></h2>
<p>Finally we <strong>Read and Close</strong> the ROM FS File: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L138-L157">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Read the ROM FS File, first 4 bytes
var buf = std.mem.zeroes([4]u8);
const ret3 = c.romfs_read(
  &amp;file,   // File Struct
  &amp;buf,    // Buffer to be populated
  buf.len  // Buffer Size
);
assert(ret3 &gt;= 0);

// Dump the 4 bytes
hexdump.hexdump(@ptrCast(&amp;buf), @intCast(ret3));

// Close the ROM FS File
const ret4 = c.romfs_close(&amp;file);
assert(ret4 &gt;= 0);
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/hexdump.zig#L9-L92">(<strong>hexdump</strong> is here)</a></p>
<p>We‚Äôll see this‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>romfs_read: Read 4 bytes from offset 0 
romfs_read: Read sector 17969028 
romfs_filecacheread: sector: 2 cached: 0 ncached: 1 sectorsize: 64 XIP base: anyopaque@1122f74 buffer: anyopaque@1122f74 
romfs_filecacheread: XIP buffer: anyopaque@1122ff4 
romfs_read: Return 4 bytes from sector offset 0 
  0000:  2F 2F 20 43  // C
romfs_close: Closing 
</code></pre></div>
<p>Which looks right because <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L1"><em>&lt;stdio.h&gt;</em></a> begins with ‚Äú<a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L1"><strong><code>// C</code></strong></a>‚Äù</p>
<p>What‚Äôs going on inside the filesystem? We snoop around‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L102-L113">(See the <strong>Read Log</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/romfs-format1.jpg" alt="ROM FS Filesystem Header" /></p>
<h1 id="inside-a-rom-fs-filesystem"><a href="#inside-a-rom-fs-filesystem">5 Inside a ROM FS Filesystem</a></h1>
<p><em>Is a ROM FS Filesystem really so simple and embeddable?</em></p>
<p>Seconds ago we bundled our C Header Files into a <strong>ROM FS Filesystem</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh#L182-L190">build.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu: Install `genromfs`
sudo apt install genromfs

## For macOS: Install `genromfs`
brew install genromfs

## Bundle the `romfs` folder into
## ROM FS Filesystem `romfs.bin`
## and label with this Volume Name
genromfs \
  -f romfs.bin \
  -d romfs \
  -V &quot;ROMFS&quot;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs">(<em>&lt;stdio.h&gt;</em> and <em>&lt;stdlib.h&gt;</em> are in the <strong>ROM FS Folder</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin">(Bundled into this <strong>ROM FS Filesystem</strong>)</a></p>
<p>Guided by the <a href="https://docs.kernel.org/filesystems/romfs.html"><strong>ROM FS Spec</strong></a>, we snoop around our <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin"><strong>ROM FS Filesystem <code>romfs.bin</code></strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump our ROM FS Filesystem
hexdump -C romfs.bin 
</code></pre></div>
<p>This <strong>ROM FS Header</strong> appears at the top of the filesystem (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>Magic Number</strong>: Always <em>‚Äú-rom1fs-‚Äù</em></p>
</li>
<li>
<p><strong>Filesystem Size</strong>: Big Endian (<code>0xF90</code>)</p>
</li>
<li>
<p><strong>Checksum</strong>: For first 512 bytes</p>
</li>
<li>
<p><strong>Volume Name</strong>: We made it ‚ÄúROMFS‚Äù</p>
</li>
</ul>
<p>Next comes <strong>File Header and Data</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/romfs-format2.jpg" alt="ROM FS File Header and Data" /></p>
<ul>
<li>
<p><strong>Next Header</strong>: Offset of Next File Header</p>
</li>
<li>
<p><strong>File Info</strong>: For Special Files</p>
</li>
<li>
<p><strong>File Size</strong>:  Big Endian (<code>0x9B7</code>)</p>
</li>
<li>
<p><strong>Checksum</strong>: For Metadata, File Name and Padding</p>
</li>
<li>
<p><strong>File Name</strong>, <strong>File Data</strong>: Padded to 16 bytes</p>
</li>
</ul>
<p>The Entire Dump of our ROM FS Filesystem is <a href="https://lupyuen.github.io/articles/romfs#appendix-rom-fs-filesystem"><strong>dissected in the Appendix</strong></a>.</p>
<p><em>Why is Next Header pointing to <code>0xA42</code>? Shouldn‚Äôt it be padded?</em></p>
<p>Bits 0 to 3 of ‚ÄúNext Header‚Äù tell us the <a href="https://github.com/apache/nuttx/blob/master/fs/romfs/fs_romfs.h#L61-L79"><strong>File Type</strong></a>.</p>
<p><strong><code>0xA42</code></strong> says that this is a <a href="https://github.com/apache/nuttx/blob/master/fs/romfs/fs_romfs.h#L61-L79"><strong>Regular File</strong></a>. (Type 2)</p>
<p>We zoom out to TCC Compiler‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/romfs-flow.jpg" alt="TCC calls ROM FS Driver" /></p>
<h1 id="tcc-calls-rom-fs-driver"><a href="#tcc-calls-rom-fs-driver">6 TCC calls ROM FS Driver</a></h1>
<p><em>TCC Compiler expects POSIX Functions like open(), read(), close()‚Ä¶</em></p>
<p><em>How will we connect them to ROM FS? (Pic above)</em></p>
<p>This is how we implement <strong>POSIX <code>open()</code></strong> to open a C Header File (from ROM FS): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L166-L219">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Open the ROM FS File and return the POSIX File Descriptor.
/// Emulates POSIX `open()`
export fn open(path: [*:0]const u8, oflag: c_uint, ...) c_int {

  // Omitted: Open the C Program File `hello.c`
  // Or create the RISC-V ELF `hello.o`
  ...
  // Allocate the File Struct
  const files = std.heap.page_allocator.alloc(c.struct_file, 1) catch {
    @panic(&quot;open: Failed to allocate file&quot;);
  };
  const file = &amp;files[0];
  file.* = std.mem.zeroes(c.struct_file);
  file.*.f_inode = romfs_inode;

  // Strip the System Include prefix
  const sys = &quot;/usr/local/lib/tcc/include/&quot;;
  const strip_path =
    if (std.mem.startsWith(u8, std.mem.span(path), sys)) (path + sys.len)
    else path;

  // Open the ROM FS File
  const ret = c.romfs_open(
    file,       // File Struct
    strip_path, // Pathname
    c.O_RDONLY, // Read-Only
    0           // Mode (Unused for Read-Only Files)
  );
  if (ret &lt; 0) { return ret; }

  // Remember the File Struct
  // for the POSIX File Descriptor
  const fd = next_fd;
  next_fd += 1;
  const f = fd - FIRST_FD - 1;
  assert(romfs_files.items.len == f);
  romfs_files.append(file) catch {
    @panic(&quot;Unable to allocate file&quot;);
  };
  return fd;
}
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L139-L141">(See the <strong>Open Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L166-L219">(Caution: We might have <strong>holes</strong>)</a></p>
<p><strong><code>romfs_files</code></strong> remembers our <strong>POSIX File Descriptors</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L27-L31">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// POSIX File Descriptors for TCC.
// This maps a File Descriptor to the File Struct.
// Index of romfs_files = File Descriptor Number - FIRST_FD - 1
var romfs_files: std.ArrayList(  // Array List of...
  *c.struct_file                 // Pointers to File Structs
) = undefined;

// At Startup: Allocate the POSIX
// File Descriptors for TCC
romfs_files = std.ArrayList(*c.struct_file)
  .init(std.heap.page_allocator);
</code></pre></div>
<p>(Why <a href="https://ziglang.org/documentation/master/std/#A;std:ArrayList"><strong>ArrayList</strong></a>? Because it grows easily as we add File Descriptors)</p>
<p>When TCC WebAssembly calls <strong>POSIX <code>read()</code></strong> to read the C Header File, we call ROM FS: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L226-L256">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read the POSIX File Descriptor `fd`.
/// Emulates POSIX `read()`
export fn read(fd: c_int, buf: [*:0]u8, nbyte: size_t) isize {

  // Omitted: Read the C Program File `hello.c`
  ...
  // Fetch the File Struct by
  // POSIX File Descriptor
  const f = fd - FIRST_FD - 1;
  const file = romfs_files.items[
    @intCast(f)
  ];

  // Read from the ROM FS File
  const ret = c.romfs_read(
    file, // File Struct
    buf,  // Buffer to be populated
    nbyte // Buffer Size
  );
  assert(ret &gt;= 0);
  return @intCast(ret);
}
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L142-L238">(See the <strong>Read Log</strong>)</a></p>
<p>Finally TCC WebAssembly calls <strong>POSIX <code>close()</code></strong> to close the C Header File: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L278-L298">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Close the POSIX File Descriptor
/// Emulates POSIX `close()`
export fn close(fd: c_int) c_int {

  // Omitted: Close the C Program File `hello.c`
  // Or close the RISC-V ELF `hello.o`
  ...
  // Fetch the File Struct by
  // POSIX File Descriptor
  const f = fd - FIRST_FD - 1;
  const file = romfs_files.items[
    @intCast(f)
  ];

  // Close the ROM FS File. TODO: Deallocate the file
  const ret = c.romfs_close(file);
  assert(ret &gt;= 0);
  return 0;
}
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L238-L240">(See the <strong>Close Log</strong>)</a></p>
<p><em>What if we need a Writeable Filesystem?</em></p>
<p>Try the <a href="https://github.com/apache/nuttx/tree/master/fs/tmpfs"><strong>Tmp FS Driver from NuttX</strong></a>.</p>
<p>It‚Äôs simpler than FAT and easier to embed in WebAssembly. Probably wiser to split the <a href="https://blog.setale.me/2022/06/27/Steam-Deck-and-Overlay-FS/"><strong>Immutable Filesystem</strong></a> (ROM FS) and Writeable Filesystem (Tmp FS).</p>
<p>Seeking closure, we circle back to our very first demo‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/romfs-title.png" alt="Compile and Run NuttX Apps in the Web Browser" /></p>
<h1 id="from-tcc-to-nuttx-emulator"><a href="#from-tcc-to-nuttx-emulator">7 From TCC to NuttX Emulator</a></h1>
<p><em>TCC compiles our C Program and sends it to NuttX Emulator‚Ä¶ How does it work?</em></p>
<p>Recall our Teleporting Magic Trick‚Ä¶</p>
<ol>
<li>
<p>Browse to <a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><strong>TCC RISC-V Compiler</strong></a></p>
</li>
<li>
<p>Change the <em>‚ÄúHello World‚Äù</em> message</p>
</li>
<li>
<p>Click ‚Äú<strong>Compile</strong>‚Äù</p>
</li>
<li>
<p>Reload the browser for <a href="https://lupyuen.github.io/nuttx-tinyemu/tcc/"><strong>NuttX Emulator</strong></a></p>
</li>
<li>
<p>Enter <strong><code>a.out</code></strong> and the new message appears</p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
</ol>
<p>What just happened? In Chrome Web Browser, click to <em>Menu &gt; Developer Tools &gt; Application Tab &gt; Local Storage &gt; lupyuen.github.io</em></p>
<p>We‚Äôll see that the <strong>RISC-V ELF <code>a.out</code></strong> is stored locally as <strong><code>elf_data</code></strong> in the <strong>JavaScript Local Storage</strong>. (Pic below)</p>
<p>That‚Äôs why NuttX Emulator can pick up <strong><code>a.out</code></strong> from our Web Browser!</p>
<p><img src="https://lupyuen.github.io/images/romfs-tcc2.png" alt="RISC-V ELF in the JavaScript Local Storage" /></p>
<p><em>How did it get there?</em></p>
<p>In our <strong>WebAssembly JavaScript</strong>: TCC Compiler saves <strong><code>a.out</code></strong> to our <strong>JavaScript Local Storage</strong> (pic below): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/docs/tcc.js#L60-L90">tcc.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Call TCC to compile a program
const ptr = wasm.instance.exports
  .compile_program(options_ptr, code_ptr);
...
// Encode the `a.out` data in text.
// Looks like: %7f%45%4c%46...
const data = new Uint8Array(memory.buffer, ptr + 4, len);
let encoded_data = &quot;&quot;;
for (const i in data) {
  const hex = Number(data[i]).toString(16).padStart(2, &quot;0&quot;);
  encoded_data += `%${hex}`;
}

// Save the ELF Data to JavaScript Local Storage.
// Will be loaded by NuttX Emulator
localStorage.setItem(
  &quot;elf_data&quot;,   // Name for Local Storage
  encoded_data  // Encoded ELF Data
);
</code></pre></div>
<p><em>But NuttX Emulator boots from a Fixed NuttX Image, loaded from our Static Web Server‚Ä¶</em></p>
<p><em>How did <code>a.out</code> magically appear inside the NuttX Image?</em></p>
<p>We conjured a Nifty Illusion‚Ä¶ <strong><code>a.out</code></strong> was in the <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/tcc/Image"><strong>NuttX Image</strong></a> all along!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Create a Fake `a.out` that
## contains a Distinct Pattern:
##   22 05 69 00
##   22 05 69 01
## For 1024 times
rm -f /tmp/pattern.txt
start=$((0x22056900))
for i in {0..1023}
do
  printf 0x%x\\n $(($start + $i)) &gt;&gt; /tmp/pattern.txt
done

## Copy the Fake `a.out`
## to our NuttX Apps Folder
cat /tmp/pattern.txt \
  | xxd -revert -plain \
  &gt;apps/bin/a.out
hexdump -C apps/bin/a.out

## Fake `a.out` looks like...
## 0000  22 05 69 00 22 05 69 01  22 05 69 02 22 05 69 03  |&quot;.i.&quot;.i.&quot;.i.&quot;.i.|
## 0010  22 05 69 04 22 05 69 05  22 05 69 06 22 05 69 07  |&quot;.i.&quot;.i.&quot;.i.&quot;.i.|
## 0020  22 05 69 08 22 05 69 09  22 05 69 0a 22 05 69 0b  |&quot;.i.&quot;.i.&quot;.i.&quot;.i.|
</code></pre></div>
<p>During our NuttX Build, the <strong>Fake <code>a.out</code></strong> gets bundled into the <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/tcc/initrd"><strong>Initial RAM Disk <code>initrd</code></strong></a>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/app#initial-ram-disk"><strong>Which gets appended</strong></a> to the <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/tcc/Image"><strong>NuttX Image</strong></a>.</p>
<p><em>So we patched Fake <code>a.out</code> in the NuttX Image with the Real <code>a.out</code>?</em></p>
<p>Exactly!</p>
<ol>
<li>
<p>In the JavaScript for <strong>NuttX Emulator</strong>: We read <strong><code>elf_data</code></strong> from JavaScript Local Storage and pass it to TinyEMU WebAssembly</p>
</li>
<li>
<p>Inside the <strong>TinyEMU WebAssembly</strong>: We receive the <strong><code>elf_data</code></strong> and copy it locally</p>
</li>
<li>
<p>Then we search for our <strong>Magic Pattern <code>22 05 69 00</code></strong> in our Fake <strong><code>a.out</code></strong></p>
</li>
<li>
<p>And we overwrite the Fake <strong><code>a.out</code></strong> with the Real <strong><code>a.out</code></strong> from <strong><code>elf_data</code></strong></p>
</li>
</ol>
<p>Everything is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/romfs#appendix-patch-the-nuttx-emulator"><strong>‚ÄúPatch the NuttX Emulator‚Äù</strong></a></li>
</ul>
<p>That‚Äôs how we compile a NuttX App in the Web Browser, and run it with NuttX Emulator in the Web Browser! üéâ</p>
<p><em>Is there something special inside &lt;stdio.h&gt; and &lt;stdlib.h&gt;?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p>They‚Äôll make System Calls to <strong>NuttX Kernel</strong>, for printing and quitting‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/romfs#appendix-print-via-nuttx-system-call"><strong>‚ÄúPrint via NuttX System Call‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/romfs#appendix-exit-via-nuttx-system-call"><strong>‚ÄúExit via NuttX System Call‚Äù</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/tcc-nuttx.jpg" alt="Compile and Run NuttX Apps in the Web Browser" /></p>
<h1 id="whats-next"><a href="#whats-next">8 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX and Zig Communities) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/romfs.md"><strong>lupyuen.github.io/src/romfs.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/romfs-tcc.png" alt="TCC Compiler in WebAssembly with ROM FS" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><em>TCC Compiler in WebAssembly with ROM FS</em></a></p>
<h1 id="appendix-build-tcc-webassembly"><a href="#appendix-build-tcc-webassembly">9 Appendix: Build TCC WebAssembly</a></h1>
<p>Follow these steps to <strong>Build and Test TCC WebAssembly</strong> (with ROM FS)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the ROMFS Branch of TCC Source Code.
## Configure the build for 64-bit RISC-V.
git clone \
  --branch romfs \
  https://github.com/lupyuen/tcc-riscv32-wasm
cd tcc-riscv32-wasm
./configure
make cross-riscv64

## Call Zig Compiler to compile TCC Compiler
## from C to WebAssembly. And link with Zig Wrapper.
## Produces `tcc-wasm.wasm` and `zig/romfs.bin`
pushd zig
./build.sh
popd

## Start the Web Server to test
## `tcc-wasm.wasm` and `zig/romfs.bin`
cargo install simple-http-server
simple-http-server ./docs &amp;

## Or test with Node.js
node zig/test.js
node zig/test-nuttx.js
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh">(See the <strong>Build Script</strong>)</a></p>
<p>Browse to this URL and our TCC WebAssembly will appear (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Test ROM FS with TCC WebAssembly
http://localhost:8000/romfs/index.html
</code></pre></div>
<p>Check the <strong>JavaScript Console</strong> for Debug Messages.</p>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191">(See the <strong>JavaScript Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/tree/romfs/docs/romfs">(See the <strong>Web Server Files</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/romfs-flow.jpg" alt="NuttX Driver for ROM FS" /></p>
<h1 id="appendix-nuttx-rom-fs-driver"><a href="#appendix-nuttx-rom-fs-driver">10 Appendix: NuttX ROM FS Driver</a></h1>
<p><em>What did we change in the NuttX ROM FS Driver? (Pic above)</em></p>
<p>Not much! NuttX ROM FS Driver will call <strong><code>mtd_ioctl</code></strong> in Zig when it maps the ROM FS Data in memory: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L963-L986">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Embed the ROM FS Filesystem
/// (Or download it, see next section)
const ROMFS_DATA = @embedFile(
  &quot;romfs.bin&quot;
);

/// ROM FS Driver makes this IOCTL Request
export fn mtd_ioctl(_: *mtd_dev_s, cmd: c_int, rm_xipbase: ?*c_int) c_int {

  // Request for Memory Address of ROM FS
  if (cmd == c.BIOC_XIPBASE) {
    // If we&#39;re loading `romfs.bin` from Web Server:
    // Change `ROMFS_DATA` to `&amp;ROMFS_DATA`
    rm_xipbase.?.* = @intCast(@intFromPtr(
      ROMFS_DATA
    ));

  // Request for Storage Device Geometry
  // Probably because NuttX Driver caches One Block of Data
  } else if (cmd == c.MTDIOC_GEOMETRY) {
    const geo: *c.mtd_geometry_s = @ptrCast(rm_xipbase.?);
    geo.*.blocksize = 64;
    geo.*.erasesize = 64;
    geo.*.neraseblocks = 1024; // TODO: Is this needed?
    const name = &quot;ZIG_ROMFS&quot;;
    @memcpy(geo.*.model[0..name.len], name);
    geo.*.model[name.len] = 0;

  // Unknown Request
  } else { debug(&quot;mtd_ioctl: Unknown command {}&quot;, .{cmd}); }
  return 0;
}
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#embedFile">(About <strong>@embedFile</strong>)</a></p>
<p>We wrote some <strong>Glue Code in C</strong> (because some things couldn‚Äôt be expressed in Zig)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/zig_romfs.c"><strong>zig_romfs.c</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/zig_romfs.h"><strong>zig_romfs.h</strong></a></p>
</li>
</ul>
<p>We made minor tweaks to the <strong>NuttX ROM FS Driver</strong> and added a Build Script‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig"><strong>ROM FS Source Files</strong></a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/pull/1/files">(See the <strong>Modified Files</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh"><strong>ROM FS Build Script</strong></a></p>
</li>
</ul>
<p><em>Anything else we changed in our Zig Wrapper?</em></p>
<p>Last week we hacked up a simple <a href="https://lupyuen.github.io/articles/tcc#fearsome-fprintf-and-friends"><strong>Format Pattern</strong></a> for handling <a href="https://lupyuen.github.io/articles/tcc#fearsome-fprintf-and-friends"><strong>fprintf and friends</strong></a>.</p>
<p>Now with Logging Enabled in NuttX ROM FS, we need to handle more complex Format Strings. Thus we extended our formatting to handle <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L368-L411"><strong>Multiple Format Patterns</strong></a> per Format String.</p>
<p>Let‚Äôs do better and download our filesystem‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/romfs-flow3.jpg" alt="NuttX Driver for ROM FS" /></p>
</blockquote>
<h1 id="appendix-download-rom-fs"><a href="#appendix-download-rom-fs">11 Appendix: Download ROM FS</a></h1>
<p>In the previous section, our Zig Wrapper <strong>embedded <code>romfs.bin</code> inside WebAssembly</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L963-L986">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Embed the ROM FS Filesystem.
/// But what if we need to update it?
const ROMFS_DATA = @embedFile(
  &quot;romfs.bin&quot;
);
</code></pre></div>
<p><strong>For Easier Updates</strong>: We should download <strong><code>romfs.bin</code></strong> from our <strong>Web Server</strong> (pic above): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/docs/romfs/tcc.js#L189-L212">tcc.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// JavaScript to load the WebAssembly Module
// and start the Main Function.
// Called by the Compile Button.
async function bootstrap() {

  // Omitted: Download the WebAssembly
  ...
  // Download the ROM FS Filesystem
  const response = await fetch(&quot;romfs.bin&quot;);
  wasm.romfs = await response.arrayBuffer();

  // Start the Main Function
  window.requestAnimationFrame(main);
}        
</code></pre></div>
<p>Our JavaScript Main Function passes the <strong>ROM FS Filesystem</strong> to our Zig Wrapper: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/docs/romfs/tcc.js#L52-L81">tcc.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Main Function
function main() {
  // Omitted: Read the Compiler Options and Program Code
  ...
  // Copy `romfs.bin` into WebAssembly Memory
  const romfs_data = new Uint8Array(wasm.romfs);
  const romfs_size = romfs_data.length;
  const memory = wasm.instance.exports.memory;
  const romfs_ptr = wasm.instance.exports
    .get_romfs(romfs_size);
  const romfs_slice = new Uint8Array(
    memory.buffer,
    romfs_ptr,
    romfs_size
  );
  romfs_slice.set(romfs_data);
    
  // Call TCC to compile the program
  const ptr = wasm.instance.exports
    .compile_program(options_ptr, code_ptr);
</code></pre></div>
<p><strong><code>get_romfs</code></strong> returns the WebAssembly Memory from our <strong>Zig Wrapper</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L112-L121">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Storage for ROM FS Filesystem, loaded from Web Server
/// Previously: We embedded the filesystem with `@embedFile`
var ROMFS_DATA = std.mem.zeroes([8192]u8);

/// Return the pointer to ROM FS Storage.
/// `size` is the expected filesystem size.
pub export fn get_romfs(size: u32) [*]const u8 {

  // Halt if we run out of memory
  if (size &gt; ROMFS_DATA.len) {
    @panic(&quot;Increase ROMFS_DATA size&quot;);
  }
  return &amp;ROMFS_DATA;
}
</code></pre></div>
<p>Inside our Zig Wrapper, <strong><code>ROMFS_DATA</code></strong> is passed to our NuttX ROM FS Driver via an <strong>IOCTL Request</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L963-L986">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// ROM FS Driver makes this IOCTL Request
export fn mtd_ioctl(_: *mtd_dev_s, cmd: c_int, rm_xipbase: ?*c_int) c_int {

  // Request for Memory Address of ROM FS
  if (cmd == c.BIOC_XIPBASE) {

    // Note: We changed `ROMFS_DATA` to `&amp;ROMFS_DATA`
    // because we&#39;re loading from Web Server
    rm_xipbase.?.* = @intCast(@intFromPtr(
      &amp;ROMFS_DATA
    ));
</code></pre></div>
<p>With a few tweaks to <strong><code>ROMFS_DATA</code></strong>, we‚Äôre now loading <strong><code>romfs.bin</code></strong> from our Web Server. Which is much better for maintainability.</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/tree/romfs/docs/romfs">(See the <strong>Web Server Files</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/app-syscall.jpg" alt="NuttX Apps make a System Call to print to the console" /></p>
<h1 id="appendix-print-via-nuttx-system-call"><a href="#appendix-print-via-nuttx-system-call">12 Appendix: Print via NuttX System Call</a></h1>
<p><em>What‚Äôs inside <code>puts</code>?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p>We implement <strong><code>puts</code></strong> by calling <strong><code>write</code></strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L18-L25">stdio.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Print the string to Standard Output
inline int puts(const char *s) {
  return
    write(1, s, strlen(s)) +
    write(1, &quot;\n&quot;, 1);
}
</code></pre></div>
<p>Then we implement <strong><code>write</code></strong> the exact same way as NuttX, making a <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>NuttX System Call (ECALL)</strong></a> to NuttX Kernel (pic above): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L25-L36">stdio.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Caution: NuttX System Call Number may change
#define SYS_write 61

// Write to the File Descriptor
// https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel
inline ssize_t write(int parm1, const void * parm2, size_t parm3) {
  return (ssize_t) sys_call3(
    (unsigned int) SYS_write,  // System Call Number
    (uintptr_t) parm1,         // File Descriptor (1 = Standard Output)
    (uintptr_t) parm2,         // Buffer to be written
    (uintptr_t) parm3          // Number of bytes to write
  );
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/app#nuttx-kernel-handles-system-call">(<strong>System Call Numbers</strong> may change)</a></p>
<p><strong><code>sys_call3</code></strong> is our hacked implementation of <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>NuttX System Call (ECALL)</strong></a>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L36-L84">stdio.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Make a System Call with 3 parameters
// https://github.com/apache/nuttx/blob/master/arch/risc-v/include/syscall.h#L240-L268
inline uintptr_t sys_call3(
  unsigned int nbr,  // System Call Number
  uintptr_t parm1,   // First Parameter
  uintptr_t parm2,   // Second Parameter
  uintptr_t parm3    // Third Parameter
) {
  // Pass the Function Number and Parameters in
  // Registers A0 to A3

  // Rightfully:
  // Register A0 is the System Call Number
  // Register A1 is the First Parameter
  // Register A2 is the Second Paramter
  // Register A3 is the Third Parameter

  // But we&#39;re manually moving them around because of... issues
  // Register A0 (parm3) goes to A3
  register long r3 asm(&quot;a0&quot;) = (long)(parm3);  // Will move to A3
  asm volatile (&quot;slli a3, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a3, a3, 32&quot;);  // To clear the top 32 bits

  // Register A0 (parm2) goes to A2
  register long r2 asm(&quot;a0&quot;) = (long)(parm2);  // Will move to A2
  asm volatile (&quot;slli a2, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a2, a2, 32&quot;);  // To clear the top 32 bits

  // Register A0 (parm1) goes to A1
  register long r1 asm(&quot;a0&quot;) = (long)(parm1);  // Will move to A1
  asm volatile (&quot;slli a1, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a1, a1, 32&quot;);  // To clear the top 32 bits

  // Register A0 (nbr) stays the same
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);  // Will stay in A0

  // `ecall` will jump from RISC-V User Mode
  // to RISC-V Supervisor Mode
  // to execute the System Call.
  asm volatile (

    // ECALL for System Call to NuttX Kernel
    &quot;ecall \n&quot;
    
    // NuttX needs NOP after ECALL
    &quot;.word 0x0001 \n&quot;

    // Input+Output Registers: None
    // Input-Only Registers: A0 to A3
    // Clobbers the Memory
    :
    : &quot;r&quot;(r0), &quot;r&quot;(r1), &quot;r&quot;(r2), &quot;r&quot;(r3)
    : &quot;memory&quot;
  );

  // Return the result from Register A0
  return r0;
} 
</code></pre></div>
<p><em>Why so complicated?</em></p>
<p>That‚Äôs because TCC <a href="https://lupyuen.github.io/articles/tcc#appendix-nuttx-system-call"><strong>won‚Äôt load the RISC-V Registers correctly</strong></a>. Thus we load the registers ourselves.</p>
<p><em>Why not simply copy A0 to A2 minus the hokey pokey?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Load SysCall Parameter to Register A0
register long r2 asm(&quot;a0&quot;) = (long)(parm2);

// Copy Register A0 to A2
asm volatile (&quot;addi a2, a0, 0&quot;);
</code></pre></div>
<p>When we do that, Register A2 <strong>becomes negative</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>riscv_swint: Entry: regs: 0x8020be10
cmd: 61
EPC: c0000160
A0: 3d 
A1: 01 
A2: ffffffffc0101000 
A3: 0f
[...Page Fault because A2 is an Invalid Address...]
</code></pre></div>
<p>So we Shift Away the <strong>Negative Sign</strong> (<em>silly</em> and <em>seriously</em>)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Load SysCall Parameter to Register A0
register long r2 asm(&quot;a0&quot;) = (long)(parm2);

// Shift 32 bits Left and
// save to Register A2
asm volatile (&quot;slli a2, a0, 32&quot;);

// Then shift 32 bits Right
// to clear the top 32 bits
asm volatile (&quot;srli a2, a2, 32&quot;);
</code></pre></div>
<p>Then Register A2 becomes <strong>Positively OK</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>riscv_swint: Entry: regs: 0x8020be10
cmd: 61
EPC: c0000164
A0: 3d 
A1: 01
A2: c0101000
A3: 0f
Hello, World!!
</code></pre></div>
<p>BTW <em>Andy</em> won‚Äôt work either‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Load SysCall Parameter to Register A0
register long r2 asm(&quot;a0&quot;) = (long)(parm2);

// Logical AND with 0xffffffff
// then save to Register A2
asm volatile (&quot;andi a2, a0, 0xffffffff&quot;);
</code></pre></div>
<p>Because <strong><code>0xFFFF_FFFF</code></strong> gets assembled to <strong><code>-1</code></strong>.</p>
<p><em>Chotto matte</em> there‚Äôs more‚Ä¶</p>
<h1 id="appendix-exit-via-nuttx-system-call"><a href="#appendix-exit-via-nuttx-system-call">13 Appendix: Exit via NuttX System Call</a></h1>
<p><em>Tell me about <code>exit</code>‚Ä¶</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p>We implement <strong><code>exit</code></strong> the same way as NuttX, by making a <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>NuttX System Call (ECALL)</strong></a> to NuttX Kernel: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdlib.h#L1-L10">stdlib.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Caution: NuttX System Call Number may change
#define SYS__exit 8

// Terminate the NuttX Process.
// From nuttx/syscall/proxies/PROXY__exit.c
inline void exit(int parm1) {

  // Make a System Call to NuttX Kernel
  sys_call1(
    (unsigned int)SYS__exit,  // System Call Number
    (uintptr_t)parm1          // Exit Status
  );

  // Loop Forever
  while(1);
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/app#nuttx-kernel-handles-system-call">(<strong>System Call Numbers</strong> may change)</a></p>
<p><strong><code>sys_call1</code></strong> makes a <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>NuttX System Call (ECALL)</strong></a>, with our hand-crafted RISC-V Assembly (as a workaround): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdlib.h#L10-L48">stdlib.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Make a System Call with 1 parameter
// https://github.com/apache/nuttx/blob/master/arch/risc-v/include/syscall.h#L188-L213
inline uintptr_t sys_call1(
  unsigned int nbr,  // System Call Number
  uintptr_t parm1    // First Parameter
) {
  // Pass the Function Number and Parameters
  // Registers A0 to A1

  // Rightfully:
  // Register A0 is the System Call Number
  // Register A1 is the First Parameter

  // But we&#39;re manually moving them around because of... issues
  // Register A0 (parm1) goes to A1
  register long r1 asm(&quot;a0&quot;) = (long)(parm1);  // Will move to A1
  asm volatile (&quot;slli a1, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a1, a1, 32&quot;);  // To clear the top 32 bits

  // Register A0 (nbr) stays the same
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);  // Will stay in A0

  // `ecall` will jump from RISC-V User Mode
  // to RISC-V Supervisor Mode
  // to execute the System Call.
  asm volatile (

    // ECALL for System Call to NuttX Kernel
    &quot;ecall \n&quot;
    
    // NuttX needs NOP after ECALL
    &quot;.word 0x0001 \n&quot;

    // Input+Output Registers: None
    // Input-Only Registers: A0 and A1
    // Clobbers the Memory
    :
    : &quot;r&quot;(r0), &quot;r&quot;(r1)
    : &quot;memory&quot;
  );

  // Return the result from Register A0
  return r0;
} 
</code></pre></div>
<p>And everything works OK!</p>
<p><em>Wow this looks horribly painful‚Ä¶ Are we doing any more of this?</em></p>
<p>Nope sorry, we won‚Äôt do any more of this! Hand-crafting the NuttX System Calls in RISC-V Assembly was <a href="https://lupyuen.github.io/articles/romfs#appendix-print-via-nuttx-system-call"><strong>positively painful</strong></a>.</p>
<p>(We‚Äôll revisit this when the RISC-V Registers are hunky dory in TCC)</p>
<p><img src="https://lupyuen.github.io/images/tcc-nuttx.jpg" alt="Compile and Run NuttX Apps in the Web Browser" /></p>
<h1 id="appendix-patch-the-nuttx-emulator"><a href="#appendix-patch-the-nuttx-emulator">14 Appendix: Patch the NuttX Emulator</a></h1>
<p>Moments ago we saw <strong>RISC-V ELF <code>a.out</code></strong> teleport magically from TCC WebAssembly to NuttX Emulator (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/romfs#from-tcc-to-nuttx-emulator"><strong>‚ÄúFrom TCC to NuttX Emulator‚Äù</strong></a></li>
</ul>
<p>And we discovered that TCC WebAssembly saves <strong><code>a.out</code></strong> to the <strong>JavaScript Local Storage</strong>, encoded as <strong><code>elf_data</code></strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/romfs-tcc2.png" alt="RISC-V ELF in the JavaScript Local Storage" /></p>
<p>This is how we take <strong><code>elf_data</code></strong> and patch the <strong>Fake <code>a.out</code></strong> in the NuttX Image with the <strong>Real <code>a.out</code></strong> (from TCC)‚Ä¶</p>
<p>In our <strong>NuttX Emulator JavaScript</strong>: We read <strong><code>elf_data</code></strong> from the <strong>JavaScript Local Storage</strong> and pass it to TinyEMU WebAssembly: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/tcc/jslinux.js#L504-L545">jslinux.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Receive the Encoded ELF Data for `a.out`
// from JavaScript Local Storage and decode it
// Encoded data looks like: %7f%45%4c%46...
const elf_data_encoded = localStorage.getItem(&quot;elf_data&quot;);
if (elf_data_encoded) {
  elf_data = new Uint8Array(
    elf_data_encoded
      .split(&quot;%&quot;)
      .slice(1)
      .map(hex=&gt;Number(&quot;0x&quot; + hex))
  );
  elf_len = elf_data.length;
}
...
// Pass the ELF Data to TinyEMU Emulator
Module.ccall(
  &quot;vm_start&quot;,  // Call `vm_start` in TinyEMU WebAssembly
  null,
  [ ... ],     // Omitted: Parameter Types
  [ // Parameters for `vm_start`
    url, mem_size, cmdline, pwd, width, height, (net_state != null) | 0, drive_url, 
    // We added these for our ELF Data
    elf_data, elf_len
  ]
);
</code></pre></div>
<p>Inside our <strong>TinyEMU WebAssembly</strong>: We receive <strong><code>elf_data</code></strong> and copy it locally, because it will be clobbered (why?): <a href="https://github.com/lupyuen/ox64-tinyemu/blob/tcc/jsemu.c#L182-L211">jsemu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Start the TinyEMU Emulator. Called by JavaScript.
void vm_start(...) {

  // Receive the ELF Data from JavaScript
  extern uint8_t elf_data[];  // From riscv_machine.c
  extern int elf_len;
  elf_len = elf_len0;

  // Copy ELF Data to Local Buffer because it will get clobbered
  if (elf_len &gt; 4096) { puts(&quot;elf_len exceeds 4096, increase elf_data and a.out size&quot;); }
  memcpy(elf_data, elf_data0, elf_len);
</code></pre></div>
<p>Then we search for our <strong>Magic Pattern <code>22 05 69 00</code></strong> in our Fake <strong><code>a.out</code></strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/tcc/riscv_machine.c#L1034-L1053">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Patch the ELF Data to Fake `a.out` in Initial RAM Disk
  uint64_t elf_addr = 0;
  for (int i = 0; i &lt; 0xD61680; i++) { // TODO: Fix the Image Size

    // Search for our Magic Pattern
    const uint8_t pattern[] = { 0x22, 0x05, 0x69, 0x00 };
    if (memcmp(&amp;kernel_ptr[i], pattern, sizeof(pattern)) == 0) {

      // Overwrite our Magic Pattern with Real `a.out`. TODO: Catch overflow
      memcpy(&amp;kernel_ptr[i], elf_data, elf_len);
      elf_addr = RAM_BASE_ADDR + i;
      break;
    }
  }
</code></pre></div>
<p>And we overwrite the Fake <strong><code>a.out</code></strong> with the Real <strong><code>a.out</code></strong> from <strong><code>elf_data</code></strong>.</p>
<p>This is perfectly OK because <a href="https://lupyuen.github.io/articles/romfs#appendix-rom-fs-filesystem"><strong>ROM FS Files are continuous</strong></a> and contiguous. (Though we ought to patch the File Size and the Filesystem Header Checksum)</p>
<p>That‚Äôs how we compile a NuttX App in the Web Browser, and run it with NuttX Emulator in the Web Browser! üéâ</p>
<p><a href="https://github.com/lupyuen/nuttx-tinyemu/tree/main/docs/tcc">(See the <strong>Web Server Files</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/romfs-format1.jpg" alt="ROM FS Filesystem Header" /></p>
<h1 id="appendix-rom-fs-filesystem"><a href="#appendix-rom-fs-filesystem">15 Appendix: ROM FS Filesystem</a></h1>
<p>A while ago we saw <strong><code>genromfs</code></strong> faithfully packing our C Header Files into a <strong>ROM FS Filesystem</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh#L182-L190">build.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu: Install `genromfs`
sudo apt install genromfs

## For macOS: Install `genromfs`
brew install genromfs

## Bundle the `romfs` folder into
## ROM FS Filesystem `romfs.bin`
## and label with this Volume Name
genromfs \
  -f romfs.bin \
  -d romfs \
  -V &quot;ROMFS&quot;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs">(<em>&lt;stdio.h&gt;</em> and <em>&lt;stdlib.h&gt;</em> are in the <strong>ROM FS Folder</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin">(Bundled into this <strong>ROM FS Filesystem</strong>)</a></p>
<p>Based on the <a href="https://docs.kernel.org/filesystems/romfs.html"><strong>ROM FS Spec</strong></a>, we take a walk inside our <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin"><strong>ROM FS Filesystem <code>romfs.bin</code></strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump our ROM FS Filesystem
hexdump -C romfs.bin 
</code></pre></div>
<p>Everything begins with the <strong>ROM FS Filesystem Header</strong> (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>      [ Magic Number        ]  [ FS Size ] [ Checksm ]
0000  2d 72 6f 6d 31 66 73 2d  00 00 0f 90 58 57 01 f8  |-rom1fs-....XW..|
      [ Volume Name: ROMFS                           ]
0010  52 4f 4d 46 53 00 00 00  00 00 00 00 00 00 00 00  |ROMFS...........|
</code></pre></div>
<p>Next comes the <strong>File Header</strong> for ‚Äú<strong><code>.</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----  File Header for `.`
      [ NextHdr ] [ Info    ]  [ Size    ] [ Checksm ]
0020  00 00 00 49 00 00 00 20  00 00 00 00 d1 ff ff 97  |...I... ........|
      [ File Name: `.`                               ]
0030  2e 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
      (NextHdr &amp; 0xF = 9 means Executable Directory)
</code></pre></div>
<p>Followed by the <strong>File Header</strong> for ‚Äú<strong><code>..</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----  File Header for `..`
      [ NextHdr ] [ Info    ]  [ Size    ] [ Checksm ]
0040  00 00 00 60 00 00 00 20  00 00 00 00 d1 d1 ff 80  |...`... ........|
      [ File Name: `..`                              ]
0050  2e 2e 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
      (NextHdr &amp; 0xF = 0 means Hard Link)
</code></pre></div>
<p>Then the <strong>File Header and Data</strong> for ‚Äú<strong><code>stdio.h</code></strong>‚Äù (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----  File Header for `stdio.h`
      [ NextHdr ] [ Info    ]  [ Size    ] [ Checksm ]
0060  00 00 0a 42 00 00 00 00  00 00 09 b7 1d 5d 1f 9e  |...B.........]..|
      [ File Name: `stdio.h`                         ]
0070  73 74 64 69 6f 2e 68 00  00 00 00 00 00 00 00 00  |stdio.h.........|
      (NextHdr &amp; 0xF = 2 means Regular File)

----  File Data for `stdio.h`
0080  2f 2f 20 43 61 75 74 69  6f 6e 3a 20 54 68 69 73  |// Caution: This|
....
0a20  74 65 72 20 41 30 0a 20  20 72 65 74 75 72 6e 20  |ter A0.  return |
0a30  72 30 3b 0a 7d 20 0a 00  00 00 00 00 00 00 00 00  |r0;.} ..........|
</code></pre></div>
<p>Finally the <strong>File Header and Data</strong> for ‚Äú<strong><code>stdlib.h</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----  File Header for `stdlib.h`
      [ NextHdr ] [ Info    ]  [ Size    ] [ Checksm ]
0a40  00 00 00 02 00 00 00 00  00 00 05 2e 23 29 67 fc  |............#)g.|
      [ File Name: `stdlib.h`                        ]
0a50  73 74 64 6c 69 62 2e 68  00 00 00 00 00 00 00 00  |stdlib.h........|
      (NextHdr &amp; 0xF = 2 means Regular File)

----  File Data for `stdio.h`
0a60  2f 2f 20 43 61 75 74 69  6f 6e 3a 20 54 68 69 73  |// Caution: This|
....
0f80  72 65 74 75 72 6e 20 72  30 3b 0a 7d 20 0a 00 00  |return r0;.} ...|
0f90  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre></div>
<p>Zero fuss, ROM FS is remarkably easy to read!</p>
<p><img src="https://lupyuen.github.io/images/romfs-format2.jpg" alt="ROM FS File Header and Data" /></p>

    
</body>
</html>