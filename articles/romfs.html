<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/romfs-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/romfs.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Zig runs ROM FS Filesystem in the Web Browser (thanks to Apache NuttX RTOS)</h1>
    <nav id="TOC"><ul>
<li><a href="#c-compiler-in-the-web-browser">1 C Compiler in the Web Browser</a><ul></ul></li>
<li><a href="#file-access-for-webassembly">2 File Access for WebAssembly</a><ul></ul></li>
<li><a href="#rom-fs-filesystem">3 ROM FS Filesystem</a><ul></ul></li>
<li><a href="#nuttx-driver-for-rom-fs">4 NuttX Driver for ROM FS</a><ul>
<li><a href="#mount-the-filesystem">4.1 Mount the Filesystem</a><ul></ul></li>
<li><a href="#open-a-rom-fs-file">4.2 Open a ROM FS File</a><ul></ul></li>
<li><a href="#read-a-rom-fs-file">4.3 Read a ROM FS File</a><ul></ul></li></ul></li>
<li><a href="#inside-a-rom-fs-filesystem">5 Inside a ROM FS Filesystem</a><ul></ul></li>
<li><a href="#tcc-calls-rom-fs-driver">6 TCC calls ROM FS Driver</a><ul></ul></li>
<li><a href="#from-tcc-to-nuttx-emulator">7 From TCC to NuttX Emulator</a><ul></ul></li>
<li><a href="#rom-fs-filesystem-for-tcc">8 ROM FS Filesystem for TCC</a><ul></ul></li>
<li><a href="#print-with-nuttx-system-call">9 Print with NuttX System Call</a><ul></ul></li>
<li><a href="#exit-with-nuttx-system-call">10 Exit with NuttX System Call</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>20 Feb 2024</em></p>
<p><img src="https://lupyuen.github.io/images/romfs-title.png" alt="TODO" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs">(Try the <strong>Online Demo</strong>)</a></p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p>We‚Äôre building a <a href="https://lupyuen.github.io/articles/tcc"><strong>C Compiler for RISC-V</strong></a> that runs in the <strong>Web Browser</strong>. (With <a href="https://ziglang.org/"><strong>Zig Compiler</strong></a> and WebAssembly)</p>
<p>But our C Compiler is kinda boring if it doesn‚Äôt support <strong>C Header Files</strong> and Library Files.</p>
<p>In this article we add a <strong>Read-Only Filesystem</strong> to our Zig Webassembly‚Ä¶</p>
<ul>
<li>
<p>TODO: Hosting Include Files</p>
</li>
<li>
<p>TODO: NuttX ROM FS Driver</p>
</li>
<li>
<p>TODO: Integrate TCC Compiler</p>
</li>
<li>
<p>TODO: Integrate NuttX Emulator</p>
</li>
<li>
<p>TODO: NuttX System Calls</p>
</li>
</ul>
<p>TODO: <img src="https://lupyuen.github.io/images/tcc-web.png" alt="Online Demo of TCC Compiler in WebAssembly" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><em>Online Demo of TCC Compiler in WebAssembly</em></a></p>
<h1 id="c-compiler-in-the-web-browser"><a href="#c-compiler-in-the-web-browser">1 C Compiler in the Web Browser</a></h1>
<p>Head over here to open <strong>TCC Compiler in our Web Browser</strong> (pic above)</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/romfs"><strong>TCC RISC-V Compiler with ROM FS</strong></a></p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
</ul>
<p>This <strong>C Program</strong> appears‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p>Click the ‚Äú<strong>Compile</strong>‚Äù button. Our Web Browser calls TCC to compile the above program‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile to RISC-V ELF
tcc -c hello.c
</code></pre></div>
<p>And it downloads the compiled <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>RISC-V ELF <code>a.out</code></strong></a>.</p>
<p>To test the Compiled Output, we browse to the <strong>NuttX Emulator</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/nuttx-tinyemu/tcc/"><strong>NuttX Emulator for Ox64 RISC-V SBC</strong></a></li>
</ul>
<p>We run <strong><code>a.out</code></strong> in the NuttX Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TinyEMU Emulator for Ox64 BL808 RISC-V SBC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; a.out
Hello, World!!
</code></pre></div>
<p>And it works: Our Web Browser generates a RISC-V Executable, that runs in a RISC-V Emulator!</p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><em>Surely it‚Äôs a staged demo? Or something server-side?</em></p>
<p>Everything runs entirely in our Web Browser. Try this‚Ä¶</p>
<ol>
<li>
<p>Change the <em>‚ÄúHello World‚Äù</em> message</p>
</li>
<li>
<p>Click ‚Äú<strong>Compile</strong>‚Äù</p>
</li>
<li>
<p>Reload the Web Browser for <a href="https://lupyuen.github.io/nuttx-tinyemu/tcc/"><strong>NuttX Emulator</strong></a></p>
</li>
<li>
<p>Run <strong><code>a.out</code></strong></p>
</li>
</ol>
<p>And the message changes! We discuss the internals‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tcc-posix.jpg" alt="TCC Compiler in WebAssembly needs POSIX Functions" /></p>
<h1 id="file-access-for-webassembly"><a href="#file-access-for-webassembly">2 File Access for WebAssembly</a></h1>
<p><em>Something oddly liberating about our demo‚Ä¶</em></p>
<p>TCC Compiler was created as a <strong>Command-Line App</strong> that calls the usual <a href="https://lupyuen.github.io/articles/tcc#posix-for-webassembly"><strong>POSIX Functions</strong></a> for File Access: <strong>open, read, write,</strong> ‚Ä¶</p>
<p>But WebAssembly runs in a Secure Sandbox. <a href="https://lupyuen.github.io/articles/tcc#file-input-and-output"><strong>No File Access</strong></a> allowed, sorry! (Like for C Header Files)</p>
<p><em>Huh! How did we get &lt;stdio.h&gt; and &lt;stdlib.h&gt;?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
// with ROM FS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}            
</code></pre></div>
<p><em>&lt;stdio.h&gt;</em> and <em>&lt;stdlib.h&gt;</em> come from the <strong>ROM FS Filesystem</strong> that‚Äôs bundled inside our TCC WebAssembly.</p>
<p>ROM FS works like a regular Filesystem (think FAT and EXT4). Just that it‚Äôs tiny, <strong>runs in memory</strong>. And bundles easily with WebAssembly.</p>
<p>(Coming up in the next section)</p>
<p><em>Hmmm sounds like a major makeover for TCC Compiler‚Ä¶</em></p>
<p>Previously TCC Compiler could access Header Files <strong>directly from the Local Filesystem</strong>‚Ä¶</p>
<p>TODO: Pic of TCC Filesystem</p>
<p>Now TCC WebAssembly needs to hoop through our <a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Wrapper</strong></a> to read the ROM FS Filesystem‚Ä¶</p>
<p>TODO: Pic of TCC ROM FS</p>
<p>This is how we made it work‚Ä¶</p>
<h1 id="rom-fs-filesystem"><a href="#rom-fs-filesystem">3 ROM FS Filesystem</a></h1>
<p><em>What‚Äôs this ROM FS?</em></p>
<p><a href="https://docs.kernel.org/filesystems/romfs.html"><strong>ROM FS</strong></a> is a <strong>Read-Only Filesystem</strong> that runs entirely in memory.</p>
<p>ROM FS is <strong>a lot simpler</strong> than Read-Write Filesystems (like FAT and EXT4). That‚Äôs why we run it inside TCC WebAssembly to host our C Include Files.</p>
<p><em>How to bundle our C Header Files into ROM FS?</em></p>
<p><strong><code>genromfs</code></strong> will pack our C Header Files into a ROM FS Filesystem: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh#L182-L190">build.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu: Install `genromfs`
sudo apt install genromfs

## For macOS: Install `genromfs`
brew install genromfs

## Bundle the `romfs` folder into
## ROM FS Filesystem `romfs.bin`
## and label with this Volume Name
genromfs \
  -f romfs.bin \
  -d romfs \
  -V &quot;ROMFS&quot;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs">(<em>&lt;stdio.h&gt;</em> and <em>&lt;stdlib.h&gt;</em> are in the <strong>ROM FS Folder</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin">(Bundled into this <strong>ROM FS Filesystem</strong>)</a></p>
<p>We embed the <strong>ROM FS Filesystem <code>romfs.bin</code></strong> into our <a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Wrapper</strong></a>, so it will be accessible by TCC WebAssembly: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/c2146f65cc8f338b8a3aaa4c2e88e550e82514ec/zig/tcc-wasm.zig#L993-L997">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Embed the ROM FS Filesystem
// into our Zig Wrapper
const ROMFS_DATA = @embedFile(&quot;romfs.bin&quot;);

// Later: Mount the ROM FS Filesystem
// from `ROMFS_DATA`
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#embedFile">(About <strong>@embedFile</strong>)</a></p>
<p><strong>For Easier Updates</strong>: We should download <a href="TODO"><strong><code>romfs.bin</code> from our Web Server</strong></a>.</p>
<p>TODO: <a href="https://emscripten.org/docs/porting/files/file_systems_overview.html">(Works like the <strong>Emscripten Filesystem</strong>)</a></p>
<h1 id="nuttx-driver-for-rom-fs"><a href="#nuttx-driver-for-rom-fs">4 NuttX Driver for ROM FS</a></h1>
<p><em>Is there a ROM FS Driver in Zig?</em></p>
<p>We looked around <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) and we found a <a href="https://github.com/apache/nuttx/blob/master/fs/romfs/fs_romfs.c"><strong>ROM FS Driver</strong></a> (in C). It works well in Zig!</p>
<p>Let‚Äôs walk through the steps to call the <strong>NuttX ROM FS Driver</strong> in Zig‚Ä¶</p>
<ul>
<li>
<p><strong>Mounting</strong> the ROM FS Filesystem</p>
</li>
<li>
<p><strong>Opening</strong> a ROM FS File</p>
</li>
<li>
<p><strong>Reading</strong> the ROM FS File</p>
</li>
<li>
<p>And <strong>Closing</strong> it</p>
</li>
</ul>
<h2 id="mount-the-filesystem"><a href="#mount-the-filesystem">4.1 Mount the Filesystem</a></h2>
<p>This is how we <strong>Mount our ROM FS Filesystem</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L11-L45">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the NuttX ROM FS Driver
const c = @cImport({
  @cInclude(&quot;zig_romfs.h&quot;);
});

/// Main Function of our Zig Wrapper
pub export fn compile_program(...) [*]const u8 {

  // Create the Memory Allocator for malloc
  memory_allocator = std.heap.FixedBufferAllocator
    .init(&amp;memory_buffer);

  // Mount the ROM FS Filesystem
  const ret = c.romfs_bind(
    c.romfs_blkdriver, // Block Driver for ROM FS
    null,              // No Data needed
    &amp;c.romfs_mountpt   // Returns the Mount Point
  );
  assert(ret &gt;= 0);

  // Prepare the Mount Inode.
  // We&#39;ll use it for opening files.
  romfs_inode = c.create_mount_inode(
    c.romfs_mountpt  // Mount Point
  );

  // Omitted: Call the TCC Compiler
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L320-L324">(<strong>romfs_files</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L160-L163">(<strong>romfs_inode</strong> is here)</a></p>
<p><em>What if the ROM FS Filesystem contains garbage?</em></p>
<p>Our ROM FS Driver will <strong>Fail the Mount Operation</strong>.</p>
<p>That‚Äôs because it searches for a <strong>Magic Number</strong> at the top of the filesystem: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/fs_romfsutil.c#L765-L770">fs_romfsutil.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Verify the Magic Number that identifies
// a ROM FS Filesystem
#define ROMFS_VHDR_MAGIC &quot;-rom1fs-&quot;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L91-L98">(See the <strong>Mount Log</strong>)</a></p>
<p><a href="https://en.wikipedia.org/wiki/I-mode">(Not to be confused with <strong>i-mode</strong>)</a></p>
<h2 id="open-a-rom-fs-file"><a href="#open-a-rom-fs-file">4.2 Open a ROM FS File</a></h2>
<p>Next we <strong>Open a ROM FS File</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L127-L138">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Create the File Struct.
// Link to the Mount Inode.
var file = std.mem.zeroes(c.struct_file);
file.f_inode = romfs_inode;

// Open the ROM FS File
const ret2 = c.romfs_open(
  &amp;file,       // File Struct
  &quot;stdio.h&quot;,   // Pathname (&quot;/&quot; paths are accepted)
  c.O_RDONLY,  // Read-Only
  0            // Mode (Unused for Read-Only Files)
);
assert(ret2 &gt;= 0);
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L99-L101">(See the <strong>Open Log</strong>)</a></p>
<h2 id="read-a-rom-fs-file"><a href="#read-a-rom-fs-file">4.3 Read a ROM FS File</a></h2>
<p>Finally we <strong>Read and Close</strong> the ROM FS File: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L138-L157">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Read the ROM FS File, first 4 bytes
var buf = std.mem.zeroes([4]u8);
const ret3 = c.romfs_read(
  &amp;file,   // File Struct
  &amp;buf,    // Buffer to be populated
  buf.len  // Buffer Size
);
assert(ret3 &gt;= 0);

// Dump the 4 bytes
hexdump.hexdump(@ptrCast(&amp;buf), @intCast(ret3));

// Close the ROM FS File
const ret4 = c.romfs_close(&amp;file);
assert(ret4 &gt;= 0);
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/hexdump.zig#L9-L92">(<strong>hexdump</strong> is here)</a></p>
<p>We‚Äôll see this‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>romfs_read: Read 4 bytes from offset 0 
romfs_read: Read sector 17969028 
romfs_filecacheread: sector: 2 cached: 0 ncached: 1 sectorsize: 64 XIP base: anyopaque@1122f74 buffer: anyopaque@1122f74 
romfs_filecacheread: XIP buffer: anyopaque@1122ff4 
romfs_read: Return 4 bytes from sector offset 0 
  0000:  2F 2F 20 43  // C
romfs_close: Closing 
</code></pre></div>
<p>Which looks right because <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L1"><em>&lt;stdio.h&gt;</em></a> begins with ‚Äú<a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L1"><strong><code>// C</code></strong></a>‚Äù</p>
<p><a href="https://gist.github.com/lupyuen/c05f606e4c25162136fd05c7a02d2191#file-tcc-wasm-nodejs-log-L102-L113">(See the <strong>Read Log</strong>)</a></p>
<p>TODO: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig">(See the <strong>Modified Source Files</strong>)</a></p>
<p>TODO: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/build.sh">(See the <strong>Build Script</strong>)</a></p>
<h1 id="inside-a-rom-fs-filesystem"><a href="#inside-a-rom-fs-filesystem">5 Inside a ROM FS Filesystem</a></h1>
<p>TODO</p>
<h1 id="tcc-calls-rom-fs-driver"><a href="#tcc-calls-rom-fs-driver">6 TCC calls ROM FS Driver</a></h1>
<p>TODO</p>
<p><em>TCC WebAssembly needs a ROM FS Filesystem that will have C Header Files and C Library Files for building apps‚Ä¶</em></p>
<p><em>How will we integrate the NuttX ROM FS Driver in Zig?</em></p>
<p>At Startup: We call the NuttX ROM FS Driver to mount the ROM FS Filesystem: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L24-L45">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Next File Descriptor Number.
/// First File Descriptor is reserved for C Program `hello.c`
var next_fd: c_int = FIRST_FD;
const FIRST_FD = 3;

/// Map a File Descriptor to the ROM FS File
/// Index of romfs_files = File Descriptor Number - FIRST_FD - 1
var romfs_files: std.ArrayList(*c.struct_file) = undefined;

/// Compile a C program to 64-bit RISC-V
pub export fn compile_program(...) [*]const u8 {

  // Create the Memory Allocator for malloc
  memory_allocator = std.heap.FixedBufferAllocator.init(&amp;memory_buffer);

  // Map from File Descriptor to ROM FS File
  romfs_files = std.ArrayList(*c.struct_file).init(std.heap.page_allocator);
  defer romfs_files.deinit();

  // Mount the ROM FS Filesystem
  const ret = c.romfs_bind( // Bind the ROM FS Filesystem
    c.romfs_blkdriver, // blkdriver: ?*struct_inode_6
    null, // data: ?*const anyopaque
    &amp;c.romfs_mountpt // handle: [*c]?*anyopaque
  );
  assert(ret &gt;= 0);

  // Create the Mount Inode and test the ROM FS
  romfs_inode = c.create_mount_inode(c.romfs_mountpt);
  test_romfs();
</code></pre></div>
<p>NuttX ROM FS Driver will call <code>mtd_ioctl</code> to map the ROM FS Data in memory: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L974-L994">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Embed the ROM FS Filesystem.
/// Later our JavaScript shall fetch this over HTTP.
const ROMFS_DATA = @embedFile(&quot;romfs.bin&quot;);

export fn mtd_ioctl(_: *mtd_dev_s, cmd: c_int, rm_xipbase: ?*c_int) c_int {
  assert(rm_xipbase != null);
  if (cmd == c.BIOC_XIPBASE) {
    // Return the XIP Base Address
    rm_xipbase.?.* = @intCast(@intFromPtr(ROMFS_DATA));
  } else if (cmd == c.MTDIOC_GEOMETRY) {
    // Return the Storage Device Geometry
    const geo: *c.mtd_geometry_s = @ptrCast(rm_xipbase.?);
    geo.*.blocksize = 64;
    geo.*.erasesize = 64;
    geo.*.neraseblocks = 1024; // TODO: Is this needed?
    const name = &quot;ZIG_ROMFS&quot;;
    @memcpy(geo.*.model[0..name.len], name);
    geo.*.model[name.len] = 0;
  } else {
    debug(&quot;mtd_ioctl: Unknown command {}&quot;, .{cmd});
  }
  return 0;
}
</code></pre></div>
<p>When TCC WebAssembly calls <code>open</code> to open an Include File, we call the NuttX ROM FS Driver to open the file in ROM FS: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L157-L207">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>export fn open(path: [*:0]const u8, oflag: c_uint, ...) c_int {

  // If opening the C Program File `hello.c`
  // Or creating `hello.o`...
  // Just return the File Descriptor
  // TODO: This might create a hole in romfs_files if we open a file for reading after writing another file
  if (next_fd == FIRST_FD or oflag == 577) {
    const fd = next_fd;
    next_fd += 1;
    return fd;
  } else {
    // If opening an Include File or Library File...
    // Allocate the File Struct
    const files = std.heap.page_allocator.alloc(c.struct_file, 1) catch {
      debug(&quot;open: Failed to allocate file&quot;, .{});
      @panic(&quot;open: Failed to allocate file&quot;);
    };
    const file = &amp;files[0];
    file.* = std.mem.zeroes(c.struct_file);
    file.*.f_inode = romfs_inode;

    // Strip the path from System Include
    const sys = &quot;/usr/local/lib/tcc/include/&quot;;
    const strip_path = if (std.mem.startsWith(u8, std.mem.span(path), sys)) (path + sys.len) else path;

    // Open the ROM FS File
    const ret = c.romfs_open( // Open for Read-Only. `mode` is used only for creating files.
      file, // filep: [*c]struct_file
      strip_path, // relpath: [*c]const u8
      c.O_RDONLY, // oflags: c_int
      0 // mode: mode_t
    );
    if (ret &lt; 0) { return ret; }

    // Remember the ROM FS File
    const fd = next_fd;
    next_fd += 1;
    const f = fd - FIRST_FD - 1;
    assert(romfs_files.items.len == f);
    romfs_files.append(file) catch {
      debug(&quot;Unable to allocate file&quot;, .{});
      @panic(&quot;Unable to allocate file&quot;);
    };
    return fd;
  }
}
</code></pre></div>
<p>When TCC WebAssembly calls <code>read</code> to read the Include File, we call ROM FS: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L214-L244">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>export fn read(fd: c_int, buf: [*:0]u8, nbyte: size_t) isize {

  // If reading the C Program...
  if (fd == FIRST_FD) {
    // Copy from the Read Buffer
    const len = read_buf.len;
    assert(len &lt; nbyte);
    @memcpy(buf[0..len], read_buf[0..len]);
    buf[len] = 0;
    read_buf.len = 0;
    return @intCast(len);
  } else {
    // Fetch the ROM FS File
    const f = fd - FIRST_FD - 1;
    const file = romfs_files.items[@intCast(f)];

    // Read from the ROM FS File
    const ret = c.romfs_read( // Read the file
      file, // filep: [*c]struct_file
      buf, // buffer: [*c]u8
      nbyte // buflen: usize
    );
    assert(ret &gt;= 0);
    return @intCast(ret);
  }
}
</code></pre></div>
<p>And finally we call ROM FS Driver to close the Include File: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/tcc-wasm.zig#L266-L286">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>export fn close(fd: c_int) c_int {

  // If closing an Include File or Library File...
  if (fd &gt; FIRST_FD) {
    // Fetch the ROM FS File
    const f = fd - FIRST_FD - 1;
    if (f &gt;= romfs_files.items.len) {
      // Skip the closing of `hello.o`
      return 0;
    }
    const file = romfs_files.items[@intCast(f)];

    // Close the ROM FS File. TODO: Deallocate the file
    const ret = c.romfs_close(file);
    assert(ret &gt;= 0);
  }
  return 0;
}
</code></pre></div>
<p>We stage the Include Files <code>stdio.h</code> and <code>stdlib.h</code> here: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs">zig/romfs</a></p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -l zig/romfs
-rw-r--r-- 1 25 stdio.h
-rw-r--r-- 1 23 stdlib.h
</code></pre></div>
<p>And we bundle them into <code>romfs.bin</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Bundle the romfs folder into ROM FS Filesystem romfs.bin
## and label with this Volume Name
genromfs \
  -f zig/romfs.bin \
  -d zig/romfs \
  -V &quot;ROMFS&quot;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin">(See the ROM FS Binary <code>zig/romfs.bin</code>)</a></p>
<p>At last we have a proper POSIX (Read-Only) Filesystem for TCC WebAssembly yay!</p>
<div class="example-wrap"><pre class="language-text"><code>open: path=/usr/local/lib/tcc/include/stdio.h, oflag=0, return fd=4
Open &#39;stdio.h&#39;
read: fd=4, nbyte=8192
XIP buffer: anyopaque@10b672
read: return buf=
  int puts(const char *s);

read: fd=4, nbyte=8192
read: return buf=
close: fd=4
Closing

open: path=/usr/local/lib/tcc/include/stdlib.h, oflag=0, return fd=5
Open &#39;stdlib.h&#39;
read: fd=5, nbyte=8192
XIP buffer: anyopaque@10b6b2
read: return buf=
  void exit(int status);

read: fd=5, nbyte=8192
read: return buf=
close: fd=5
Closing
</code></pre></div>
<p><em>What if we need a Temporary Writeable Filesystem?</em></p>
<p>Try the NuttX Tmp FS Driver: <a href="https://github.com/apache/nuttx/tree/master/fs/tmpfs">nuttx/fs/tmpfs</a></p>
<p><em>Why not FAT?</em></p>
<p>TODO: <a href="https://blog.setale.me/2022/06/27/Steam-Deck-and-Overlay-FS/"><strong>Immutable Filesystem</strong></a></p>
<p>Time to wrap up and run everything in a Web Browser‚Ä¶</p>
<h1 id="from-tcc-to-nuttx-emulator"><a href="#from-tcc-to-nuttx-emulator">7 From TCC to NuttX Emulator</a></h1>
<p>TODO</p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p>Remember we‚Äôre doing a Decent Demo of Building and Testing a #NuttX App in the Web Browser‚Ä¶ <code>puts</code> and <code>exit</code> finally work OK yay! üéâ</p>
<ol>
<li>
<p>TCC Compiler in WebAssembly compiles <code>puts</code> and <code>exit</code> to proper NuttX System Calls</p>
</li>
<li>
<p>By loading <code>&lt;stdio.h&gt;</code> and <code>&lt;stdlib.h&gt;</code> from the ROM FS Filesystem (thanks to the NuttX Driver)</p>
</li>
<li>
<p>TCC Compiler generates the 64-bit RISC-V ELF <code>a.out</code></p>
</li>
<li>
<p>Which gets automagically copied to NuttX Emulator in WebAssembly</p>
</li>
<li>
<p>And NuttX Emulator executes <code>puts</code> and <code>exit</code> correctly as NuttX System Calls!</p>
</li>
</ol>
<p>Try the new ROM FS Demo here: https://lupyuen.github.io/tcc-riscv32-wasm/romfs/</p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]) {
  puts(&quot;Hello, World!!\n&quot;);
  exit(0);
}
</code></pre></div>
<p>Click ‚ÄúCompile‚Äù. Then run the <code>a.out</code> here: https://lupyuen.github.io/nuttx-tinyemu/tcc/</p>
<div class="example-wrap"><pre class="language-text"><code>Loading...
TinyEMU Emulator for Ox64 BL808 RISC-V SBC
ABC
NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; a.out
Hello, World!!
 
nsh&gt; a.out
Hello, World!!
 
nsh&gt; a.out
Hello, World!!
 
nsh&gt;
</code></pre></div>
<p>Try changing ‚ÄúHello World‚Äù to something else. Recompile and Reload the <a href="https://lupyuen.github.io/nuttx-tinyemu/tcc/">NuttX Emulator</a>. It works!</p>
<p>Impressive, no? 3 things we fixed‚Ä¶</p>
<p><a href="https://youtu.be/sU69bUyrgN8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<h1 id="rom-fs-filesystem-for-tcc"><a href="#rom-fs-filesystem-for-tcc">8 ROM FS Filesystem for TCC</a></h1>
<p>TODO</p>
<p><em>How did we get &lt;stdio.h&gt; and &lt;stdlib.h&gt; in TCC WebAssembly?</em></p>
<p>We create a Staging Folder <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs">zig/romfs</a> that contains our C Header Files for TCC Compiler‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h">stdio.h</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdlib.h">stdlib.h</a></p>
</li>
</ul>
<p>Then we bundle the Staging Folder into a ROM FS Filesystem‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Bundle the romfs folder into ROM FS Filesystem romfs.bin
## and label with this Volume Name
genromfs \
  -f zig/romfs.bin \
  -d zig/romfs \
  -V &quot;ROMFS&quot;
</code></pre></div>
<p>Which becomes the ROM FS Data File <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs.bin">zig/romfs.bin</a></p>
<p>Inside our TCC WebAssembly: We mounted the ROM FS Filesystem by calling the NuttX ROM FS Driver. (Which has been integrated into our Zig WebAssembly)</p>
<p>See the earlier sections to find out how we modded the POSIX Filesystem Calls (from TCC WebAssembly) to access the NuttX ROM FS Driver.</p>
<h1 id="print-with-nuttx-system-call"><a href="#print-with-nuttx-system-call">9 Print with NuttX System Call</a></h1>
<p>TODO</p>
<p>In our Demo NuttX App, we implement <code>puts</code> by calling <code>write</code>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L18-L25">stdio.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Print the string to Standard Output
inline int puts(const char *s) {
  return
    write(1, s, strlen(s)) +
    write(1, &quot;\n&quot;, 1);
}
</code></pre></div>
<p>Then we implement <code>write</code> the exact same way as NuttX, making a System Call: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L25-L36">stdio.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Caution: This may change
#define SYS_write 61

// Write to the File Descriptor
// https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel
inline ssize_t write(int parm1, const void * parm2, size_t parm3) {
  return (ssize_t) sys_call3(
    (unsigned int) SYS_write,  // System Call Number
    (uintptr_t) parm1,         // File Descriptor (1 = Standard Output)
    (uintptr_t) parm2,         // Buffer to be written
    (uintptr_t) parm3          // Number of bytes to write
  );
}
</code></pre></div>
<p><code>sys_call3</code> is our hacked implementation of NuttX System Call: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdio.h#L36-L84">stdio.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Make a System Call with 3 parameters
// https://github.com/apache/nuttx/blob/master/arch/risc-v/include/syscall.h#L240-L268
inline uintptr_t sys_call3(
  unsigned int nbr,  // System Call Number
  uintptr_t parm1,   // First Parameter
  uintptr_t parm2,   // Second Parameter
  uintptr_t parm3    // Third Parameter
) {
  // Pass the Function Number and Parameters in
  // Registers A0 to A3
  register long r3 asm(&quot;a0&quot;) = (long)(parm3);  // Will move to A3
  asm volatile (&quot;slli a3, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a3, a3, 32&quot;);  // To clear the top 32 bits

  register long r2 asm(&quot;a0&quot;) = (long)(parm2);  // Will move to A2
  asm volatile (&quot;slli a2, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a2, a2, 32&quot;);  // To clear the top 32 bits

  register long r1 asm(&quot;a0&quot;) = (long)(parm1);  // Will move to A1
  asm volatile (&quot;slli a1, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a1, a1, 32&quot;);  // To clear the top 32 bits

  register long r0 asm(&quot;a0&quot;) = (long)(nbr);  // Will stay in A0

  // `ecall` will jump from RISC-V User Mode
  // to RISC-V Supervisor Mode
  // to execute the System Call.
  // Input + Output Registers: A0 to A3
  // Clobbers the Memory
  asm volatile
  (
    // ECALL for System Call to NuttX Kernel
    &quot;ecall \n&quot;
    
    // NuttX needs NOP after ECALL
    &quot;.word 0x0001 \n&quot;

    // Input+Output Registers: None
    // Input-Only Registers: A0 to A3
    // Clobbers the Memory
    :
    : &quot;r&quot;(r0), &quot;r&quot;(r1), &quot;r&quot;(r2), &quot;r&quot;(r3)
    : &quot;memory&quot;
  );

  // Return the result from Register A0
  return r0;
} 
</code></pre></div>
<p><em>Why so complicated?</em></p>
<p>That‚Äôs because TCC <a href="https://lupyuen.github.io/articles/tcc#appendix-nuttx-system-call">won‚Äôt load the RISC-V Registers correctly</a>. Thus we load the registers ourselves.</p>
<p><em>Why not simply copy A0 to A2?</em></p>
<div class="example-wrap"><pre class="language-c"><code>register long r2 asm(&quot;a0&quot;) = (long)(parm2);  // Will move to A2
asm volatile (&quot;addi a2, a0, 0&quot;);  // Copy A0 to A2
</code></pre></div>
<p>Because then Register A2 becomes negative‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_swint: Entry: regs: 0x8020be10
cmd: 61
EPC: 00000000c0000160
A0: 000000000000003d 
A1: 0000000000000001 
A2: ffffffffc0101000 
A3: 000000000000000f
[...Page Fault because A2 is Invalid Address...]
</code></pre></div>
<p>So we Shift away the Negative Sign‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>register long r2 asm(&quot;a0&quot;) = (long)(parm2);  // Will move to A2
asm volatile (&quot;slli a2, a0, 32&quot;);  // Shift 32 bits Left then Right
asm volatile (&quot;srli a2, a2, 32&quot;);  // To clear the top 32 bits
</code></pre></div>
<p>Then Register A2 becomes Positively OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv_swint: Entry: regs: 0x8020be10
cmd: 61
EPC: 00000000c0000164
A0: 000000000000003d 
A1: 0000000000000001
A2: 00000000c0101000
A3: 000000000000000f
Hello, World!!
</code></pre></div>
<p>BTW <code>andi</code> doesn‚Äôt work‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>register long r2 asm(&quot;a0&quot;) = (long)(parm2);  // Will move to A2
asm volatile (&quot;andi a2, a0, 0xffffffff&quot;);
</code></pre></div>
<p>Because 0xffffffff gets assembled to -1. (Bug?)</p>
<h1 id="exit-with-nuttx-system-call"><a href="#exit-with-nuttx-system-call">10 Exit with NuttX System Call</a></h1>
<p>TODO</p>
<p>In our Demo NuttX App, we implement <code>exit</code> the same way as NuttX, by making a System Call: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdlib.h#L1-L10">stdlib.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Caution: This may change
#define SYS__exit 8

// Terminate the NuttX Process
// From nuttx/syscall/proxies/PROXY__exit.c
inline void exit(int parm1) {
  sys_call1((unsigned int)SYS__exit, (uintptr_t)parm1);
  while(1);
}
</code></pre></div>
<p><code>sys_call1</code> makes a NuttX System Call, with our hand-crafted RISC-V Assembly (as a workaround): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/romfs/zig/romfs/stdlib.h#L10-L48">stdlib.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Make a System Call with 1 parameters
// https://github.com/apache/nuttx/blob/master/arch/risc-v/include/syscall.h#L188-L213
inline uintptr_t sys_call1(
  unsigned int nbr,  // System Call Number
  uintptr_t parm1    // First Parameter
) {
  // Pass the Function Number and Parameters
  // Registers A0 to A1
  register long r1 asm(&quot;a0&quot;) = (long)(parm1);  // Will move to A1
  asm volatile (&quot;slli a1, a0, 32&quot;);  // Shift 32 bits Left then Right
  asm volatile (&quot;srli a1, a1, 32&quot;);  // To clear the top 32 bits

  register long r0 asm(&quot;a0&quot;) = (long)(nbr);  // Will stay in A0

  // `ecall` will jump from RISC-V User Mode
  // to RISC-V Supervisor Mode
  // to execute the System Call.
  // Input + Output Registers: A0 to A1
  // Clobbers the Memory
  asm volatile
  (
    // ECALL for System Call to NuttX Kernel
    &quot;ecall \n&quot;
    
    // NuttX needs NOP after ECALL
    &quot;.word 0x0001 \n&quot;

    // Input+Output Registers: None
    // Input-Only Registers: A0 to A1
    // Clobbers the Memory
    :
    : &quot;r&quot;(r0), &quot;r&quot;(r1)
    : &quot;memory&quot;
  );

  // Return the result from Register A0
  return r0;
} 
</code></pre></div>
<p>And everything works OK now!</p>
<p><em>Wow this looks horribly painful‚Ä¶ Are we doing any more of this?</em></p>
<p>Nope we won‚Äôt do any more of this! Hand-crafting the NuttX System Calls in RISC-V Assembly was extremely painful.</p>
<p>(Maybe we‚Äôll revisit this when the RISC-V Registers are working OK in TCC)</p>
<p>TODO: Define the printf formats %jd, %zu</p>
<p>TODO: Iteratively handle printf formats</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX and Zig Communities) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/romfs.md"><strong>lupyuen.github.io/src/romfs.md</strong></a></p>

    
</body>
</html>