<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Early Days of Rust Apps on Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Early Days of Rust Apps on Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust6-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/rust6.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Early Days of Rust Apps on Apache NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#blink-the-led">1 Blink The LED</a><ul></ul></li>
<li><a href="#test-on-qemu-emulator">2 Test on QEMU Emulator</a><ul></ul></li>
<li><a href="#handle-errors-safely">3 Handle Errors Safely</a><ul></ul></li>
<li><a href="#runs-on-linux--macos--windows">4 Runs on Linux / macOS / Windows</a><ul></ul></li>
<li><a href="#main-function-for-rust">5 Main Function for Rust</a><ul></ul></li>
<li><a href="#panic-handler-for-rust">6 Panic Handler for Rust</a><ul></ul></li>
<li><a href="#no-crates-in-nuttx">7 No Crates in NuttX</a><ul></ul></li>
<li><a href="#led-drivers-for-nuttx">8 LED Drivers for NuttX</a><ul></ul></li>
<li><a href="#daily-build-and-test">9 Daily Build and Test</a><ul></ul></li>
<li><a href="#all-things-considered">10 All Things Considered</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-daily-test-of-rust-blinky">12 Appendix: Daily Test of Rust Blinky</a><ul></ul></li>
<li><a href="#appendix-daily-test-of-nuttx-qemu-risc-v">13 Appendix: Daily Test of NuttX QEMU RISC-V</a><ul></ul></li>
<li><a href="#appendix-nuttx-qemu-risc-v-fails-on-github-actions">14 Appendix: NuttX QEMU RISC-V fails on GitHub Actions</a><ul></ul></li></ul></nav><p>üìù <em>26 Aug 2024</em></p>
<p><img src="https://lupyuen.github.io/images/rust6-title.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<p>My student <a href="TODO"><strong>Rushabh Gala</strong></a> has just completed his project for <a href="TODO"><strong>Google Summer of Code</strong></a>. Rushabh has created safer <strong>Rust Apps</strong> for <strong>Apache NuttX RTOS</strong>‚Ä¶</p>
<ul>
<li>
<p>TODO: Final Report</p>
</li>
<li>
<p>TODO: Midterm Report</p>
</li>
<li>
<p>TODO: NuttX Workshop Presentation </p>
</li>
</ul>
<p>In this article we walk through Rushabh‚Äôs contributions. And understand how we‚Äôre evolving <strong>Rust Apps for NuttX</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Blinking the LED</strong> in Rust</p>
</li>
<li>
<p>Testing on <strong>QEMU RISC-V Emulator</strong></p>
</li>
<li>
<p><strong>Handling Errors</strong> returned by NuttX</p>
</li>
<li>
<p>TODO: Runs on Linux / macOS / Window</p>
</li>
<li>
<p>TODO: Main Function</p>
</li>
<li>
<p>TODO: Panic Handler</p>
</li>
<li>
<p>TODO: No Crates in NuttX</p>
</li>
<li>
<p>TODO: LED Drivers for NuttX</p>
</li>
<li>
<p>TODO: Daily Build and Test</p>
</li>
<li>
<p>TODO: Updating the docker image for CI</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-flow2.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="blink-the-led"><a class="doc-anchor" href="#blink-the-led">¬ß</a>1 Blink The LED</h1>
<p>This is how we <strong>Blink the LED</strong> in a NuttX Rust App: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Main Program Logic. Called by `leds_rust_main`
</span><span class="kw">fn </span>rust_main(_argc: i32, _argv: <span class="kw-2">*const *const </span>u8)  <span class="comment">// Args from NuttX Shell
  </span>-&gt; <span class="prelude-ty">Result</span>&lt;i32, i32&gt; {  <span class="comment">// Return a Result Code (int) or Error Code (int)

  // Open the LED Device
  </span>safe_puts(<span class="string">"Hello, Rust!!"</span>);
  <span class="kw">let </span>fd = safe_open(<span class="string">"/dev/userleds"</span>, O_WRONLY) <span class="question-mark">?</span>;  <span class="comment">// Quit on error

  // Flip LED 1 to On
  </span>safe_ioctl(fd, ULEDIOC_SETALL, <span class="number">1</span>) <span class="question-mark">?</span>;  <span class="comment">// Quit on error
  </span><span class="kw">unsafe </span>{ usleep(<span class="number">500_000</span>); }

  <span class="comment">// Flip LED 1 to Off
  </span>safe_ioctl(fd, ULEDIOC_SETALL, <span class="number">0</span>) <span class="question-mark">?</span>;  <span class="comment">// Quit on error
  </span><span class="kw">unsafe </span>{ close(fd); }

  <span class="comment">// Return successfully with result 0
  </span><span class="prelude-val">Ok</span>(<span class="number">0</span>)
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-rust-app/blob/main/app/src/main.rs">(<strong>Mirrored here:</strong> nuttx-rust-app/app/src/main.rs)</a></p>
<p>Our Rust Blinky App looks mighty similar to the <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85"><strong>C Version</strong></a>! But with simpler Error Handling than C. (We‚Äôll talk more)</p>
<p><em>What are safe_open and safe_ioctl?</em></p>
<p>They are safer versions of <strong>open</strong> and <strong>ioctl</strong> from our <a href="TODO"><strong>NuttX Module</strong></a>. Inside the NuttX Module we‚Ä¶</p>
<ul>
<li>
<p>Define the Safe Wrappers: <strong><code>safe_*</code></strong></p>
</li>
<li>
<p>Import <strong>usleep</strong> and <strong>close</strong> from C</p>
</li>
<li>
<p>Plus the NuttX Constants: <strong>O_WRONLY</strong> and <strong>ULEDIOC_SETALL</strong></p>
</li>
</ul>
<p>We import the <strong>NuttX Module</strong> into our Rust App like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Comment out these lines for testing on Linux / macOS / Windows
</span><span class="attr">#![no_main]  </span><span class="comment">// For NuttX Only: No Main Function
</span><span class="attr">#![no_std]   </span><span class="comment">// For NuttX Only: Use Rust Core Library (instead of Rust Standard Library)

// Import the NuttX Module
</span><span class="kw">mod </span>nuttx;
<span class="kw">use </span>nuttx::<span class="kw-2">*</span>;</code></pre></div>
<p>And yes this code runs on Linux, macOS and Windows! We‚Äôll come back to this. First we test on QEMU‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-qemu.jpg" alt="Testing Rust Blinky on QEMU Emulator" /></p>
<h1 id="test-on-qemu-emulator"><a class="doc-anchor" href="#test-on-qemu-emulator">¬ß</a>2 Test on QEMU Emulator</h1>
<p>To test Rust Blinky on <strong>QEMU RISC-V Emulator</strong>, follow these steps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install the Rust Target for QEMU RISC-V 64-bit
rustup target add riscv64gc-unknown-none-elf

## Install QEMU Emulator for RISC-V
sudo apt install qemu-system-riscv64  ## For Linux
brew install qemu  ## For macOS

## Download the Source Code for NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure the NuttX Build: QEMU RISC-V 64-bit with LED Driver and Rust
tools/configure.sh rv-virt:leds64_rust

## Build the NuttX Kernel. Ignore the warning: `nuttx has a LOAD segment with RWX permissions`
make

## Boot the NuttX Kernel in QEMU RISC-V 64-bit
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-leds64-rust.yml">(See the <strong>Build Script</strong>)</a></p>
<p>At the NSH Prompt: Enter ‚Äú<strong><code>leds_rust</code></strong>‚Äù (pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.6.0-RC1
nsh&gt; leds_rust
Hello, Rust!!
Opening /dev/userleds

Set LED 1 to 1
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
Sleeping...

Set LED 1 to 0
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/actions/runs/10396419763/job/28790386663">(See the <strong>NuttX Log</strong>)</a></p>
<p>Rust blinks our Simulated LED on NuttX QEMU!</p>
<p><img src="https://lupyuen.github.io/images/rust6-title.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="handle-errors-safely"><a class="doc-anchor" href="#handle-errors-safely">¬ß</a>3 Handle Errors Safely</h1>
<p><em>Why the funny question mark? (Pic above)</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fd = safe_open(  <span class="comment">// Open the LED Device...
  </span><span class="string">"/dev/userleds"</span>,   <span class="comment">// Device Path
  </span>O_WRONLY           <span class="comment">// Open for Write-Only
</span>) <span class="question-mark">?</span>;                 <span class="comment">// Quit on error</span></code></pre></div>
<p>Remember in C we check the <a href="TODO"><strong>Result Value</strong></a> at every call to <strong>open</strong> and <strong>ioctl</strong>‚Ä¶ Now with <strong>safe_open</strong> and <strong>safe_ioctl</strong>, Rust does the checking for us!</p>
<p>If something goes wrong, the code above will exit the function with an <strong>Error Value</strong>. (Like if <em>‚Äú/dev/userleds‚Äù</em> doesn‚Äôt exist)</p>
<p>Our NuttX App becomes a little safer with the <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html"><strong>Question Mark Operator</strong></a>, by auto-checking the results of System Calls.</p>
<p>(Rust Compiler will warn us if we forget the Question Mark)</p>
<p>TODO: safe_puts buffer size</p>
<p><em>But usleep and close are still unsafe?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Wait a while
</span><span class="kw">unsafe </span>{ usleep(<span class="number">500_000</span>); }
...
<span class="comment">// Close the LED Device
</span><span class="kw">unsafe </span>{ close(fd); }</code></pre></div>
<p>Yeah there‚Äôs not much point in wrapping <strong>usleep</strong> and <strong>close</strong>? Since we don‚Äôt check the Return Values.</p>
<p><em>Can we auto-close the File Descriptor when it goes out of scope?</em></p>
<p>Probably, if we do <a href="https://docs.rs/rustix/latest/rustix/fd/struct.OwnedFd.html"><strong>Managed File Descriptors</strong></a>? But that‚Äôs way beyond the size, scope and scale of GSoC.</p>
<p><img src="https://lupyuen.github.io/images/rust6-cargo.jpg" alt="Run Rust Blinky on Linux / macOS / Windows" /></p>
<h1 id="runs-on-linux--macos--windows"><a class="doc-anchor" href="#runs-on-linux--macos--windows">¬ß</a>4 Runs on Linux / macOS / Windows</h1>
<p><em>Will our NuttX App actually run on Linux, macOS and Windows?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Comment out these lines for testing on Linux / macOS / Windows
</span><span class="attr">#![no_main]  </span><span class="comment">// For NuttX Only: No Main Function
</span><span class="attr">#![no_std]   </span><span class="comment">// For NuttX Only: Use Rust Core Library (instead of Rust Standard Library)</span></code></pre></div>
<p>Yep indeed! Just comment out the above lines and run our Rust Blinky App on <strong>Linux / macOS / Windows</strong> (WSL)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ git clone https://github.com/lupyuen/nuttx-rust-app
$ cd nuttx-rust-app
$ cd app
$ cargo run
Hello, Rust!!
Opening /dev/userleds
ERROR: rust_main() failed with error -1
</code></pre></div>
<p>Which fails (as expected) because <em>‚Äú/dev/userleds‚Äù</em> doesn‚Äôt exist on Linux / macOS / Windows. (Pic above)</p>
<p>This greatly simplifies our NuttX App Development: We could (potentially) compile and run our NuttX App on our <strong>Local Computer</strong>, before testing on NuttX!</p>
<p>(<strong>Rust Analyzer</strong> won‚Äôt work inside NuttX Projects sigh)</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="main-function-for-rust"><a class="doc-anchor" href="#main-function-for-rust">¬ß</a>5 Main Function for Rust</h1>
<p><em>We saw the LED Blinky code in rust_main. Who calls rust_main?</em></p>
<p>Remember that <strong>rust_main</strong> returns a <strong>Result Type</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// `rust_main` accepts the args from NuttX Shell
// And returns a Result Code (int) or Error Code (int)
</span><span class="kw">fn </span>rust_main(_argc: i32, _argv: <span class="kw-2">*const *const </span>u8)
  -&gt; <span class="prelude-ty">Result</span>&lt;i32, i32&gt; { ... }</code></pre></div>
<p>But NuttX expects us to provide a Main Function named <strong>leds_rust_main</strong>. And it shall return an <strong>Integer Result</strong>. (Not a Result Type)</p>
<p>Thus we create an <strong>leds_rust_main</strong> function that calls <strong>rust_main</strong> and returns the right result‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// For NuttX: This will be called by NuttX Shell
// For Linux / macOS / Windows: This wil be called by `main`
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>leds_rust_main(argc: i32, argv: <span class="kw-2">*const *const </span>u8)  <span class="comment">// Args from NuttX Shell
  </span>-&gt; i32 {  <span class="comment">// Return a Result Code (0) or Error Code (negative)

  // Call the program logic in Rust Main
  </span><span class="kw">let </span>res = rust_main(argc, argv);

  <span class="comment">// If Rust Main returns an error, print it.
  // We won't wrap `printf`, because it needs VarArgs.
  </span><span class="kw">if let </span><span class="prelude-val">Err</span>(e) = res {
    <span class="kw">unsafe </span>{ printf(<span class="string">b"ERROR: rust_main() failed with error %d\n\0" </span><span class="kw">as </span><span class="kw-2">*const </span>u8, e); }
    e  <span class="comment">// Return the Error Code
  </span>} <span class="kw">else </span>{
    <span class="number">0  </span><span class="comment">// Or return the Result Code 0
  </span>}
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rust6-flow3.jpg" alt="Main Function for Rust Blinky" /></p>
<p><em>What about Linux / macOS / Windows?</em></p>
<p>They expect us to provide a <strong>main</strong> function. Thus we do this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// For Linux / macOS / Windows: Define the Main Function
</span><span class="attr">#[cfg(not(target_os = <span class="string">"none"</span>))]
</span><span class="kw">fn </span>main() {

  <span class="comment">// Call Rust Main without args
  </span>leds_rust_main(<span class="number">0</span>, core::ptr::null());
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rust6-flow4.jpg" alt="Panic Handler for Rust Blinky App" /></p>
<h1 id="panic-handler-for-rust"><a class="doc-anchor" href="#panic-handler-for-rust">¬ß</a>6 Panic Handler for Rust</h1>
<p><em>Anything else specific to NuttX?</em></p>
<p>Yep NuttX Apps run on the <a href="TODO"><strong>Rust Core Library</strong></a> (no_std) and require a <strong>Panic Handler</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// For NuttX Only: Import the Panic Type
</span><span class="attr">#[cfg(target_os = <span class="string">"none"</span>)]
</span><span class="kw">use </span>core::{
  panic::PanicInfo,
  result::Result::{<span class="self">self</span>, <span class="prelude-val">Err</span>, <span class="prelude-val">Ok</span>},
};

<span class="comment">// For NuttX Only: Define the Panic Handler for `no_std`
</span><span class="attr">#[cfg(target_os = <span class="string">"none"</span>)]
#[panic_handler]
</span><span class="kw">fn </span>panic(_panic: <span class="kw-2">&amp;</span>PanicInfo&lt;<span class="lifetime">'_</span>&gt;) -&gt; ! {
  <span class="kw">loop </span>{}
}</code></pre></div>
<p>(Sorry <strong>cfg</strong> won‚Äôt work for <strong>no_main</strong> and <strong>no_std</strong>)</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow5.jpg" alt="No Crates allowed in NuttX" /></p>
<h1 id="no-crates-in-nuttx"><a class="doc-anchor" href="#no-crates-in-nuttx">¬ß</a>7 No Crates in NuttX</h1>
<p><em>We‚Äôre coding Rust in a strange way. Why not use crates and cargo?</em></p>
<p>Ah that‚Äôs because NuttX <a href="TODO"><strong>doesn‚Äôt support Rust Crates</strong></a>! We can‚Äôt use <strong>cargo</strong> either, NuttX Build calls <strong>rustc</strong> directly‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Configure the NuttX Project
## for QEMU RISC-V 64-bit including Rust
$ tools/configure.sh rv-virt:leds64_rust

## Build the NuttX Project
## Which calls `rustc`
$ make
</code></pre></div>
<p>Which complicates our coding of NuttX Rust Apps. That‚Äôs why we hope to test them on <a href="TODO"><strong>Linux / macOS / Windows</strong></a>.</p>
<p>TODO: No Crates! Need to embed NuttX Module in every Rust App (common folder?)</p>
<p><img src="https://lupyuen.github.io/images/rust6-ox64.jpg" alt="Testing Rust Blinky on Ox64 BL808 SBC" /></p>
<h1 id="led-drivers-for-nuttx"><a class="doc-anchor" href="#led-drivers-for-nuttx">¬ß</a>8 LED Drivers for NuttX</h1>
<p><em>12 weeks of GSoC: What else have we implemented?</em></p>
<p>Remember our Blinky NuttX App in Rust? Well a NuttX App ain‚Äôt really a NuttX App‚Ä¶ Unless it runs <strong>on Real Hardware</strong>!</p>
<p>We tested our Rust Blinky App on <a href="TODO"><strong>Ox64 BL808 SBC</strong></a> (pic above). Which needs us to create the <strong>GPIO and LED Drivers</strong> for Ox64 SBC‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12571"><strong>‚ÄúAdd GPIO Driver for BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12614"><strong>‚ÄúAdd LED Driver for Ox64‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/rust5#appendix-main-function-is-missing">(NuttX Ox64 needs <strong>leds_rust_main</strong> to be renamed as <strong>main</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-flow6.jpg" alt="NuttX LED Drivers for QEMU RISC-V Emulator and Ox64 BL808 SBC" /></p>
<p><em>What about folks without Ox64 SBC?</em></p>
<p>We created the LED Driver for <strong>QEMU RISC-V Emulator</strong>, which will blink a Simulated LED on NuttX. (Pic above)</p>
<p>Everyone can run the <strong>Rust Blinky App</strong> (from above) and reproduce the exact same results, thanks to the QEMU LED Driver‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12762"><strong>‚ÄúAdd LED Driver for QEMU RISC-V‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/rust4#custom-target-for-rust">(<strong>QEMU RISC-V 32-bit</strong> needs a <strong>Custom Rust Target</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-daily.png" alt="Daily Build and Test of Rust Blinky App at GitHub Actions" /></p>
<h1 id="daily-build-and-test"><a class="doc-anchor" href="#daily-build-and-test">¬ß</a>9 Daily Build and Test</h1>
<p><em>Our Rust Blinky App: Will it break someday?</em></p>
<p>Yeah it‚Äôs possible that our Rust App will someday <strong>fail to build or execute</strong> correctly‚Ä¶</p>
<ol>
<li>
<p><strong>Rust Compiler</strong> might change and break our app</p>
<p>(Since we‚Äôre not calling it the <strong>cargo</strong> way)</p>
</li>
<li>
<p><strong>NuttX Makefiles</strong> might cause problems for Rust Apps</p>
<p>(Because NuttX is mostly in C, not Rust)</p>
</li>
</ol>
<p>That‚Äôs why we extended the <strong>Continuous Integration</strong> workflow for NuttX‚Ä¶</p>
<p>Every NuttX Pull Request will now trigger a rebuild of our <a href="TODO"><strong>Rust Blinky App</strong></a>. If anything breaks, we‚Äôll find out right away!</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12854"><strong>‚ÄúFix the Rust and D Builds for QEMU RISC-V‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12858"><strong>‚ÄúAdd Rust Target for QEMU RISC-V 64-bit‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12862"><strong>‚ÄúAdd Build Config for leds64_rust‚Äù</strong></a></p>
</li>
</ul>
<p><em>Why so complicated?</em></p>
<p>That‚Äôs because the NuttX Continuous Integration (CI) runs inside a <strong>Docker Container</strong>. Which requires delicate modding‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pr#appendix-building-the-docker-image-for-nuttx-ci"><strong>‚ÄúBuilding the Docker Image for NuttX CI‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pr#appendix-downloading-the-docker-image-for-nuttx-ci"><strong>‚ÄúDownloading the Docker Image for NuttX CI‚Äù</strong></a></p>
</li>
</ul>
<p>NuttX CI also compiles <strong>hello_rust</strong> for <a href="https://github.com/apache/nuttx/blob/master/boards/sim/sim/sim/configs/rust/defconfig#L27"><strong>NuttX Simulator</strong></a>. But it doesn‚Äôt need a Special Rust Target for the Docker Image.</p>
<p><em>Will we know if the Rust Blinky App fails to execute correctly?</em></p>
<p>Every day through <strong>GitHub Actions</strong>: We‚Äôre testing the Rust Blinky App on QEMU RISC-V Emulator. (Pic above)</p>
<p>If Rust Blinky fails to execute (or produces the wrong output), GitHub Actions will notify us‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-rust-blinky"><strong>‚ÄúDaily Test of Rust Blinky‚Äù</strong></a></li>
</ul>
<p><em>Anything else we‚Äôre testing daily?</em></p>
<p>If something goes wrong: We need to be clear whether it‚Äôs our Rust App Failing vs <strong>NuttX QEMU Failing</strong>. That‚Äôs why we also test NuttX QEMU every day at GitHub Actions‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>‚ÄúDaily Test of NuttX QEMU RISC-V‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rust6#appendix-nuttx-qemu-risc-v-fails-on-github-actions"><strong>‚ÄúNuttX QEMU RISC-V fails on GitHub Actions‚Äù</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-target.jpg" alt="Adding NuttX as Tier 3 Target to Rust" /></p>
<h1 id="all-things-considered"><a class="doc-anchor" href="#all-things-considered">¬ß</a>10 All Things Considered</h1>
<p><em>Wow that‚Äôs plenty of coding for 12 weeks of GSoC!</em></p>
<p>Indeed, we tracked all Coding Tasks in our <a href="TODO"><strong>GSoC Task Spreadsheet</strong></a>. And we recorded Daily Updates in the <a href="https://discord.gg/eAz5QudKSQ"><strong>NuttX Discord Channel</strong></a>.</p>
<p><em>Will Rust officially support NuttX?</em></p>
<p>The NuttX Community is now adding NuttX as <a href="https://lists.apache.org/thread/oqx7p3vb4dcgko4mm2f0vqgqnkorn49p"><strong>Tier 3 Target</strong></a> to Rust. <a href="https://github.com/rust-lang/rust/pull/127755">(And it‚Äôs <strong>approved</strong>! Pic above)</a></p>
<p><em>Everything in this article‚Ä¶ Becomes redundant?</em></p>
<p>Soon we will have lots of Coding and Testing to implement NuttX as Tier 3 Target that works with the <strong>Rust Standard Library</strong>.</p>
<p>In the meantime, we can call <strong>NuttX Safe Wrappers</strong> (prescribed in this article) to build Rust Apps for NuttX, the Interim Way.</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>11 What‚Äôs Next</h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<p>Special Thanks to <strong>Mr Rushabh Gala</strong>: Sorry it‚Äôs my first GSoC, I could have done better, I‚Äôm grateful for your patience and understanding üôè</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rust6.md"><strong>lupyuen.github.io/src/rust6.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/rust6-qemu.jpg" alt="Testing Rust Blinky on QEMU Emulator" /></p>
<h1 id="appendix-daily-test-of-rust-blinky"><a class="doc-anchor" href="#appendix-daily-test-of-rust-blinky">¬ß</a>12 Appendix: Daily Test of Rust Blinky</h1>
<p>Earlier we said that our Rust Blinky App might someday <a href="TODO"><strong>fail to build or execute</strong></a> correctly. That‚Äôs why we‚Ä¶</p>
<ul>
<li>
<p><a href="TODO"><strong>Trigger a Rebuild</strong></a> of our Rust Blinky App on every NuttX Pull Request</p>
</li>
<li>
<p><strong>Run and Test</strong> our Rust Blinky App every day at GitHub Actions</p>
</li>
</ul>
<p>If anything breaks, we‚Äôll find out right away!</p>
<p><em>How to test our app with GitHub Actions?</em></p>
<p><strong>Every day at GitHub Actions:</strong> We boot NuttX on QEMU RISC-V (64-bit) and verify the output of ‚Äú<strong><code>leds_rust</code></strong>‚Äù (pic above)</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU Emulator for 64-bit RISC-V
$ spawn qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run `leds_rust` and verify the output
NuttShell (NSH) NuttX-12.6.0-RC1
nsh&gt; leds_rust
Hello, Rust!!
Opening /dev/userleds

Set LED 1 to 1
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
Sleeping...

Set LED 1 to 0
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-leds64-rust.yml">(See the <strong>GitHub Actions Log</strong>)</a></p>
<p>Here‚Äôs the <strong>GitHub Actions Workflow</strong> (pic below) to build and run Rust Blinky: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-leds64-rust.yml">qemu-riscv-leds64-rust.yml</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Source Code for NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Install the Rust Target for QEMU RISC-V 64-bit
rustup target add riscv64gc-unknown-none-elf

## Configure the NuttX Build: QEMU RISC-V 64-bit with LED Driver and Rust
tools/configure.sh rv-virt:leds64_rust

## Build the NuttX Kernel. Ignore the warning: `nuttx has a LOAD segment with RWX permissions`
make

## Install QEMU Emulator for RISC-V
sudo apt install qemu-system-riscv64

## Test NuttX and Rust Blinky with our Expect Script
wget https://raw.githubusercontent.com/lupyuen/nuttx-riscv64/main/qemu-riscv-leds64-rust.exp
chmod +x qemu-riscv-leds64-rust.exp
./qemu-riscv-leds64-rust.exp
</code></pre></div>
<p>Which calls our <strong>Expect Script</strong> to test Rust Blinky: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/qemu-riscv-leds64-rust.exp">qemu-riscv-leds64-rust.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX Rust Blinky with QEMU Emulator

## Wait at most 10 seconds
set timeout 10

## For every 1 character sent, wait 0.01 milliseconds
set send_slow {1 0.01}

## Start the QEMU Emulator for 64-bit RISC-V
spawn qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Wait for the prompt and enter `leds_rust`
expect &quot;nsh&gt; &quot;
send -s &quot;leds_rust\r&quot;

## Check the response: LEDs 1, 2 and 3 should be Off
expect &quot;board_userled: LED 1 set to 0&quot;
expect &quot;board_userled: LED 2 set to 0&quot;
expect {
  ## If we see this message, continue normally
  &quot;board_userled: LED 3 set to 0&quot; {}

  ## If timeout, exit with an error
  ## And rerminate the session: Ctrl-A x
  timeout { 
    send &quot;\x01x&quot;
    puts &quot;\n===== Error: Test Failed\n&quot;
    exit 1 
  }
}

## Terminate the session: Ctrl-A x
send &quot;\x01x&quot;
puts &quot;\n===== Test OK\n&quot;
exit 0 
</code></pre></div>
<p>But our test is incomplete: We need to know if NuttX on QEMU is really OK‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-daily.png" alt="Daily Build and Test of Rust Blinky App at GitHub Actions" /></p>
<h1 id="appendix-daily-test-of-nuttx-qemu-risc-v"><a class="doc-anchor" href="#appendix-daily-test-of-nuttx-qemu-risc-v">¬ß</a>13 Appendix: Daily Test of NuttX QEMU RISC-V</h1>
<p>If something goes wrong with <strong>Rust Blinky</strong>: We need to be clear whether it‚Äôs our Rust App Failing vs <strong>NuttX QEMU Failing</strong>. That‚Äôs why we also test NuttX QEMU every day at GitHub Actions. (Pic above)</p>
<p><strong>NuttX for QEMU RISC-V</strong> comes in Multiple Flavours, we test 4 of the popular flavours every day‚Ä¶</p>
<ul>
<li>
<p><strong>32-bit RISC-V, Flat Build: <br> <code>rv-virt:nsh</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-nsh.yml">Test Log</a></p>
</li>
<li>
<p><strong>32-bit RISC-V, Kernel Build: <br> <code>rv-virt:knsh</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-knsh.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-knsh.yml">Test Log</a></p>
</li>
<li>
<p><strong>64-bit RISC-V, Flat Build: <br> <code>rv-virt:nsh64</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh64.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-nsh64.yml">Test Log</a></p>
</li>
<li>
<p><strong>64-bit RISC-V, Kernel Build: <br> <code>rv-virt:knsh64</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-knsh64.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-knsh64.yml">Test Log</a></p>
</li>
</ul>
<p><em>What‚Äôs inside the GitHub Actions Workflow?</em></p>
<p><strong>Every day at GitHub Actions:</strong> We boot NuttX on QEMU RISC-V and verify the output of OSTest‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU Emulator for 32-bit RISC-V
$ spawn qemu-system-riscv32 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv32 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run `ostest` and verify the output
NuttShell (NSH) NuttX-12.6.0-RC1
nsh&gt; ostest
...
ostest_main: Exiting with status 0
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-nsh.yml">(See the <strong>GitHub Actions Log</strong>)</a></p>
<p>Here‚Äôs the <strong>GitHub Actions Workflow</strong> to build and run NuttX QEMU RISC-V (32-bit): <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh.yml">qemu-riscv-nsh.yml</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Source Code for NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure the NuttX Build: QEMU RISC-V 32-bit (Flat Build)
tools/configure.sh rv-virt:nsh

## Build the NuttX Kernel. Ignore the warning: `nuttx has a LOAD segment with RWX permissions`
make

## Install QEMU Emulator for RISC-V (32-bit)
sudo apt install qemu-system-riscv32

## Test NuttX and OSTest with our Expect Script
wget https://raw.githubusercontent.com/lupyuen/nuttx-riscv64/main/qemu-riscv-nsh.exp
chmod +x qemu-riscv-nsh.exp
./qemu-riscv-nsh.exp
</code></pre></div>
<p>Which calls our <strong>Expect Script</strong> to boot NuttX and run OSTest: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/qemu-riscv-nsh.exp">qemu-riscv-nsh.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX with QEMU Emulator

## Wait at most 300 seconds
set timeout 300

## For every 1 character sent, wait 0.01 milliseconds
set send_slow {1 0.01}

## Start the QEMU Emulator for 32-bit RISC-V
spawn qemu-system-riscv32 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv32 \
  -bios none \
  -kernel nuttx \
  -nographic

## Wait for the prompt and enter `ostest`
expect &quot;nsh&gt; &quot;
send -s &quot;ostest\r&quot;

## Check the response...
expect {
  ## If we see this message, exit normally
  &quot;ostest_main: Exiting with status 0&quot; { 
    ## Terminate the session: Ctrl-A x
    send &quot;\x01x&quot;
    puts &quot;\n===== Test OK\n&quot;
    exit 0 
  }

  ## If timeout, exit with an error
  timeout { 
    ## Terminate the session: Ctrl-A x
    send &quot;\x01x&quot;
    puts &quot;\n===== Error: Test Failed\n&quot;
    exit 1 
  }
}
</code></pre></div>
<p>But there‚Äôs a problem: OSTest for <strong>64-bit QEMU RISC-V</strong> fails on GitHub Actions‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-task.jpg" alt="Running a script on my Home Computer to download the 64-bit Daily Builds and run OSTest locally" /></p>
<h1 id="appendix-nuttx-qemu-risc-v-fails-on-github-actions"><a class="doc-anchor" href="#appendix-nuttx-qemu-risc-v-fails-on-github-actions">¬ß</a>14 Appendix: NuttX QEMU RISC-V fails on GitHub Actions</h1>
<p><strong>Every day at GitHub Actions:</strong> We boot NuttX on <strong>QEMU RISC-V Emulator</strong> (32-bit and 64-bit) and test it with <a href="TODO"><strong>OSTest</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>‚ÄúDaily Test of NuttX QEMU RISC-V‚Äù</strong></a></li>
</ul>
<p><em>But we have problems?</em></p>
<p>Yeah OSTest for <strong>64-bit QEMU RISC-V</strong> fails on GitHub Actions, wonder why‚Ä¶</p>
<ul>
<li>
<p><strong>64-bit RISC-V Flat Build <br> <code>rv-virt:nsh64</code></strong> crashes with‚Ä¶</p>
<p><em>‚Äúfpu_test: Started task FPU#1  / riscv_exception: Illegal instruction‚Äù</em></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh64.yml#L2">(GitHub Actions Workflow)</a></p>
</li>
<li>
<p><strong>64-bit RISC-V Kernel Build <br> <code>rv-virt:knsh64</code></strong> hangs at‚Ä¶</p>
<p><em>‚Äúostest_main: Started user_main‚Äù</em></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-knsh64.yml#L2">(GitHub Actions Workflow)</a></p>
</li>
</ul>
<p>That‚Äôs why I run a script on my Home Computer to download the 64-bit Daily Builds and <strong>run OSTest locally</strong> (pic above)</p>
<p>TODO: 64-bit Flat Build (rv-virt:nsh64): <a href="https://github.com/lupyuen/nuttx-riscv64/releases/tag/qemu-riscv-nsh64-2024-08-08">qemu-riscv-nsh64-2024-08-08</a></p>
<ul>
<li>Task Script</li>
<li>Test Script</li>
<li>Upload Script</li>
<li>Sample Log</li>
</ul>
<p>TODO: 64-bit Kernel Build (rv-virt:knsh64): <a href="https://github.com/lupyuen/nuttx-riscv64/releases/tag/qemu-riscv-knsh64-2024-08-08">qemu-riscv-knsh64-2024-08-08</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/task-nsh64.sh">task-nsh64.sh</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/test-nsh64.sh">test-nsh64.sh</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/upload-nsh64.sh">upload-nsh64.sh</a></p>
<p><em>What‚Äôs inside the scripts?</em></p>
<p>Inside our <strong>Task Script</strong>: We wait for the 64-bit <strong>NuttX Daily Build</strong> to be published as a GitHub Release: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/task-nsh64.sh">task-nsh64.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Background Task: Automated Testing of Apache NuttX RTOS for QEMU RISC-V 64-bit Flat Build
export BUILD_PREFIX=qemu-riscv-nsh64

## Wait for GitHub Release, then test NuttX
for (( ; ; ))
do
  ## Build Date is today (YYYY-MM-DD)
  BUILD_DATE=$(date +&#39;%Y-%m-%d&#39;)
  test_nuttx $BUILD_DATE

  ## Wait a while
  sleep 600
done

## Wait for GitHub Release, then test NuttX on SBC
function test_nuttx {
  ...
  ## Download the NuttX Build
  local date=$1
  NUTTX_ZIP=/tmp/$BUILD_PREFIX-$date-nuttx.zip
  wget -q \
    https://github.com/lupyuen/nuttx-riscv64/releases/download/$BUILD_PREFIX-$date/nuttx.zip \
    -O $NUTTX_ZIP
  ...
  ## Run the NuttX Test
  test-nsh64.sh \
    &gt;/tmp/release-$BUILD_PREFIX.log \
    2&gt;&amp;1
  ...
  ## Upload the Test Log
  upload-nsh64.sh \
    /tmp/release-$BUILD_PREFIX.tag \
    /tmp/release-$BUILD_PREFIX.log
}
</code></pre></div>
<p>And call our <strong>Test Script</strong> to boot NuttX on QEMU and run <strong>OSTest</strong>: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/test-nsh64.sh">test-nsh64.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Test Script: Apache NuttX RTOS for QEMU RISC-V 64-bit Flat Build
BUILD_PREFIX=qemu-riscv-nsh64

## Build Date is today (YYYY-MM-DD)
BUILD_DATE=$(date +&#39;%Y-%m-%d&#39;)

## Download the latest NuttX build
wget -q https://github.com/lupyuen/nuttx-riscv64/releases/download/$BUILD_PREFIX-$BUILD_DATE/nuttx.zip
unzip -o nuttx.zip

## Write the Release Tag for populating the GitHub Release Notes later
echo &quot;$BUILD_PREFIX-$BUILD_DATE&quot; &gt;/tmp/release-$BUILD_PREFIX.tag

## Boot NuttX on QEMU and run OSTest
wget https://raw.githubusercontent.com/lupyuen/nuttx-riscv64/main/qemu-riscv-nsh64.exp
chmod +x qemu-riscv-nsh64.exp
./qemu-riscv-nsh64.exp
</code></pre></div>
<p><a href="TODO">(<strong>qemu-riscv-nsh64.exp</strong> is here)</a></p>
<p>Finally our Task Script calls our <strong>Upload Script</strong>, to upload the Test Log into the <strong>GitHub Release Notes</strong>: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/upload-nsh64.sh">upload-nsh64.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Upload Test Log to GitHub Release Notes of Apache NuttX RTOS for QEMU RISC-V 64-bit Flat Build
## Parameters: Release Tag, Test Log
repo=lupyuen/nuttx-riscv64
tag=$1
log=$2

## Preserve the Auto-Generated GitHub Release Notes.
## Fetch the current GitHub Release Notes and extract the body text.
gh release view \
  `cat $tag` \
  --json body \
  --jq &#39;.body&#39; \
  --repo $repo \
  &gt;/tmp/upload-nsh64.old

## Find the position of the Previous Test Log, starting with &quot;```&quot;
cat /tmp/upload-nsh64.old \
  | grep &#39;```&#39; --max-count=1 --byte-offset \
  | sed &#39;s/:.*//g&#39; \
  &gt;/tmp/upload-nsh64-previous-log.txt
prev=`cat /tmp/upload-nsh64-previous-log.txt`

## If Previous Test Log exists, discard it
if [ &quot;$prev&quot; != &#39;&#39; ]; then
  cat /tmp/upload-nsh64.old \
    | head --bytes=$prev \
    &gt;&gt;/tmp/upload-nsh64.log
else
  ## Else copy the entire Release Notes
  cat /tmp/upload-nsh64.old \
    &gt;&gt;/tmp/upload-nsh64.log
  echo &quot;&quot; &gt;&gt;/tmp/upload-nsh64.log
fi

## Show the Test Status
grep &quot;^===== &quot; $log \
  | colrm 1 6 \
  &gt;&gt;/tmp/upload-nsh64.log

## Enquote the Test Log without Carriage Return and Terminal Control Characters.
## The long pattern for sed doesn&#39;t work on macOS.
echo &#39;```text&#39; &gt;&gt;/tmp/upload-nsh64.log
cat $log \
  | tr -d &#39;\r&#39; \
  | tr -d &#39;\r&#39; \
  | sed &#39;s/\x08/ /g&#39; \
  | sed &#39;s/\x1B(B//g&#39; \
  | sed &#39;s/\x1B\[K//g&#39; \
  | sed &#39;s/\x1B[&lt;=&gt;]//g&#39; \
  | sed &#39;s/\x1B\[[0-9:;&lt;=&gt;?]*[!]*[A-Za-z]//g&#39; \
  | sed &#39;s/\x1B[@A-Z\\\]^_]\|\x1B\[[0-9:;&lt;=&gt;?]*[-!&quot;#$%&amp;&#39;&quot;&#39;&quot;&#39;()*+,.\/]*[][\\@A-Z^_`a-z{|}~]//g&#39; \
  &gt;&gt;/tmp/upload-nsh64.log
echo &#39;```&#39; &gt;&gt;/tmp/upload-nsh64.log

## Upload the Test Log to the GitHub Release Notes
gh release edit \
  `cat $tag` \
  --notes-file /tmp/upload-nsh64.log \
  --repo $repo
</code></pre></div>
    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>