<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S SBC)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S SBC)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/sg2000-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/sg2000.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S SBC)</h1>
    <nav id="TOC"><ul>
<li><a href="#sophgo-sg2000-risc-v-soc">1 Sophgo SG2000 RISC-V SoC</a><ul></ul></li>
<li><a href="#boot-without-microsd">2 Boot Without MicroSD</a><ul></ul></li>
<li><a href="#download-the-linux-microsd">3 Download the Linux MicroSD</a><ul></ul></li>
<li><a href="#boot-the-linux-microsd">4 Boot the Linux MicroSD</a><ul></ul></li>
<li><a href="#settings-for-u-boot-bootloader">5 Settings for U-Boot Bootloader</a><ul></ul></li>
<li><a href="#boot-nuttx-over-tftp">6 Boot NuttX over TFTP</a><ul></ul></li>
<li><a href="#uart-controller-for-sg2000">7 UART Controller for SG2000</a><ul></ul></li>
<li><a href="#print-to-uart-in-risc-v-assembly">8 Print to UART in RISC-V Assembly</a><ul></ul></li>
<li><a href="#nuttx-boots-a-tiny-bit">9 NuttX Boots A Tiny Bit</a><ul></ul></li>
<li><a href="#nuttx-kernel-boots-ok">10 NuttX Kernel Boots OK</a><ul></ul></li>
<li><a href="#dump-the-sg2000-linux-device-tree">11 Dump the SG2000 Linux Device Tree</a><ul></ul></li>
<li><a href="#interrupt-controller-for-sg2000">12 Interrupt Controller for SG2000</a><ul></ul></li>
<li><a href="#fix-the-plic-interrupt-controller-for-sg2000">13 Fix the PLIC Interrupt Controller for SG2000</a><ul></ul></li>
<li><a href="#nuttx-shell-runs-ok-on-sg2000">14 NuttX Shell runs OK on SG2000!</a><ul></ul></li>
<li><a href="#u-boot-commands-for-milk-v-duo-s">15 U-Boot Commands for Milk-V Duo S</a><ul></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-sg2000">17 Appendix: Build NuttX for SG2000</a><ul></ul></li>
<li><a href="#appendix-set-the-nuttx-memory-map-for-sg2000">18 Appendix: Set the NuttX Memory Map for SG2000</a><ul></ul></li>
<li><a href="#appendix-disable-the-plic-interrupt-controller">19 Appendix: Disable the PLIC Interrupt Controller</a><ul></ul></li>
<li><a href="#appendix-select-the-nuttx-driver-for-16550-uart">20 Appendix: Select the NuttX Driver for 16550 UART</a><ul></ul></li>
<li><a href="#appendix-enable-logging-for-nuttx-scheduler-and-binary-loader">21 Appendix: Enable Logging for NuttX Scheduler and Binary Loader</a><ul></ul></li>
<li><a href="#appendix-nuttx-crash-dump-on-sg2000">22 Appendix: NuttX Crash Dump on SG2000</a><ul></ul></li></ul></nav><p>üìù <em>22 May 2024</em></p>
<p><img src="https://lupyuen.github.io/images/sg2000-title.jpg" alt="TODO" /></p>
<p>TODO</p>
<p>64-bit RISC-V Sophgo SG2000 SoC ‚Ä¶ Will it boot Apache NuttX RTOS? ü§î (T-Head C906 / Milk-V Duo S)</p>
<ul>
<li>
<p><a href="https://www.cnx-software.com/2024/02/07/sophgo-sg2000-sg2002-ai-soc-features-risc-v-arm-8051-cores-android-linux-freertos/">SG2000 Overview</a></p>
</li>
<li>
<p><a href="https://github.com/sophgo/sophgo-doc/releases">SG2000 Reference Manual</a></p>
</li>
</ul>
<p>Let‚Äôs find out!</p>
<p>Something strangely satisfying about NuttX on RISC-V‚Ä¶ We finished the port in only 10 days! üéâ</p>
<p><em>Is this a sponsored review?</em></p>
<p>I was given a Milk-V Duo S, and I bought another. So it cancels out, I guess?</p>
<p><em>Why are we doing all this?</em></p>
<ol>
<li>
<p>We hear that there will be plenty of interesting new SBCs based on Sophgo SG2000 and SG2002. Perfect for NuttX!</p>
</li>
<li>
<p>NuttX has been ported from QEMU RISC-V to Star64 JH7110 to Ox64 BL808 and now Sophgo SG2000. Let‚Äôs find the most efficient way to port NuttX to new RISC-V Devices!</p>
</li>
</ol>
<p>TODO: <a href="https://www.youtube.com/watch?v=pPNDiC5NLqM">(Watch the Demo on YouTube)</a></p>
<p><img src="https://lupyuen.github.io/images/sg2000-soc.jpg" alt="Sophgo SG2000 RISC-V SoC" /></p>
<h1 id="sophgo-sg2000-risc-v-soc"><a class="doc-anchor" href="#sophgo-sg2000-risc-v-soc">¬ß</a>1 Sophgo SG2000 RISC-V SoC</h1>
<p><strong>Sophgo SG2000 SoC</strong> has a fascinating mix of 64-bit RISC-V Cores (Arm too)‚Ä¶</p>
<ul>
<li>
<p><strong>Main Processor:</strong> 64-bit RISC-V Core</p>
<p><strong>T-Head C906</strong> <em>(1.0 GHz)</em></p>
<p>(For NuttX and Linux)</p>
</li>
<li>
<p><strong>Co-Processor:</strong> 64-bit RISC-V Core</p>
<p><strong>T-Head C906</strong> <em>(700 MHz)</em></p>
<p>(No Cache)</p>
</li>
<li>
<p><strong>Alt-Main Processor:</strong> 64-bit Arm Core</p>
<p><strong>Cortex-A53</strong> <em>(1.0 GHz)</em></p>
</li>
</ul>
<p>Plus a <strong>Low-Power 8051 MCU</strong> (for wakeup duties) and a <strong>Tensor Processing Unit</strong> (for image recognition, not LLM)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sg2000-arch.jpg" alt="Sophgo SG2000 RISC-V SoC" /></p>
<p><em>Whoa RISC-V AND Arm CPUs in a single SoC?</em></p>
<p>Actually there‚Äôs a <strong>Hardware Switch</strong> that selects the Main CPU: <strong>RISC-V OR Arm</strong>.</p>
<p>(Don‚Äôt let yer pet hamster flip it‚Ä¶ It will get super frustrating!)</p>
<p><img src="https://lupyuen.github.io/images/sg2000-board.jpg" alt="Milk-V Duo S" /></p>
<h1 id="boot-without-microsd"><a class="doc-anchor" href="#boot-without-microsd">¬ß</a>2 Boot Without MicroSD</h1>
<p><em>What happens if we boot Milk-V Duo S? Fresh from the box?</em></p>
<p>Connect our <strong>USB UART Dongle</strong> according to <a href="https://milkv.io/docs/duo/getting-started/duos#uart-serial-console"><strong>the instructions</strong></a> (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Milk-V Duo S</th><th style="text-align: center">USB UART</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>GND</strong> (Pin 6)</td><td style="text-align: center"><strong>GND</strong></td></tr>
<tr><td style="text-align: center"><strong>TX</strong> (Pin 8)</td><td style="text-align: center"><strong>RX</strong></td></tr>
<tr><td style="text-align: center"><strong>RX</strong> (Pin 10)</td><td style="text-align: center"><strong>TX</strong></td></tr>
</tbody></table>
</div>
<p>USB UART Dongle must be <a href="http://sun-light.com.sg/index.php?route=product/product&amp;product_id=2367"><strong>CP2102</strong></a>, it doesn‚Äôt like <a href="https://pine64.com/product/serial-console-woodpecker-edition/"><strong>CH340</strong></a> üò¨</p>
<p><img src="https://lupyuen.github.io/images/sg2000-switch.jpg" alt="Switch to ‚ÄúRV‚Äù (RISC-V) instead of ‚ÄúArm‚Äù" /></p>
<p>Flip the Switch so it‚Äôs set to ‚Äú<strong><code>RV</code></strong>‚Äù (RISC-V) instead of ‚Äú<strong><code>Arm</code></strong>‚Äù. (Pic above)</p>
<p>Power up the board via the <strong>USB-C Port</strong>. Connect to the USB UART at <strong>115.2 kbps</strong>.</p>
<p>Milk-V Duo S <a href="https://gist.github.com/lupyuen/a7c3af98be36dcd5cc5b45f5aadc5d16"><strong>won‚Äôt boot</strong></a> because it doesn‚Äôt ship with <strong>U-Boot Bootloader</strong> in Flash Memory‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>C.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000. 
E:eMMC initializing failed
E:Boot failed
</code></pre></div>
<p>We‚Äôll need U-Boot on MicroSD. (Next section)</p>
<p>If we see <a href="https://gist.github.com/lupyuen/d55b77a51ee8b258d6d1c0799770742a">‚Äú<strong><code>B.SCS</code></strong>‚Äù</a> instead of ‚Äú<strong><code>C.SCS</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>B.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000.
</code></pre></div>
<p>Nope we‚Äôre in Arm Mode‚Ä¶ Flip the switch back to RISC-V!</p>
<p><a href="https://pine64.com/product/serial-console-woodpecker-edition/"><strong>If we use CH340</strong></a> (instead of CP2102): UART Output will be <a href="https://gist.github.com/lupyuen/1d5ba1b2a47c110ee7ff265102b1aae5"><strong>hopelessly garbled</strong></a>.</p>
<h1 id="download-the-linux-microsd"><a class="doc-anchor" href="#download-the-linux-microsd">¬ß</a>3 Download the Linux MicroSD</h1>
<p><em>Milk-V Duo S won‚Äôt boot without MicroSD. How now?</em></p>
<p>Let‚Äôs boot <strong>Linux on MicroSD</strong>, thanks to the awesome work by <a href="https://github.com/Fishwaldo"><strong>Justin Hammond</strong></a> (Fishwaldo)‚Ä¶</p>
<ul>
<li><a href="https://github.com/Fishwaldo/sophgo-sg200x-debian/releases"><strong>Debian Images for Sophgo SG2000</strong></a></li>
</ul>
<p>We download the Latest Release for <strong>Milk-V Duo S</strong> (SG2000)‚Ä¶</p>
<ul>
<li><a href="https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4"><strong>duos_sd.img.lz4</strong></a></li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux
$ sudo apt install lz4

## For macOS
$ brew install lz4

## Uncompress the download to get `duos_sd.img`
$ lz4 duos_sd.img.lz4

## TODO: Write `duos_sd.img` to MicroSD with Balena Etcher

## Here are the MicroSD Files
$ ls -l /Volumes/boot
-rwxrwxrwx  3494900 System.map-5.10.4-20240329-1+
-rwxrwxrwx   125534 config-5.10.4-20240329-1+
drwxrwxrwx     2048 extlinux
drwxrwxrwx     2048 fdt
-rwxrwxrwx   388608 fip.bin
-rwxrwxrwx  4937389 vmlinuz-5.10.4-20240329-1+

## U-Boot Bootloader Config
$ ls -l /Volumes/boot/extlinux
-rwxrwxrwx  749 extlinux.conf

## Linux Device Tree for SG2000
$ ls -l /Volumes/boot/fdt/linux-image-duos-5.10.4-20240329-1+
-rwxrwxrwx  21575 cv181x_milkv_duos_sd.dtb
</code></pre></div>
<p>We peek at the <strong>U-Boot Bootloader Config</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cat /Volumes/boot/extlinux/extlinux.conf
...
label l0
  menu label Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
  linux /vmlinuz-5.10.4-20240329-1+
  fdtdir /fdt/linux-image-duos-5.10.4-20240329-1+/
  append root=/dev/root console=ttyS0,115200 earlycon=sbi root=/dev/mmcblk0p2 rootwait rw
</code></pre></div>
<p>(With a tiny tweak, we can boot NuttX RTOS!)</p>
<p>TODO: Pic of OpenSBI</p>
<h1 id="boot-the-linux-microsd"><a class="doc-anchor" href="#boot-the-linux-microsd">¬ß</a>4 Boot the Linux MicroSD</h1>
<p><em>Linux on MicroSD: Does it boot on Milk-V Duo S?</em></p>
<p>Yep Linux boots OK on Milk-V Duo S!</p>
<p>First we see <a href="TODO"><strong>OpenSBI (Supervisor Binary Interface)</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>OpenSBI v0.9
Platform Name             : Milk-V DuoS
Platform Features         : mfdeleg
Platform HART Count       : 1
Platform Console Device   : uart8250
Firmware Base             : 0x80000000
Firmware Size             : 132 KB
Runtime SBI Version       : 0.3

Domain0 Region00          : 0x0000000074000000-0x000000007400ffff (I)
Domain0 Region01          : 0x0000000080000000-0x000000008003ffff ()
Domain0 Region02          : 0x0000000000000000-0xffffffffffffffff (R,W,X)
Boot HART ISA             : rv64imafdcvsux
Boot HART Features        : scounteren,mcounteren,time
Boot HART MIDELEG         : 0x0000000000000222
Boot HART MEDELEG         : 0x000000000000b109

## OpenSBI boots at 0x8000_0000.
## 0x7400_0000 looks interesting! We&#39;ll come back to this
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/01d409b7bde9607a96cd4d460e53330a">(See the <strong>Complete Log</strong>)</a></p>
<p>Followed by the <strong>U-Boot Bootloader</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## U-Boot Boots
U-Boot 2021.10-ga57aa1f2-dirty (Apr 24 2024 - 11:24:46 +0000) cvitek_cv181x
Hit any key to stop autoboot:  0 
Scanning mmc 0:1...
Found /extlinux/extlinux.conf

## U-Boot Menu
1:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
2:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+ (rescue target)
Enter choice: 1:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+

## U-Boot boots Debian Linux
Retrieving file: /vmlinuz-5.10.4-20240329-1+
append: root=/dev/root console=ttyS0,115200 earlycon=sbi root=/dev/mmcblk0p2 rootwait rw
Retrieving file: /fdt/linux-image-duos-5.10.4-20240329-1+/cv181x_milkv_duos_sd.dtb
Booting using the fdt blob at 0x81200000
Loading Device Tree to 000000009f275000, end 000000009f27d446 ... OK
</code></pre></div>
<p>Finally we see <strong>Debian Linux</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Starting kernel ...
Linux version 5.10.4-20240329-1+ (root@3abcc283c6ba) (riscv64-unknown-linux-musl-gcc (Xuantie-900 linux-5.10.4 musl gcc Toolchain V2.6.1 B-20220906) 10.2.0, GNU ld (GNU Binutils) 2.35) #1 PREEMPT Wed Apr 24 11:26:16 UTC 2024
...
Debian GNU/Linux trixie/sid duos ttyS0
duos login: 
</code></pre></div>
<p>TODO</p>
<h1 id="settings-for-u-boot-bootloader"><a class="doc-anchor" href="#settings-for-u-boot-bootloader">¬ß</a>5 Settings for U-Boot Bootloader</h1>
<p>TODO</p>
<p>Let‚Äôs dump the U-Boot Config‚Ä¶</p>
<p>As we power on Milk-V Duo S, hit Enter a few times to see the <strong>U-Boot Command Prompt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>U-Boot 2021.10-ga57aa1f2-dirty (May 07 2024 - 08:13:12 +0000) cvitek_cv181x
Loading Environment from FAT... mmc1 : finished tuning, code:53
Hit any key to stop autoboot:  0
cv181x_c906# 
</code></pre></div>
<p>Enter <strong><code>printenv</code></strong> to dump the U-Boot Settings‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ printenv
fdt_addr_r=0x81200000
fdtoverlay_addr_r=0x81300000
kernel_addr_r=0x80200000
kernel_comp_addr_r=0x81800000
kernel_comp_size=0x1000000
ramdisk_addr_r=0x84000000
uImage_addr=0x81800000
update_addr=0x9fe00000
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L189-L246">(See the <strong>U-Boot Settings</strong>)</a></p>
<p><strong><code>kernel_addr_r</code></strong> says that U-Boot will load Linux Kernel into RAM at Address <strong><code>0x8020_0000</code></strong>. (We‚Äôll set this in NuttX)</p>
<p>And the <strong>Ethernet Driver</strong> is fully operational in U-Boot. Which means we can boot <strong>NuttX over the Network</strong> yay! (TFTP)</p>
<div class="example-wrap"><pre class="language-bash"><code>$ net list
eth0: ethernet@4070000
00:00:00:00:00:00
active
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L99-L188">(See the <strong>U-Boot Commands</strong>)</a></p>
<p>TODO: Pic of TFTP</p>
<h1 id="boot-nuttx-over-tftp"><a class="doc-anchor" href="#boot-nuttx-over-tftp">¬ß</a>6 Boot NuttX over TFTP</h1>
<p><em>What‚Äôs the quickest way to port NuttX?</em></p>
<p>Like Linux, we could <strong>copy NuttX to MicroSD</strong>, insert into Milk-V Duo S and power up. Again and again and again‚Ä¶</p>
<p>But there‚Äôs a quicker way: Boot <strong>NuttX over the Network</strong>, thanks to U-Boot Bootloader and TFTP! (Trivial File Transfer Protocol)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp"><strong>‚ÄúConfigure U-Boot for TFTP‚Äù</strong></a></li>
</ul>
<p>At the <strong>U-Boot Command Prompt</strong>: We configure our <strong>TFTP Server</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## If Initial RAM Disk is needed (like for Linux, not for NuttX)...
## Set the RAM Disk Size (assume the max)
## setenv ramdisk_size 0x1000000

## Save the U-Boot Config for future reboots
saveenv
</code></pre></div>
<p>Then we load the <strong>NuttX Image</strong> into RAM over TFTP‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x80200000
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Load the Device Tree from TFTP Server
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
fdt addr ${fdt_addr_r}

## If Initial RAM Disk is needed...
## Load the Intial RAM Disk from TFTP Server
## ramdisk_addr_r=0x81600000
## tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd
</code></pre></div>
<p>And we boot <strong>NuttX from RAM</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot the NuttX Image with the Device Tree
## kernel_addr_r=0x80200000
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}

## For Linux: We need the RAM Disk Address
## ramdisk_addr_r=0x81600000
## ramdisk_size=0x1000000
## booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
</code></pre></div>
<p>Or mashed up in a single line‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot NuttX Image over TFTP
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}
</code></pre></div>
<p><em>What happens when we boot NuttX?</em></p>
<p>Absolutely nothing!</p>
<div class="example-wrap"><pre class="language-bash"><code>$ booti ${kernel_addr_r} - ${fdt_addr_r}
   Booting using the fdt blob at 0x81200000
   Loading Ramdisk to 9e27f000, end 9f27f000 ... OK
   Loading Device Tree to 000000009e26f000, end 000000009e27e43a ... OK

Starting kernel ...
</code></pre></div>
<p>But that‚Äôs OK, we haven‚Äôt modified NuttX Kernel for SG2000. Let‚Äôs print something in the next section.</p>
<p><em>We type these commands EVERY TIME we boot?</em></p>
<p>We can automate this! Just do this once, and <strong>NuttX will Auto-Boot</strong> whenever we power up‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Add the Boot Command for TFTP
setenv bootcmd_tftp &#39;dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}&#39;

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Targets
setenv orig_boot_targets &quot;$boot_targets&quot;

## Prepend TFTP to the Boot Targets
setenv boot_targets &quot;tftp $boot_targets&quot;

## Save it for future reboots
saveenv
</code></pre></div><h1 id="uart-controller-for-sg2000"><a class="doc-anchor" href="#uart-controller-for-sg2000">¬ß</a>7 UART Controller for SG2000</h1>
<p><em>How will NuttX print something to the Serial Console?</em></p>
<p>According to the <a href="https://github.com/sophgo/sophgo-doc/releases"><strong>SG2000 Reference Manual</strong></a>: The <strong>UART Controller</strong> is at these Base Addresses‚Ä¶</p>
<div><table><thead><tr><th>GPIO Module</th><th>Base Address</th></tr></thead><tbody>
<tr><td>UART0</td><td>0x04140000</td></tr>
<tr><td>UART1</td><td>0x04150000</td></tr>
<tr><td>UART2</td><td>0x04160000</td></tr>
<tr><td>UART3</td><td>0x04170000</td></tr>
<tr><td>UART4</td><td>0x041C0000</td></tr>
<tr><td>RTCSYS_UART</td><td>0x05022000</td></tr>
</tbody></table>
</div>
<p>We‚Äôll print to UART0 in NuttX.</p>
<p><em>What UART Controller is inside SG2000?</em></p>
<p>According to <a href="TODO"><strong>OpenSBI Log</strong></a>: The UART Controller is <strong><code>uart8250</code></strong>.</p>
<p>Which is supported by NuttX yay! We mod the NuttX Boot Code to print something‚Ä¶</p>
<h1 id="print-to-uart-in-risc-v-assembly"><a class="doc-anchor" href="#print-to-uart-in-risc-v-assembly">¬ß</a>8 Print to UART in RISC-V Assembly</h1>
<p><em>We‚Äôre printing in RISC-V Assembly? Why not C?</em></p>
<p>That‚Äôs because the very first thing that boots is the NuttX Boot Code in <strong>RISC-V Assembly</strong>. Which we‚Äôll modify like this‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console"><strong>‚ÄúPrint to QEMU Console‚Äù</strong></a></li>
</ul>
<p>SG2000 UART0 Controller is at <strong><code>0x0414_0000</code></strong> (previous section). To print something, we write to the <strong>UART Output Register</strong> at that address: <a href="https://github.com/lupyuen2/wip-nuttx/blob/sg2000/arch/risc-v/src/bl808/bl808_head.S#L70-L89">bl808_head.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* RISC-V Boot Code for Apache NuttX RTOS */
real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x04140000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)
</code></pre></div>
<p>Our code will print ‚Äú<strong><code>123</code></strong>‚Äù when NuttX boots. We test this‚Ä¶</p>
<h1 id="nuttx-boots-a-tiny-bit"><a class="doc-anchor" href="#nuttx-boots-a-tiny-bit">¬ß</a>9 NuttX Boots A Tiny Bit</h1>
<p>TODO</p>
<p>Follow these steps to build (work-in-progress) Apache NuttX RTOS for SG2000 and Milk-V Duo S‚Ä¶</p>
<p>TODO</p>
<p>This produces the NuttX Image file: <strong><code>Image</code></strong>. Which we copy to our <strong>TFTP Server</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to TFTP Server
## TODO: Change `tftpserver` and `tftpboot` to our TFTP Server and Path
scp Image tftpserver:/tftpboot/Image-sg2000
</code></pre></div>
<p>We have copied the NuttX Image to our TFTP Server. Let‚Äôs boot this on Milk-V Duo S‚Ä¶</p>
<p>TODO</p>
<p>Earlier we have‚Ä¶</p>
<ul>
<li>
<p>Inserted the RISC-V Boot Code to print <code>123</code> (at NuttX Startup)</p>
</li>
<li>
<p>Compiled Apache NuttX RTOS for Milk-V Duo S</p>
</li>
<li>
<p>Copied the NuttX Image to our TFTP Server</p>
</li>
</ul>
<p>Let‚Äôs boot NuttX over TFTP, with a little help from U-Boot Bootloader! Run these commands at the U-Boot Command Prompt‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/78b54326daf0894a2c23ab6d2c03456d">(See the <strong>Complete Log</strong>)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change to your TFTP Server IP Address
$ setenv tftp_server 192.168.31.10

## Download NuttX Image from TFTP Server
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000
Speed: 100, full duplex
BOOTP broadcast 1
BOOTP broadcast 2
*** Unhandled DHCP Option in OFFER/ACK: 43
*** Unhandled DHCP Option in OFFER/ACK: 43
DHCP client bound to address 192.168.31.243 (424 ms)
Using ethernet@4070000 device
TFTP from server 192.168.31.10; our IP address is 192.168.31.243
Filename &#39;Image-sg2000&#39;.
Load address: 0x80200000
Loading: #################################################################
. 1.2 MiB/s
done
Bytes transferred = 14195281 (d89a51 hex)

## TODO: NuttX doesn&#39;t need the Device Tree. Remove this.
$ tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb
Speed: 100, full duplex
Using ethernet@4070000 device
TFTP from server 192.168.31.10; our IP address is 192.168.31.243
Filename &#39;jh7110-star64-pine64.dtb&#39;.
Load address: 0x81200000
Loading: ####
. 1.2 MiB/s
done
Bytes transferred = 50235 (c43b hex)

## TODO: NuttX doesn&#39;t need the Device Tree. Remove this.
$ fdt addr ${fdt_addr_r}

## Boot NuttX from RAM. RAM Disk Address must be `-`!
$ booti ${kernel_addr_r} - ${fdt_addr_r}

## For Linux: We need the RAM Disk Address
## booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
</code></pre></div>
<p>NuttX boots a tiny bit, and prints <code>123</code> yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

## Flattened Device Tree blob at 81200000
Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9fe00000, end 9fe00000 ... OK
Loading Device Tree to 000000009f26f000, end 000000009f27e43a ... OK

Starting kernel ...
123
</code></pre></div>
<p>Our NuttX Boot Code is actually running on SG2000 / Milk-V Duo S!</p>
<p>Coming up‚Ä¶</p>
<ol>
<li>
<p>Fix the Boot Address of NuttX, so the rest of NuttX can start</p>
</li>
<li>
<p>Configure the 16550 UART Driver for NuttX, so can see the Console Output</p>
</li>
</ol>
<p>TODO: Can we run <code>expect</code> with <code>screen</code> to automate the testing of NuttX on SG2000?</p>
<p>TODO: If we prefer to boot NuttX with MicroSD instead of TFTP, try this <a href="https://www.tindie.com/products/badgerdnl/sdwire-usb-c-sd-card-reader-sd-mux/">MicroSD Multiplexer (USB / FTDI)</a></p>
<h1 id="nuttx-kernel-boots-ok"><a class="doc-anchor" href="#nuttx-kernel-boots-ok">¬ß</a>10 NuttX Kernel Boots OK</h1>
<p><em>NuttX Kernel prints ‚Äú123‚Äù. What about the rest?</em></p>
<p>More mods for <strong>NuttX Kernel</strong>!</p>
<ol>
<li>
<p>We set the <a href="TODO"><strong>NuttX Memory Map</strong></a> for SG2000: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Kernel RAM
CONFIG_RAM_START=0x80200000
CONFIG_RAM_SIZE=1048576
</code></pre></div>
<p><a href="TODO">(Explained here)</a></p>
</li>
<li>
<p>Also the <a href="TODO"><strong>NuttX Linker Script</strong></a>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37">ld.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY {
  kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
  ...
SECTIONS {
  . = 0x80200000;
</code></pre></div>
<p><a href="TODO">(Explained here)</a></p>
</li>
<li>
<p>We select the <a href="TODO"><strong>NuttX Driver for 16550 UART</strong></a>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x04140000
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y
</code></pre></div>
<p><a href="TODO">(Explained here)</a></p>
</li>
<li>
<p>Enable Logging for <a href="TODO"><strong>NuttX Scheduler and Binary Loader</strong></a>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_DEBUG_BINFMT=y
CONFIG_DEBUG_BINFMT_ERROR=y
CONFIG_DEBUG_BINFMT_WARN=y
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y
</code></pre></div>
<p><a href="TODO">(Explained here)</a></p>
</li>
<li>
<p>And disable the <a href="TODO"><strong>PLIC Interrupt Controller</strong></a> (until we figure it out)</p>
<p><a href="TODO">(Explained here)</a></p>
</li>
</ol>
<p>TODO: NuttX Crash Dump on SG2000</p>
<p>Here‚Äôs the correct U-Boot Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## This works OK for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; 
booti ${kernel_addr_r} - ${fdt_addr_r}
</code></pre></div>
<p>NuttX Kernel boots OK on SG2000 yay!</p>
<p><a href="https://gist.github.com/lupyuen/aaa0a6646490d45e5cd99b781cbe59f8">(See the <strong>Complete Log</strong>)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Flattened Device Tree blob at 81200000
   Booting using the fdt blob at 0x81200000
   Loading Device Tree to 000000009f26f000, end 000000009f27e43a ... OK

Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x80409140
nxtask_exit: AppBringUp pid=2,TCB=0x80408740
</code></pre></div>
<p><a href="https://www.youtube.com/watch?v=pPNDiC5NLqM">(Watch the Demo on YouTube)</a></p>
<p><em>But where‚Äôs the NuttX Shell?</em></p>
<p>We won‚Äôt see the NuttX Shell until we fix the Interrupt Controller for SG2000. Which is NOT documented!</p>
<p>Let‚Äôs sniff around and find out how it works‚Ä¶</p>
<h1 id="dump-the-sg2000-linux-device-tree"><a class="doc-anchor" href="#dump-the-sg2000-linux-device-tree">¬ß</a>11 Dump the SG2000 Linux Device Tree</h1>
<p>TODO</p>
<p>Let‚Äôs dump the SG2000 Linux Device Tree to understand the Interrupt Controller.</p>
<p>From the SG2000 Debian Release: https://github.com/Fishwaldo/sophgo-sg200x-debian/releases</p>
<p>We pick the Latest Release for Milk-V Duo S: <a href="https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4">duos_sd.img.lz4</a></p>
<p>We copy out the SG2000 Device Tree Binary: <a href="cv181x_milkv_duos_sd.dtb">cv181x_milkv_duos_sd.dtb</a></p>
<p>And convert it to Device Tree Source: <a href="cv181x_milkv_duos_sd.dts">cv181x_milkv_duos_sd.dts</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Convert the SG2000 Device Tree
dtc \
  -o cv181x_milkv_duos_sd.dts \
  -O dts \
  -I dtb \
  cv181x_milkv_duos_sd.dtb
</code></pre></div><h1 id="interrupt-controller-for-sg2000"><a class="doc-anchor" href="#interrupt-controller-for-sg2000">¬ß</a>12 Interrupt Controller for SG2000</h1>
<p>TODO</p>
<p>We dumped the SG2000 Linux Device Tree. Let‚Äôs extract the Interrupt Controller to understand it.</p>
<p>Based on the SG2000 Device Tree: <a href="cv181x_milkv_duos_sd.dts">cv181x_milkv_duos_sd.dts</a></p>
<div class="example-wrap"><pre class="language-c"><code>cpus {
  #address-cells = &lt;0x01&gt;;
  #size-cells = &lt;0x00&gt;;
  timebase-frequency = &lt;0x17d7840&gt;;

  cpu-map {

    cluster0 {

      core0 {
        cpu = &lt;0x01&gt;;
      };
    };
  };

  cpu@0 {
    device_type = &quot;cpu&quot;;
    reg = &lt;0x00&gt;;
    status = &quot;okay&quot;;
    compatible = &quot;riscv&quot;;
    riscv,isa = &quot;rv64imafdvcsu&quot;;
    mmu-type = &quot;riscv,sv39&quot;;
    clock-frequency = &lt;0x17d7840&gt;;

    interrupt-controller {
      #interrupt-cells = &lt;0x01&gt;;
      interrupt-controller;
      compatible = &quot;riscv,cpu-intc&quot;;
      phandle = &lt;0x16&gt;;
    };
  };
};

soc {
  #address-cells = &lt;0x02&gt;;
  #size-cells = &lt;0x02&gt;;
  compatible = &quot;simple-bus&quot;;
  ranges;

  interrupt-controller@70000000 {
    riscv,ndev = &lt;0x65&gt;;
    riscv,max-priority = &lt;0x07&gt;;
    reg-names = &quot;control&quot;;
    reg = &lt;0x00 0x70000000 0x00 0x4000000&gt;;
    interrupts-extended = &lt;0x16 0xffffffff 0x16 0x09&gt;;
    interrupt-controller;
    compatible = &quot;riscv,plic0&quot;;
    #interrupt-cells = &lt;0x02&gt;;
    #address-cells = &lt;0x00&gt;;
    phandle = &lt;0x04&gt;;
  };

  clint@74000000 {
    interrupts-extended = &lt;0x16 0x03 0x16 0x07&gt;;
    reg = &lt;0x00 0x74000000 0x00 0x10000&gt;;
    compatible = &quot;riscv,clint0&quot;;
    clint,has-no-64bit-mmio;
  };
};
</code></pre></div>
<p>We see that PLIC is at 0x7000_0000, CLINT at 0x7400_0000. Let‚Äôs implement this in NuttX‚Ä¶</p>
<h1 id="fix-the-plic-interrupt-controller-for-sg2000"><a class="doc-anchor" href="#fix-the-plic-interrupt-controller-for-sg2000">¬ß</a>13 Fix the PLIC Interrupt Controller for SG2000</h1>
<p>TODO</p>
<p>Based on the PLIC Address from above: We fix the PLIC Interrupt Controller for SG2000‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6">Fix the PLIC Interrupt Controller for SG2000</a></p>
<p>Now we see a bit more NuttX‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/922e6379375fbc5d775d1e83cac4deb5">(See the <strong>Complete Log</strong>)</a></p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80409130
nxtask_activate: AppBringUp pid=2,TCB=0x80409740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x8040b730
nxtask_exit: AppBringUp pid=2,TCB=0x80409740

Nuttnx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><em>Why did it stop?</em></p>
<p>Duh we set the wrong UART0 IRQ! Here‚Äôs the fix‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/122c717447f81c310a4fb082101213ad338dfb0e">Set UART0 IRQ to 69 (25 + 44)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_UART0_IRQ=69
</code></pre></div>
<p><em>How did we get IRQ 69 for UART?</em></p>
<p>We saw this in the <a href="https://github.com/sophgo/sophgo-doc/releases">SG2000 Reference Manual</a>‚Ä¶</p>
<blockquote>
<p>3.1 Interrupt Subsystem</p>
</blockquote>
<blockquote>
<p>Table 3.2: Interrupt number and Interrupt source mapping for Master RISCV C906 @ 1.0Ghz</p>
</blockquote>
<blockquote>
<p>Int #44: UART0</p>
</blockquote>
<p>Linx Device Tree also says UART0 IRQ is 44 (0x2C)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>serial@04140000 {
  compatible = &quot;snps,dw-apb-uart&quot;;
  reg = &lt;0x00 0x4140000 0x00 0x1000&gt;;
  clock-frequency = &lt;0x17d7840&gt;;
  reg-shift = &lt;0x02&gt;;
  reg-io-width = &lt;0x04&gt;;
  status = &quot;okay&quot;;
  interrupts = &lt;0x2c 0x04&gt;;
  interrupt-parent = &lt;0x04&gt;;
};
</code></pre></div>
<p>Thus we compute <a href="https://lupyuen.github.io/articles/plic2#uart-interrupt">NuttX IRQ</a> = 25 + RISC-V IRQ = 69</p>
<h1 id="nuttx-shell-runs-ok-on-sg2000"><a class="doc-anchor" href="#nuttx-shell-runs-ok-on-sg2000">¬ß</a>14 NuttX Shell runs OK on SG2000!</h1>
<p>TODO</p>
<ul>
<li>
<p>Dump the SG2000 Linux Device Tree</p>
</li>
<li>
<p>Interrupt Controller for SG2000</p>
</li>
<li>
<p>Fix the PLIC Interrupt Controller for SG2000</p>
</li>
</ul>
<p>After fixing the Interrupt Controller and UART Interrupt: NuttX Kernel now boots all the way to NuttX Shell yay!</p>
<p><a href="https://gist.github.com/lupyuen/b778986ba87c18067cd993b92c673634">(See the <strong>Complete Log</strong>)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80409130
nxtask_activate: AppBringUp pid=2,TCB=0x80409740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x8040b730
nxtask_exit: AppBringUp pid=2,TCB=0x80409740

NuttShell (NSH) NuttX-12.4.0
nsh&gt; nx_start: CPU0: Beginning Idle Loop
ls
posix_spawn: pid=0xc0202968 path=ls file_actions=0xc0202970 attr=0xc0202978 argv=0xc0202a18
exec_internal: ERROR: Failed to load program &#39;ls&#39;: -2
nxposix_spawn_exec: ERROR: exec failed: 2
/:
 dev/
 proc/
 system/
nsh&gt; 
nsh&gt; uname -a
posix_spawn: pid=0xc0202968 path=uname file_actions=0xc0202970 attr=0xc0202978 argv=0xc0202a18
exec_internal: ERROR: Failed to load program &#39;uname&#39;: -2
nxposix_spawn_exec: ERROR: exec failed: 2
NuttX 12.4.0 122c717 May  8 2024 18:13:30 risc-v ox64
nsh&gt; 
nsh&gt; free
posix_spawn: pid=0xc0202968 path=free file_actions=0xc0202970 attr=0xc0202978 argv=0xc0202a18
exec_internal: ERROR: Failed to load program &#39;free&#39;: -2
nxposix_spawn_exec: ERROR: exec failed: 2
                 total       used       free    maxused    maxfree  nused  nfree
      Kmem:    2065400      14296    2051104      76632    2049392     36      3
      Page:   20971520     647168   20324352   20324352
nsh&gt; 
nsh&gt; ls /dev
posix_spawn: pid=0xc0202968 path=ls file_actions=0xc0202970 attr=0xc0202978 argv=0xc0202a18
exec_internal: ERROR: Failed to load program &#39;ls&#39;: -2
nxposix_spawn_exec: ERROR: exec failed: 2
/dev:
 console
 null
 ram0
 ttyS0
 zero
nsh&gt; 
nsh&gt; 
</code></pre></div>
<p>NuttX OSTest works great too!</p>
<p><a href="https://gist.github.com/lupyuen/fff5242cf77a3f52d81f3effb9aa402f">(See the <strong>Complete Log</strong>)</a></p>
<h1 id="u-boot-commands-for-milk-v-duo-s"><a class="doc-anchor" href="#u-boot-commands-for-milk-v-duo-s">¬ß</a>15 U-Boot Commands for Milk-V Duo S</h1>
<p>TODO</p>
<p>Here are the U-Boot Commands available for Milk-V Duo S‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2">(See the <strong>Complete Log</strong>)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>cv181x_c906# help

?         - alias for &#39;help&#39;
base      - print or set address offset
bdinfo    - print Board Info structure
blkcache  - block cache diagnostics and control
boot      - boot default, i.e., run &#39;bootcmd&#39;
bootd     - boot default, i.e., run &#39;bootcmd&#39;
bootefi   - Boots an EFI payload from memory
bootelf   - Boot from an ELF image in memory
booti     - boot Linux kernel &#39;Image&#39; format from memory
bootm     - boot application image from memory
bootp     - boot image via network using BOOTP/TFTP protocol
bootvx    - Boot vxWorks from an ELF image
cmp       - memory compare
cp        - memory copy
cpu       - display information about CPUs
cvi_sd_boot- boot from SD card
cvi_update- cvi_update [eth, sd, usb]- check boot status and update if necessary

cvi_utask - bootloader control block command
dcache    - enable or disable data cache
dhcp      - boot image via network using DHCP/TFTP protocol
echo      - echo args to console
efuser    - Read efuse
efuser_dump- Read/Dump efuse
efusew    - Write efuse
efusew_word- Write word to efuse
env       - environment handling commands
erase     - erase FLASH memory
exit      - exit script
ext2load  - load binary file from a Ext2 filesystem
ext2ls    - list files in a directory (default /)
ext4load  - load binary file from a Ext4 filesystem
ext4ls    - list files in a directory (default /)
ext4size  - determine a file&#39;s size
false     - do nothing, unsuccessfully
fatinfo   - print information about filesystem
fatload   - load binary file from a dos filesystem
fatls     - list files in a directory (default /)
fatmkdir  - create a directory
fatrm     - delete a file
fatsize   - determine a file&#39;s size
fatwrite  - write file into a dos filesystem
fdt       - flattened device tree utility commands
flinfo    - print FLASH memory information
fstype    - Look up a filesystem type
fstypes   - List supported filesystem types
go        - start application at address &#39;addr&#39;
help      - print command description/usage
icache    - enable or disable instruction cache
iminfo    - print header information for application image
ln        - Create a symbolic link
load      - load binary file from a filesystem
loadb     - load binary file over serial line (kermit mode)
loadx     - load binary file over serial line (xmodem mode)
loady     - load binary file over serial line (ymodem mode)
loop      - infinite loop on address range
ls        - list files in a directory (default /)
md        - memory display
mdio      - MDIO utility commands
mii       - MII utility commands
mm        - memory modify (auto-incrementing address)
mmc       - MMC sub system
mmcinfo   - display MMC info
mw        - memory write (fill)
net       - NET sub-system
nfs       - boot image via network using NFS protocol
nm        - memory modify (constant address)
panic     - Panic with optional message
part      - disk partition related commands
ping      - send ICMP ECHO_REQUEST to network host
printenv  - print environment variables
protect   - enable or disable FLASH write protection
pxe       - commands to get and boot from pxe files
random    - fill memory with random pattern
reset     - Perform RESET of the CPU
run       - run commands in an environment variable
save      - save file to a filesystem
saveenv   - save environment variables to persistent storage
setenv    - set environment variables
setexpr   - set environment variable as the result of eval expression
showvar   - print local hushshell variables
size      - determine a file&#39;s size
sleep     - delay execution for some time
source    - run script from memory
sysboot   - command to get and boot from syslinux files
test      - minimal test like /bin/sh
tftpboot  - boot image via network using TFTP protocol
true      - do nothing, successfully
version   - print monitor, compiler and linker version
</code></pre></div><h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>16 What‚Äôs Next</h1>
<p>TODO</p>
<p>All Things Considered
crash and burn out</p>
<p>SG2000 Emulator</p>
<p>Legacy qemu -&gt; star64 -&gt; ox64 -&gt; sg2000</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000.md"><strong>lupyuen.github.io/src/sg2000.md</strong></a></p>
<h1 id="appendix-build-nuttx-for-sg2000"><a class="doc-anchor" href="#appendix-build-nuttx-for-sg2000">¬ß</a>17 Appendix: Build NuttX for SG2000</h1>
<p>TODO</p>
<p>Follow these steps to build (work-in-progress) Apache NuttX RTOS for SG2000 / Milk-V Duo S‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Set PATH
export PATH=&quot;$HOME/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-apple-darwin/bin:$PATH&quot;

set -e  #  Exit when any command fails
set -x  #  Echo commands

## Build NuttX
function build_nuttx {

  ## Go to NuttX Folder
  pushd ../nuttx

  ## Build NuttX
  make -j 8

  ## Return to previous folder
  popd
}

## Build Apps Filesystem
function build_apps {

  ## Go to NuttX Folder
  pushd ../nuttx

  ## Build Apps Filesystem
  make -j 8 export
  pushd ../apps
  ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
  make -j 8 import
  popd

  ## Return to previous folder
  popd
}

## Download WIP NuttX for SG2000 (based on Ox64 BL808)
git clone --branch sg2000 \
  https://github.com/lupyuen2/wip-nuttx \
  nuttx
git clone --branch sg2000 \
  https://github.com/lupyuen2/wip-nuttx-apps \
  apps
cd nuttx

## Pull updates
git pull &amp;&amp; git status &amp;&amp; hash1=`git rev-parse HEAD`
pushd ../apps
git pull &amp;&amp; git status &amp;&amp; hash2=`git rev-parse HEAD`
popd
echo NuttX Source: https://github.com/apache/nuttx/tree/$hash1 &gt;nuttx.hash
echo NuttX Apps: https://github.com/apache/nuttx-apps/tree/$hash2 &gt;&gt;nuttx.hash

## Show the version of GCC
riscv64-unknown-elf-gcc -v

## Configure build
tools/configure.sh ox64:nsh

## Build NuttX
build_nuttx

## Build Apps Filesystem
build_apps

## Generate Initial RAM Disk
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;

## Show the size
riscv64-unknown-elf-size nuttx

## Export the Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Copy the config
cp .config nuttx.config

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## Dump the init disassembly to init.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/init \
  &gt;init.S \
  2&gt;&amp;1

## Dump the hello disassembly to hello.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello \
  &gt;hello.S \
  2&gt;&amp;1

## Copy NuttX Image to TFTP Server
scp Image tftpserver:/tftpboot/Image-sg2000
ssh tftpserver ls -l /tftpboot/Image-sg2000
</code></pre></div>
<p>We have copied the NuttX Image to our TFTP Server. Let‚Äôs boot this on Milk-V Duo S‚Ä¶</p>
<p>TODO</p>
<h1 id="appendix-set-the-nuttx-memory-map-for-sg2000"><a class="doc-anchor" href="#appendix-set-the-nuttx-memory-map-for-sg2000">¬ß</a>18 Appendix: Set the NuttX Memory Map for SG2000</h1>
<p>TODO</p>
<p>From the U-Boot Bootloader Config above: We see that SG2000 boots at this address‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>kernel_addr_r=0x80200000
</code></pre></div>
<p>Thus we define the NuttX Memory Map for SG2000 like so‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2">Set the NuttX Memory Map for SG2000</a></p>
<p>NuttX Kernel will boot at 0x8020_0000, NuttX Apps will run at Virtual Address 0xC000_0000.</p>
<p>Here‚Äôs the NuttX Config: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078">boards/risc-v/bl808/ox64/configs/nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Kernel RAM
CONFIG_RAM_START=0x80200000
CONFIG_RAM_SIZE=1048576

## Kernel Paged Pool (Allocated to NuttX Apps)
CONFIG_ARCH_PGPOOL_PBASE=0x80600000
CONFIG_ARCH_PGPOOL_VBASE=0x80600000
CONFIG_ARCH_PGPOOL_SIZE=4194304

## Virtual Memory for NuttX App Code
CONFIG_ARCH_TEXT_VBASE=0xC0000000
CONFIG_ARCH_TEXT_NPAGES=128

## Virtual Memory for NuttX App Data
CONFIG_ARCH_DATA_VBASE=0xC0100000
CONFIG_ARCH_DATA_NPAGES=128

## Virtual Memory for NuttX App Heap
CONFIG_ARCH_HEAP_VBASE=0xC0200000
CONFIG_ARCH_HEAP_NPAGES=128
</code></pre></div>
<p>And here‚Äôs the NuttX Linker Script: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37">boards/risc-v/bl808/ox64/scripts/ld.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY {
    kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
    ksram (rwx) : ORIGIN = 0x80400000, LENGTH = 2048K   /* w/ cache */
    pgram (rwx) : ORIGIN = 0x80600000, LENGTH = 4096K   /* w/ cache */
    ramdisk (rwx) : ORIGIN = 0x80A00000, LENGTH = 16M   /* w/ cache */
}
...
SECTIONS {
  . = 0x80200000;
</code></pre></div><h1 id="appendix-disable-the-plic-interrupt-controller"><a class="doc-anchor" href="#appendix-disable-the-plic-interrupt-controller">¬ß</a>19 Appendix: Disable the PLIC Interrupt Controller</h1>
<p>TODO</p>
<p>Most RISC-V SBCs (Ox64, Star64) will manage Interrupts with a Platform-Level Interrupt Controller (PLIC). For now, let‚Äôs disable PLIC in NuttX‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/6d66caa1408d7a7d7b21b0e876ce32ceb5b93ec4">Disable the PLIC Interrupt Controller</a></p>
<p>Later we‚Äôll dump the SG2000 Linux Device Tree to understand the Interrupt Controller.</p>
<h1 id="appendix-select-the-nuttx-driver-for-16550-uart"><a class="doc-anchor" href="#appendix-select-the-nuttx-driver-for-16550-uart">¬ß</a>20 Appendix: Select the NuttX Driver for 16550 UART</h1>
<p>TODO</p>
<p>From the OpenSBI Log above: We see that SG2000 operates with a 8250 UART Controller.</p>
<p>Thus we select the NuttX Driver for 16550 UART, which is compatible with 8250‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec">Select the NuttX Driver for 16550 UART</a></p>
<p>Here‚Äôs the NuttX Config: <a href="https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078">boards/risc-v/bl808/ox64/configs/nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x04140000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y
</code></pre></div>
<p>Don‚Äôt update the NuttX Config File directly! We ran <code>make menuconfig</code> to generate the above file‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Update NuttX Config
make menuconfig \
  &amp;&amp; make savedefconfig \
  &amp;&amp; grep -v CONFIG_HOST defconfig \
  &gt;boards/risc-v/bl808/ox64/configs/nsh/defconfig
</code></pre></div>
<p>To find the menuconfig settings: Press ‚Äú<code>/</code>‚Äù and enter  the name of the setting, like ‚Äú16550_ADDRWIDTH‚Äù. This ensures that the Kconfig Dependencies are correctly updated.</p>
<p><em>How did we get IRQ 69 for UART?</em></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/122c717447f81c310a4fb082101213ad338dfb0e">Set UART0 IRQ to 69 (25 + 44)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_UART0_IRQ=69
</code></pre></div>
<p>We saw this in the <a href="https://github.com/sophgo/sophgo-doc/releases">SG2000 Reference Manual</a>‚Ä¶</p>
<blockquote>
<p>3.1 Interrupt Subsystem</p>
</blockquote>
<blockquote>
<p>Table 3.2: Interrupt number and Interrupt source mapping for Master RISCV C906 @ 1.0Ghz</p>
</blockquote>
<blockquote>
<p>Int #44: UART0</p>
</blockquote>
<p>Linx Device Tree also says UART0 IRQ is 44 (0x2C)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>serial@04140000 {
  compatible = &quot;snps,dw-apb-uart&quot;;
  reg = &lt;0x00 0x4140000 0x00 0x1000&gt;;
  clock-frequency = &lt;0x17d7840&gt;;
  reg-shift = &lt;0x02&gt;;
  reg-io-width = &lt;0x04&gt;;
  status = &quot;okay&quot;;
  interrupts = &lt;0x2c 0x04&gt;;
  interrupt-parent = &lt;0x04&gt;;
};
</code></pre></div>
<p>Thus we compute <a href="https://lupyuen.github.io/articles/plic2#uart-interrupt">NuttX IRQ</a> = 25 + RISC-V IRQ = 69</p>
<p>TODO: Fix the UART Clock: 16550_UART0_CLOCK</p>
<h1 id="appendix-enable-logging-for-nuttx-scheduler-and-binary-loader"><a class="doc-anchor" href="#appendix-enable-logging-for-nuttx-scheduler-and-binary-loader">¬ß</a>21 Appendix: Enable Logging for NuttX Scheduler and Binary Loader</h1>
<p>TODO</p>
<p>For easier troubleshooting: We enable the Logging for NuttX Scheduler and Binary Loader‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47">Enable Logging for Scheduler and Binary Loader</a></p>
<p>Here‚Äôs the NuttX Config: <a href="https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078">boards/risc-v/bl808/ox64/configs/nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_DEBUG_BINFMT=y
CONFIG_DEBUG_BINFMT_ERROR=y
CONFIG_DEBUG_BINFMT_WARN=y
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y
</code></pre></div>
<p>Remember: Always use <code>make menuconfig</code> to update the settings!</p>
<h1 id="appendix-nuttx-crash-dump-on-sg2000"><a class="doc-anchor" href="#appendix-nuttx-crash-dump-on-sg2000">¬ß</a>22 Appendix: NuttX Crash Dump on SG2000</h1>
<p>TODO</p>
<p>We apply the fixes above. Now NuttX boots some more on RISC-V SG2000 SoC / Milk-V Duo S. And shows our very first NuttX Crash Dump yay!</p>
<p><a href="https://gist.github.com/lupyuen/594f0df20d39001bac171412d594d517">(See the <strong>Complete Log</strong>)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Flattened Device Tree blob at 81200000
   Booting using the fdt blob at 0x81200000
   Loading Ramdisk to 9fe00000, end 9fe00000 ... OK
   Loading Device Tree to 000000009f26f000, end 000000009f27e43a ... OK

Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
_assert: Current Version: NuttX  12.4.0 f37a380-dirty May  7 2024 10:31:33 risc-v
_assert: Assertion failed 0x17 == (insn &amp; 0x7F): at file: machine/risc-v/arch_elf.c:494 task: AppBringUp process: Kernel 0x80200f34
up_dump_register: EPC: 000000008021087a
up_dump_register: A0: 0000000080401b70 A1: 00000000000001ee A2: 0000000080228ef8 A3: 0000000000000000
up_dump_register: A4: 0000000000000017 A5: 0000000000000002 A6: 000000000000ab9c A7: fffffffffffffff8
up_dump_register: T0: 000000000000002e T1: 0000000000000007 T2: 00000000000001ff T3: 000000008040c3fc
up_dump_register: T4: 000000008040c3f0 T5: 0000000000000009 T6: 000000000000002a
up_dump_register: S0: 0000000000000000 S1: 0000000080408740 S2: 0000000000000017 S3: 0000000000000000
up_dump_register: S4: 0000000080228ef8 S5: 0000000080228de8 S6: 0000000080401e10 S7: 8000000201842022
up_dump_register: S8: 00000000000001ee S9: 000000008040b9a0 S10: 0000000000000070 S11: 000000008040b990
up_dump_register: SP: 000000008040c330 FP: 0000000000000000 TP: 0000000000000000 RA: 000000008021087a
dump_stack: User Stack:
dump_stack:   base: 0x8040c030
dump_stack:   size: 00002000
dump_stack:     sp: 0x8040c330
</code></pre></div>
<p><em>What‚Äôs this Assertion Failure?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>_assert: Assertion failed 0x17 == (insn &amp; 0x7F):
at file: machine/risc-v/arch_elf.c:494
task: AppBringUp process: Kernel 0x80200f34
</code></pre></div>
<p>Oops we goofed and used the wrong U-Boot Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Nope! This won&#39;t work for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ;
booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
</code></pre></div>
<p>Which overwrites the NuttX Image in RAM. Watch what happens when we use the correct U-Boot Command‚Ä¶</p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>