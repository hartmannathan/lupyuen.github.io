<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="(Partially) Booting Apache NuttX Real-Time Operating System on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC"
    data-rh="true">
<meta name="description" 
    content="(Partially) Booting Apache NuttX Real-Time Operating System on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/nuttx2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#start-with-qemu-emulator">1 Start with QEMU Emulator</a><ul></ul></li>
<li><a href="#print-to-qemu-console">2 Print to QEMU Console</a><ul></ul></li>
<li><a href="#uart-controller-on-star64">3 UART Controller on Star64</a><ul></ul></li>
<li><a href="#risc-v-linux-kernel-header">4 RISC-V Linux Kernel Header</a><ul></ul></li>
<li><a href="#start-address-of-nuttx-kernel">5 Start Address of NuttX Kernel</a><ul></ul></li>
<li><a href="#boot-nuttx-on-star64">6 Boot NuttX on Star64</a><ul></ul></li>
<li><a href="#nuttx-fails-to-get-hart-id">7 NuttX Fails To Get Hart ID</a><ul></ul></li>
<li><a href="#risc-v-privilege-levels">8 RISC-V Privilege Levels</a><ul></ul></li>
<li><a href="#downgrade-nuttx-to-supervisor-mode">9 Downgrade NuttX to Supervisor Mode</a><ul></ul></li>
<li><a href="#fix-the-nuttx-boot-code">10 Fix the NuttX Boot Code</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>12 Jul 2023</em></p>
<p><img src="https://lupyuen.github.io/images/nuttx2-title.jpg" alt="Pine64 Star64 64-bit RISC-V SBC" /></p>
<p>In this article we‚Äôll boot a tiny bit of <a href="https://lupyuen.github.io/articles/riscv"><strong>Apache NuttX RTOS</strong></a> on the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> 64-bit RISC-V Single-Board Computer.</p>
<p>(Based on <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p><em>What‚Äôs NuttX?</em></p>
<p><a href="https://lupyuen.github.io/articles/riscv"><strong>Apache NuttX</strong></a> is a <strong>Real-Time Operating System (RTOS)</strong> that runs on many kinds of devices, from 8-bit to 64-bit.</p>
<p><em>NuttX supports Star64?</em></p>
<p>Nope NuttX won‚Äôt run on Star64 yet, we‚Äôll hit some interesting (and highly educational) RISC-V challenges.</p>
<p>But the things that we learn today will be super helpful for <a href="https://lupyuen.github.io/articles/riscv#jump-to-start"><strong>porting NuttX to Star64</strong></a>.</p>
<p>Please read on to find out how we‚Äôre <strong>booting a new OS</strong> (from scratch) on Star64 and JH7110, as we‚Ä¶</p>
<ul>
<li>
<p>Migrate NuttX from <strong>QEMU Emulator</strong> to Real Hardware</p>
</li>
<li>
<p>Log to the <strong>Serial Console</strong> in RISC-V Assembly</p>
</li>
<li>
<p>Trick <strong>U-Boot Bootloader</strong> into thinking we‚Äôre Linux</p>
</li>
<li>
<p>Downgrade from Machine to <strong>Supervisor Privilege Level</strong></p>
</li>
<li>
<p>With a little help from <strong>OpenSBI Supervisor Interface</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/riscv-title.png" alt="Apache NuttX RTOS on 64-bit QEMU RISC-V Emulator" /></p>
<h1 id="start-with-qemu-emulator"><a href="#start-with-qemu-emulator">1 Start with QEMU Emulator</a></h1>
<p>Earlier we successfully tested <strong>NuttX RTOS on QEMU Emulator</strong> for 64-bit RISC-V (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv"><strong>‚Äú64-bit RISC-V with Apache NuttX Real-Time Operating System‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs run this on Star64 JH7110 SBC! Starting with the <strong>NuttX Boot Code</strong> (in RISC-V Assembly)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv#risc-v-boot-code-in-nuttx"><strong>‚ÄúRISC-V Boot Code in NuttX‚Äù</strong></a></li>
</ul>
<p><em>Surely we‚Äôll run into problems?</em></p>
<p>Fortunately we have a <a href="https://lupyuen.github.io/articles/linux#serial-console-on-star64"><strong>Serial Debug Console</strong></a> connected to Star64. (Pic below)</p>
<p>We‚Äôll print some <strong>Debug Logs</strong> as we run the NuttX Boot Code.</p>
<p><em>But the NuttX Boot Code is in RISC-V Assembly!</em></p>
<p>Yep we‚Äôll print the Debug Logs with our own <strong>RISC-V Assembly Code</strong>.</p>
<p>Here‚Äôs our plan‚Ä¶</p>
<ul>
<li>
<p>Check the <strong>Serial Console on QEMU Emulator</strong>, how it‚Äôs wired up</p>
</li>
<li>
<p><strong>Test our Debug Log</strong> on QEMU Emulator</p>
</li>
<li>
<p><strong>Port our Debug Log</strong> to Star64 JH7110</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Star64 SBC with Woodpecker USB Serial Adapter" /></p>
<p><a href="https://lupyuen.github.io/articles/linux"><em>Star64 with Woodpecker USB Serial Adapter</em></a></p>
<h1 id="print-to-qemu-console"><a href="#print-to-qemu-console">2 Print to QEMU Console</a></h1>
<p><em>We‚Äôre printing to the Serial Console on QEMU Emulator‚Ä¶</em></p>
<p><em>What‚Äôs the UART Controller in QEMU?</em></p>
<p>Let‚Äôs check the <strong>NuttX Build Configuration</strong> for QEMU: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>This says that QEMU emulates a <a href="https://en.wikipedia.org/wiki/16550_UART"><strong>16550 UART Controller</strong></a>.</p>
<p>And the <strong>Base Address</strong> of QEMU‚Äôs UART Controller is <strong><code>0x1000</code> <code>0000</code></strong>.</p>
<p><em>How to print to the 16550 UART Port?</em></p>
<p>Checking the <strong>NuttX Driver</strong> for 16550 UART: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1539-L1553">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Send one byte to 16550 UART
static void u16550_send(struct uart_dev_s *dev, int ch) {

  // Fetch the 16550 Struct
  FAR struct u16550_s *priv = (FAR struct u16550_s *)dev-&gt;priv;

  // Print to 16550 UART...
  u16550_serialout(
    priv,                  // 16550 Struct
    UART_THR_OFFSET,       // Offset of Transmit Holding Register
    (uart_datawidth_t) ch  // Character to print
  );
}
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L610-L624">(<strong>u16550_serialout</strong> is defined here)</a></p>
<p>To print a character, the driver writes to the UART Base Address <strong><code>0x1000</code> <code>0000</code></strong> at Offset <strong>UART_THR_OFFSET</strong>.</p>
<p>And we discover that <strong>UART_THR_OFFSET</strong> is 0: <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/serial/uart_16550.h#L172-L200">uart_16550.h</a> is 0:</p>
<div class="example-wrap"><pre class="language-c"><code>#define UART_THR_INCR 0 /* (DLAB =0) Transmit Holding Register */
#define UART_THR_OFFSET (CONFIG_16550_REGINCR*UART_THR_INCR)
</code></pre></div>
<p>Which means that we can print to the QEMU Console by writing to <strong><code>0x1000</code> <code>0000</code></strong>. How convenient!</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `1` to QEMU Console
*(volatile uint8_t *) 0x10000000 = &#39;1&#39;;
</code></pre></div>
<p><em>What about RISC-V Assembly?</em></p>
<p>This is how we print to QEMU Console in <strong>RISC-V Assembly Code</strong>, so we can debug the NuttX Boot Code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L71-L93">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load UART Base Address to Register t0 */
li  t0, 0x10000000

/* Load `1` to Register t1 */
li  t1, 0x31
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb  t1, 0(t0)

/* Load `2` to Register t1 */
li  t1, 0x32
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb  t1, 0(t0)

/* Load `3` to Register t1 */
li  t1, 0x33
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb  t1, 0(t0)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#other-instructions">(<strong><code>li</code></strong> loads a Value into a Register)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--load-and-store-instructions">(<strong><code>sb</code></strong> stores a byte from a Register into an Address)</a></p>
<p>When we start QEMU Emulator, the code above prints ‚Äú<strong><code>123</code></strong>‚Äù to the QEMU Console (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic

123123123123123123112323
NuttShell (NSH) NuttX-12.0.3
nsh&gt; 
</code></pre></div>
<p>‚Äú<strong><code>123</code></strong>‚Äù is printed 8 times because QEMU is running with 8 CPUs.</p>
<p>Now we port the Debug Code to Star64‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/riscv-print.png" alt="NuttX prints to QEMU Console" /></p>
<h1 id="uart-controller-on-star64"><a href="#uart-controller-on-star64">3 UART Controller on Star64</a></h1>
<p><em>What‚Äôs the UART Controller in Star64?</em></p>
<p>Star64 JH7110 uses the <strong>8250 UART Controller</strong>, according to‚Ä¶</p>
<ul>
<li><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/function_layer.html"><strong>JH7110 UART Developing Guide</strong></a></li>
</ul>
<p>Which is <a href="https://en.wikipedia.org/wiki/16550_UART"><strong>compatible with the 16550 UART Controller</strong></a> used by QEMU.</p>
<p>So our UART Debug Code for QEMU will run on Star64!</p>
<p><em>But what‚Äôs the UART Base Address for Star64 JH7110?</em></p>
<p>UART0 Base Address is at <strong><code>0x1000</code> <code>0000</code></strong>, according to‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/system_memory_map.html"><strong>JH7110 System Memory Map</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html"><strong>JH7110 UART Device Tree</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/Datasheet/JH7110_DS/uart.html"><strong>JH7110 UART Datasheet</strong></a></p>
</li>
</ul>
<p><em>Isn‚Äôt that the same UART Base Address as QEMU?</em></p>
<p>Yep! Earlier we saw the <strong>UART Base Address</strong> for NuttX QEMU: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>NuttX QEMU UART Base Address is <strong><code>0x1000</code> <code>0000</code></strong>. The exact same UART Base Address for QEMU AND Star64!</p>
<p>So no changes needed, our UART Debug Code will run on <strong>QEMU AND Star64</strong>!</p>
<p>Our Kernel Image needs a special format, let‚Äôs tweak it‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-kernel.png" alt="Armbian Kernel Image" /></p>
<p><a href="https://lupyuen.github.io/articles/star64#inside-the-kernel-image"><em>Kernel Header for RISC-V Armbian Linux</em></a></p>
<h1 id="risc-v-linux-kernel-header"><a href="#risc-v-linux-kernel-header">4 RISC-V Linux Kernel Header</a></h1>
<p><em>How will U-Boot Bootloader boot NuttX?</em></p>
<p>For U-Boot Bootloader to boot NuttX, we need to embed the <strong>RISC-V Linux Kernel Header</strong> (and pretend we‚Äôre Linux)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#inside-the-kernel-image"><strong>‚ÄúInside the Kernel Image‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#appendix-decode-the-risc-v-linux-header"><strong>‚ÄúDecode the RISC-V Linux Header‚Äù</strong></a></p>
</li>
</ul>
<p>We‚Äôve done this previously for the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/arm64/src/common/arm64_head.S#L79-L118"><strong>Arm64 Linux Header</strong></a>.</p>
<p>This is how we adapt it for our <strong>RISC-V Linux Header</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L42-L75">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>c.li    s4, -13              /* Magic Signature &quot;MZ&quot; (2 bytes) */
j       real_start           /* Jump to Kernel Start (2 bytes) */
.long   0                    /* Executable Code padded to 8 bytes */
.quad   0x200000             /* Image load offset from start of RAM */
/* TODO: Change this to `_e_initstack - __start` */
.quad   171644               /* Effective size of kernel image, little-endian */
.quad   0x0                  /* Kernel flags, little-endian */
.long   0x2                  /* Version of this header */
.long   0                    /* Reserved */
.quad   0                    /* Reserved */
.ascii  &quot;RISCV\x00\x00\x00&quot;  /* Magic number, &quot;RISCV&quot; (8 bytes) */
.ascii  &quot;RSC\x05&quot;            /* Magic number 2, &quot;RSC\x05&quot; (4 bytes) */
.long   0                    /* Reserved for PE COFF offset */

real_start:
  /* Actual Boot Code starts here... */
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/star64#decompile-the-kernel-with-ghidra">(Why we need <strong>Magic Signature ‚ÄúMZ‚Äù</strong>)</a></p>
<p>Note that <strong>Image Load Offset</strong> must be <strong><code>0x20</code> <code>0000</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>.quad   0x200000             /* Image load offset from start of RAM */
</code></pre></div>
<p>That‚Äôs because our NuttX Kernel starts at <strong><code>0x4020</code> <code>0000</code></strong>. Here‚Äôs why‚Ä¶</p>
<h1 id="start-address-of-nuttx-kernel"><a href="#start-address-of-nuttx-kernel">5 Start Address of NuttX Kernel</a></h1>
<p><em>What‚Äôs this magical address <code>0x4020</code> <code>0000</code>?</em></p>
<p>From previous articles, we saw that Star64‚Äôs U-Boot Bootloader will load Linux Kernels into RAM at Address <strong><code>0x4020</code> <code>0000</code></strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64"><strong>‚ÄúArmbian Image for Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64"><strong>‚ÄúYocto Image for Star64‚Äù</strong></a></p>
</li>
</ul>
<p>Thus we do the same for NuttX on Star64.</p>
<p>This is how we set the Start Address to <strong><code>0x4020</code> <code>0000</code></strong> in the <strong>NuttX Build Configuration</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L56-L57">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_SIZE=33554432
CONFIG_RAM_START=0x40200000
</code></pre></div>
<p>And we updated the <strong>NuttX Linker Script</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script#L21-L26">ld.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#set-start-address-of-nuttx-kernel">(Remember to update <strong>knsh64/defconfig</strong> and <strong>ld-kernel64.script</strong>)</a></p>
<p><em>We‚Äôre sure this is correct?</em></p>
<p>Checking the <strong>RISC-V Disassembly</strong> of NuttX Kernel: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/star64-0.0.1/nuttx.S">nuttx.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>0000000040200000 &lt;__start&gt;:
  li  s4, -0xd    /* Magic Signature &quot;MZ&quot; (2 bytes) */
    40200000:	5a4d  li  s4,-13
  j   real_start  /* Jump to Kernel Start (2 bytes) */
    40200002:	a83d  j	  40200040 &lt;real_start&gt;
</code></pre></div>
<p>The NuttX Start Address is indeed <strong><code>0x4020</code> <code>0000</code></strong>.</p>
<p>Yep Looks Good To Us (YLGTU), we‚Äôre ready to boot on Star64!</p>
<p><img src="https://lupyuen.github.io/images/star64-nuttx.png" alt="Boot NuttX on Star64" /></p>
<h1 id="boot-nuttx-on-star64"><a href="#boot-nuttx-on-star64">6 Boot NuttX on Star64</a></h1>
<p>We‚Äôre finally ready to <strong>boot NuttX on Star64</strong>! We compile <strong>NuttX for RISC-V QEMU</strong> with these steps‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><strong>‚ÄúBuild Apache NuttX RTOS for 64-bit RISC-V QEMU‚Äù</strong></a> </li>
</ul>
<p>Then we tweak it to <strong>boot on Star64</strong> (and rebuild)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console"><strong>‚ÄúPrint to QEMU Console‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#uart-controller-on-star64"><strong>‚ÄúUART Controller on Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#risc-v-linux-kernel-header"><strong>‚ÄúRISC-V Linux Kernel Header‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#start-address-of-nuttx-kernel"><strong>‚ÄúStart Address of NuttX Kernel‚Äù</strong></a></p>
</li>
</ul>
<p>This produces the <strong>NuttX ELF Image</strong> for Star64: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/star64-0.0.1/nuttx"><strong>nuttx</strong></a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/31/files">(See the <strong>Modified Files</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64-0.0.1">(See the <strong>Build Outputs</strong>)</a></p>
<p><em>How to copy it to microSD?</em></p>
<p>For the microSD Image, we start with this <a href="https://www.armbian.com/star64/"><strong>Armbian Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/armbianro/os/releases/download/23.8.0-trunk.56/Armbian_23.8.0-trunk.56_Star64_lunar_edge_5.15.0_minimal.img.xz"><strong>Armbian 23.8 Lunar for Star64 (Minimal)</strong></a></li>
</ul>
<p>Uncompress the <strong>.xz</strong> file. Write the <strong>.img</strong> file to a microSD Card with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a> or <a href="https://wiki.gnome.org/Apps/Disks"><strong>GNOME Disks</strong></a>.</p>
<p>We fix the <a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64"><strong>Missing Device Tree</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Fix the Missing Device Tree
sudo chmod go+w /run/media/$USER/armbi_root/boot
sudo chmod go+w /run/media/$USER/armbi_root/boot/dtb/starfive
cp \
  /run/media/$USER/armbi_root/boot/dtb/starfive/jh7110-visionfive-v2.dtb \
  /run/media/$USER/armbi_root/boot/dtb/starfive/jh7110-star64-pine64.dtb
</code></pre></div>
<p>Then we delete the sym-link <strong>/boot/Image</strong> and copy the NuttX Binary Image <strong>nuttx.bin</strong> to <strong>/boot/Image</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## We assume that `nuttx` contains the NuttX ELF Image.
## Export the NuttX Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Delete Armbian Kernel `/boot/Image`
rm /run/media/$USER/armbi_root/boot/Image

## Copy `nuttx.bin` to Armbian Kernel `/boot/Image`
cp nuttx.bin /run/media/$USER/armbi_root/boot/Image
</code></pre></div>
<p>Insert the microSD Card into Star64 and power up.</p>
<p>NuttX boots on Star64 and prints ‚Äú<strong><code>123</code></strong>‚Äù yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console">(Which is printed by our <strong>Boot Code</strong>)</a></p>
<p>But NuttX crashes with a <strong>RISC-V Illegal Instruction Exception</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
EPC: ffffffff804ba05c RA: 00000000402011c6 reloc adjusted

SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
A4:  0000000000000000 A5:  0000000040200000 A6:  00000000fffd5708
A7:  0000000000000000 S2:  00000000fff47194 S3:  0000000000000003
S4:  fffffffffffffff3 S5:  00000000fffdbb50 S6:  0000000000000000
S7:  0000000000000000 S8:  00000000fff47194 S9:  0000000000000002
S10: 0000000000000000 S11: 0000000000000000 T3:  0000000000000023
T4:  000000004600b5cc T5:  000000000000ff00 T6:  000000004600b5cc
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#boot-nuttx-on-star64">(See the <strong>Complete Log</strong>)</a></p>
<p>(<strong>EPC</strong> is the Program Counter for the Exception: <strong><code>0x4020</code> <code>005C</code></strong>)</p>
<p>And shows (cryptically) the offending <strong>RISC-V Machine Code</strong> (in brackets)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Code:
  0313 0320 8023 0062 0313 0330 8023 0062
  (2573 f140)
resetting ...
reset not supported yet
### ERROR ### Please RESET the board ###
</code></pre></div>
<p>Why did NuttX crash at <strong><code>0x4020</code> <code>005C</code></strong>? Let‚Äôs find out‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-exception.jpg" alt="Cody AI Assistant tries to explain our RISC-V Exception" /></p>
<p><em>Cody AI Assistant tries to explain our RISC-V Exception</em></p>
<h1 id="nuttx-fails-to-get-hart-id"><a href="#nuttx-fails-to-get-hart-id">7 NuttX Fails To Get Hart ID</a></h1>
<p><em>What‚Äôs at <code>0x4020</code> <code>005C</code>?</em></p>
<p><em>Why did it crash NuttX?</em></p>
<p>TODO</p>
<p>Here‚Äôs our RISC-V Boot Code‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ed09c34532ee7c51ac2da816cd6cf0adcce336e6/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L103">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/qemu_rv_head.S:95
  /* Load mhartid (cpuid) */
  csrr a0, mhartid
    4020005c:	f1402573  csrr a0, mhartid
</code></pre></div>
<p>NuttX tries loads the CPU ID or Hardware Thread ‚ÄúHart‚Äù ID from the RISC-V Control and Status Register (CSR). <a href="https://lupyuen.github.io/articles/riscv#get-cpu-id">(Explained here)</a></p>
<p>But it fails! Because we don‚Äôt have sufficient privilege to access the Hart ID.</p>
<h1 id="risc-v-privilege-levels"><a href="#risc-v-privilege-levels">8 RISC-V Privilege Levels</a></h1>
<p>TODO</p>
<p>RISC-V runs at 3 Privilege Levels‚Ä¶</p>
<ul>
<li>
<p>M: Machine Level (Most powerful)</p>
</li>
<li>
<p>S: Supervisor Level (Less powerful)</p>
</li>
<li>
<p>U: User Level (Least powerful)</p>
</li>
</ul>
<p>NuttX runs at Supervisor Level, which <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html">doesn‚Äôt allow access to Machine-Level CSR Registers</a>.  (Including <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid">Hart ID</a>)</p>
<p>(The <code>m</code> in <code>mhartid</code> signifies that it‚Äôs a Machine-Level Register)</p>
<p><em>What runs at Machine Level?</em></p>
<p><a href="https://www.thegoodpenguin.co.uk/blog/an-overview-of-opensbi/">OpenSBI</a> (Supervisor Binary Interface) is the first thing that boots on Star64. It runs at Machine Level and starts the U-Boot Bootloader.</p>
<p><a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.pdf">(See the RISC-V SBI Spec)</a></p>
<p><em>What about U-Boot Bootloader?</em></p>
<p>U-Boot Bootloader runs at Supervisor Level. And starts NuttX, also at Supervisor Level.</p>
<p>So OpenSBI is the only thing that runs at Machine Level. And can access the Machine-Level Registers.</p>
<h1 id="downgrade-nuttx-to-supervisor-mode"><a href="#downgrade-nuttx-to-supervisor-mode">9 Downgrade NuttX to Supervisor Mode</a></h1>
<p>TODO</p>
<p><em>How to get the Hart ID from OpenSBI?</em></p>
<p>Let‚Äôs refer to the Linux Boot Code: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S">linux/arch/riscv/kernel/head.S</a></p>
<p>(Tip: <code>CONFIG_RISCV_M_MODE</code> is False and <code>CONFIG_EFI</code> is True)</p>
<p>From <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L292-L295">linux/blob/master/arch/riscv/kernel/head.S</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>/* Save hart ID and DTB physical address */
mv s0, a0
mv s1, a1
</code></pre></div>
<p>Here we see that U-Boot <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.adoc#function-hart-start-fid-0">(or OpenSBI)</a> will pass 2 arguments when it starts our kernel‚Ä¶</p>
<ul>
<li>
<p>Register A0: Hart ID</p>
</li>
<li>
<p>Register A1: RAM Address of Device Tree</p>
</li>
</ul>
<p>So we‚Äôll simply read the Hart ID from Register A0. (And ignore A1)</p>
<p>We‚Äôll remove <code>csrr a0, mhartid</code>.</p>
<p><em>What are the actual values of Registers A0 and A1?</em></p>
<p>Thanks to our <a href="https://github.com/lupyuen/nuttx-star64#boot-nuttx-on-star64">earlier Crash Dump</a>, we know the actual values of A0 and A1!</p>
<div class="example-wrap"><pre class="language-text"><code>SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
</code></pre></div>
<p>This says that‚Ä¶</p>
<ul>
<li>
<p>Hart ID is 1 (Register A0)</p>
</li>
<li>
<p>RAM Address of Device Tree is <code>0x4600</code> <code>0000</code> (Register A1)</p>
</li>
</ul>
<p>Yep looks correct! But we‚Äôll subtract 1 from Register A0 because NuttX expects Hart ID to start with 0.</p>
<p><em>What about other CSR Instructions in our NuttX Boot Code?</em></p>
<p>We change the Machine-Level <code>m</code> Registers to Supervisor-Level <code>s</code> Registers.</p>
<p>To Disable Interrupts: Change <code>mie</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><code>sie</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Disable all interrupts (i.e. timer, external) in mie */
csrw  mie, zero
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#disable-interrupts">(Source)</a></p>
<p>To Load Interrupt Vector Table: Change <code>mtvec</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><code>stvec</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Load address of Interrupt Vector Table */
csrw  mtvec, t0
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#load-interrupt-vector">(Source)</a></p>
<p><em>The Linux Boot Code looks confusing. What are CSR_IE and CSR_IP?</em></p>
<div class="example-wrap"><pre class="language-text"><code>/* Mask all interrupts */
csrw CSR_IE, zero
csrw CSR_IP, zero
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L195-L200">(Source)</a></p>
<p>That‚Äôs because the Linux Boot Code will work for Machine Level AND Supervisor Level! Here‚Äôs how <code>CSR_IE</code> and <code>CSR_IP</code> are mapped to the <code>m</code> and <code>s</code> CSR Registers‚Ä¶</p>
<p>(Remember: <code>CONFIG_RISCV_M_MODE</code> is false for NuttX)</p>
<div class="example-wrap"><pre class="language-text"><code>#ifdef CONFIG_RISCV_M_MODE
  /* Use Machine-Level CSR Registers */
  # define CSR_IE		CSR_MIE
  # define CSR_IP		CSR_MIP
  ...
#else
  /* Use Supervisor-Level CSR Registers */
  # define CSR_IE		CSR_SIE
  # define CSR_IP		CSR_SIP
  ...
#endif /* !CONFIG_RISCV_M_MODE */
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/csr.h#L391-L444">(Source)</a></p>
<p>Let‚Äôs fix the Boot Code‚Ä¶</p>
<h1 id="fix-the-nuttx-boot-code"><a href="#fix-the-nuttx-boot-code">10 Fix the NuttX Boot Code</a></h1>
<p>TODO</p>
<p>From the previous section, we identified these fixes for the NuttX Boot Code‚Ä¶</p>
<ol>
<li>
<p>Remove <code>csrr a0, mhartid</code> because OpenSBI will pass Hart ID in Register A0. Subtract 1 from Register A0 because NuttX expects Hart ID to start with 0.</p>
</li>
<li>
<p>To Disable Interrupts: Change <code>mie</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><code>sie</code></a></p>
</li>
<li>
<p>To Load Interrupt Vector Table: Change <code>mtvec</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><code>stvec</code></a></p>
</li>
</ol>
<p>Here‚Äôs the updated Boot Code, and our analysis: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>real_start:
  ...
  /* Load mhartid (cpuid) */
  /* Previously: csrr a0, mhartid */

  /* We assume that OpenSBI has passed Hart ID (value 1) in Register a0. */
  /* But NuttX expects Hart ID to start at 0, so we subtract 1. */
  addi a0, a0, -1

  /* Print the Hart ID */
  addi t1, a0, 0x30
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb   t1, 0(t0)
</code></pre></div>
<p><strong>If Hart ID is 0:</strong></p>
<ul>
<li>Set Stack Pointer to the Idle Thread Stack</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>  /* Set stack pointer to the idle thread stack */
  bnez a0, 1f
  la   sp, QEMU_RV_IDLESTACK_TOP
  j    2f
</code></pre></div>
<p><strong>If Hart ID is 1, 2, 3, ‚Ä¶</strong></p>
<ul>
<li>Validate the Hart ID (Must be less than number of CPUs)</li>
<li>Compute the Stack Base Address based on <code>g_cpu_basestack</code> and Hart ID</li>
<li>Set the Stack Pointer to the computed Stack Base Address</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>1:
  /* Load the number of CPUs that the kernel supports */
#ifdef CONFIG_SMP
  li   t1, CONFIG_SMP_NCPUS
#else
  li   t1, 1
#endif

  /* If a0 (mhartid) &gt;= t1 (the number of CPUs), stop here */
  blt  a0, t1, 3f
  csrw sie, zero
  /* Previously: csrw mie, zero */
  wfi

3:
  /* To get g_cpu_basestack[mhartid], must get g_cpu_basestack first */
  la   t0, g_cpu_basestack

  /* Offset = pointer width * hart id */
#ifdef CONFIG_ARCH_RV32
  slli t1, a0, 2
#else
  slli t1, a0, 3
#endif
  add  t0, t0, t1

  /* Load idle stack base to sp */
  REGLOAD sp, 0(t0)

  /*
   * sp (stack top) = sp + idle stack size - XCPTCONTEXT_SIZE
   *
   * Note: Reserve some space used by up_initial_state since we are already
   * running and using the per CPU idle stack.
   */
  li   t0, STACK_ALIGN_UP(CONFIG_IDLETHREAD_STACKSIZE - XCPTCONTEXT_SIZE)
  add  sp, sp, t0
</code></pre></div>
<p><strong>For All Hart IDs:</strong></p>
<ul>
<li>Disable Interrupts</li>
<li>Load the Interrupt Vector Table</li>
<li>Jump to <code>qemu_rv_start</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">2</span>:
  <span class="comment">/* Disable all interrupts (i.e. timer, external) in mie */
  </span>csrw	sie, zero
  <span class="comment">/* Previously: csrw	mie, zero */

  /* Don&#39;t load the Interrupt Vector Table, use OpenSBI for crash logging */
  /* la   t0, __trap_vec */
  /* csrw stvec, t0 */
  /* Previously: csrw mtvec, t0 */

  /* Jump to qemu_rv_start */
  </span>jal  x1, qemu_rv_start

  <span class="comment">/* We shouldn&#39;t return from _start */</span></code></pre></div>
<p>Note that we don‚Äôt load the Interrupt Vector Table, because we‚Äôll use OpenSBI for crash logging. (Like when we hit M-Mode Instructions)</p>
<p><em>What happens when we run this?</em></p>
<p>Hart ID is now 0, which is correct‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123067
</code></pre></div>
<p>But <code>qemu_rv_start</code> hangs. Why?</p>
<div class="example-wrap"><pre class="language-text"><code>  /* Print `7` */
  li  t0, 0x10000000
  li  t1, 0x37
  sb  t1, 0(t0)

  /* Jump to qemu_rv_start */
  jal  x1, qemu_rv_start
</code></pre></div>
<p>TODO: Trace <code>qemu_rv_start</code></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO: This is the first in a series of articles on porting NuttX to Star64.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nuttx2.md"><strong>lupyuen.github.io/src/nuttx2.md</strong></a></p>

    
</body>
</html>