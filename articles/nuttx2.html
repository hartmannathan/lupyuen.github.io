<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="(Partially) Booting Apache NuttX Real-Time Operating System on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC"
    data-rh="true">
<meta name="description" 
    content="(Partially) Booting Apache NuttX Real-Time Operating System on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/nuttx2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#start-with-qemu-emulator">1 Start with QEMU Emulator</a><ul></ul></li>
<li><a href="#print-to-qemu-console">2 Print to QEMU Console</a><ul></ul></li>
<li><a href="#uart-controller-on-star64">3 UART Controller on Star64</a><ul></ul></li>
<li><a href="#risc-v-linux-kernel-header">4 RISC-V Linux Kernel Header</a><ul></ul></li>
<li><a href="#start-address-of-nuttx-kernel">5 Start Address of NuttX Kernel</a><ul></ul></li>
<li><a href="#boot-nuttx-on-star64">6 Boot NuttX on Star64</a><ul></ul></li>
<li><a href="#nuttx-fails-to-get-hart-id">7 NuttX Fails To Get Hart ID</a><ul></ul></li>
<li><a href="#risc-v-privilege-levels">8 RISC-V Privilege Levels</a><ul></ul></li>
<li><a href="#downgrade-nuttx-to-supervisor-mode">9 Downgrade NuttX to Supervisor Mode</a><ul></ul></li>
<li><a href="#fix-the-nuttx-boot-code">10 Fix the NuttX Boot Code</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-hart-id-from-opensbi">12 Appendix: Hart ID from OpenSBI</a><ul></ul></li>
<li><a href="#appendix-nuttx-in-supervisor-mode">13 Appendix: NuttX in Supervisor Mode</a><ul></ul></li>
<li><a href="#appendix-nuttx-start-address">14 Appendix: NuttX Start Address</a><ul></ul></li>
<li><a href="#appendix-nuttx-crash-log">15 Appendix: NuttX Crash Log</a><ul></ul></li></ul></nav><p>üìù <em>12 Jul 2023</em></p>
<p><img src="https://lupyuen.github.io/images/nuttx2-title.jpg" alt="Pine64 Star64 64-bit RISC-V SBC" /></p>
<p>In this article we‚Äôll boot a tiny bit of <a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX RTOS</strong></a> on the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> 64-bit RISC-V Single-Board Computer.</p>
<p>(Based on <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p><em>What‚Äôs NuttX?</em></p>
<p><a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX</strong></a> is a <strong>Real-Time Operating System (RTOS)</strong> that runs on many kinds of devices, from 8-bit to 64-bit.</p>
<p><em>NuttX supports Star64?</em></p>
<p>Nope NuttX won‚Äôt run on Star64 yet, we‚Äôll hit some interesting (and highly educational) RISC-V challenges.</p>
<p>But the things that we learn today will be super helpful for <a href="https://lupyuen.github.io/articles/riscv#jump-to-start"><strong>porting NuttX to Star64</strong></a>.</p>
<p>Please join me as we whip up a tiny tasty treat of NuttX on Star64‚Ä¶</p>
<ul>
<li>
<p>Migrate NuttX from <strong>QEMU Emulator</strong> to Real Hardware</p>
</li>
<li>
<p>Log to the <strong>Serial Console</strong> in RISC-V Assembly</p>
</li>
<li>
<p>Trick <strong>U-Boot Bootloader</strong> into thinking we‚Äôre Linux</p>
</li>
<li>
<p>Downgrade from Machine to <strong>Supervisor Privilege Level</strong></p>
</li>
<li>
<p>With a little help from <strong>OpenSBI Supervisor Interface</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/riscv-title.png" alt="Apache NuttX RTOS on 64-bit QEMU RISC-V Emulator" /></p>
<h1 id="start-with-qemu-emulator"><a href="#start-with-qemu-emulator">1 Start with QEMU Emulator</a></h1>
<p>Earlier we successfully tested <strong>NuttX RTOS on QEMU Emulator</strong> for 64-bit RISC-V (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv"><strong>‚Äú64-bit RISC-V with Apache NuttX Real-Time Operating System‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs run this on Star64! Starting with the <strong>NuttX Boot Code</strong> (in RISC-V Assembly)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv#risc-v-boot-code-in-nuttx"><strong>‚ÄúRISC-V Boot Code in NuttX‚Äù</strong></a></li>
</ul>
<p><em>Surely we‚Äôll run into problems?</em></p>
<p>Fortunately we have a <a href="https://lupyuen.github.io/articles/linux#serial-console-on-star64"><strong>Serial Debug Console</strong></a> connected to Star64. (Pic below)</p>
<p>We‚Äôll print some <strong>Debug Logs</strong> as NuttX boots on Star64. Here‚Äôs our plan‚Ä¶</p>
<ul>
<li>
<p>Check the <strong>Serial Console on QEMU Emulator</strong>, how it‚Äôs wired up</p>
</li>
<li>
<p><strong>Test our Debug Log</strong> on QEMU Emulator</p>
</li>
<li>
<p><strong>Port our Debug Log</strong> to Star64</p>
</li>
</ul>
<p>Our cooking begins‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Star64 SBC with Woodpecker USB Serial Adapter" /></p>
<p><a href="https://lupyuen.github.io/articles/linux"><em>Star64 with Woodpecker USB Serial Adapter</em></a></p>
<h1 id="print-to-qemu-console"><a href="#print-to-qemu-console">2 Print to QEMU Console</a></h1>
<p><em>We‚Äôre printing to the Serial Console on QEMU Emulator‚Ä¶</em></p>
<p><em>What‚Äôs the UART Controller in QEMU?</em></p>
<p>We check the <strong>NuttX Build Configuration</strong> for QEMU: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>This says that QEMU emulates a <a href="https://en.wikipedia.org/wiki/16550_UART"><strong>16550 UART Controller</strong></a>.</p>
<p>And the <strong>Base Address</strong> of QEMU‚Äôs UART Controller is <strong><code>0x1000</code> <code>0000</code></strong>.</p>
<p><em>How to print to the 16550 UART Port?</em></p>
<p>We check the <strong>NuttX Driver</strong> for 16550 UART: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1539-L1553">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Send one byte to 16550 UART
static void u16550_send(struct uart_dev_s *dev, int ch) {

  // Fetch the 16550 Struct
  FAR struct u16550_s *priv = (FAR struct u16550_s *)dev-&gt;priv;

  // Print to 16550 UART...
  u16550_serialout(
    priv,                  // 16550 Struct
    UART_THR_OFFSET,       // Offset of Transmit Holding Register
    (uart_datawidth_t) ch  // Character to print
  );
}
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L610-L624">(<strong>u16550_serialout</strong> is defined here)</a></p>
<p>To print a character, the driver writes to the UART Base Address <strong><code>0x1000</code> <code>0000</code></strong> at Offset <strong>UART_THR_OFFSET</strong>.</p>
<p>And we discover that <strong>UART_THR_OFFSET</strong> is 0: <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/serial/uart_16550.h#L172-L200">uart_16550.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define UART_THR_INCR 0 /* Transmit Holding Register (when DLAB is 0) */
#define UART_THR_OFFSET (CONFIG_16550_REGINCR*UART_THR_INCR)
</code></pre></div>
<p>Which means that we can print to QEMU Console by writing to <strong><code>0x1000</code> <code>0000</code></strong>. How convenient!</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `1` to QEMU Console
*(volatile uint8_t *) 0x10000000 = &#39;1&#39;;
</code></pre></div>
<p><em>What about RISC-V Assembly?</em></p>
<p>This is how we print to QEMU Console in <strong>RISC-V Assembly</strong> (to debug our NuttX Boot Code): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L71-L93">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Load UART Base Address to Register t0 */
li  t0, 0x10000000

/* Load `1` to Register t1 */
li  t1, 0x31
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb  t1, 0(t0)

/* Load `2` to Register t1 */
li  t1, 0x32
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb  t1, 0(t0)

/* Load `3` to Register t1 */
li  t1, 0x33
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb  t1, 0(t0)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#other-instructions">(<strong><code>li</code></strong> loads a Value into a Register)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--load-and-store-instructions">(<strong><code>sb</code></strong> stores a byte from a Register into an Address)</a></p>
<p>When we start QEMU Emulator, our RISC-V Assembly prints ‚Äú<strong><code>123</code></strong>‚Äù to the QEMU Console (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic

123123123123123123112323
NuttShell (NSH) NuttX-12.0.3
nsh&gt; 
</code></pre></div>
<p>‚Äú<strong><code>123</code></strong>‚Äù is printed 8 times because QEMU is running with 8 CPUs.</p>
<p>Now we sprinkle some Debug Logs on Star64‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/riscv-print.png" alt="NuttX prints to QEMU Console" /></p>
<h1 id="uart-controller-on-star64"><a href="#uart-controller-on-star64">3 UART Controller on Star64</a></h1>
<p><em>What‚Äôs the UART Controller in Star64?</em></p>
<p>Star64 JH7110 uses the <strong>8250 UART Controller</strong>, according to‚Ä¶</p>
<ul>
<li><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/function_layer.html"><strong>JH7110 UART Developing Guide</strong></a></li>
</ul>
<p>Which is <a href="https://en.wikipedia.org/wiki/16550_UART"><strong>compatible with the 16550 UART Controller</strong></a> used by QEMU.</p>
<p><em>But what‚Äôs the UART Base Address for Star64?</em></p>
<p>UART0 Base Address is at <strong><code>0x1000</code> <code>0000</code></strong>, according to‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/system_memory_map.html"><strong>JH7110 System Memory Map</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html"><strong>JH7110 UART Device Tree</strong></a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/Datasheet/JH7110_DS/uart.html"><strong>JH7110 UART Datasheet</strong></a></p>
</li>
</ul>
<p><em>Isn‚Äôt that the same UART Base Address as QEMU?</em></p>
<p>Yep! Earlier we saw the <strong>UART Base Address</strong> for NuttX QEMU: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_UART0_BASE=0x10000000
</code></pre></div>
<p><strong><code>0x1000</code> <code>0000</code></strong> is the exact same UART Base Address for QEMU AND Star64‚Ä¶</p>
<p>So no changes needed, our Debug Log will work on Star64!</p>
<p>To boot NuttX on Star64, it needs a special ingredient‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-kernel.png" alt="Armbian Kernel Image" /></p>
<p><a href="https://lupyuen.github.io/articles/star64#inside-the-kernel-image"><em>Kernel Header for RISC-V Armbian Linux</em></a></p>
<h1 id="risc-v-linux-kernel-header"><a href="#risc-v-linux-kernel-header">4 RISC-V Linux Kernel Header</a></h1>
<p><em>How will Star64 boot NuttX?</em></p>
<p>Star64‚Äôs <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a> will load NuttX Kernel into RAM and run it.</p>
<p>But we need to embed the <strong>RISC-V Linux Kernel Header</strong> (and pretend we‚Äôre Linux)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#inside-the-kernel-image"><strong>‚ÄúInside the Kernel Image‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#appendix-decode-the-risc-v-linux-header"><strong>‚ÄúDecode the RISC-V Linux Header‚Äù</strong></a></p>
</li>
</ul>
<p>Thus we cooked up this Assembly Code for our <strong>RISC-V Linux Header</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L42-L75">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>c.li    s4, -13              /* Magic Signature &quot;MZ&quot; (2 bytes) */
j       real_start           /* Jump to Kernel Start (2 bytes) */
.long   0                    /* Executable Code padded to 8 bytes */
.quad   0x200000             /* Image load offset from start of RAM */
/* TODO: Change this to `_e_initstack - __start` */
.quad   171644               /* Effective size of kernel image, little-endian */
.quad   0x0                  /* Kernel flags, little-endian */
.long   0x2                  /* Version of this header */
.long   0                    /* Reserved */
.quad   0                    /* Reserved */
.ascii  &quot;RISCV\x00\x00\x00&quot;  /* Magic number, &quot;RISCV&quot; (8 bytes) */
.ascii  &quot;RSC\x05&quot;            /* Magic number 2, &quot;RSC\x05&quot; (4 bytes) */
.long   0                    /* Reserved for PE COFF offset */

real_start:
  /* Actual Boot Code starts here... */
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/star64#decompile-the-kernel-with-ghidra">(<strong><code>c.li</code></strong> emits the <strong>Magic Signature ‚ÄúMZ‚Äù</strong>)</a></p>
<p>Note that <strong>Image Load Offset</strong> must be <strong><code>0x20</code> <code>0000</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>.quad  0x200000  /* Image load offset from start of RAM */
</code></pre></div>
<p>That‚Äôs because our NuttX Kernel will start at RAM Address <strong><code>0x4020</code> <code>0000</code></strong>. Chew on it for a bit‚Ä¶</p>
<h1 id="start-address-of-nuttx-kernel"><a href="#start-address-of-nuttx-kernel">5 Start Address of NuttX Kernel</a></h1>
<p><em>What‚Äôs this magical address <code>0x4020</code> <code>0000</code>?</em></p>
<p>From previous articles, we saw that Star64‚Äôs U-Boot Bootloader will load Linux Kernels into RAM at Address <strong><code>0x4020</code> <code>0000</code></strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64"><strong>‚ÄúArmbian Image for Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64"><strong>‚ÄúYocto Image for Star64‚Äù</strong></a></p>
</li>
</ul>
<p>Thus we do the same for NuttX on Star64.</p>
<p>This is how we set the Start Address to <strong><code>0x4020</code> <code>0000</code></strong> in our <strong>NuttX Build Configuration</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L56-L57">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>// TODO: Fix CONFIG_RAM_SIZE
CONFIG_RAM_SIZE=33554432
CONFIG_RAM_START=0x40200000
</code></pre></div>
<p>And our <strong>NuttX Linker Script</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script#L21-L26">ld.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx2#appendix-nuttx-start-address">(Also <strong>knsh64/defconfig</strong> and <strong>ld-kernel64.script</strong>)</a></p>
<p><em>We‚Äôre sure this is correct?</em></p>
<p>We check the <strong>RISC-V Disassembly</strong> of our NuttX Kernel: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/star64-0.0.1/nuttx.S">nuttx.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>0000000040200000 &lt;__start&gt;:
  li  s4, -0xd    /* Magic Signature &quot;MZ&quot; (2 bytes) */
    40200000:	5a4d  li  s4,-13
  j   real_start  /* Jump to Kernel Start (2 bytes) */
    40200002:	a83d  j	  40200040 &lt;real_start&gt;
</code></pre></div>
<p>The Start Address is indeed <strong><code>0x4020</code> <code>0000</code></strong>.</p>
<p>Yep Looks Good To Us (YLGTU), we‚Äôre ready to serve it on Star64!</p>
<p><img src="https://lupyuen.github.io/images/star64-nuttx.png" alt="Boot NuttX on Star64" /></p>
<h1 id="boot-nuttx-on-star64"><a href="#boot-nuttx-on-star64">6 Boot NuttX on Star64</a></h1>
<p>We‚Äôre finally ready to <strong>boot NuttX on Star64</strong>! We compile <strong>NuttX for RISC-V QEMU</strong> with these steps‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><strong>‚ÄúBuild Apache NuttX RTOS for 64-bit RISC-V QEMU‚Äù</strong></a> </li>
</ul>
<p>Then we tweak it to <strong>boot on Star64</strong> (and rebuild)‚Ä¶</p>
<ol>
<li>
<p>Print the <a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console"><strong>Debug Logs</strong></a> in RISC-V Assembly</p>
</li>
<li>
<p>Check the <a href="https://lupyuen.github.io/articles/nuttx2#uart-controller-on-star64"><strong>UART Base Address</strong></a></p>
</li>
<li>
<p>Embed the <a href="https://lupyuen.github.io/articles/nuttx2#risc-v-linux-kernel-header"><strong>RISC-V Kernel Header</strong></a></p>
</li>
<li>
<p>Set the <a href="https://lupyuen.github.io/articles/nuttx2#start-address-of-nuttx-kernel"><strong>Start Address</strong></a> of NuttX Kernel</p>
</li>
</ol>
<p>This produces the <strong>NuttX ELF Image</strong> for Star64‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/download/star64-0.0.1/nuttx"><strong>nuttx: NuttX ELF Image</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/31/files">See the <strong>Modified Files</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64-0.0.1">See the <strong>Build Outputs</strong></a></p>
</li>
</ul>
<p><em>How to boot NuttX on microSD?</em></p>
<p>For the microSD Image, we start with this <a href="https://www.armbian.com/star64/"><strong>Armbian Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/armbianro/os/releases/download/23.8.0-trunk.69/Armbian_23.8.0-trunk.69_Star64_lunar_edge_5.15.0_minimal.img.xz"><strong>Armbian 23.8 Lunar for Star64 (Minimal)</strong></a></li>
</ul>
<p>Uncompress the <strong>.xz</strong> file. Write the <strong>.img</strong> file to a microSD Card with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a> or <a href="https://wiki.gnome.org/Apps/Disks"><strong>GNOME Disks</strong></a>.</p>
<p>The <a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64"><strong>Device Tree</strong></a> is missing, so we fix it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Fix the Missing Device Tree
sudo chmod go+w /run/media/$USER/armbi_root/boot
sudo chmod go+w /run/media/$USER/armbi_root/boot/dtb/starfive
cp \
  /run/media/$USER/armbi_root/boot/dtb/starfive/jh7110-visionfive-v2.dtb \
  /run/media/$USER/armbi_root/boot/dtb/starfive/jh7110-star64-pine64.dtb
</code></pre></div>
<p>Then we overwrite the Linux Kernel Image by our <strong>NuttX Binary Image</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## We assume that `nuttx` contains the NuttX ELF Image.
## Export the NuttX Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Delete Linux Kernel `/boot/Image`
rm /run/media/$USER/armbi_root/boot/Image

## Copy `nuttx.bin` to Linux Kernel `/boot/Image`
cp nuttx.bin /run/media/$USER/armbi_root/boot/Image
</code></pre></div>
<p>Insert the microSD Card into Star64 and power up.</p>
<p>When it boots on Star64, NuttX prints ‚Äú<strong><code>123</code></strong>‚Äù yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console">(Printed by our <strong>Boot Code</strong>)</a></p>
<p>But NuttX crashes with a <strong>RISC-V Illegal Instruction Exception</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
EPC: ffffffff804ba05c RA: 00000000402011c6 reloc adjusted

SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx2#appendix-nuttx-crash-log">(See the <strong>Complete Log</strong>)</a></p>
<p>(<strong>EPC</strong> is the Program Counter for the Exception: <strong><code>0x4020</code> <code>005C</code></strong>)</p>
<p>And Star64 (OpenSBI) shows the offending <strong>RISC-V Machine Code</strong> (in brackets)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Code:
  0313 0320 8023 0062 0313 0330 8023 0062
  (2573 f140)
resetting ...
reset not supported yet
### ERROR ### Please RESET the board ###
</code></pre></div>
<p>Why did NuttX crash at <strong><code>0x4020</code> <code>005C</code></strong>? We percolate our code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-exception.jpg" alt="Cody AI Assistant tries to explain our RISC-V Exception" /></p>
<p><em>Cody AI Assistant tries to explain our RISC-V Exception</em></p>
<h1 id="nuttx-fails-to-get-hart-id"><a href="#nuttx-fails-to-get-hart-id">7 NuttX Fails To Get Hart ID</a></h1>
<p><em>What‚Äôs at <code>0x4020</code> <code>005C</code>?</em></p>
<p><em>Why did it crash NuttX?</em></p>
<p>We look up our <strong>NuttX RISC-V Disassembly nuttx.S</strong> and see this in our Boot Code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ed09c34532ee7c51ac2da816cd6cf0adcce336e6/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L103">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/qemu_rv_head.S:95
  /* Load the Hart ID (CPU ID) */
  csrr a0, mhartid
    4020005c:	f1402573  csrr a0, mhartid
</code></pre></div>
<p>Breaking it down‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load the Hart ID (CPU ID) */
csrr a0, mhartid
</code></pre></div>
<ul>
<li>
<p><strong><code>csrr</code></strong> is the RISC-V Instruction that reads the <a href="https://five-embeddev.com/quickref/instructions.html#-csr--csr-instructions"><strong>Control and Status Register</strong></a></p>
<p>(Which contains the CPU ID)</p>
</li>
<li>
<p><strong><code>a0</code></strong> is the RISC-V Register that will be loaded with the CPU ID</p>
</li>
<li>
<p><strong><code>mhartid</code></strong> says that we‚Äôll read from the <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid"><strong>Hart ID Register</strong></a>, containing the ID of the Hardware Thread (‚ÄúHart‚Äù) that‚Äôs running our code.</p>
<p>(Equivalent to CPU ID)</p>
</li>
</ul>
<p>So the above code will load the Hart ID (or CPU ID) into Register <strong>a0</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/riscv#get-cpu-id">(As explained here)</a></p>
<p><em>But it worked perfectly on QEMU! Why did it fail?</em></p>
<p>Ah that‚Äôs because something super spicy has changed on Star64: Our Privilege Level‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nuttx2-privilege.jpg" alt="RISC-V Privilege Levels" /></p>
<h1 id="risc-v-privilege-levels"><a href="#risc-v-privilege-levels">8 RISC-V Privilege Levels</a></h1>
<p><em>What‚Äôs this Privilege Level?</em></p>
<p>RISC-V Machine Code runs at three <strong>Privilege Levels</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>M: Machine Mode</strong> (Most powerful)</p>
</li>
<li>
<p><strong>S: Supervisor Mode</strong> (Less powerful)</p>
</li>
<li>
<p><strong>U: User Mode</strong> (Least powerful)</p>
</li>
</ul>
<p>NuttX on Star64 runs in <strong>Supervisor Mode</strong>. Which doesn‚Äôt allow access to <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html"><strong>Machine-Mode CSR Registers</strong></a>. (Pic above)</p>
<p>Remember this?</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load the Hart ID (CPU ID) */
csrr a0, mhartid
</code></pre></div>
<p>The <strong>‚Äú<code>m</code>‚Äù</strong> in <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid"><strong><code>mhartid</code></strong></a> signifies that it‚Äôs a <strong>Machine-Mode Register</strong>.</p>
<p>That‚Äôs why NuttX fails to read the Hart ID!</p>
<p><em>What runs in Machine Mode?</em></p>
<p><a href="https://lupyuen.github.io/articles/linux#opensbi-supervisor-binary-interface"><strong>OpenSBI (Supervisor Binary Interface)</strong></a> is the first thing that boots on Star64.</p>
<p>It runs in <strong>Machine Mode</strong> and starts the U-Boot Bootloader.</p>
<p><a href="https://lupyuen.github.io/articles/linux#opensbi-supervisor-binary-interface">(More about <strong>OpenSBI</strong>)</a></p>
<p><em>What about U-Boot Bootloader?</em></p>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a> runs in <strong>Supervisor Mode</strong>. And starts NuttX, also in Supervisor Mode.</p>
<p>Thus <strong>OpenSBI is the only thing</strong> that runs in Machine Mode. And can access the Machine-Mode Registers. (Pic above)</p>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64">(More about <strong>U-Boot</strong>)</a></p>
<p><em>QEMU doesn‚Äôt have this problem?</em></p>
<p>Because QEMU runs NuttX in (super-powerful) <strong>Machine Mode</strong>!</p>
<p><img src="https://lupyuen.github.io/images/nuttx2-privilege2.jpg" alt="NuttX QEMU runs in Machine Mode" /></p>
<p>NuttX needs to fetch the Hart ID with a different recipe‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-opensbi.jpg" alt="OpenSBI starts U-Boot Bootloader on Star64" /></p>
<p><a href="https://lupyuen.github.io/articles/linux#opensbi-supervisor-binary-interface"><em>OpenSBI starts U-Boot Bootloader on Star64</em></a></p>
<h1 id="downgrade-nuttx-to-supervisor-mode"><a href="#downgrade-nuttx-to-supervisor-mode">9 Downgrade NuttX to Supervisor Mode</a></h1>
<p><em>OpenSBI runs in Machine Mode and reads the Hart ID (CPU ID)‚Ä¶</em></p>
<p><em>How will NuttX get the Hart ID from OpenSBI?</em></p>
<p>Thankfully OpenSBI will pass the Hart ID to NuttX through <a href="https://lupyuen.github.io/articles/nuttx2#appendix-hart-id-from-opensbi"><strong>Register A0</strong></a>.</p>
<p>So this (overly-powerful) line in our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ed09c34532ee7c51ac2da816cd6cf0adcce336e6/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L103"><strong>NuttX Boot Code</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load the Hart ID (CPU ID) */
csrr a0, mhartid
</code></pre></div>
<p>Gets demoted to this: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L104">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* We assume that OpenSBI has passed Hart ID (value 1) in Register A0. */
/* But NuttX expects Hart ID to start at 0, so we subtract 1. */
addi a0, a0, -1

/* Print the Hart ID */
addi t1, a0, 0x30
/* Store byte from Register t1 to UART Base Address, Offset 0 */
sb   t1, 0(t0)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx2#appendix-hart-id-from-opensbi">(OpenSBI passes <strong>Hart ID as 1</strong>, instead of 0)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-register-immediate-instructions">(<strong><code>addi</code></strong> adds an Immediate Value to a Register)</a></p>
<p><em>What about other CSR Instructions in our NuttX Boot Code?</em></p>
<p>Easy! We change the Machine-Mode <strong><code>m</code></strong> Registers to Supervisor-Mode <strong><code>s</code></strong> Registers‚Ä¶</p>
<ul>
<li>
<p><strong>To Disable Interrupts:</strong> Change <a href="https://lupyuen.github.io/articles/riscv#disable-interrupts"><strong><code>mie</code></strong></a> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><strong><code>sie</code></strong></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Disable all interrupts (i.e. timer, external) */
csrw  sie, zero
/* Previously `mie` */
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L169-L174">(Source)</a></p>
</li>
<li>
<p><strong>To Load Trap Vector Table:</strong> Change <a href="https://lupyuen.github.io/articles/riscv#load-interrupt-vector"><strong><code>mtvec</code></strong></a> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><strong><code>stvec</code></strong></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Load address of Trap Vector Table */
csrw  stvec, t0
/* Previously `mtvec` */
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L174-L179">(Source)</a></p>
</li>
</ul>
<p>Time to taste this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nuttx2-boot.png" alt="After fixing NuttX for Supervisor Mode" /></p>
<h1 id="fix-the-nuttx-boot-code"><a href="#fix-the-nuttx-boot-code">10 Fix the NuttX Boot Code</a></h1>
<p>From the previous section, we identified these fixes to run our NuttX Boot Code in <strong>Supervisor Mode</strong>‚Ä¶</p>
<ol>
<li>
<p>Remove <strong><code>mhartid</code></strong> because OpenSBI will pass <strong>Hart ID</strong> in Register A0</p>
</li>
<li>
<p>Subtract 1 from <strong>Register A0</strong> because NuttX expects Hart ID to start with 0</p>
</li>
<li>
<p>To Disable Interrupts: Change <a href="https://lupyuen.github.io/articles/riscv#disable-interrupts"><strong><code>mie</code></strong></a> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><strong><code>sie</code></strong></a></p>
</li>
<li>
<p>To Load Trap Vector Table: Change <a href="https://lupyuen.github.io/articles/riscv#load-interrupt-vector"><strong><code>mtvec</code></strong></a> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><strong><code>stvec</code></strong></a></p>
</li>
</ol>
<p>Here‚Äôs the updated NuttX Boot Code and our analysis‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx2#appendix-nuttx-in-supervisor-mode"><strong>NuttX in Supervisor Mode</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/31/files">See the <strong>Modified Files</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64-0.0.1">See the <strong>Build Outputs</strong></a></p>
</li>
</ul>
<p><em>What happens when we run this?</em></p>
<p>When we boot the modified NuttX on Star64, we see this (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123067
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/star64-0.0.1">(Source)</a></p>
<p>Now we‚Äôre smokin‚Äô hot‚Ä¶</p>
<ul>
<li>
<p>No more <a href="https://lupyuen.github.io/articles/nuttx2#appendix-nuttx-crash-log"><strong>Crash Dump</strong></a>!</p>
</li>
<li>
<p>‚Äú<strong><code>0</code></strong>‚Äù is the Adjusted Hart ID passed by OpenSBI to NuttX</p>
<p><a href="https://lupyuen.github.io/articles/nuttx2#appendix-hart-id-from-opensbi">(From here)</a></p>
</li>
<li>
<p>‚Äú<strong><code>7</code></strong>‚Äù is the last thing that‚Äôs printed by our NuttX Boot Code‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Print `7` */
li  t0, 0x10000000
li  t1, 0x37
sb  t1, 0(t0)

/* Jump to qemu_rv_start */
jal  x1, qemu_rv_start
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L163-L199">(Source)</a></p>
</li>
<li>
<p>Which means that our <strong>NuttX Boot Code has completed</strong> execution yay!</p>
</li>
<li>
<p>But NuttX hangs in the C Function <a href="https://lupyuen.github.io/articles/riscv#jump-to-start"><strong>qemu_rv_start</strong></a></p>
</li>
</ul>
<p>Why? Stay tuned for more tantalising treats in the next article!</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>I hope this has been an Educational Experience on booting a fresh new OS for a 64-bit RISC-V SBC‚Ä¶</p>
<ul>
<li>
<p>We migrated NuttX RTOS from <strong>QEMU Emulator</strong> to Star64 JH7110</p>
</li>
<li>
<p>And printed to the <strong>Serial Console</strong> in RISC-V Assembly</p>
</li>
<li>
<p>We fooled <strong>U-Boot Bootloader</strong> into thinking we‚Äôre Linux</p>
</li>
<li>
<p>But we demoted NuttX to <strong>Supervisor Privilege Level</strong></p>
</li>
<li>
<p>Helped by <strong>OpenSBI Supervisor Interface</strong></p>
</li>
</ul>
<p>This is the first in a series of (yummy) articles on porting NuttX to Star64, please join me next time‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-star64"><strong>‚ÄúApache NuttX RTOS for Star64 JH7110‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Other Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nuttx2.md"><strong>lupyuen.github.io/src/nuttx2.md</strong></a></p>
<h1 id="appendix-hart-id-from-opensbi"><a href="#appendix-hart-id-from-opensbi">12 Appendix: Hart ID from OpenSBI</a></h1>
<p><em>NuttX can‚Äôt read the <code>mhartid</code> CSR Register in Supervisor Mode‚Ä¶</em></p>
<p><em>How to get the Hart ID from OpenSBI?</em></p>
<p>We refer to the Linux Boot Code: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S">linux/arch/riscv/kernel/head.S</a></p>
<p>(Tip: CONFIG_RISCV_M_MODE is False and CONFIG_EFI is True)</p>
<div class="example-wrap"><pre class="language-c"><code>/* Save hart ID and DTB physical address */
mv s0, a0
mv s1, a1
</code></pre></div>
<p>Here we see that U-Boot <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.adoc#function-hart-start-fid-0">(or OpenSBI)</a> will pass 2 arguments when it starts our kernel‚Ä¶</p>
<ul>
<li>
<p><strong>Register A0:</strong> Hart ID</p>
</li>
<li>
<p><strong>Register A1:</strong> RAM Address of Device Tree</p>
</li>
</ul>
<p>So we‚Äôll simply read the Hart ID from Register A0. (And ignore A1)</p>
<p><em>What are the actual values of Registers A0 and A1?</em></p>
<p>Thanks to our <a href="https://lupyuen.github.io/articles/nuttx2#appendix-nuttx-crash-log"><strong>Crash Dump</strong></a>, we know the actual values of A0 and A1!</p>
<div class="example-wrap"><pre class="language-text"><code>SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
</code></pre></div>
<p>This says that‚Ä¶</p>
<ul>
<li>
<p><strong>Hart ID</strong> is 1 (Register A0)</p>
</li>
<li>
<p><strong>RAM Address of Device Tree</strong> is <code>0x4600</code> <code>0000</code> (Register A1)</p>
</li>
</ul>
<p>Yep looks correct! But we‚Äôll subtract 1 from Register A0 because NuttX expects Hart ID to start with 0.</p>
<p><em>The Linux Boot Code looks confusing. What are CSR_IE and CSR_IP?</em></p>
<div class="example-wrap"><pre class="language-text"><code>/* Mask all interrupts */
csrw CSR_IE, zero
csrw CSR_IP, zero
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L195-L200">(Source)</a></p>
<p>That‚Äôs because the Linux Boot Code will work for Machine Mode AND Supervisor Mode! Here‚Äôs how <strong><code>CSR_IE</code></strong> and <strong><code>CSR_IP</code></strong> are mapped to the <strong><code>m</code></strong> and <strong><code>s</code></strong> CSR Registers‚Ä¶</p>
<p>(Remember: CONFIG_RISCV_M_MODE is false for NuttX)</p>
<div class="example-wrap"><pre class="language-text"><code>#ifdef CONFIG_RISCV_M_MODE
  /* Use Machine-Mode CSR Registers */
  # define CSR_IE		CSR_MIE
  # define CSR_IP		CSR_MIP
  ...
#else
  /* Use Supervisor-Mode CSR Registers */
  # define CSR_IE		CSR_SIE
  # define CSR_IP		CSR_SIP
  ...
#endif /* !CONFIG_RISCV_M_MODE */
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/csr.h#L391-L444">(Source)</a></p>
<h1 id="appendix-nuttx-in-supervisor-mode"><a href="#appendix-nuttx-in-supervisor-mode">13 Appendix: NuttX in Supervisor Mode</a></h1>
<p>Earlier we identified these fixes for the <a href="https://lupyuen.github.io/articles/nuttx2#fix-the-nuttx-boot-code"><strong>NuttX Boot Code</strong></a> to run in Supervisor Mode‚Ä¶</p>
<ol>
<li>
<p>Remove <strong><code>mhartid</code></strong> because OpenSBI will pass <strong>Hart ID</strong> in Register A0</p>
</li>
<li>
<p>Subtract 1 from <strong>Register A0</strong> because NuttX expects Hart ID to start with 0</p>
</li>
<li>
<p>To Disable Interrupts: Change <a href="https://lupyuen.github.io/articles/riscv#disable-interrupts"><strong><code>mie</code></strong></a> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><strong><code>sie</code></strong></a></p>
</li>
<li>
<p>To Load Trap Vector Table: Change <a href="https://lupyuen.github.io/articles/riscv#load-interrupt-vector"><strong><code>mtvec</code></strong></a> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><strong><code>stvec</code></strong></a></p>
</li>
</ol>
<p>Here‚Äôs the updated NuttX Boot Code for Supervisor Mode, and our analysis: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S">qemu_rv_head.S</a></p>
<p><strong>For All Hart IDs:</strong></p>
<p>We receive the Hart ID from OpenSBI, subtract one, and print it‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>real_start:
  ...
  /* Load mhartid (cpuid) */
  /* Previously: csrr a0, mhartid */

  /* We assume that OpenSBI has passed Hart ID (value 1) in Register a0. */
  /* But NuttX expects Hart ID to start at 0, so we subtract 1. */
  addi a0, a0, -1

  /* Print the Hart ID */
  addi t1, a0, 0x30
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb   t1, 0(t0)
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L104">(Source)</a></p>
<p><strong>If Hart ID is 0:</strong></p>
<p>Set Stack Pointer to the Idle Thread Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  /* Set stack pointer to the idle thread stack */
  bnez a0, 1f
  la   sp, QEMU_RV_IDLESTACK_TOP
  j    2f
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L104-L110">(Source)</a></p>
<p><strong>If Hart ID is 1, 2, 3, ‚Ä¶</strong></p>
<ul>
<li>Validate the Hart ID (Must be less than number of CPUs)</li>
<li>Compute the Stack Base Address based on <code>g_cpu_basestack</code> and Hart ID</li>
<li>Set the Stack Pointer to the computed Stack Base Address</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>1:
  /* Load the number of CPUs that the kernel supports */
#ifdef CONFIG_SMP
  li   t1, CONFIG_SMP_NCPUS
#else
  li   t1, 1
#endif

  /* If a0 (mhartid) &gt;= t1 (the number of CPUs), stop here */
  blt  a0, t1, 3f
  csrw sie, zero
  /* Previously: csrw mie, zero */
  wfi

3:
  /* To get g_cpu_basestack[mhartid], must get g_cpu_basestack first */
  la   t0, g_cpu_basestack

  /* Offset = pointer width * hart id */
#ifdef CONFIG_ARCH_RV32
  slli t1, a0, 2
#else
  slli t1, a0, 3
#endif
  add  t0, t0, t1

  /* Load idle stack base to sp */
  REGLOAD sp, 0(t0)

  /*
   * sp (stack top) = sp + idle stack size - XCPTCONTEXT_SIZE
   *
   * Note: Reserve some space used by up_initial_state since we are already
   * running and using the per CPU idle stack.
   */
  li   t0, STACK_ALIGN_UP(CONFIG_IDLETHREAD_STACKSIZE - XCPTCONTEXT_SIZE)
  add  sp, sp, t0
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L110-L164">(Source)</a></p>
<p><strong>For All Hart IDs:</strong></p>
<ul>
<li>Disable Interrupts</li>
<li>Load the Trap Vector Table</li>
<li>Jump to <a href="https://lupyuen.github.io/articles/riscv#jump-to-start"><strong>qemu_rv_start</strong></a></li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>2:
  /* Disable all interrupts (i.e. timer, external) in mie */
  csrw	sie, zero
  /* Previously: csrw	mie, zero */

  /* Don&#39;t load the Trap Vector Table, use OpenSBI for crash logging */
  /* la   t0, __trap_vec */
  /* csrw stvec, t0 */
  /* Previously: csrw mtvec, t0 */

  /* Jump to qemu_rv_start */
  jal  x1, qemu_rv_start

  /* We shouldn&#39;t return from _start */
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L163-L199">(Source)</a></p>
<p>Note that we don‚Äôt load the Trap Vector Table, because we‚Äôll use OpenSBI for Crash Logging.</p>
<p>(Like when we hit Exceptions with Machine-Mode Instructions)</p>
<h1 id="appendix-nuttx-start-address"><a href="#appendix-nuttx-start-address">14 Appendix: NuttX Start Address</a></h1>
<p>Previously we changed the NuttX Start Address in <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L56-L57"><strong>nsh64/defconfig</strong></a> and <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script#L21-L26"><strong>ld.script</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx2#start-address-of-nuttx-kernel"><strong>‚ÄúStart Address of NuttX Kernel‚Äù</strong></a></li>
</ul>
<p>Remember to change this Linker Script if building for <strong>NuttX Kernel Mode</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld-kernel64.script#L21-L51">ld-kernel64.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>MEMORY
{
  /* Previously 0x80000000 */
  kflash (rx) : ORIGIN = 0x40200000, LENGTH = 2048K   /* w/ cache */
  /* Previously 0x80200000 */
  ksram (rwx) : ORIGIN = 0x40400000, LENGTH = 2048K   /* w/ cache */
  /* Previously 0x80400000 */
  pgram (rwx) : ORIGIN = 0x40600000, LENGTH = 4096K   /* w/ cache */
}
...
SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p>Which should match the <strong>NuttX Build Configuration</strong> for Kernel Mode: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/knsh64/defconfig">knsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_ARCH_PGPOOL_PBASE=0x40600000
CONFIG_ARCH_PGPOOL_VBASE=0x40600000
// TODO: Fix CONFIG_RAM_SIZE
CONFIG_RAM_SIZE=1048576
CONFIG_RAM_START=0x40200000
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/star64-nuttx.png" alt="Boot NuttX on Star64" /></p>
<h1 id="appendix-nuttx-crash-log"><a href="#appendix-nuttx-crash-log">15 Appendix: NuttX Crash Log</a></h1>
<p>Earlier we ran NuttX for QEMU on Star64 (before fixing for Supervisor Mode)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx2#boot-nuttx-on-star64"><strong>‚ÄúBoot NuttX on Star64‚Äù</strong></a></li>
</ul>
<p>Here‚Äôs the Crash Log dumped by OpenSBI‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Retrieving file: /boot/extlinux/extlinux.conf
383 bytes read in 7 ms (52.7 KiB/s)
1:[6CArmbian
Retrieving file: /boot/uInitrd
10911538 bytes read in 466 ms (22.3 MiB/s)
Retrieving file: /boot/Image
163201 bytes read in 14 ms (11.1 MiB/s)
append: root=UUID=99f62df4-be35-475c-99ef-2ba3f74fe6b5 console=ttyS0,115200n8 console=tty0 earlycon=sbi rootflags=data=writeback stmmaceth=chain_mode:1 rw rw no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 splash plymouth.ignore-serial-consoles
Retrieving file: /boot/dtb/starfive/jh7110-star64-pine64.dtb
50235 bytes read in 14 ms (3.4 MiB/s)
## Loading init Ramdisk from Legacy Image at 46100000 ...
   Image Name:   uInitrd
   Image Type:   RISC-V Linux RAMDisk Image (gzip compressed)
   Data Size:    10911474 Bytes = 10.4 MiB
   Load Address: 00000000
   Entry Point:  00000000
   Verifying Checksum ... OK
## Flattened Device Tree blob at 46000000
   Booting using the fdt blob at 0x46000000
   Using Device Tree in place at 0000000046000000, end 000000004600f43a

Starting kernel ...

clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
EPC: ffffffff804ba05c RA: 00000000402011c6 reloc adjusted

SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
A4:  0000000000000000 A5:  0000000040200000 A6:  00000000fffd5708
A7:  0000000000000000 S2:  00000000fff47194 S3:  0000000000000003
S4:  fffffffffffffff3 S5:  00000000fffdbb50 S6:  0000000000000000
S7:  0000000000000000 S8:  00000000fff47194 S9:  0000000000000002
S10: 0000000000000000 S11: 0000000000000000 T3:  0000000000000023
T4:  000000004600b5cc T5:  000000000000ff00 T6:  000000004600b5cc

Code: 0313 0320 8023 0062 0313 0330 8023 0062 (2573 f140)


resetting ...
reset not supported yet
### ERROR ### Please RESET the board ###
</code></pre></div>
    
</body>
</html>