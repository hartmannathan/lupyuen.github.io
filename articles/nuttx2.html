<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="(Partially) Booting Apache NuttX Real-Time Operating System on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC"
    data-rh="true">
<meta name="description" 
    content="(Partially) Booting Apache NuttX Real-Time Operating System on Pine64's Star64 64-bit RISC-V Single-Board Computer, based on StarFive JH7110 SoC">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/nuttx2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS on RISC-V: Star64 JH7110 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#start-with-qemu-emulator">1 Start with QEMU Emulator</a><ul></ul></li>
<li><a href="#print-to-qemu-console">2 Print to QEMU Console</a><ul></ul></li>
<li><a href="#uart-base-address-for-star64">3 UART Base Address for Star64</a><ul></ul></li>
<li><a href="#risc-v-linux-kernel-header">4 RISC-V Linux Kernel Header</a><ul></ul></li>
<li><a href="#set-start-address-of-nuttx-kernel">5 Set Start Address of NuttX Kernel</a><ul></ul></li>
<li><a href="#boot-nuttx-on-star64">6 Boot NuttX on Star64</a><ul></ul></li>
<li><a href="#nuttx-fails-to-get-hart-id">7 NuttX Fails To Get Hart ID</a><ul></ul></li>
<li><a href="#risc-v-privilege-levels">8 RISC-V Privilege Levels</a><ul></ul></li>
<li><a href="#downgrade-nuttx-to-supervisor-mode">9 Downgrade NuttX to Supervisor Mode</a><ul></ul></li>
<li><a href="#fix-the-nuttx-boot-code">10 Fix the NuttX Boot Code</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>12 Jul 2023</em></p>
<p><img src="https://lupyuen.github.io/images/nuttx2-title.jpg" alt="Pine64 Star64 64-bit RISC-V SBC" /></p>
<p>In this article we‚Äôll boot a tiny bit of <a href="https://lupyuen.github.io/articles/riscv"><strong>Apache NuttX RTOS</strong></a> on the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> 64-bit RISC-V Single-Board Computer.</p>
<p>(Based on <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p><em>What‚Äôs NuttX?</em></p>
<p><a href="https://lupyuen.github.io/articles/riscv"><strong>Apache NuttX</strong></a> is a <strong>Real-Time Operating System (RTOS)</strong> that runs on many kinds of devices, from 8-bit to 64-bit.</p>
<p><em>NuttX supports Star64?</em></p>
<p>Nope NuttX won‚Äôt run on Star64 yet, we‚Äôll hit some interesting (and highly educational) RISC-V challenges.</p>
<p>But the things that we learn today will be super helpful for <a href="https://lupyuen.github.io/articles/riscv#jump-to-start"><strong>porting NuttX to Star64</strong></a>.</p>
<p>Please read on to find out how we‚Äôre <strong>booting a new OS</strong> (from scratch) on Star64 and JH7110, as we‚Ä¶</p>
<ul>
<li>
<p>Migrate NuttX from <strong>QEMU Emulator</strong> to Real Hardware</p>
</li>
<li>
<p>Log to the <strong>Serial Console</strong> in RISC-V Assembly</p>
</li>
<li>
<p>Trick <strong>U-Boot Bootloader</strong> into thinking we‚Äôre Linux</p>
</li>
<li>
<p>Downgrade from Machine to <strong>Supervisor Privilege Level</strong></p>
</li>
<li>
<p>With a little help from <strong>OpenSBI Supervisor Interface</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/riscv-title.png" alt="Apache NuttX RTOS on 64-bit QEMU RISC-V Emulator" /></p>
<h1 id="start-with-qemu-emulator"><a href="#start-with-qemu-emulator">1 Start with QEMU Emulator</a></h1>
<p>Earlier we successfully tested <strong>NuttX RTOS on QEMU Emulator</strong> for 64-bit RISC-V (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv"><strong>‚Äú64-bit RISC-V with Apache NuttX Real-Time Operating System‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs run this on Star64 JH7110 SBC! Starting with the <strong>NuttX Boot Code</strong> (in RISC-V Assembly)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/riscv#risc-v-boot-code-in-nuttx"><strong>‚ÄúRISC-V Boot Code in NuttX‚Äù</strong></a></li>
</ul>
<p><em>Surely we‚Äôll run into problems?</em></p>
<p>Fortunately we have a <a href="https://lupyuen.github.io/articles/linux#serial-console-on-star64"><strong>Serial Debug Console</strong></a> connected to Star64. (Pic below)</p>
<p>We‚Äôll print some <strong>Debug Logs</strong> as we run the NuttX Boot Code.</p>
<p><em>But the NuttX Boot Code is in RISC-V Assembly!</em></p>
<p>Yep we‚Äôll print the Debug Logs with our own <strong>RISC-V Assembly Code</strong>.</p>
<p>Here‚Äôs our plan‚Ä¶</p>
<ul>
<li>
<p>Check the <strong>Serial Console on QEMU Emulator</strong>, how it‚Äôs wired up</p>
</li>
<li>
<p><strong>Test our Debug Log</strong> on QEMU Emulator</p>
</li>
<li>
<p><strong>Port our Debug Log</strong> to Star64 JH7110</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Star64 SBC with Woodpecker USB Serial Adapter" /></p>
<p><a href="https://lupyuen.github.io/articles/linux"><em>Star64 with Woodpecker USB Serial Adapter</em></a></p>
<h1 id="print-to-qemu-console"><a href="#print-to-qemu-console">2 Print to QEMU Console</a></h1>
<p><em>We‚Äôre printing to the Serial Console on QEMU Emulator‚Ä¶</em></p>
<p><em>What‚Äôs the UART Controller in QEMU?</em></p>
<p>Let‚Äôs check the <strong>NuttX Build Configuration</strong> for QEMU: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>This says that QEMU emulates a <a href="https://en.wikipedia.org/wiki/16550_UART"><strong>16550 UART Controller</strong></a>.</p>
<p>And the <strong>Base Address</strong> of QEMU‚Äôs UART Controller is <strong><code>0x1000</code> <code>0000</code></strong>.</p>
<p><em>How to print to the 16550 UART Port?</em></p>
<p>Checking the <strong>NuttX Driver</strong> for 16550 UART: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1539-L1553">uart_16550.c</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>// Send one byte to 16550 UART
static void u16550_send(struct uart_dev_s *dev, int ch) {

  // Fetch the 16550 Struct
  FAR struct u16550_s *priv = (FAR struct u16550_s *)dev-&gt;priv;

  // Print to 16550 UART...
  u16550_serialout(
    priv,                 // 16550 Struct
    UART_THR_OFFSET,      // Offset of Transmit Holding Register
    (uart_datawidth_t)ch  // Character to print
  );
}
</code></pre></div>
<p>TODO</p>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L610-L624">(u16550_serialout is defined here)</a></p>
<p>To print a character, the driver writes to the UART Base Address (<code>0x1000</code> <code>0000</code>) at Offset UART_THR_OFFSET.</p>
<p>And we discover that <a href="https://github.com/apache/nuttx/blob/dc69b108b8e0547ecf6990207526c27aceaf1e2e/include/nuttx/serial/uart_16550.h#L172-L200">UART_THR_OFFSET</a> is 0:</p>
<div class="example-wrap"><pre class="language-c"><code>#define UART_THR_INCR          0 /* (DLAB =0) Transmit Holding Register */
#define UART_THR_OFFSET        (CONFIG_16550_REGINCR*UART_THR_INCR)
</code></pre></div>
<p>So we can transmit to UART Port by simply writing to <code>0x1000</code> <code>0000</code>. How convenient!</p>
<p><em>How to print to the QEMU Console?</em></p>
<p>Let‚Äôs do the printing in RISC-V Assembly Code, so that we can debug the NuttX Boot Code.</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L71-L93">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>  /* Load UART Base Address to Register t0 */
  li  t0, 0x10000000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)
</code></pre></div>
<p>This prints ‚Äú123‚Äù to the QEMU Console. Here‚Äôs the output:</p>
<div class="example-wrap"><pre class="language-text"><code>+ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic

123123123123123123112323
NuttShell (NSH) NuttX-12.0.3
nsh&gt; 
</code></pre></div>
<p>Which is correct because QEMU is running with 8 CPUs. Yay!</p>
<p><img src="https://lupyuen.github.io/images/riscv-print.png" alt="NuttX prints to QEMU Console" /></p>
<h1 id="uart-base-address-for-star64"><a href="#uart-base-address-for-star64">3 UART Base Address for Star64</a></h1>
<p>TODO</p>
<p>We‚Äôll take the UART Assembly Code from the previous section and run on Star64 / JH7110. (So we can troubleshoot the NuttX Boot Code)</p>
<p><em>Does Star64 / JH7110 use a 16550 UART Controller like QEMU?</em></p>
<p>According to the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/function_layer.html">JH7110 UART Developing Guide</a>, Star64 / JH7110 uses the 8250 UART Controller‚Ä¶</p>
<p>Which is <a href="https://en.wikipedia.org/wiki/16550_UART">compatible with QEMU‚Äôs 16550 UART Controller</a>. So our UART Assembly Code for QEMU will run on Star64!</p>
<p><em>What‚Äôs the UART Base Address for Star64 / JH7110?</em></p>
<p>Based on <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/system_memory_map.html">JH7110 System Memory Map</a>, UART0 is at <code>0x1000</code> <code>0000</code>.</p>
<p>Also from the <a href="https://doc-en.rvspace.org/VisionFive2/DG_UART/JH7110_SDK/general_uart_controller.html">JH7110 UART Device Tree</a>: UART Register Base Address is <code>0x1000</code> <code>0000</code> with range <code>0x10000</code>.</p>
<p><a href="https://doc-en.rvspace.org/JH7110/Datasheet/JH7110_DS/uart.html">(JH7110 UART Datasheet)</a></p>
<p><em>Isn‚Äôt that the same UART Base Address as QEMU?</em></p>
<p>Let‚Äôs check the UART Base Address in NuttX for QEMU. From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L10-L16">nsh64/defconfig</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x10000000
CONFIG_16550_UART0_CLOCK=3686400
CONFIG_16550_UART0_IRQ=37
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
</code></pre></div>
<p>NuttX UART Base Address is <code>0x1000</code> <code>0000</code>. The exact same UART Base Address for QEMU AND Star64!</p>
<p>So no changes needed, our UART Assembly Code will run on QEMU AND Star64 yay!</p>
<h1 id="risc-v-linux-kernel-header"><a href="#risc-v-linux-kernel-header">4 RISC-V Linux Kernel Header</a></h1>
<p>TODO</p>
<p>For U-Boot Bootloader to boot NuttX, we need to embed the RISC-V Linux Kernel Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#inside-the-kernel-image"><strong>‚ÄúInside the Kernel Image‚Äù</strong></a></li>
</ul>
<p>This is how we decode the RISC-V Linux Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#appendix-decode-the-risc-v-linux-header"><strong>‚ÄúDecode the RISC-V Linux Header‚Äù</strong></a></li>
</ul>
<p>We copy the Arm64 Linux Header from <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/arm64/src/common/arm64_head.S#L79-L118">arm64_head.S</a>‚Ä¶</p>
<p>And tweak for RISC-V Linux Header, like this: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L42-L75">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>__start:
  /* Begin Test */

  /* DO NOT MODIFY. Image Header expected by Linux bootloaders.
   *
   * This `li` instruction has no meaningful effect except that
   * its opcode forms the magic &quot;MZ&quot; signature of a PE/COFF file
   * that is required for UEFI applications.
   *
   * Some bootloaders check the magic &quot;MZ&quot; to see if the image is a valid
   * Linux image. But modifying the bootLoader is unnecessary unless we
   * need to do a customized secure boot. So we just put &quot;MZ&quot; in the
   * header to make the bootloader happy.
   */

  c.li    s4, -13              /* Magic Signature &quot;MZ&quot; (2 bytes) */
  j       real_start           /* Jump to Kernel Start (2 bytes) */
  .long   0                    /* Executable Code padded to 8 bytes */
  .quad   0x200000             /* Image load offset from start of RAM */
  /* TODO: _e_initstack - __start */
  .quad   171644               /* Effective size of kernel image, little-endian */
  .quad   0x0                  /* Kernel flags, little-endian */
  .long   0x2                  /* Version of this header */
  .long   0                    /* Reserved */
  .quad   0                    /* Reserved */
  .ascii  &quot;RISCV\x00\x00\x00&quot;  /* Magic number, &quot;RISCV&quot; (8 bytes) */
  .ascii  &quot;RSC\x05&quot;            /* Magic number 2, &quot;RSC\x05&quot; (4 bytes) */
  .long   0                    /* Reserved for PE COFF offset */

real_start:

  /* Load UART Base Address to Register t0 */
  li  t0, 0x10000000
</code></pre></div>
<p>Note that Image Load Offset must be <code>0x20</code> <code>0000</code>!</p>
<div class="example-wrap"><pre class="language-text"><code>  .quad   0x200000             /* Image load offset from start of RAM */
</code></pre></div>
<p>That‚Äôs because our kernel starts at <code>0x4020</code> <code>0000</code></p>
<p>Here‚Äôs the assembled output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>0000000040200000 &lt;__start&gt;:
  li      s4, -0xd             /* Magic Signature &quot;MZ&quot; (2 bytes) */
    40200000:	5a4d                	li	s4,-13
  j       real_start           /* Jump to Kernel Start (2 bytes) */
    40200002:	a83d                	j	40200040 &lt;real_start&gt;
    40200004:	0000                	unimp
    40200006:	0000                	unimp
    40200008:	0000                	unimp
    4020000a:	0020                	addi	s0,sp,8
    4020000c:	0000                	unimp
    4020000e:	0000                	unimp
    40200010:	9e7c                	0x9e7c
    40200012:	0002                	c.slli64	zero
	...
    40200020:	0002                	c.slli64	zero
	...
    4020002e:	0000                	unimp
    40200030:	4952                	lw	s2,20(sp)
    40200032:	00564353          	fadd.s	ft6,fa2,ft5,rmm
    40200036:	0000                	unimp
    40200038:	5352                	lw	t1,52(sp)
    4020003a:	00000543          	fmadd.s	fa0,ft0,ft0,ft0,rne
	...

0000000040200040 &lt;real_start&gt;:
</code></pre></div>
<p>Check that the lengths and offsets match the RISC-V Linux Header Format‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/star64#appendix-decode-the-risc-v-linux-header"><strong>‚ÄúDecode the RISC-V Linux Header‚Äù</strong></a></li>
</ul>
<p>And our RISC-V Boot Code tested OK with QEMU.</p>
<h1 id="set-start-address-of-nuttx-kernel"><a href="#set-start-address-of-nuttx-kernel">5 Set Start Address of NuttX Kernel</a></h1>
<p>TODO</p>
<p>Earlier we saw that Star64‚Äôs U-Boot Bootloader will load Linux Kernels into RAM at Address <code>0x4020</code> <code>0000</code>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64">‚ÄúArmbian Image for Star64‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/star64#yocto-image-for-star64">‚ÄúYocto Image for Star64‚Äù</a></p>
</li>
</ul>
<p>To boot NuttX on Star64, let‚Äôs set the Start Address of the NuttX Kernel to <code>0x4020</code> <code>0000</code>.</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig#L56-L57">nsh64/defconfig</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_SIZE=33554432
CONFIG_RAM_START=0x80000000
</code></pre></div>
<p>We changed the above NuttX Build Config to <code>0x40200000</code></p>
<p>We also updated the Linker Script: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script#L21-L26">ld.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p>Remember to change this if building for NuttX Kernel Mode: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/scripts/ld-kernel64.script#L21-L51">ld-kernel64.script</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>MEMORY
{
    /* Previously 0x80000000 */
    kflash (rx) : ORIGIN = 0x40200000, LENGTH = 2048K   /* w/ cache */
    /* Previously 0x80200000 */
    ksram (rwx) : ORIGIN = 0x40400000, LENGTH = 2048K   /* w/ cache */
    /* Previously 0x80400000 */
    pgram (rwx) : ORIGIN = 0x40600000, LENGTH = 4096K   /* w/ cache */
}
...
SECTIONS
{
  /* Previously 0x80000000 */
  . = 0x40200000;
  .text :
</code></pre></div>
<p>Which should match <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/boards/risc-v/qemu-rv/rv-virt/configs/knsh64/defconfig">knsh64/defconfig</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_ARCH_PGPOOL_PBASE=0x40600000
CONFIG_ARCH_PGPOOL_VBASE=0x40600000
// TODO: Fix CONFIG_RAM_SIZE
CONFIG_RAM_SIZE=1048576
CONFIG_RAM_START=0x40200000
</code></pre></div>
<p>RISC-V Disassembly of NuttX Kernel shows that the Start Address is correct‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>0000000040200000 &lt;__start&gt;:
  li      s4, -0xd             /* Magic Signature &quot;MZ&quot; (2 bytes) */
    40200000:	5a4d                	li	s4,-13
  j       real_start           /* Jump to Kernel Start (2 bytes) */
    40200002:	a83d                	j	40200040 &lt;real_start&gt;
</code></pre></div>
<p>We‚Äôre ready to boot NuttX on Star64!</p>
<h1 id="boot-nuttx-on-star64"><a href="#boot-nuttx-on-star64">6 Boot NuttX on Star64</a></h1>
<p>TODO</p>
<p>Let‚Äôs boot NuttX on Star64! We compile <a href="https://lupyuen.github.io/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu">NuttX for 64-bit RISC-V QEMU</a> with these tweaks‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#nuttx-prints-to-qemu-console">‚ÄúNuttX prints to QEMU Console‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#uart-base-address-for-star64">‚ÄúUART Base Address for Star64‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#risc-v-linux-kernel-header">‚ÄúRISC-V Linux Kernel Header‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#set-start-address-of-nuttx-kernel">‚ÄúSet Start Address of NuttX Kernel‚Äù</a></p>
</li>
</ul>
<p>For the microSD Image, we pick this <a href="https://www.armbian.com/star64/"><strong>Armbian Image for Star64</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/armbianro/os/releases/download/23.8.0-trunk.56/Armbian_23.8.0-trunk.56_Star64_lunar_edge_5.15.0_minimal.img.xz"><strong>Armbian 23.8 Lunar for Star64 (Minimal)</strong></a></li>
</ul>
<p>Write the Armbian Image to a microSD Card with Balena Etcher.</p>
<p>We fix the <a href="https://lupyuen.github.io/articles/star64#armbian-image-for-star64">Missing Device Tree</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Fix the Missing Device Tree
sudo chmod go+w /run/media/$USER/armbi_root/boot
sudo chmod go+w /run/media/$USER/armbi_root/boot/dtb/starfive
cp \
  /run/media/$USER/armbi_root/boot/dtb/starfive/jh7110-visionfive-v2.dtb \
  /run/media/$USER/armbi_root/boot/dtb/starfive/jh7110-star64-pine64.dtb
</code></pre></div>
<p>Then we delete the sym-link <code>/boot/Image</code> and copy the NuttX Binary Image <code>nuttx.bin</code> to <code>/boot/Image</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## We assume that `nuttx` contains the NuttX ELF Image.
## Export the NuttX Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Delete Armbian Kernel `/boot/Image`
rm /run/media/$USER/armbi_root/boot/Image

## Copy `nuttx.bin` to Armbian Kernel `/boot/Image`
cp nuttx.bin /run/media/$USER/armbi_root/boot/Image
</code></pre></div>
<p>Insert the microSD Card into Star64 and power up.</p>
<p>NuttX boots with <code>123</code> yay! <a href="https://github.com/lupyuen/nuttx-star64#nuttx-prints-to-qemu-console">(Which is printed by our Boot Code)</a></p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123
Unhandled exception: Illegal instruction
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/star64-nuttx.png" alt="Boot NuttX on Star64" /></p>
<p>Here‚Äôs the complete log‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Retrieving file: /boot/extlinux/extlinux.conf
383 bytes read in 7 ms (52.7 KiB/s)
1:[6CArmbian
Retrieving file: /boot/uInitrd
10911538 bytes read in 466 ms (22.3 MiB/s)
Retrieving file: /boot/Image
163201 bytes read in 14 ms (11.1 MiB/s)
append: root=UUID=99f62df4-be35-475c-99ef-2ba3f74fe6b5 console=ttyS0,115200n8 console=tty0 earlycon=sbi rootflags=data=writeback stmmaceth=chain_mode:1 rw rw no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 splash plymouth.ignore-serial-consoles
Retrieving file: /boot/dtb/starfive/jh7110-star64-pine64.dtb
50235 bytes read in 14 ms (3.4 MiB/s)
## Loading init Ramdisk from Legacy Image at 46100000 ...
   Image Name:   uInitrd
   Image Type:   RISC-V Linux RAMDisk Image (gzip compressed)
   Data Size:    10911474 Bytes = 10.4 MiB
   Load Address: 00000000
   Entry Point:  00000000
   Verifying Checksum ... OK
## Flattened Device Tree blob at 46000000
   Booting using the fdt blob at 0x46000000
   Using Device Tree in place at 0000000046000000, end 000000004600f43a

Starting kernel ...

clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
EPC: ffffffff804ba05c RA: 00000000402011c6 reloc adjusted

SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
A4:  0000000000000000 A5:  0000000040200000 A6:  00000000fffd5708
A7:  0000000000000000 S2:  00000000fff47194 S3:  0000000000000003
S4:  fffffffffffffff3 S5:  00000000fffdbb50 S6:  0000000000000000
S7:  0000000000000000 S8:  00000000fff47194 S9:  0000000000000002
S10: 0000000000000000 S11: 0000000000000000 T3:  0000000000000023
T4:  000000004600b5cc T5:  000000000000ff00 T6:  000000004600b5cc

Code: 0313 0320 8023 0062 0313 0330 8023 0062 (2573 f140)


resetting ...
reset not supported yet
### ERROR ### Please RESET the board ###
</code></pre></div>
<p>Why does NuttX crash at <code>4020005c</code>? See the next section‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/star64-exception.jpg" alt="Cody AI Assistant tries to explain our RISC-V Exception" /></p>
<p><em>Cody AI Assistant tries to explain our RISC-V Exception</em></p>
<h1 id="nuttx-fails-to-get-hart-id"><a href="#nuttx-fails-to-get-hart-id">7 NuttX Fails To Get Hart ID</a></h1>
<p>TODO</p>
<p>Earlier we saw NuttX crashing when booting on Star64‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123
Unhandled exception: Illegal instruction
EPC: 000000004020005c RA: 00000000fff471c6 TVAL: 00000000f1402573
</code></pre></div>
<p><em>Why did NuttX crash at <code>4020005c</code>?</em></p>
<p>Here‚Äôs our RISC-V Boot Code‚Ä¶</p>
<p>From <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/ed09c34532ee7c51ac2da816cd6cf0adcce336e6/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L92-L103">qemu_rv_head.S</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx/arch/risc-v/src/chip/qemu_rv_head.S:95
  /* Load mhartid (cpuid) */
  csrr a0, mhartid
    4020005c:	f1402573  csrr a0, mhartid
</code></pre></div>
<p>NuttX tries loads the CPU ID or Hardware Thread ‚ÄúHart‚Äù ID from the RISC-V Control and Status Register (CSR). <a href="https://lupyuen.github.io/articles/riscv#get-cpu-id">(Explained here)</a></p>
<p>But it fails! Because we don‚Äôt have sufficient privilege to access the Hart ID.</p>
<h1 id="risc-v-privilege-levels"><a href="#risc-v-privilege-levels">8 RISC-V Privilege Levels</a></h1>
<p>TODO</p>
<p>RISC-V runs at 3 Privilege Levels‚Ä¶</p>
<ul>
<li>
<p>M: Machine Level (Most powerful)</p>
</li>
<li>
<p>S: Supervisor Level (Less powerful)</p>
</li>
<li>
<p>U: User Level (Least powerful)</p>
</li>
</ul>
<p>NuttX runs at Supervisor Level, which <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html">doesn‚Äôt allow access to Machine-Level CSR Registers</a>.  (Including <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid">Hart ID</a>)</p>
<p>(The <code>m</code> in <code>mhartid</code> signifies that it‚Äôs a Machine-Level Register)</p>
<p><em>What runs at Machine Level?</em></p>
<p><a href="https://www.thegoodpenguin.co.uk/blog/an-overview-of-opensbi/">OpenSBI</a> (Supervisor Binary Interface) is the first thing that boots on Star64. It runs at Machine Level and starts the U-Boot Bootloader.</p>
<p><a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.pdf">(See the RISC-V SBI Spec)</a></p>
<p><em>What about U-Boot Bootloader?</em></p>
<p>U-Boot Bootloader runs at Supervisor Level. And starts NuttX, also at Supervisor Level.</p>
<p>So OpenSBI is the only thing that runs at Machine Level. And can access the Machine-Level Registers.</p>
<h1 id="downgrade-nuttx-to-supervisor-mode"><a href="#downgrade-nuttx-to-supervisor-mode">9 Downgrade NuttX to Supervisor Mode</a></h1>
<p>TODO</p>
<p><em>How to get the Hart ID from OpenSBI?</em></p>
<p>Let‚Äôs refer to the Linux Boot Code: <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S">linux/arch/riscv/kernel/head.S</a></p>
<p>(Tip: <code>CONFIG_RISCV_M_MODE</code> is False and <code>CONFIG_EFI</code> is True)</p>
<p>From <a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L292-L295">linux/blob/master/arch/riscv/kernel/head.S</a>:</p>
<div class="example-wrap"><pre class="language-c"><code>/* Save hart ID and DTB physical address */
mv s0, a0
mv s1, a1
</code></pre></div>
<p>Here we see that U-Boot <a href="https://github.com/riscv-non-isa/riscv-sbi-doc/blob/master/riscv-sbi.adoc#function-hart-start-fid-0">(or OpenSBI)</a> will pass 2 arguments when it starts our kernel‚Ä¶</p>
<ul>
<li>
<p>Register A0: Hart ID</p>
</li>
<li>
<p>Register A1: RAM Address of Device Tree</p>
</li>
</ul>
<p>So we‚Äôll simply read the Hart ID from Register A0. (And ignore A1)</p>
<p>We‚Äôll remove <code>csrr a0, mhartid</code>.</p>
<p><em>What are the actual values of Registers A0 and A1?</em></p>
<p>Thanks to our <a href="https://github.com/lupyuen/nuttx-star64#boot-nuttx-on-star64">earlier Crash Dump</a>, we know the actual values of A0 and A1!</p>
<div class="example-wrap"><pre class="language-text"><code>SP:  00000000ff733630 GP:  00000000ff735e00 TP:  0000000000000001
T0:  0000000010000000 T1:  0000000000000033 T2:  7869662e6b637366
S0:  0000000000000400 S1:  00000000ffff1428 A0:  0000000000000001
A1:  0000000046000000 A2:  0000000000000600 A3:  0000000000004000
</code></pre></div>
<p>This says that‚Ä¶</p>
<ul>
<li>
<p>Hart ID is 1 (Register A0)</p>
</li>
<li>
<p>RAM Address of Device Tree is <code>0x4600</code> <code>0000</code> (Register A1)</p>
</li>
</ul>
<p>Yep looks correct! But we‚Äôll subtract 1 from Register A0 because NuttX expects Hart ID to start with 0.</p>
<p><em>What about other CSR Instructions in our NuttX Boot Code?</em></p>
<p>We change the Machine-Level <code>m</code> Registers to Supervisor-Level <code>s</code> Registers.</p>
<p>To Disable Interrupts: Change <code>mie</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><code>sie</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Disable all interrupts (i.e. timer, external) in mie */
csrw  mie, zero
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#disable-interrupts">(Source)</a></p>
<p>To Load Interrupt Vector Table: Change <code>mtvec</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><code>stvec</code></a></p>
<div class="example-wrap"><pre class="language-text"><code>/* Load address of Interrupt Vector Table */
csrw  mtvec, t0
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/riscv#load-interrupt-vector">(Source)</a></p>
<p><em>The Linux Boot Code looks confusing. What are CSR_IE and CSR_IP?</em></p>
<div class="example-wrap"><pre class="language-text"><code>/* Mask all interrupts */
csrw CSR_IE, zero
csrw CSR_IP, zero
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/kernel/head.S#L195-L200">(Source)</a></p>
<p>That‚Äôs because the Linux Boot Code will work for Machine Level AND Supervisor Level! Here‚Äôs how <code>CSR_IE</code> and <code>CSR_IP</code> are mapped to the <code>m</code> and <code>s</code> CSR Registers‚Ä¶</p>
<p>(Remember: <code>CONFIG_RISCV_M_MODE</code> is false for NuttX)</p>
<div class="example-wrap"><pre class="language-text"><code>#ifdef CONFIG_RISCV_M_MODE
  /* Use Machine-Level CSR Registers */
  # define CSR_IE		CSR_MIE
  # define CSR_IP		CSR_MIP
  ...
#else
  /* Use Supervisor-Level CSR Registers */
  # define CSR_IE		CSR_SIE
  # define CSR_IP		CSR_SIP
  ...
#endif /* !CONFIG_RISCV_M_MODE */
</code></pre></div>
<p><a href="https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/csr.h#L391-L444">(Source)</a></p>
<p>Let‚Äôs fix the Boot Code‚Ä¶</p>
<h1 id="fix-the-nuttx-boot-code"><a href="#fix-the-nuttx-boot-code">10 Fix the NuttX Boot Code</a></h1>
<p>TODO</p>
<p>From the previous section, we identified these fixes for the NuttX Boot Code‚Ä¶</p>
<ol>
<li>
<p>Remove <code>csrr a0, mhartid</code> because OpenSBI will pass Hart ID in Register A0. Subtract 1 from Register A0 because NuttX expects Hart ID to start with 0.</p>
</li>
<li>
<p>To Disable Interrupts: Change <code>mie</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><code>sie</code></a></p>
</li>
<li>
<p>To Load Interrupt Vector Table: Change <code>mtvec</code> to <a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><code>stvec</code></a></p>
</li>
</ol>
<p>Here‚Äôs the updated Boot Code, and our analysis: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/star64/arch/risc-v/src/qemu-rv/qemu_rv_head.S">qemu_rv_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>real_start:
  ...
  /* Load mhartid (cpuid) */
  /* Previously: csrr a0, mhartid */

  /* We assume that OpenSBI has passed Hart ID (value 1) in Register a0. */
  /* But NuttX expects Hart ID to start at 0, so we subtract 1. */
  addi a0, a0, -1

  /* Print the Hart ID */
  addi t1, a0, 0x30
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb   t1, 0(t0)
</code></pre></div>
<p><strong>If Hart ID is 0:</strong></p>
<ul>
<li>Set Stack Pointer to the Idle Thread Stack</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>  /* Set stack pointer to the idle thread stack */
  bnez a0, 1f
  la   sp, QEMU_RV_IDLESTACK_TOP
  j    2f
</code></pre></div>
<p><strong>If Hart ID is 1, 2, 3, ‚Ä¶</strong></p>
<ul>
<li>Validate the Hart ID (Must be less than number of CPUs)</li>
<li>Compute the Stack Base Address based on <code>g_cpu_basestack</code> and Hart ID</li>
<li>Set the Stack Pointer to the computed Stack Base Address</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>1:
  /* Load the number of CPUs that the kernel supports */
#ifdef CONFIG_SMP
  li   t1, CONFIG_SMP_NCPUS
#else
  li   t1, 1
#endif

  /* If a0 (mhartid) &gt;= t1 (the number of CPUs), stop here */
  blt  a0, t1, 3f
  csrw sie, zero
  /* Previously: csrw mie, zero */
  wfi

3:
  /* To get g_cpu_basestack[mhartid], must get g_cpu_basestack first */
  la   t0, g_cpu_basestack

  /* Offset = pointer width * hart id */
#ifdef CONFIG_ARCH_RV32
  slli t1, a0, 2
#else
  slli t1, a0, 3
#endif
  add  t0, t0, t1

  /* Load idle stack base to sp */
  REGLOAD sp, 0(t0)

  /*
   * sp (stack top) = sp + idle stack size - XCPTCONTEXT_SIZE
   *
   * Note: Reserve some space used by up_initial_state since we are already
   * running and using the per CPU idle stack.
   */
  li   t0, STACK_ALIGN_UP(CONFIG_IDLETHREAD_STACKSIZE - XCPTCONTEXT_SIZE)
  add  sp, sp, t0
</code></pre></div>
<p><strong>For All Hart IDs:</strong></p>
<ul>
<li>Disable Interrupts</li>
<li>Load the Interrupt Vector Table</li>
<li>Jump to <code>qemu_rv_start</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="number">2</span>:
  <span class="comment">/* Disable all interrupts (i.e. timer, external) in mie */
  </span>csrw	sie, zero
  <span class="comment">/* Previously: csrw	mie, zero */

  /* Don&#39;t load the Interrupt Vector Table, use OpenSBI for crash logging */
  /* la   t0, __trap_vec */
  /* csrw stvec, t0 */
  /* Previously: csrw mtvec, t0 */

  /* Jump to qemu_rv_start */
  </span>jal  x1, qemu_rv_start

  <span class="comment">/* We shouldn&#39;t return from _start */</span></code></pre></div>
<p>Note that we don‚Äôt load the Interrupt Vector Table, because we‚Äôll use OpenSBI for crash logging. (Like when we hit M-Mode Instructions)</p>
<p><em>What happens when we run this?</em></p>
<p>Hart ID is now 0, which is correct‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123067
</code></pre></div>
<p>But <code>qemu_rv_start</code> hangs. Why?</p>
<div class="example-wrap"><pre class="language-text"><code>  /* Print `7` */
  li  t0, 0x10000000
  li  t1, 0x37
  sb  t1, 0(t0)

  /* Jump to qemu_rv_start */
  jal  x1, qemu_rv_start
</code></pre></div>
<p>TODO: Trace <code>qemu_rv_start</code></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO: This is the first in a series of articles on porting NuttX to Star64.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nuttx2.md"><strong>lupyuen.github.io/src/nuttx2.md</strong></a></p>

    
</body>
</html>