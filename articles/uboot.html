<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>PinePhone boots Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="PinePhone boots Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content="How we ported Apache NuttX RTOS to PinePhone... And what's inside the U-Boot Bootloader"
    data-rh="true">
<meta name="description" 
    content="How we ported Apache NuttX RTOS to PinePhone... And what's inside the U-Boot Bootloader">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/uboot-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">PinePhone boots Apache NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#allwinner-a64-soc">1 Allwinner A64 SoC</a><ul></ul></li>
<li><a href="#usb-serial-debug-cable">2 USB Serial Debug Cable</a><ul></ul></li>
<li><a href="#pinephone-jumpdrive">3 PinePhone Jumpdrive</a><ul></ul></li>
<li><a href="#u-boot-bootloader">4 U-Boot Bootloader</a><ul></ul></li>
<li><a href="#boot-log">5 Boot Log</a><ul></ul></li>
<li><a href="#boot-script">6 Boot Script</a><ul></ul></li>
<li><a href="#boot-address">7 Boot Address</a><ul></ul></li>
<li><a href="#linux-kernel-header">8 Linux Kernel Header</a><ul></ul></li>
<li><a href="#nuttx-header">9 NuttX Header</a><ul></ul></li>
<li><a href="#uart-output">10 UART Output</a><ul></ul></li>
<li><a href="#nuttx-uart-macros">11 NuttX UART Macros</a><ul></ul></li>
<li><a href="#pinephone-boots-nuttx">12 PinePhone Boots NuttX</a><ul></ul></li>
<li><a href="#upcoming-fixes">13 Upcoming Fixes</a><ul></ul></li>
<li><a href="#nuttx-source-code">14 NuttX Source Code</a><ul></ul></li>
<li><a href="#whats-next">15 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">16 Notes</a><ul></ul></li>
<li><a href="#appendix-pinephone-is-now-supported-by-apache-nuttx-rtos">17 Appendix: PinePhone is now supported by Apache NuttX RTOS</a><ul>
<li><a href="#upcoming-features">17.1 Upcoming Features</a><ul></ul></li>
<li><a href="#upcoming-fixes-1">17.2 Upcoming Fixes</a><ul></ul></li>
<li><a href="#porting-notes">17.3 Porting Notes</a><ul></ul></li></ul></li>
<li><a href="#appendix-build-nuttx-for-pinephone">18 Appendix: Build NuttX for PinePhone</a><ul>
<li><a href="#download-nuttx">18.1 Download NuttX</a><ul></ul></li>
<li><a href="#install-prerequisites">18.2 Install Prerequisites</a><ul></ul></li>
<li><a href="#download-toolchain">18.3 Download Toolchain</a><ul></ul></li>
<li><a href="#build-nuttx">18.4 Build NuttX</a><ul></ul></li>
<li><a href="#output-files">18.5 Output Files</a><ul></ul></li></ul></li>
<li><a href="#appendix-allwinner-a64-uart">19 Appendix: Allwinner A64 UART</a><ul>
<li><a href="#wait-for-uart-ready">19.1 Wait for UART Ready</a><ul></ul></li>
<li><a href="#initialise-uart">19.2 Initialise UART</a><ul></ul></li>
<li><a href="#uart-driver">19.3 UART Driver</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>28 Aug 2022</em></p>
<p><img src="https://lupyuen.github.io/images/uboot-title.png" alt="Apache NuttX RTOS booting on Pine64 PinePhone" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#nuttx-boot-log"><em>Apache NuttX RTOS booting on Pine64 PinePhone</em></a></p>
<p><strong>UPDATE:</strong> PinePhone is now officially supported by Apache NuttX RTOS <a href="https://lupyuen.github.io/articles/what">(See this)</a></p>
<p>Suppose we‚Äôre creating our own <strong>Operating System</strong> (non-Linux) for <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs the File Format?</p>
</li>
<li>
<p>Where in RAM should it run?</p>
</li>
<li>
<p>Can we make a microSD that will boot our OS?</p>
</li>
<li>
<p>What happens when PinePhone powers on?</p>
</li>
</ul>
<p>This article explains how we ported <a href="https://lupyuen.github.io/articles/arm"><strong>Apache NuttX RTOS</strong></a> to PinePhone. And we‚Äôll answer the questions along the way!</p>
<p>Let‚Äôs walk through the steps to create our own <strong>PinePhone Operating System</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/uboot-a64.jpg" alt="Allwinner A64 SoC User Manual" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Allwinner A64 SoC User Manual</em></a></p>
<h1 id="allwinner-a64-soc"><a href="#allwinner-a64-soc">1 Allwinner A64 SoC</a></h1>
<p><em>What‚Äôs inside PinePhone?</em></p>
<p>At the heart of PinePhone is the <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> (System-on-a-Chip) with 4 Cores of 64-bit <strong>Arm Cortex-A53</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://wiki.pine64.org/index.php/PinePhone"><strong>PinePhone Wiki</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 Info</strong></a></p>
</li>
<li>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a></p>
</li>
</ul>
<p>The A64 SoC in PinePhone comes with <strong>2GB RAM</strong> (or 3GB RAM via a mainboard upgrade)‚Ä¶</p>
<ul>
<li><a href="https://linux-sunxi.org/A64/Memory_map"><strong>Allwinner A64 Memory Map</strong></a></li>
</ul>
<p>A64‚Äôs <strong>Memory Map</strong> says that the RAM starts at address <strong><code>0x4000</code> <code>0000</code></strong>.</p>
<p><em>So our OS will run at <code>0x4000</code> <code>0000</code>?</em></p>
<p>Not quite! Our OS will actually be loaded at <strong><code>0x4008</code> <code>0000</code></strong></p>
<p>We‚Äôll see why in a while, but first we talk about a Very Important Cable‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-uart2.jpg" alt="PinePhone connected to USB Serial Debug Cable" /></p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><em>PinePhone connected to USB Serial Debug Cable</em></a></p>
<h1 id="usb-serial-debug-cable"><a href="#usb-serial-debug-cable">2 USB Serial Debug Cable</a></h1>
<p><em>Can we watch what happens when PinePhone boots?</em></p>
<p>There‚Äôs a magical cable for that: <strong>USB Serial Debug Cable</strong> (pic above)‚Ä¶</p>
<ul>
<li><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><strong>PinePhone Serial Debug Cable</strong></a></li>
</ul>
<p>It connects to PinePhone‚Äôs <strong>Headphone Port</strong> (pic below) and exposes PinePhone‚Äôs hidden <strong>UART Port.</strong> Genius!</p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Privacy_switch_configuration">(Remember to flip the Headphone Switch to OFF)</a></p>
<p>I highly recommend the USB Serial Debug Cable for <strong>PinePhone Hacking</strong>.</p>
<p><em>What secrets will the Debug Cable reveal?</em></p>
<p>We‚Äôll find out shortly! First we need to prep our microSD Card for hacking‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-uart.jpg" alt="PinePhone UART Port in disguise" /></p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><em>PinePhone UART Port in disguise</em></a></p>
<h1 id="pinephone-jumpdrive"><a href="#pinephone-jumpdrive">3 PinePhone Jumpdrive</a></h1>
<p>Let‚Äôs watch and learn how a <strong>Linux Kernel</strong> boots on PinePhone.</p>
<p>We pick a small, simple Linux Kernel: <strong>PinePhone Jumpdrive</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/dreemurrs-embedded/Jumpdrive"><strong>dreemurrs-embedded/Jumpdrive</strong></a></li>
</ul>
<p>And prepare a <strong>microSD Card</strong> for Jumpdrive‚Ä¶</p>
<ol>
<li>
<p>Download <a href="https://github.com/dreemurrs-embedded/Jumpdrive/releases/download/0.8/pine64-pinephone.img.xz"><strong><code>pine64-pinephone.img.xz</code></strong></a></p>
</li>
<li>
<p>Write the downloaded file to a microSD Card with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a></p>
</li>
<li>
<p>Insert the microSD Card into PinePhone</p>
</li>
</ol>
<p>Don‚Äôt power up PinePhone yet! We need to talk about PinePhone‚Äôs Bootloader‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-jumpdrive.png" alt="PinePhone Jumpdrive on microSD" /></p>
<p><a href="https://github.com/dreemurrs-embedded/Jumpdrive"><em>PinePhone Jumpdrive on microSD</em></a></p>
<h1 id="u-boot-bootloader"><a href="#u-boot-bootloader">4 U-Boot Bootloader</a></h1>
<p><em>What happens when we power up PinePhone?</em></p>
<p>The <a href="https://en.wikipedia.org/wiki/Das_U-Boot"><strong>U-Boot Bootloader</strong></a> runs, searching for a Linux Kernel to boot (on microSD or eMMC)‚Ä¶</p>
<ul>
<li>
<p><a href="https://linux-sunxi.org/BROM#A64"><strong>Allwinner A64 Boot ROM</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/U-Boot"><strong>Allwinner A64 U-Boot</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/BROM#U-Boot_SPL_limitations"><strong>Allwinner A64 U-Boot SPL</strong></a></p>
<p>(Secondary Program Loader)</p>
</li>
<li>
<p><a href="https://linux-sunxi.org/Bootable_SD_card#SD_Card_Layout"><strong>SD Card Layout</strong></a></p>
</li>
</ul>
<p><em>Whoa! These docs look so superdry‚Ä¶</em></p>
<p>There‚Äôs an easier way to grok U-Boot. Let‚Äôs watch PinePhone boot Jumpdrive!</p>
<p><img src="https://lupyuen.github.io/images/uboot-uboot.png" alt="U-Boot Bootloader on PinePhone" /></p>
<p><a href="https://lupyuen.github.io/articles/arm#appendix-pinephone-uart-log"><em>U-Boot Bootloader on PinePhone</em></a></p>
<h1 id="boot-log"><a href="#boot-log">5 Boot Log</a></h1>
<p>Now we‚Äôre ready to watch what happens when PinePhone boots‚Ä¶</p>
<ol>
<li>
<p>Insert the <strong>Jumpdrive microSD</strong> into PinePhone</p>
</li>
<li>
<p>Flip PinePhone‚Äôs <a href="https://wiki.pine64.org/index.php/PinePhone#Privacy_switch_configuration"><strong>Headphone Switch</strong></a> to OFF</p>
</li>
<li>
<p>Connect our computer to PinePhone via the <a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><strong>USB Serial Debug Cable</strong></a></p>
</li>
<li>
<p>Launch a <strong>Serial Terminal</strong> (115.2 kbps) on our computer and connect to PinePhone‚Ä¶</p>
<p>For Linux:</p>
<div class="example-wrap"><pre class="language-bash"><code>## Change ttyUSB0 to the USB Serial Device
sudo screen /dev/ttyUSB0 115200
</code></pre></div>
<p>For macOS: Use <strong><code>screen</code></strong> or <a href="https://freeware.the-meiers.org/"><strong>CoolTerm</strong></a></p>
<p>For Windows: Use <a href="https://www.putty.org/"><strong>PuTTY</strong></a></p>
</li>
<li>
<p>Power up PinePhone</p>
</li>
</ol>
<p>This is the <strong>Boot Log</strong> that we‚Äôll see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ sudo screen /dev/ttyUSB0 115200

DRAM: 2048 MiB
Trying to boot from MMC1
NOTICE:  BL31: v2.2(release):v2.2-904-gf9ea3a629
NOTICE:  BL31: Built : 15:32:12, Apr  9 2020
NOTICE:  BL31: Detected Allwinner A64/H64/R18 SoC (1689)
NOTICE:  BL31: Found U-Boot DTB at 0x4064410, model: PinePhone
NOTICE:  PSCI: System suspend is unavailable
</code></pre></div>
<p><strong>BL31</strong> refers to <a href="https://chromium.googlesource.com/chromiumos/third_party/arm-trusted-firmware/+/v1.2-rc0/docs/firmware-design.md"><strong>Arm Trusted Firmware</strong></a>, the very first thing that runs on PinePhone.</p>
<p>BL31 finds the <strong>Device Tree</strong> (DTB) for the U-Boot Bootloader, and starts U-Boot‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2020.07 (Nov 08 2020 - 00:15:12 +0100)
DRAM:  2 GiB
MMC:   Device &#39;mmc@1c11000&#39;: seq 1 is in use by &#39;mmc@1c10000&#39;
mmc@1c0f000: 0, mmc@1c10000: 2, mmc@1c11000: 1
Loading Environment from FAT... *** Warning - bad CRC, using default environment

starting USB...
No working controllers found
Hit any key to stop autoboot:  0 
</code></pre></div>
<p>Yep U-Boot <strong>can be stopped!</strong> Later we‚Äôll hit some keys to stop U-Boot and run some commands.</p>
<p>But for now we let U-Boot do its booting thing‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>switch to partitions #0, OK
mmc0 is current device
Scanning mmc 0:1...
Found U-Boot script /boot.scr
653 bytes read in 3 ms (211.9 KiB/s)
</code></pre></div>
<p>U-Boot scans our microSD and discovers a <strong>U-Boot Script <code>boot.scr</code></strong></p>
<p>(We‚Äôll talk more about the script)</p>
<p>The U-Boot Script <strong>loads the Linux Kernel</strong> into RAM and starts it‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Executing script at 4fc00000
gpio: pin 114 (gpio 114) value is 1
4275261 bytes read in 192 ms (21.2 MiB/s)
Uncompressed size: 10170376 = 0x9B3008
36162 bytes read in 4 ms (8.6 MiB/s)
1078500 bytes read in 50 ms (20.6 MiB/s)
## Flattened Device Tree blob at 4fa00000
   Booting using the fdt blob at 0x4fa00000
   Loading Ramdisk to 49ef8000, end 49fff4e4 ... OK
   Loading Device Tree to 0000000049eec000, end 0000000049ef7d41 ... OK

Starting kernel ...
/ #
</code></pre></div>
<p>The <strong>Linux Kernel</strong> is running! It works like we expect‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/ # uname -a
Linux (none) 5.9.1jumpdrive #3 SMP Sun Nov 8 00:41:50 CET 2020 aarch64 GNU/Linux

/ # ls
bin                info.sh            root               telnet_connect.sh
config             init               sbin               usr
dev                init_functions.sh  splash.ppm
error.ppm.gz       linuxrc            splash.ppm.gz
etc                proc               sys
</code></pre></div>
<p>And that‚Äôs how PinePhone boots a Linux Kernel, thanks to the U-Boot Bootloader!</p>
<h1 id="boot-script"><a href="#boot-script">6 Boot Script</a></h1>
<p><em>What‚Äôs <code>boot.scr</code>?</em></p>
<div class="example-wrap"><pre class="language-text"><code>Found U-Boot script /boot.scr
</code></pre></div>
<p>According to the log above, the U-Boot Bootloader runs the <strong>U-Boot Script <code>boot.scr</code></strong> to‚Ä¶</p>
<ul>
<li>
<p>Light up the PinePhone LED (I think?)</p>
</li>
<li>
<p>Load the <strong>Linux Kernel <code>Image.gz</code></strong> into RAM</p>
<p>(At <code>0x4408</code> <code>0000</code>)</p>
</li>
<li>
<p>Unzip the <strong>Linux Kernel <code>Image.gz</code></strong> in RAM</p>
<p>(At <code>0x4008</code> <code>0000</code>)</p>
</li>
<li>
<p>Load the <strong>Linux Device Tree</strong>‚Ä¶</p>
<p><code>sun50i-a64-pinephone-1.2.dtb</code></p>
<p>(At <code>0x4FA0</code> <code>0000</code>)</p>
</li>
<li>
<p>Load the <strong>RAM File System <code>initramfs.gz</code></strong></p>
<p>(At <code>0x4FE0</code> <code>0000</code>)</p>
</li>
<li>
<p>Boot the <strong>Unzipped Linux Kernel</strong> in RAM</p>
<p>(At <code>0x4008</code> <code>0000</code>)</p>
</li>
</ul>
<p>Here‚Äôs the Source File: <a href="https://github.com/dreemurrs-embedded/Jumpdrive/blob/master/src/pine64-pinephone.txt">Jumpdrive/src/pine64-pinephone.txt</a></p>
<div class="example-wrap"><pre class="language-bash"><code>setenv kernel_addr_z 0x44080000

setenv bootargs loglevel=0 silent console=tty0 vt.global_cursor_default=0

gpio set 114

if load ${devtype} ${devnum}:${distro_bootpart} ${kernel_addr_z} /Image.gz; then
  unzip ${kernel_addr_z} ${kernel_addr_r}
  if load ${devtype} ${devnum}:${distro_bootpart} ${fdt_addr_r} /sun50i-a64-pinephone-1.2.dtb; then
    if load ${devtype} ${devnum}:${distro_bootpart} ${ramdisk_addr_r} /initramfs.gz; then
      booti ${kernel_addr_r} ${ramdisk_addr_r}:${filesize} ${fdt_addr_r};
    else
      booti ${kernel_addr_r} - ${fdt_addr_r};
    fi;
  fi;
fi
</code></pre></div>
<p>(We‚Äôll explain <em>fdt_addr_r</em>, <em>kernel_addr_r</em> and <em>ramdisk_addr_r</em>)</p>
<p>The above U-Boot Script <strong><code>pine64-pinephone.txt</code></strong> is compiled to <strong><code>boot.scr</code></strong> by this Makefile: <a href="https://github.com/dreemurrs-embedded/Jumpdrive/blob/master/Makefile#L207-L209">Jumpdrive/Makefile</a></p>
<div class="example-wrap"><pre class="language-text"><code>%.scr: src/%.txt
	@echo &quot;MKIMG $@&quot;
	@mkimage -A arm -O linux -T script -C none -n &quot;U-Boot boot script&quot; -d $&lt; $@
</code></pre></div>
<p><a href="https://manpages.ubuntu.com/manpages/bionic/man1/mkimage.1.html">(<strong><code>mkimage</code></strong> is documented here)</a></p>
<h1 id="boot-address"><a href="#boot-address">7 Boot Address</a></h1>
<p><em>What are fdt_addr_r, kernel_addr_r and ramdisk_addr_r?</em></p>
<p>They are <strong>Environment Variables</strong> defined in U-Boot. To see the variables in U-Boot‚Ä¶</p>
<ol>
<li>
<p>Power off PinePhone</p>
</li>
<li>
<p>On our computer‚Äôs Serial Terminal, keep hitting Enter, don‚Äôt stop‚Ä¶</p>
</li>
<li>
<p>Power up PinePhone</p>
</li>
</ol>
<p>U-Boot should stop and reveal the <strong>U-Boot Prompt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2020.07 (Nov 08 2020 - 00:15:12 +0100)
Hit any key to stop autoboot:
=&gt;
</code></pre></div>
<p>Enter <strong><code>printenv</code></strong> to print the <strong>Environment Variables</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>=&gt; printenv
kernel_addr_r=0x40080000
fdt_addr_r=0x4FA00000
ramdisk_addr_r=0x4FE00000
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#pinephone-u-boot-log">(See the Complete Log)</a></p>
<p>When we match these addresses with our <a href="https://github.com/dreemurrs-embedded/Jumpdrive/blob/master/src/pine64-pinephone.txt"><strong>U-Boot Script</strong></a>, we discover‚Ä¶</p>
<ul>
<li>
<p><strong><code>kernel_addr_r</code></strong>: Linux Kernel <code>Image</code> will be unzipped into RAM at <strong><code>0x4008</code> <code>0000</code></strong>. And it will execute at that address.</p>
</li>
<li>
<p><strong><code>fdt_addr_r</code></strong>: Linux Device Tree <code>sun50i*.dtb</code> will be loaded into RAM at <strong><code>0x4FA0</code> <code>0000</code></strong></p>
</li>
<li>
<p><strong><code>ramdisk_addr_r</code></strong>: Linux RAM File System <code>initramfs</code> will be loaded into RAM at <strong><code>0x4FE0</code> <code>0000</code></strong></p>
</li>
</ul>
<p><em>Aha that‚Äôs why our kernel must start at <code>0x4008</code> <code>0000</code>!</em></p>
<p>Yep! Thus we can‚Ä¶</p>
<ul>
<li>
<p>Compile our own operating system to start at <strong><code>0x4008</code> <code>0000</code></strong></p>
</li>
<li>
<p>Replace <strong><code>Image.gz</code></strong> in the microSD by our compiled OS (gzipped)</p>
</li>
</ul>
<p>And PinePhone will <strong>boot our own OS!</strong> (Theoretically)</p>
<p>But there‚Äôs a catch: U-Boot expects to find a Linux Kernel Header in our OS‚Ä¶</p>
<h1 id="linux-kernel-header"><a href="#linux-kernel-header">8 Linux Kernel Header</a></h1>
<p><em>What! A Linux Kernel Header in our non-Linux OS?</em></p>
<p>Yep it‚Äôs totally strange, but U-Boot Bootloader expects our OS to begin with an <strong>Arm64 Linux Kernel Header</strong> as defined here‚Ä¶</p>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/arm64/booting.html"><strong>‚ÄúBooting AArch64 Linux‚Äù</strong></a></li>
</ul>
<p>The doc says that a Linux Kernel Image (for Arm64) should begin with this <strong>64-byte header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>u32 code0;              /* Executable code */
u32 code1;              /* Executable code */
u64 text_offset;        /* Image load offset, little endian */
u64 image_size;         /* Effective Image size, little endian */
u64 flags;              /* kernel flags, little endian */
u64 res2  = 0;          /* reserved */
u64 res3  = 0;          /* reserved */
u64 res4  = 0;          /* reserved */
u32 magic = 0x644d5241; /* Magic number, little endian, &quot;ARM\x64&quot; */
u32 res5;               /* reserved (used for PE COFF offset) */
</code></pre></div>
<p><a href="https://www.kernel.org/doc/html/latest/arm64/booting.html">(Source)</a></p>
<p>Let‚Äôs make a Linux Kernel Header to appease U-Boot‚Ä¶</p>
<h1 id="nuttx-header"><a href="#nuttx-header">9 NuttX Header</a></h1>
<p><em>How do we make a Linux Kernel Header in our non-Linux OS?</em></p>
<p>Apache NuttX RTOS can help!</p>
<p>This is how we created the <strong>Arm64 Linux Kernel Header</strong> in NuttX: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L79-L117">arch/arm64/src/common/arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>  /* Kernel startup entry point.
   * ---------------------------
   *
   * This must be the very first address in the loaded image.
   * It should be loaded at any 4K-aligned address.
   * __start will be set to 0x4008 0000 in the Linker Script
   */
  .globl __start;
__start:

  /* DO NOT MODIFY. Image header expected by Linux boot-loaders.
   *
   * This add instruction has no meaningful effect except that
   * its opcode forms the magic &quot;MZ&quot; signature of a PE/COFF file
   * that is required for UEFI applications.
   */
  add     x13, x18, #0x16  /* the magic &quot;MZ&quot; signature */
  b       real_start       /* branch to kernel start */
</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">(‚ÄúMZ‚Äù refers to Mark Zbikowski)</a></p>
<p>The header begins at <strong>Kernel Start Address <code>0x4008</code> <code>0000</code></strong>.</p>
<p>At the top of the header we jump to <strong><code>real_start</code></strong> to skip the header.</p>
<p>(NuttX code begins at <strong><code>real_start</code></strong> after the header)</p>
<p>Then comes the rest of the header‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  /* PinePhone Image load offset from start of RAM */
  .quad   0x0000  

  /* Effective size of kernel image, little-endian */
  .quad   _e_initstack - __start

  /* Informative flags, little-endian */
  .quad   __HEAD_FLAGS

  .quad   0          /* reserved */
  .quad   0          /* reserved */
  .quad   0          /* reserved */
  .ascii  &quot;ARM\x64&quot;  /* Magic number, &quot;ARM\x64&quot; */
  .long   0          /* reserved */

/* NuttX OS Code begins here, after the header */
real_start: ... 
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/scripts/dramboot.ld#L97-L106">(<strong><code>_e_initstack</code></strong> is End of Stack Space)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L41-L49">(<strong><code>__HEAD_FLAGS</code></strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/uboot#porting-notes">(<strong>UPDATE:</strong> We don‚Äôt need to change the Image Load Offset)</a></p>
<p><em>What‚Äôs the value of <code>__start</code>?</em></p>
<p>Remember <strong><code>kernel_addr_r</code></strong>, the <a href="https://lupyuen.github.io/articles/uboot#boot-address"><strong>Kernel Start Address</strong></a> from U-Boot?</p>
<p>In NuttX, we define the Kernel Start Address <strong><code>__start</code></strong> as <strong><code>0x4008</code> <code>0000</code></strong> in our Linker Script: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/scripts/dramboot.ld#L30-L34">boards/arm64/qemu/qemu-a53/scripts/dramboot</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  /* PinePhone uboot load address (kernel_addr_r) */
  . = 0x40080000;
  _start = .;
</code></pre></div>
<p>We also updated the Kernel Start Address in the NuttX <strong>Memory Map</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#memory-map"><strong>‚ÄúMemory Map‚Äù</strong></a></li>
</ul>
<p>We‚Äôre almost ready to boot NuttX on PinePhone!</p>
<p><em>Will we see anything when NuttX boots on PinePhone?</em></p>
<p>Not yet. We need to implement the UART Driver‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/uboot-uart1.png" alt="Allwinner A64 UART Controller Registers" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Allwinner A64 UART Controller Registers</em></a></p>
<h1 id="uart-output"><a href="#uart-output">10 UART Output</a></h1>
<p>Our operating system will show some output on PinePhone‚Äôs <strong>Serial Debug Console</strong> as it boots.</p>
<p>To do that, we‚Äôll talk to the <strong>UART Controller</strong> on the Allwinner A64 SoC‚Ä¶</p>
<ul>
<li><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a></li>
</ul>
<p>Flip the <a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><strong>A64 User Manual</strong></a> to page 562 (‚ÄúUART‚Äù) and we‚Äôll see the <strong>UART Registers</strong>. (Pic above)</p>
<p>PinePhone‚Äôs Serial Console is connected to <strong>UART0</strong> at Base Address <strong><code>0x01C2</code> <code>8000</code></strong></p>
<p>The First Register of UART0 is what we need: <strong>UART_THR</strong> at <strong><code>0x01C2</code> <code>8000</code></strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/uboot-uart2.png" alt="A64 UART Register UART_THR" /></p>
<p><em>What‚Äôs UART_THR?</em></p>
<p><strong>UART_THR</strong> is the <strong>Transmit Holding Register</strong>.</p>
<p>We‚Äôll write our output data to <strong><code>0x01C2</code> <code>8000</code></strong>, byte by byte, and the data will appear in the Serial Console. Let‚Äôs do that!</p>
<p><em>Did we forget something?</em></p>
<p>Rightfully we should wait for <strong>THR Empty</strong> (Transmit Buffer Empty) before sending our data.</p>
<p>And we should initialise the <strong>UART Baud Rate</strong>. We‚Äôll come back to this.</p>
<h1 id="nuttx-uart-macros"><a href="#nuttx-uart-macros">11 NuttX UART Macros</a></h1>
<p>NuttX writes to the UART Port with some clever <strong>Arm Assembly Macros</strong>.</p>
<p>This Assembly Code in NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cpu_boot:
  PRINT(cpu_boot, &quot;- Ready to Boot CPU\r\n&quot;)
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L176-L179">(Source)</a></p>
<p>Calls our <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L58-L69"><strong><code>PRINT</code> Macro</strong></a> to print a string at startup.</p>
<p>Which is super convenient because our <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S"><strong>Startup Code</strong></a> has plenty of Assembly Code!</p>
<p><em>What‚Äôs inside the macro?</em></p>
<p>Our <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L58-L69"><strong><code>PRINT</code> Macro</strong></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L292-L308"><strong><code>boot_stage_puts</code></strong></a> Function, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L81-L91"><strong><code>up_lowputc</code></strong></a> Function</p>
</li>
</ul>
<p>Which loads our <strong>UART Base Address</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* PinePhone Allwinner A64 UART0 Base Address: */
#define UART0_BASE_ADDRESS 0x1C28000

/* Print a character on the UART - this function is called by C
 * x0: character to print
 */
GTEXT(up_lowputc)
SECTION_FUNC(text, up_lowputc)
  ldr   x15, =UART0_BASE_ADDRESS  /* Load UART Base Address */
  early_uart_ready    x15, w2     /* Wait for UART ready    */
  early_uart_transmit x15, w0     /* Transmit to UART       */
  ret
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L81-L91">(Source)</a> </p>
<p>And calls <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L87-L94"><strong><code>early_uart_transmit</code></strong></a> Macro to transmit a character‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* UART transmit character
 * xb: register which contains the UART base address
 * wt: register which contains the character to transmit
 */
.macro early_uart_transmit xb, wt
  /* Write to UART_THR (Transmit Holding Register) */
  strb  \wt, [\xb]
.endm
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L81-L91">(Source)</a></p>
<p>That‚Äôs how we print a string to the console at startup!</p>
<p><em>What‚Äôs <code>early_uart_ready</code>?</em></p>
<p><strong><code>early_uart_ready</code></strong> Macro waits for the UART Port to be <strong>ready to transmit</strong>, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/uboot#wait-for-uart-ready"><strong>‚ÄúWait for UART Ready‚Äù</strong></a></li>
</ul>
<p><em>How do we initialise the UART Port?</em></p>
<p>Right now we don‚Äôt <strong>initialise the UART Port</strong> because U-Boot has kindly done it for us. Eventually this needs to be fixed: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L51-L72">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* UART initialization
 * xb: register which contains the UART base address
 * c: scratch register number
 */
GTEXT(up_earlyserialinit)
SECTION_FUNC(text, up_earlyserialinit)
  ## TODO: Set PinePhone Allwinner A64 Baud Rate Divisor:
  ## Write to UART_LCR (DLAB), UART_DLL and UART_DLH
  ...
</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L168-L176">(<strong><code>up_earlyserialinit</code></strong> is called by our Startup Code)</a></p>
<p>More about this in the Appendix‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/uboot#initialise-uart"><strong>‚ÄúInitialise UART‚Äù</strong></a></li>
</ul>
<p>We‚Äôre finally ready to boot our own PinePhone Operating System!</p>
<p><img src="https://lupyuen.github.io/images/uboot-title2.png" alt="Apache NuttX RTOS booting on Pine64 PinePhone" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#nuttx-boot-log"><em>Apache NuttX RTOS booting on Pine64 PinePhone</em></a></p>
<h1 id="pinephone-boots-nuttx"><a href="#pinephone-boots-nuttx">12 PinePhone Boots NuttX</a></h1>
<p><em>Can we boot our own OS on PinePhone‚Ä¶ By replacing a single file on Jumpdrive microSD?</em></p>
<p>Earlier we said that we‚Äôll overwrite <strong><code>Image.gz</code> on Jumpdrive microSD</strong> to boot our own OS‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/uboot#boot-address"><strong>‚ÄúBoot Address‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs do it!</p>
<ol>
<li>
<p>Prepare a microSD Card with <strong>PinePhone Jumpdrive</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/uboot#pinephone-jumpdrive"><strong>‚ÄúPinePhone Jumpdrive‚Äù</strong></a></p>
</li>
<li>
<p>Follow these steps to <strong>build Apache NuttX RTOS</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/uboot#appendix-build-nuttx-for-pinephone"><strong>‚ÄúBuild NuttX for PinePhone‚Äù</strong></a></p>
<p>Or <strong>download <code>nuttx.bin</code></strong> from here (includes BASIC Interpreter)‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v11.0.0/nuttx.bin"><strong>NuttX Binary Image for PinePhone: <code>nuttx.bin</code></strong></a></p>
</li>
<li>
<p>Compress the <strong>NuttX Binary Image</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compress the NuttX Binary Image
cp nuttx.bin Image
rm -f Image.gz
gzip Image
</code></pre></div>
<p>Or <strong>download <code>Image.gz</code></strong> from here (includes BASIC Interpreter)‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v11.0.0/Image.gz"><strong>Compressed NuttX Binary Image: <code>Image.gz</code></strong></a></p>
</li>
<li>
<p>Overwrite <strong><code>Image.gz</code></strong> on <strong>Jumpdrive microSD</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy compressed NuttX Binary Image to Jumpdrive microSD
## TODO: Change the microSD Path
cp Image.gz &quot;/Volumes/NO NAME&quot;
</code></pre></div></li>
<li>
<p>Connect PinePhone to our computer with a <strong>USB Serial Debug Cable</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/uboot#boot-log"><strong>‚ÄúBoot Log‚Äù</strong></a></p>
</li>
<li>
<p>Insert <strong>Jumpdrive microSD</strong> into PinePhone and power up</p>
</li>
</ol>
<p>On our computer‚Äôs <a href="https://lupyuen.github.io/articles/uboot#boot-log"><strong>Serial Terminal</strong></a>, we see PinePhone‚Äôs <strong>U-Boot Bootloader</strong> loading NuttX RTOS into RAM‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2020.07 (Nov 08 2020 - 00:15:12 +0100)
Found U-Boot script /boot.scr
653 bytes read in 3 ms (211.9 KiB/s)
## Executing script at 4fc00000
gpio: pin 114 (gpio 114) value is 1
99784 bytes read in 8 ms (11.9 MiB/s)
Uncompressed size: 278528 = 0x44000
36162 bytes read in 4 ms (8.6 MiB/s)
1078500 bytes read in 51 ms (20.2 MiB/s)
## Flattened Device Tree blob at 4fa00000
   Booting using the fdt blob at 0x4fa00000
   Loading Ramdisk to 49ef8000, end 49fff4e4 ... OK
   Loading Device Tree to 0000000049eec000, end 0000000049ef7d41 ... OK
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#nuttx-boot-log">(See the Complete Log)</a></p>
<p>Then NuttX runs‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...

HELLO NUTTX ON PINEPHONE!
- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

nx_start: Entry
up_allocate_heap: heap_start=0x0x400c4000, heap_size=0x7f3c000

arm64_gic_initialize: TODO: Init GIC for PinePhone
arm64_gic_initialize: CONFIG_GICD_BASE=0x1c81000
arm64_gic_initialize: CONFIG_GICR_BASE=0x1c82000
arm64_gic_initialize: GIC Version is 2

up_timer_initialize: up_timer_initialize: cp15 timer(s) running at 24.00MHz, cycle 24000
up_timer_initialize: _vector_table=0x400a7000
up_timer_initialize: Before writing: vbar_el1=0x40227000
up_timer_initialize: After writing: vbar_el1=0x400a7000

uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0

work_start_highpri: Starting high-priority kernel worker thread(s)
nx_start_application: Starting init thread
lib_cxx_initialize: _sinit: 0x400a7000 _einit: 0x400a7000 _stext: 0x40080000 _etext: 0x400a8000
nsh: sysinit: fopen failed: 2

nshn:x _msktfaarttf:s :C PcUo0m:m aBnedg innonti nfgo uInddle  L oNouptt
 Shell (NSH) NuttX-10.3.0-RC2
</code></pre></div>
<p>(Yeah the output is slightly garbled, the UART Driver needs fixing)</p>
<p><strong>NuttX Shell</strong> works perfectly OK on PinePhone‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC2 fc909c6-dirty Sep  1 2022 17:05:44 arm64 qemu-armv8a

nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]

  .         cd        dmesg     help      mount     rmdir     true      xd        
  [         cp        echo      hexdump   mv        set       truncate  
  ?         cmp       exec      kill      printf    sleep     uname     
  basename  dirname   exit      ls        ps        source    umount    
  break     dd        false     mkdir     pwd       test      unset     
  cat       df        free      mkrd      rm        time      usleep    

Builtin Apps:
  getprime  hello     nsh       ostest    sh        

nsh&gt; hello
task_spawn: name=hello entry=0x4009b1a0 file_actions=0x400c9580 attr=0x400c9588 argv=0x400c96d0
spawn_execattrs: Setting policy=2 priority=100 for pid=3
Hello, World!!

nsh&gt; ls /dev
/dev:
 console
 null
 ram0
 ram2
 ttyS0
 zero
</code></pre></div>
<p><a href="https://youtube.com/shorts/WmRzfCiWV6o?feature=share"><strong>Watch the Demo on YouTube</strong></a></p>
<p><a href="https://youtu.be/MJDxCcKAv0g"><strong>Another Demo Video</strong></a></p>
<p>Yep NuttX boots on PinePhone‚Ä¶ After replacing a single <strong><code>Image.gz</code></strong> file!</p>
<h1 id="upcoming-fixes"><a href="#upcoming-fixes">13 Upcoming Fixes</a></h1>
<p>Right now we‚Äôre running NuttX on a <strong>Single Arm64 CPU</strong>. In future we might run on all <strong>4 Arm64 CPUs</strong> of PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#multi-core-smp"><strong>‚ÄúMulti Core SMP‚Äù</strong></a></li>
</ul>
<p>We fixed some issues with <strong>Arm64 Interrupts</strong> on PinePhone‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS on PinePhone: Fixing the Interrupts‚Äù</strong></a></li>
</ul>
<p>And we fixed UART Input in our <a href="https://lupyuen.github.io/articles/uboot#uart-driver"><strong>UART Driver</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS on PinePhone: UART Driver‚Äù</strong></a></li>
</ul>
<p>Now we‚Äôre ready to <strong>build the Missing Drivers</strong> for PinePhone! Like MIPI DSI Display, I2C Touch Panel, LTE Modem, ‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#pinephone-device-tree"><strong>‚ÄúPinePhone Device Tree‚Äù</strong></a></li>
</ul>
<p>Below are tips for debugging the <strong>NuttX Boot Sequence</strong> on PinePhone‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#boot-sequence"><strong>‚ÄúBoot Sequence‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#boot-debugging"><strong>‚ÄúBoot Debugging‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#memory-map"><strong>‚ÄúMemory Map‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#handling-interrupts"><strong>‚ÄúHandling Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#dump-interrupt-vector-table"><strong>‚ÄúDump Interrupt Vector Table‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#interrupt-debugging"><strong>‚ÄúInterrupt Debugging‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/arm-source.png" alt="Arm64 Source Files in NuttX" /></p>
<p><a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common"><em>Arm64 Source Files in NuttX</em></a></p>
<h1 id="nuttx-source-code"><a href="#nuttx-source-code">14 NuttX Source Code</a></h1>
<p>Apache NuttX RTOS has plenty of <strong>Arm64 Code</strong> that will be helpful to creators of PinePhone Operating Systems.</p>
<p>The <strong>Arm64 Architecture Functions</strong> (pic above) are defined here‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common">arch/arm64/src/common</a></li>
</ul>
<p>These functions implement all kinds of Arm64 Features: <a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common/arm64_fpu.c"><strong>FPU</strong></a>, <a href="https://github.com/lupyuen/pinephone-nuttx#interrupt-controller"><strong>Interrupts</strong></a>, <a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common/arm64_mmu.c"><strong>MMU</strong></a>, <a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common/arm64_task_sched.c"><strong>Tasks</strong></a>, <a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/common/arm64_arch_timer.c"><strong>Timers</strong></a>, ‚Ä¶</p>
<p>The <strong>Arm64 Startup Code</strong> (including Linux Kernel Header) is at‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S">arch/arm64/src/common/arm64_head.S</a></li>
</ul>
<p>Previously NuttX supports only one <strong>Arm64 Target Board</strong>: QEMU Emulator.</p>
<p>Below are the Source Files and Build Configuration for <strong>QEMU Emulator</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/boards/arm64/qemu/qemu-armv8a">boards/arm64/qemu/qemu-armv8a</a></li>
</ul>
<p>We clone this to create a Target Board for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/boards/arm64/a64/pinephone">boards/arm64/a64/pinephone</a></li>
</ul>
<p>And we start the <strong>Board-Specific Drivers</strong> for PinePhone in <a href="https://github.com/apache/nuttx/tree/master/boards/arm64/a64/pinephone/src/pinephone_bringup.c">pinephone_bringup.c</a></p>
<p>Our Board calls the <strong>Architecture-Specific Drivers</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/a64">arch/arm64/src/a64</a></li>
</ul>
<p>The <strong>UART Driver</strong> is located at <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_serial.c">a64_serial.c</a> and <a href="https://github.com/apache/nuttx/tree/master/arch/arm64/src/a64/a64_lowputc.S">a64_lowputc.S</a></p>
<p><a href="https://lupyuen.github.io/articles/uboot#uart-driver">(More about UART Driver)</a></p>
<p>The <strong>QEMU Target for NuttX</strong> is described in this article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></li>
</ul>
<h1 id="whats-next"><a href="#whats-next">15 What‚Äôs Next</a></h1>
<p>It‚Äôs indeed possible to <strong>boot our own OS</strong> on PinePhone‚Ä¶ By <strong>replacing a single file</strong> on Jumpdrive microSD!</p>
<p>We‚Äôve done that with <strong>Apache NuttX RTOS</strong>, which has plenty of code that will be helpful for PinePhone OS Developers.</p>
<p><em>Will NuttX work with all PinePhone features?</em></p>
<p><strong>NuttX on PinePhone</strong> might take a while to become a <strong>Daily Driver</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm#pinephone-on-rtos"><strong>‚ÄúPinePhone on RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/arm#pinephone-drivers-and-apps"><strong>‚ÄúPinePhone Drivers and Apps‚Äù</strong></a></p>
</li>
</ul>
<p>But today NuttX is ready to turn PinePhone into a valuable <strong>Learning Resource</strong>!</p>
<p>There‚Äôs plenty to be done for NuttX on PinePhone, please lemme know if you would like to join me üôè</p>
<p>Please check out the other articles on NuttX for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/wz0hit/pinephone_boots_apache_nuttx_rtos/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/uboot.md"><strong>lupyuen.github.io/src/uboot.md</strong></a></p>
<h1 id="notes"><a href="#notes">16 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1564380402110070785"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>Check out this detailed doc on porting <strong>Genode OS</strong> to PinePhone‚Ä¶</p>
<p><a href="https://genode.org/documentation/genode-platforms-22-05.pdf"><strong>‚ÄúGenode Operating System Framework 22.05‚Äù</strong></a></p>
<p>PinePhone‚Äôs <strong>Touch Display</strong> is explained in pages 171 to 197.</p>
<p>PinePhone‚Äôs <strong>LTE Modem</strong> is covered in pages 198 to 204.</p>
</li>
</ol>
<h1 id="appendix-pinephone-is-now-supported-by-apache-nuttx-rtos"><a href="#appendix-pinephone-is-now-supported-by-apache-nuttx-rtos">17 Appendix: PinePhone is now supported by Apache NuttX RTOS</a></h1>
<p>PinePhone is now officially supported by <a href="https://github.com/apache/nuttx"><strong>Apache NuttX Mainline!</strong></a></p>
<p>Follow these steps to build and boot the <a href="https://github.com/apache/nuttx"><strong><code>master</code> branch of NuttX</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/arm/a64/boards/pinephone/index.html"><strong>‚ÄúApache NuttX RTOS for PINE64 PinePhone‚Äù</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/7ce5f5abedba365cb70b59e39e081cdc">(See the Build Log)</a></p>
</li>
</ul>
<p>Or download the <strong>Build Outputs</strong> from‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v11.0.0"><strong>‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></li>
</ul>
<p>We‚Äôll see this on the <strong>Serial Console</strong>‚Ä¶</p>
<ul>
<li><a href="https://gist.github.com/lupyuen/5029b5d1195c4ee6a7c74f24897ceecd"><strong>‚ÄúLog of Apache NuttX RTOS on PinePhone‚Äù</strong></a></li>
</ul>
<p>We have updated these articles to point to the PinePhone code in NuttX Mainline‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
</ul>
<h2 id="upcoming-features"><a href="#upcoming-features">17.1 Upcoming Features</a></h2>
<p><strong>Upcoming Features</strong> for NuttX on PinePhone‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pio#touch-panel"><strong>Touch Input Driver</strong></a> for PinePhone‚Äôs Touch Panel</li>
</ul>
<p>And we‚Äôll be able to run <strong>LVGL Touchscreen Apps</strong> on PinePhone. Stay Tuned!</p>
<h2 id="upcoming-fixes-1"><a href="#upcoming-fixes-1">17.2 Upcoming Fixes</a></h2>
<p>These are the <strong>Upcoming Fixes</strong> for NuttX on PinePhone‚Ä¶</p>
<ol>
<li>
<p><strong>RAM Size</strong> will be increased to 2 GB: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/include/a64/chip.h#L45-L48">chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Allwinner A64 Memory Map
// TODO: Increase RAM to 2 GB
#define CONFIG_RAMBANK1_ADDR      0x40000000
#define CONFIG_RAMBANK1_SIZE      MB(128)
</code></pre></div></li>
<li>
<p>Only <strong>Single Core CPU</strong> has been tested on PinePhone: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/a64/pinephone/configs/nsh/defconfig">pinephone/defconfig</a></p>
<p>We shall test <strong>Quad Core CPU</strong> on PinePhone: <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/nsh_smp/defconfig#L0-L1">qemu-armv8a/nsh_smp/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>## TODO: Enable Symmetric Multiprocessing (SMP) for PinePhone
CONFIG_ARCH_INTERRUPTSTACK=8192
CONFIG_DEFAULT_TASK_STACKSIZE=16384
CONFIG_IDLETHREAD_STACKSIZE=16384
CONFIG_PTHREAD_STACK_MIN=16384
CONFIG_SMP=y
CONFIG_SYSTEM_TASKSET=y
CONFIG_TESTING_OSTEST_STACKSIZE=16384
CONFIG_TESTING_SMP=y
</code></pre></div></li>
<li>
<p>Enable <strong>Memory Protection</strong> so that NuttX Apps can‚Äôt access NuttX Kernel Memory and Hardware Registers.</p>
</li>
</ol>
<h2 id="porting-notes"><a href="#porting-notes">17.3 Porting Notes</a></h2>
<p><strong>Porting Notes</strong> for NuttX on PinePhone‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot#nuttx-header"><strong>Image Load Offset</strong></a> in the Linux Kernel Header isn‚Äôt used: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L79-L117">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>.quad 0x480000 /* Image load offset from start of RAM */
</code></pre></div>
<p>NuttX boots OK without changing the Image Load Offset.</p>
<p>(Seems the Image Load Offset is not used by the U-Boot Bootloader. It‚Äôs probably used by the Linux Kernel only)</p>
</li>
<li>
<p>Previously the <strong>Vector Base Address Register</strong> for EL1 was set incorrectly. <a href="https://lupyuen.github.io/articles/interrupt#arm64-vector-table-is-wrong">(See this)</a></p>
<p>The new code doesn‚Äôt have this problem.</p>
<p>(Is it due to the Image Load Offset?)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/arm-build.png" alt="Build NuttX" /></p>
<h1 id="appendix-build-nuttx-for-pinephone"><a href="#appendix-build-nuttx-for-pinephone">18 Appendix: Build NuttX for PinePhone</a></h1>
<p><strong>UPDATE:</strong> PinePhone is now officially supported by Apache NuttX RTOS <a href="https://lupyuen.github.io/articles/what">(See this)</a></p>
<p>Follow these steps to build <strong>Apache NuttX RTOS</strong> for PinePhone‚Ä¶</p>
<h2 id="download-nuttx"><a href="#download-nuttx">18.1 Download NuttX</a></h2>
<p>Download the Source Code for NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Create NuttX Directory
mkdir nuttx
cd nuttx

## Download NuttX OS
git clone \
  https://github.com/apache/nuttx \
  nuttx

## Download NuttX Apps
git clone \
  https://github.com/apache/nuttx-apps \
  apps

## We&#39;ll build NuttX inside nuttx/nuttx
cd nuttx
</code></pre></div><h2 id="install-prerequisites"><a href="#install-prerequisites">18.2 Install Prerequisites</a></h2>
<p>Install the <strong>Build Prerequisites</strong> below, but skip the RISC-V Toolchain‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></li>
</ul>
<h2 id="download-toolchain"><a href="#download-toolchain">18.3 Download Toolchain</a></h2>
<p>Download the Arm Toolchain for <strong>AArch64 Bare-Metal Target <code>aarch64-none-elf</code></strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads"><strong>Arm GNU Toolchain Downloads</strong></a></p>
<p>(Skip the section for Beta Releases)</p>
</li>
</ul>
<p>For Linux x64 and WSL:</p>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz">gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz</a></li>
</ul>
<p>For macOS:</p>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.3.rel1/binrel/arm-gnu-toolchain-11.3.rel1-darwin-x86_64-aarch64-none-elf.pkg">arm-gnu-toolchain-11.3.rel1-darwin-x86_64-aarch64-none-elf.pkg</a></li>
</ul>
<p>(I don‚Äôt recommend building NuttX on Plain Old Windows CMD, please use WSL instead)</p>
<p>Add the downloaded Arm Toolchain to the <strong><code>PATH</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux x64 and WSL:
export PATH=&quot;$PATH:$HOME/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin&quot;

## For macOS:
export PATH=&quot;$PATH:/Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin&quot;
</code></pre></div>
<p>Check the Arm Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ aarch64-none-elf-gcc -v
gcc version 11.3.1 20220712 (Arm GNU Toolchain 11.3.Rel1)
</code></pre></div><h2 id="build-nuttx"><a href="#build-nuttx">18.4 Build NuttX</a></h2>
<p>Finally we <strong>configure and build</strong> NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For QEMU: Configure NuttX for Arm Cortex-A53 Single Core
tools/configure.sh qemu-armv8a:nsh

## For PinePhone: Configure NuttX for PinePhone
tools/configure.sh pinephone:lcd

## Build NuttX
make

## Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/2c5db82c3103f52ed7ca99804f9220c1">(See the Build Log)</a></p>
<p><a href="https://gist.github.com/lupyuen/7e828ea476d12cffa5e535a215723908">(See our Build Script)</a></p>
<p>On an old MacBook Pro 2012, NuttX builds in 2 minutes.</p>
<p>If we wish to use the <strong>BASIC Interpreter</strong>, follow these steps to enable it‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx#enable-basic"><strong>‚ÄúEnable BASIC‚Äù</strong></a></li>
</ul>
<p>Then run <strong><code>make</code></strong> to rebuild NuttX.</p>
<p>If the build fails with this error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>token &quot;@&quot; is not valid in preprocessor
</code></pre></div>
<p>Look for this file in the Arm64 Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>gcc-arm-none-eabi/arm-none-eabi/include/_newlib_version.h
</code></pre></div>
<p>And <a href="https://github.com/apache/nuttx/pull/7284/commits/518b0eb31cb66f25b590ae9a79ab16c319b96b94#diff-12291efd8a0ded1bc38bad733d99e4840ae5112b465c04287f91ba5169612c73"><strong>apply this patch</strong></a>.</p>
<h2 id="output-files"><a href="#output-files">18.5 Output Files</a></h2>
<p>The NuttX Output Files may be found here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v11.0.0"><strong>Apache NuttX RTOS for PinePhone</strong></a></li>
</ul>
<p>The <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v11.0.0/nuttx.bin"><strong>NuttX Binary Image <code>nuttx.bin</code></strong></a> will be gzipped and copied to Jumpdrive microSD as <strong><code>Image.gz</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/uboot#pinephone-boots-nuttx"><strong>‚ÄúPinePhone Boots NuttX‚Äù</strong></a></li>
</ul>
<p>For Troubleshooting: Refer to these files‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v11.0.0/nuttx"><strong>NuttX ELF Image <code>nuttx</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v11.0.0/nuttx.S"><strong>NuttX Arm Disassembly <code>nuttx.S</code></strong></a></p>
</li>
</ul>
<p>This article explains how we may load the <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v11.0.0/nuttx"><strong>NuttX ELF Image <code>nuttx</code></strong></a> into Ghidra for inspection‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/arm#appendix-analyse-nuttx-image-with-ghidra"><strong>‚ÄúAnalyse NuttX Image with Ghidra‚Äù</strong></a></li>
</ul>
<h1 id="appendix-allwinner-a64-uart"><a href="#appendix-allwinner-a64-uart">19 Appendix: Allwinner A64 UART</a></h1>
<p>Earlier we talked about our implementation of <strong>Allwinner A64 UART</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L72-L85"><strong><code>early_uart_ready</code></strong></a> needs to wait for UART to be <strong>ready to transmit</strong></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L51-L60"><strong><code>up_earlyserialinit</code></strong></a> needs to <strong>initialise the UART Port</strong></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_serial.c"><strong>UART Driver</strong></a> needs to support <strong>UART Input</strong></p>
</li>
</ul>
<p>Let‚Äôs talk about these changes‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/uboot-uart2.png" alt="Allwinner A64 UART Register UART_THR" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Allwinner A64 UART Register UART_THR</em></a></p>
<h2 id="wait-for-uart-ready"><a href="#wait-for-uart-ready">19.1 Wait for UART Ready</a></h2>
<p><em>How do we wait for the UART Port to be ready before we transmit data?</em></p>
<p>See the pic above. According to the <strong>Allwinner A64 UART</strong> doc (page 563, ‚ÄúUART‚Äù)‚Ä¶</p>
<ul>
<li><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a></li>
</ul>
<p>We should write data to the UART Port‚Ä¶</p>
<p>ONLY WHEN the <strong>THRE Bit</strong> is set.</p>
<p>(THRE means <strong>Transmit Holding Register Empty</strong>)</p>
<p><em>Where‚Äôs the THRE Bit?</em></p>
<p>THRE Bit is <strong>Bit 5</strong> (<code>0x20</code>) of UART_LSR.</p>
<p><strong>UART_LSR</strong> (Line Status Register) is at <strong>Offset <code>0x14</code></strong> from the UART Base Address.</p>
<p>In Arm64 Assembly, this is how we wait for the UART to be ready: <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L60-L72">a64_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* PinePhone Allwinner A64: 
 * Wait for UART to be ready to transmit
 * xb: register which contains the UART base address
 * wt: scratch register number
 */

.macro early_uart_ready xb, wt
1:
  /* Load the Line Status Register at Offset 0x14 from UART Base Address */
  ldrh  \wt, [\xb, #0x14]

  /* Check the THRE Bit (Tx Holding Register Empty) */
  tst   \wt, #0x20

  /* If UART is not ready (THRE=0), jump back to label `1:` */
  b.eq  1b                     
.endm
</code></pre></div><h2 id="initialise-uart"><a href="#initialise-uart">19.2 Initialise UART</a></h2>
<p><em>How will we initialise the UART Port?</em></p>
<p>According to the <strong>Allwinner A64 UART</strong> doc (page 562, ‚ÄúUART‚Äù)‚Ä¶</p>
<ul>
<li><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a></li>
</ul>
<p>We might <strong>initialise the UART Port</strong> in <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L51-L60"><strong><code>up_earlyserialinit</code></strong></a> like so‚Ä¶</p>
<ol>
<li>
<p>Set <strong>DLAB Flag</strong> to allow update of UART Divisor‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ldr  x15, =UART1_BASE_ADDRESS
mov  x0,  #0x80
strb w0,  [x15, #0x0C]
</code></pre></div></li>
<li>
<p>Write the <strong>UART Divisor</strong> (Least Significant Byte) to UART_DLL‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>mov  x0, #(divisor % 256)
strb w0, [x15, #0x00]
</code></pre></div></li>
<li>
<p>Write the <strong>UART Divisor</strong> (Most Significant Byte) to UART_DLH‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>mov  x0, #(divisor / 256)
strb w0, [x15, #0x04]
</code></pre></div></li>
<li>
<p>Clear <strong>DLAB Flag</strong> to disallow update of UART Divisor‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>mov  x0, #0x00
strb w0, [x15, #0x0C]
</code></pre></div></li>
</ol>
<p><a href="https://developer.arm.com/documentation/102374/0100/Registers-in-AArch64---general-purpose-registers">(Confused? <strong><code>x0</code></strong> and <strong><code>w0</code></strong> are actually the same register, 64-bit vs 32-bit)</a></p>
<p>Where‚Ä¶</p>
<ul>
<li>
<p><strong>DLAB (Divisor Latch Access Bit)</strong> is Bit 7 of UART_LCR</p>
</li>
<li>
<p><strong>UART_LCR (Line Control Register)</strong> is at Offset <code>0x0C</code> of the UART Base Address</p>
</li>
<li>
<p><strong>UART_DLL (Divisor Latch Low)</strong> is at Offset <code>0x00</code></p>
</li>
<li>
<p><strong>UART_DLH (Divisor Latch High)</strong> is at Offset <code>0x04</code></p>
</li>
<li>
<p><strong>UART Divisor</strong> is computed as‚Ä¶</p>
<p>(Serial Clock Frequency / 16) / Baud Rate</p>
</li>
</ul>
<p><strong>TODO:</strong> What is the Serial Clock Frequency (SCLK)?</p>
<h2 id="uart-driver"><a href="#uart-driver">19.3 UART Driver</a></h2>
<p>We have implemented the <strong>UART Driver</strong> for PinePhone‚Äôs Allwinner A64 UART Port‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_serial.c">arch/arm64/src/a64/a64_serial.c</a> </li>
</ul>
<p>Check out the details in this article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS on PinePhone: UART Driver‚Äù</strong></a></li>
</ul>

    
</body>
</html>