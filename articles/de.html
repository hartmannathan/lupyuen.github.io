<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rendering PinePhone&#39;s Display (DE and TCON0)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rendering PinePhone's Display (DE and TCON0)" 
    data-rh="true">
<meta property="og:description" 
    content="How does Pine64 PinePhone render graphics on its LCD Display? Let's find out about the Allwinner A64 SoC's Display Engine (DE) and Timing Controller (TCON0)."
    data-rh="true">
<meta name="description" 
    content="How does Pine64 PinePhone render graphics on its LCD Display? Let's find out about the Allwinner A64 SoC's Display Engine (DE) and Timing Controller (TCON0).">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/de-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rendering PinePhone&#39;s Display (DE and TCON0)</h1>
    <nav id="TOC"><ul>
<li><a href="#display-rendering-on-pinephone">1 Display Rendering on PinePhone</a><ul></ul></li>
<li><a href="#display-engine-in-allwinner-a64">2 Display Engine in Allwinner A64</a><ul></ul></li>
<li><a href="#render-colours">3 Render Colours</a><ul></ul></li>
<li><a href="#render-mandelbrot-set">4 Render Mandelbrot Set</a><ul></ul></li>
<li><a href="#animate-madelbrot-set">5 Animate Madelbrot Set</a><ul></ul></li>
<li><a href="#render-square-overlay">6 Render Square Overlay</a><ul></ul></li>
<li><a href="#render-circle-overlay">7 Render Circle Overlay</a><ul></ul></li>
<li><a href="#test-pinephone-display-engine">8 Test PinePhone Display Engine</a><ul></ul></li>
<li><a href="#other-display-engine-features">9 Other Display Engine Features</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-overview-of-allwinner-a64-display-engine">11 Appendix: Overview of Allwinner A64 Display Engine</a><ul></ul></li>
<li><a href="#appendix-display-engine-usage">12 Appendix: Display Engine Usage</a><ul></ul></li></ul></nav><p>üìù <em>2 Nov 2022</em></p>
<p><img src="https://lupyuen.github.io/images/de-title.jpg" alt="PinePhone rendering Mandelbrot Set on Apache NuttX RTOS" /></p>
<p><em>PinePhone rendering Mandelbrot Set on Apache NuttX RTOS</em></p>
<p>In the last 2 articles we talked about <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> (pic above) and how we built a <strong>Display Driver</strong> for PinePhone‚Äôs MIPI Display Serial Interface‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
</ul>
<p>But our PinePhone Display Driver <strong>isn‚Äôt complete</strong>‚Ä¶ It won‚Äôt render any graphics!</p>
<p>Today we‚Äôll learn about the missing bits in our Display Driver‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs the <strong>Display Engine (DE)</strong> inside PinePhone</p>
</li>
<li>
<p>How the <strong>Timing Controller (TCON0)</strong> controls PinePhone‚Äôs LCD Display</p>
</li>
<li>
<p>How we call DE and TCON0 to <strong>render graphics</strong></p>
</li>
<li>
<p>How our new <strong>PinePhone Display Driver</strong> will support DE and TCON0</p>
</li>
</ul>
<p><em>Why are we doing this?</em></p>
<p>We‚Äôre now porting <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> to PinePhone and we have created a (barebones) <a href="https://lupyuen.github.io/articles/dsi2"><strong>Display Driver in Zig</strong></a> that initialises the LCD Display.</p>
<p>To finish the driver, we need to understand what‚Äôs inside PinePhone‚Äôs Display Engine and Timing Controller.</p>
<p>Let‚Äôs dive in and continue the journey from our (super long) <strong>NuttX Porting Journal</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/de-block1a.jpg" alt="Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)</em></a></p>
<h1 id="display-rendering-on-pinephone"><a href="#display-rendering-on-pinephone">1 Display Rendering on PinePhone</a></h1>
<p><em>Suppose we‚Äôre building our own Operating System for PinePhone‚Ä¶</em></p>
<p><em>How do we render graphics on the LCD Display?</em></p>
<p>Rendering graphics directly to PinePhone Hardware (‚ÄúBare Metal‚Äù) is more complicated than we expect!</p>
<p>Let‚Äôs walk through the steps (pic above)‚Ä¶</p>
<ol>
<li>
<p>Inside PinePhone‚Äôs <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> is a <strong>Display Engine</strong> that combines and transforms Pixel Data for display</p>
</li>
<li>
<p>The Display Engine reads the Pixel Data from <strong>Framebuffers in RAM</strong> via <strong>Direct Memory Access (DMA)</strong></p>
<p>(Up to 3 Framebuffers)</p>
</li>
<li>
<p>Inside the Display Engine is a <strong>Real-Time Mixer</strong> (RT Mixer Core 0) that handles real-time <strong>DMA, Overlay, Scaling and Blending</strong> of the Pixel Data (from the Framebuffers)</p>
<p>(We won‚Äôt need RT Mixer Core 1 today, it‚Äôs a smaller version of Core 0)</p>
</li>
<li>
<p>The Real-Time Mixer supports <strong>3 UI Channels</strong> (for graphics), all mixed together into a <strong>Single Image Frame</strong> in real time</p>
<p>(The Mixer supports Video, but we won‚Äôt use it today)</p>
</li>
<li>
<p>The successive Image Frames (generated by the Display Engine) are pumped in real time to the <strong>Timing Controller (TCON0)</strong></p>
</li>
<li>
<p>The Timing Controller pushes the Image Frames to <strong>PinePhone‚Äôs LCD Controller</strong> as a stream of pixels (over MIPI Display Serial Interface)</p>
</li>
</ol>
<p>All this happens in <strong>Real Time</strong>‚Ä¶ Any updates to the Framebuffers in RAM are <strong>pushed out instantly</strong> to the LCD Display.</p>
<p>(Super efficient thanks to DMA!)</p>
<p><em>Why so complicated?</em></p>
<p>PinePhone‚Äôs ST7703 LCD Controller <strong>doesn‚Äôt have any RAM</strong> inside‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>‚ÄúSitronix ST7703 LCD Controller‚Äù</strong></a></li>
</ul>
<p>That‚Äôs why we need to <strong>pump a constant stream of pixels</strong> to the LCD Display via DMA, Display Engine and Timing Controller‚Ä¶ Otherwise the display stays blank!</p>
<p><a href="https://en.wikipedia.org/wiki/Video_Toaster">(Sounds a bit like the Amiga Video Toaster)</a></p>
<p>Let‚Äôs look inside the Display Engine‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-mixer1a.jpg" alt="Real-Time Mixer in A64 Display Engine (Page 22)" /></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><em>Real-Time Mixer in A64 Display Engine (Page 22)</em></a></p>
<h1 id="display-engine-in-allwinner-a64"><a href="#display-engine-in-allwinner-a64">2 Display Engine in Allwinner A64</a></h1>
<p>Recall that Allwinner A64‚Äôs Display Engine is a <strong>Real-Time Mixer</strong> that handles real-time <strong>DMA, Overlay, Scaling and Blending</strong> of the Framebuffers‚Ä¶</p>
<p>And the Display Engine pushes the output pixels to the <strong>Timing Controller (TCON0)</strong> for display on PinePhone‚Äôs LCD Display.</p>
<p>The pic above shows how the Display Engine mixes together <strong>3 UI Channels (Framebuffers)</strong> via DMA1, 2 and 3.</p>
<p>(Plus a Video Channel on DMA0, but we won‚Äôt use it today)</p>
<p><em>Is the Display Engine documented?</em></p>
<p>The official doc for the A64 Display Engine is here‚Ä¶</p>
<ul>
<li><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>Allwinner Display Engine 2.0 Specifications</strong></a></li>
</ul>
<p>Though it doesn‚Äôt describe the actual steps for programming the Display Engine.</p>
<p>In a while we‚Äôll boot <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> on PinePhone and experiment with the Display Engine, to understand it better.</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#display-engine-mixers">(Overview of A64 Display Engine)</a></p>
<p><em>But the Display Engine doc doesn‚Äôt mention A64?</em></p>
<p>PinePhone‚Äôs A64 Display Engine is hidden under <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>Allwinner H3 (page 22)</strong></a>, because Allwinner A64 is actually a H3 upgraded with 64-bit Cores‚Ä¶</p>
<blockquote>
<p>‚ÄúThe A64 is basically an Allwinner H3 with the Cortex-A7 cores replaced with Cortex-A53 cores (ARM64 architecture). They share most of the memory map, clocks, interrupts and also uses the same IP blocks.‚Äù</p>
</blockquote>
<blockquote>
<p><a href="https://linux-sunxi.org/A64">(Source)</a></p>
</blockquote>
<p><em>Why are there 2 Mixers in the A64 Display Engine?</em></p>
<p>Maybe because A64 (or H3) was designed for <a href="https://linux-sunxi.org/H3"><strong>OTT Set-Top Boxes</strong></a> with Picture-In-Picture Overlay Videos?</p>
<p>The 3 UI Overlay Channels would be super helpful for overlaying an OTT Graphical UI on top of a Video Channel.</p>
<p><a href="https://en.wikipedia.org/wiki/Pine64#History">(Wait‚Ä¶ Wasn‚Äôt Pine64 created thanks to OTT Boxes? ü§î)</a></p>
<p><img src="https://lupyuen.github.io/images/de-code1a.png" alt="Rendering simple Colour Blocks on the PinePhone Display" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214">(Source)</a></p>
<h1 id="render-colours"><a href="#render-colours">3 Render Colours</a></h1>
<p><em>How do we program the A64 Display Engine to render graphics?</em></p>
<p>Let‚Äôs begin by rendering simple <strong>Colour Blocks</strong> on the PinePhone Display‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-rgb.jpg" alt="Blue, Green, Red Blocks on PinePhone" /></p>
<p>First we <strong>allocate the Framebuffer</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/PinePhone">(PinePhone‚Äôs display resolution is 720 x 1440)</a></p>
<p>Each Pixel occupies <strong>4 bytes</strong>. (ARGB 8888 Format)</p>
<p>Then we <strong>fill the Framebuffer</strong> with Blue, Green and Red: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fill with Blue, Green and Red
for (int i = 0; i &lt; fb0_len; i++) {
  // Colours are in ARGB format
  if (i &lt; fb0_len / 4) {
    // Blue for top quarter
    fb0[i] = 0x80000080;
  } else if (i &lt; fb0_len / 2) {
    // Green for next quarter
    fb0[i] = 0x80008000;
  } else {
    // Red for lower half
    fb0[i] = 0x80800000;
  }
}</code></pre></div>
<p>Each Pixel in the Framebuffer is stored as <strong>32-bit ARGB 8888</strong>.</p>
<p>Thus <strong><code>0x8000</code> <code>8000</code></strong> means Semi-Transparent Green‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Channel</th><th>Value</th></tr></thead><tbody>
<tr><td style="text-align: left">Alpha</td><td><code>0x80</code></td></tr>
<tr><td style="text-align: left">Red</td><td><code>0x00</code></td></tr>
<tr><td style="text-align: left">Green</td><td><code>0x80</code></td></tr>
<tr><td style="text-align: left">Blue</td><td><code>0x00</code></td></tr>
</tbody></table>
</div>
<p>A64 Display Engine lets us render of 3 Framebuffers as <strong>3 UI Channels</strong>.</p>
<p>This is how we allocate the 3 UI Channels: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L262">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Allocate 3 UI Channels
static struct display disp;
memset(&amp;disp, 0, sizeof(disp));
struct display *d = &amp;disp;</code></pre></div>
<p><a href="https://megous.com/git/p-boot/tree/src/display.h#n28">(<strong><code>display</code></strong> struct is defined here)</a></p>
<p>We point the <strong>First UI Channel</strong> to our Framebuffer: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L262-L271">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init UI Channel 1: (Base Channel)
// Fullscreen 720 x 1440
d-&gt;planes[0].fb_start = (uintptr_t) fb0;  // Framebuffer Address
d-&gt;planes[0].fb_pitch = 720 * 4;  // Framebuffer Pitch
d-&gt;planes[0].src_w    = 720;   // Source Width
d-&gt;planes[0].src_h    = 1440;  // Source Height
d-&gt;planes[0].dst_w    = 720;   // Dest Width
d-&gt;planes[0].dst_h    = 1440;  // Dest Height</code></pre></div>
<p>(<strong><code>fb_pitch</code></strong> is the number of bytes per row of pixels)</p>
<p>We disable the <strong>Second and Third UI Channels</strong> for now: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L299">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init UI Channel 2: (First Overlay)
// Disable Channel for now
d-&gt;planes[1].fb_start = 0;

// Init UI Channel 3: (Second Overlay)
// Disable Channel for now
d-&gt;planes[2].fb_start = 0;

// Render the UI Channels
display_commit(d);</code></pre></div>
<p>And we <strong>render the 3 UI Channels</strong>.</p>
<p>(<a href="https://megous.com/git/p-boot/tree/src/display.c#n2017"><strong><code>display_commit</code></strong></a> is defined in the p-boot Display Code, we‚Äôll come back to this)</p>
<p>That‚Äôs it! We should see the <a href="https://lupyuen.github.io/images/de-rgb.jpg"><strong>Blue, Green and Red Blocks</strong></a> like in the pic above.</p>
<p>(Not sure why there are black lines, needs investigation)</p>
<p><em>Didn‚Äôt we set the Alpha Channel to <code>0x80</code>?</em></p>
<p><strong>UI Channel 1</strong> is the Base UI Channel, so the Alpha Channel has no effect.</p>
<p>(Actually UI Channel 1 is configured as <strong>XRGB 8888</strong>)</p>
<p>In a while we‚Äôll set the Alpha Channels for UI Channels 2 and 3. And the UI Channels will appear as semi-transparent overlays.</p>
<p><img src="https://lupyuen.github.io/images/de-code3a.png" alt="Rendering Mandelbrot Set on PinePhone" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200">(Source)</a></p>
<h1 id="render-mandelbrot-set"><a href="#render-mandelbrot-set">4 Render Mandelbrot Set</a></h1>
<p><em>Rendering colour blocks is so blah. Are we sure we can render every single pixel correctly?</em></p>
<p>Let‚Äôs render something more detailed and sophisticated‚Ä¶ <a href="https://en.wikipedia.org/wiki/Mandelbrot_set"><strong>Mandelbrot Set</strong></a>!</p>
<p><img src="https://lupyuen.github.io/images/de-title.jpg" alt="Mandelbrot Set on PinePhone" /></p>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fill with Mandelbrot Set
for (int y = 0; y &lt; 1440; y++) {
  for (int x = 0; x &lt; 720; x++) {
    // Convert Pixel Coordinates to a Complex Number
    float cx = x_start + (y / 1440.0) * (x_end - x_start);
    float cy = y_start + (x / 720.0)  * (y_end - y_start);

    // Compute Manelbrot Set
    int m = mandelbrot(cx, cy);

    // Color depends on the number of iterations
    uint8_t hue = 255.0 * m / MAX_ITER;
    uint8_t saturation = 255;
    uint8_t value = (m &lt; MAX_ITER) ? 255 : 0;

    // Convert Hue / Saturation / Value to RGB
    uint32_t rgb = hsvToRgb(hue, saturation, value);

    // Set the Pixel Colour (ARGB Format)
    int p = (y * 720) + x;
    assert(p &lt; fb0_len);
    fb0[p] = 0x80000000 | rgb;
  }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L335-L432">(<strong><code>mandelbrot</code></strong> and <strong><code>hsvToRgb</code></strong> are defined here)</a></p>
<p>TODO: We should see this Mandelbrot Set‚Ä¶</p>
<h1 id="animate-madelbrot-set"><a href="#animate-madelbrot-set">5 Animate Madelbrot Set</a></h1>
<p>TODO</p>
<p><em>Earlier we said DMA. Can we prove it?</em></p>
<p>Now we animate the Mandelbrot Set: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Omitted: Init UI Channels 1, 2 and 3
...
// Render the UI Channels
display_commit(d);

// Animate the Mandelbrot Set forever...
for (;;) {
  // Fill with Mandelbrot Set
  for (int y = 0; y &lt; 1440; y++) {
    for (int x = 0; x &lt; 720; x++) {
      // Convert Pixel Coordinates to a Complex Number
      float cx = x_start + (y / 1440.0) * (x_end - x_start);
      float cy = y_start + (x / 720.0)  * (y_end - y_start);

      // Compute Manelbrot Set
      int m = mandelbrot(cx, cy);

      // Color depends on the number of iterations
      uint8_t hue = 255.0 * m / MAX_ITER;
      uint8_t saturation = 255;
      uint8_t value = (m &lt; MAX_ITER) ? 255 : 0;

      // Convert Hue / Saturation / Value to RGB
      uint32_t rgb = hsvToRgb(hue, saturation, value);

      // Set the Pixel Colour (ARGB Format)
      int p = (y * 720) + x;
      assert(p &lt; fb0_len);
      fb0[p] = 0x80000000 | rgb;
    }
  }
  // Zoom in to (-1.4, 0)
  float x_dest = -1.4;
  float y_dest = 0;
  x_start += (x_dest - x_start) * 0.05;
  x_end   -= (x_end  - x_dest)  * 0.05;
  y_start += (y_dest - y_start) * 0.05;
  y_end   -= (y_end  - y_dest)  * 0.05;
}</code></pre></div>
<p>We should see the Animated Mandelbrot Set‚Ä¶</p>
<ul>
<li><a href="https://youtu.be/toC9iiPRwRI">Demo Video on YouTube</a></li>
</ul>
<p><em>Don‚Äôt we need to call <code>display_commit</code> after every frame?</em></p>
<p>Nope, remember that the Display Engine reads our Framebuffer directly via DMA.</p>
<p>So any updates to the Framebuffer will be pushed to the display instantly.</p>
<p><img src="https://lupyuen.github.io/images/de-code3a.png" alt="TODO" /></p>
<h1 id="render-square-overlay"><a href="#render-square-overlay">6 Render Square Overlay</a></h1>
<p>TODO</p>
<p>This is how we render a Blue Square as an Overlay on UI Channel 2: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 1:
// Square 600 x 600 (4 bytes per ARGB pixel)
// fb1_len is 600 * 600
static uint32_t fb1[600 * 600];
int fb1_len = sizeof(fb1) / sizeof(fb1[0]);

// Fill with Blue
for (int i = 0; i &lt; fb1_len; i++) {
  // Colours are in ARGB format
  fb1[i] = 0x80000080;
}

// Init UI Channel 2: (First Overlay)
// Square 600 x 600
d-&gt;planes[1].fb_start = (uintptr_t) fb1;  // Framebuffer Address
d-&gt;planes[1].fb_pitch = 600 * 4;  // Framebuffer Pitch
d-&gt;planes[1].src_w    = 600;  // Source Width
d-&gt;planes[1].src_h    = 600;  // Source Height
d-&gt;planes[1].dst_w    = 600;  // Dest Width
d-&gt;planes[1].dst_h    = 600;  // Dest Height
d-&gt;planes[1].dst_x    = 52;   // Dest X
d-&gt;planes[1].dst_y    = 52;   // Dest Y</code></pre></div>
<p><img src="https://lupyuen.github.io/images/de-code4a.png" alt="TODO" /></p>
<h1 id="render-circle-overlay"><a href="#render-circle-overlay">7 Render Circle Overlay</a></h1>
<p>TODO</p>
<p>This is how we render a Green Circle as an Overlay on UI Channel 3: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 2:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb2_len is 720 * 1440
static uint32_t fb2[720 * 1440];
int fb2_len = sizeof(fb2) / sizeof(fb2[0]);

// Fill with Green Circle
for (int y = 0; y &lt; 1440; y++) {
  for (int x = 0; x &lt; 720; x++) {
    // Get pixel index
    int p = (y * 720) + x;
    assert(p &lt; fb2_len);

    // Shift coordinates so that centre of screen is (0,0)
    int x_shift = x - 360;
    int y_shift = y - 720;

    // If x^2 + y^2 &lt; radius^2, set the pixel to Green
    if (x_shift*x_shift + y_shift*y_shift &lt; 360*360) {
      fb2[p] = 0x80008000;  // Green in ARGB Format
    } else {  // Otherwise set to Black
      fb2[p] = 0x00000000;  // Black in ARGB Format
    }
  }
}

// Init UI Channel 3: (Second Overlay)
// Fullscreen 720 x 1440 with Alpha Blending
d-&gt;planes[2].fb_start = (uintptr_t) fb2;  // Framebuffer Address
d-&gt;planes[2].fb_pitch = 720 * 4;  // Framebuffer Pitch
d-&gt;planes[2].src_w    = 720;   // Source Width
d-&gt;planes[2].src_h    = 1440;  // Source Height
d-&gt;planes[2].dst_w    = 720;   // Dest Width
d-&gt;planes[2].dst_h    = 1440;  // Dest Height
d-&gt;planes[2].dst_x    = 0;     // Dest X
d-&gt;planes[2].dst_y    = 0;     // Dest Y
d-&gt;planes[2].alpha    = 128;   // Dest Alpha</code></pre></div>
<p>Note that we set the Destination Alpha. So the black pixels will appear transparent.</p>
<p>We should see the Animated Mandelbrot Set, with Blue Square and Green Circle as Overlays‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-overlay.jpg" alt="Mandelbrot Set with Blue Square and Green Circle on PinePhone" /></p>
<p>(Why the missing horizontal lines in the Blue Square and Green Circle?)</p>
<p><img src="https://lupyuen.github.io/images/de-code5a.png" alt="TODO" /></p>
<p><img src="https://lupyuen.github.io/images/de-code6a.png" alt="TODO" /></p>
<h1 id="test-pinephone-display-engine"><a href="#test-pinephone-display-engine">8 Test PinePhone Display Engine</a></h1>
<p>TODO</p>
<p>To test the A64 Display Engine with NuttX on PinePhone, we‚Äôll run this p-boot Display Code‚Ä¶</p>
<ul>
<li><a href="https://megous.com/git/p-boot/tree/src/display.c#n2017">display.c</a></li>
</ul>
<p>With our Test App‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c">test_display.c</a></li>
</ul>
<p>Here are the steps to download these files and build them‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nuttx
‚îú‚îÄ‚îÄ apps (NuttX Apps for PinePhone including Display Engine Version 2)
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Application.mk
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DISCLAIMER
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Directory.mk
...
‚îú‚îÄ‚îÄ nuttx (NuttX OS for PinePhone)
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ AUTHORS
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DISCLAIMER
...
‚îú‚îÄ‚îÄ p-boot (Modified p-boot Display Code)
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HACKING
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LICENSE
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NEWS
...
‚îî‚îÄ‚îÄ pinephone-nuttx (Zig MIPI DSI Driver for PinePhone)
 ¬†¬† ‚îú‚îÄ‚îÄ LICENSE
 ¬†¬† ‚îú‚îÄ‚îÄ README.md
 ¬†¬† ‚îú‚îÄ‚îÄ display.o
 ¬†¬† ‚îî‚îÄ‚îÄ display.zig</code></pre></div>
<ol>
<li>
<p>Create the NuttX Directory‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx</code></pre></div></li>
<li>
<p>Download the Modified Instrumented p-boot Display Code <code>p-boot.6.zip</code> from‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/pboot6">pinephone-nuttx/releases/tag/pboot6</a></p>
<p>Extract into the <code>nuttx</code> folder and rename as <code>p-boot</code></p>
</li>
<li>
<p>Download and build NuttX for PinePhone inside the <code>nuttx</code> folder‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Install Build Prerequisites
# https://lupyuen.github.io/articles/uboot#install-prerequisites

# Download NuttX OS for PinePhone
git clone \
    --recursive \
    --branch pinephone \
    https://github.com/lupyuen/incubator-nuttx \
    nuttx

# Download NuttX Apps for PinePhone including Display Engine (Version 2)
git clone \
    --recursive \
    --branch de2 \
    https://github.com/lupyuen/incubator-nuttx-apps \
    apps

# We&#39;ll build NuttX inside nuttx/nuttx
cd nuttx

# Configure NuttX for Single Core
./tools/configure.sh -l qemu-a53:nsh

# Build NuttX. Ignore the Linker Errors
make</code></pre></div></li>
<li>
<p>Follow these steps to compile our Zig MIPI DSI Driver and link into NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#zig-on-pinephone">‚ÄúZig on PinePhone‚Äù</a></li>
</ul>
</li>
<li>
<p>Compress the NuttX Binary Image‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cp nuttx.bin Image
rm -f Image.gz
gzip Image</code></pre></div></li>
<li>
<p>Copy the compressed NuttX Binary Image to Jumpdrive microSD‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Copy compressed NuttX Binary Image to Jumpdrive microSD.
# How to create Jumpdrive microSD: https://lupyuen.github.io/articles/uboot#pinephone-jumpdrive
# TODO: Change the microSD Path
cp Image.gz &quot;/Volumes/NO NAME&quot;</code></pre></div></li>
<li>
<p>To access the UART Port on PinePhone, we‚Äôll connect this USB Serial Debug Cable (at 115.2 kbps)‚Ä¶</p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console">PinePhone Serial Debug Cable</a></p>
</li>
<li>
<p>Insert the Jumpdrive microSD into PinePhone and power up</p>
</li>
<li>
<p>At the NuttX Shell, enter <code>hello</code></p>
</li>
</ol>
<p>(The steps look messy today, hopefully we‚Äôll remove p-boot after we have created our NuttX Display Driver)</p>
<p>We should see the Animated Mandelbrot Set, with Blue Square and Green Circle as Overlays‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-overlay.jpg" alt="Mandelbrot Set with Blue Square and Green Circle on PinePhone" /></p>
<p>(Why the missing horizontal lines in the Blue Square and Green Circle?)</p>
<h1 id="other-display-engine-features"><a href="#other-display-engine-features">9 Other Display Engine Features</a></h1>
<p>TODO</p>
<p>We won‚Äôt use these Display Engine Features today‚Ä¶</p>
<p><strong>DE RT-WB:</strong> (Page 116)</p>
<blockquote>
<p>The Real-time write-back controller (RT-WB) provides data capture function for display engine. It captures data from RT-mixer module, performs the image resizing function, and then write-back to SDRAM.</p>
</blockquote>
<p>(For screen capture?)</p>
<p><strong>DE VSU:</strong> (Page 128)</p>
<blockquote>
<p>The Video Scaler (VS) provides YUV format image resizing function for display engine. It receives data from overlay module, performs the image resizing function, and outputs to video post-processing modules. </p>
</blockquote>
<p><strong>DE Rotation:</strong> (Page 137)</p>
<blockquote>
<p>There are several types of rotation: clockwise 0/90/180/270 degree Rotation and H-Flip/V-Flip. Operation of Copy is the same as a 0 degree rotation.</p>
</blockquote>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Current Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/de.md"><strong>lupyuen.github.io/src/de.md</strong></a></p>
<h1 id="appendix-overview-of-allwinner-a64-display-engine"><a href="#appendix-overview-of-allwinner-a64-display-engine">11 Appendix: Overview of Allwinner A64 Display Engine</a></h1>
<p>TODO</p>
<p>According to the doc, DE Base Address is 0x0100 0000 (Page 24)</p>
<p><em>What‚Äôs a Display Engine Mixer?</em></p>
<p><strong>DE RT-MIXER:</strong> (Page 87)</p>
<blockquote>
<p>The RT-mixer Core consist of dma, overlay, scaler and blender block. It supports 4 layers overlay in one pipe, and its result can scaler up or down to blender in the next processing.</p>
</blockquote>
<p>The Display Engine has 2 Mixers: RT-MIXER0 and RT-MIXER1‚Ä¶</p>
<p><strong>DE RT-MIXER0</strong> has 4 Channels (DE Offset 0x10 0000, Page 87)</p>
<ul>
<li>Channel 0 for Video: DMA0, Video Overlay, Video Scaler</li>
<li>Channels 1, 2, 3 for UI: DMA1 / 2 / 3, UI Overlays, UI Scalers, UI Blenders</li>
<li>4 Overlay Layers per Channel</li>
<li>Layer priority is Layer 3 &gt; Layer2 &gt; Layer 1 &gt; Layer 0 (Page 89)</li>
<li>Channel 0 is unused (we don‚Äôt use video right now)</li>
<li>Channel 1 has format XRGB 8888</li>
<li>Channels 2 and 3 have format ARGB 8888</li>
<li>MIXER0 Registers:
<ul>
<li>GLB at MIXER0 Offset 0x00000 (de_glb_regs)</li>
<li>BLD (Blender) at MIXER0 Offset 0x01000 (de_bld_regs)</li>
<li>OVL_V(CH0) (Video Overlay / Channel 0) at MIXER0 Offset 0x2000 (Unused)</li>
<li>OVL_UI(CH1) (UI Overlay / Channel 1) at MIXER0 Offset 0x3000</li>
<li>OVL_UI(CH2) (UI Overlay / Channel 2) at MIXER0 Offset 0x4000</li>
<li>OVL_UI(CH3) (UI Overlay / Channel 3) at MIXER0 Offset 0x5000</li>
<li>POST_PROC2 at MIXER0 Offset 0xB0000 (de_csc_regs)</li>
</ul>
</li>
</ul>
<p><strong>DE RT-MIXER1</strong> has 2 Channels (DE Offset 0x20 0000, Page 23)</p>
<ul>
<li>Channel 0 for Video: DMA0, Video Overlay, Video Scaler</li>
<li>Channel 1 for UI: DMA1, UI Overlay, UI Scaler, UI Blender</li>
<li>We don‚Äôt use MIXER1 right now</li>
</ul>
<p>RT-MIXER0 and RT-MIXER1 are multiplexed to Timing Controller TCON0.</p>
<p>(TCON0 is connected to ST7703 over MIPI DSI)</p>
<p>So MIXER0 mixes 1 Video Channel with 3 UI Channels over DMA ‚Ä¶ And pumps the pixels continuously to ST7703 LCD Controller (via the Timing Controller)</p>
<p>Let‚Äôs use the 3 UI Channels to render: 1Ô∏è‚É£ Mandelbrot Set 2Ô∏è‚É£ Blue Square 3Ô∏è‚É£ Green Circle</p>
<p><img src="https://lupyuen.github.io/images/de-overlay.jpg" alt="Mandelbrot Set with UI Overlays on PinePhone" /></p>
<h1 id="appendix-display-engine-usage"><a href="#appendix-display-engine-usage">12 Appendix: Display Engine Usage</a></h1>
<p>TODO</p>
<p>Based on the log captured from our instrumented <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c">test_display.c</a>, we have identified the steps to render 3 UI Channels (1 to 3) with the Display Engine <a href="https://megous.com/git/p-boot/tree/src/display.c#n2017">(<code>display_commit</code>)</a></p>
<p>This is how we‚Äôll create a NuttX Driver for PinePhone‚Äôs A64 Display Engine that implements Display Rendering‚Ä¶</p>
<ol>
<li>
<p>Configure Blender‚Ä¶</p>
<ul>
<li>BLD BkColor (BLD_BK_COLOR Offset 0x88): BLD background color register</li>
<li>BLD Premultiply (BLD_PREMUL_CTL Offset 0x84): BLD pre-multiply control register</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Configure Blender
BLD BkColor:     0x110 1088 = 0xff000000
BLD Premultiply: 0x110 1084 = 0x0</code></pre></div></li>
<li>
<p>For Channels 1 to 3‚Ä¶</p>
<ol>
<li>
<p>If Channel is unused, disable Overlay, Pipe and Scaler. Skip to next Channel</p>
<ul>
<li>UI Config Attr (OVL_UI_ATTCTL @ OVL_UI Offset 0x00): OVL_UI attribute control register</li>
<li>Mixer (??? @ 0x113 0000 + 0x10000 * Channel)</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 2: Disable Overlay and Pipe
UI Config Attr: 0x110 4000 = 0x0

Channel 3: Disable Overlay and Pipe
UI Config Attr: 0x110 5000 = 0x0

Channel 2: Disable Scaler
Mixer: 0x115 0000 = 0x0

Channel 3: Disable Scaler
Mixer: 0x116 0000 = 0x0</code></pre></div></li>
<li>
<p>Channel 1 has format XRGB 8888, Channel 2 and 3 have format ARGB 8888</p>
</li>
<li>
<p>Set Overlay (Assume Layer = 0)</p>
<ul>
<li>UI Config Attr (OVL_UI_ATTCTL @ OVL_UI Offset 0x00): OVL_UI attribute control register</li>
<li>UI Config Top LAddr (OVL_UI_TOP_LADD @ OVL_UI Offset 0x10): OVL_UI top field memory block low address register</li>
<li>UI Config Pitch (OVL_UI_PITCH @ OVL_UI Offset 0x0C): OVL_UI memory pitch register</li>
<li>UI Config Size (OVL_UI_MBSIZE @ OVL_UI Offset 0x04): OVL_UI memory block size register</li>
<li>UI Overlay Size (OVL_UI_SIZE @ OVL_UI Offset 0x88): OVL_UI overlay window size register</li>
<li>IO Config Coord (OVL_UI_COOR @ OVL_UI Offset 0x08): OVL_UI memory block coordinate register</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Set Overlay (fb0 is 720 x 1440)
UI Config Attr:      0x110 3000 = 0xff00 0405
UI Config Top LAddr: 0x110 3010 = 0x4064 a6ac (Address of fb0)
UI Config Pitch:     0x110 300c = 0xb40 (720 * 4)
UI Config Size:      0x110 3004 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
UI Overlay Size:     0x110 3088 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
IO Config Coord:     0x110 3008 = 0x0

Channel 2: Set Overlay (fb1 is 600 x 600)
UI Config Attr:      0x110 4000 = 0xff00 0005
UI Config Top LAddr: 0x110 4010 = 0x404e adac (Address of fb1)
UI Config Pitch:     0x110 400c = 0x960 (600 * 4)
UI Config Size:      0x110 4004 = 0x257 0257 (599 &lt;&lt; 16 + 599)
UI Overlay Size:     0x110 4088 = 0x257 0257 (599 &lt;&lt; 16 + 599)
IO Config Coord:     0x110 4008 = 0x0

Channel 3: Set Overlay (fb2 is 720 x 1440)
UI Config Attr:      0x110 5000 = 0x7f00 0005
UI Config Top LAddr: 0x110 5010 = 0x400f 65ac (Address of fb2)
UI Config Pitch:     0x110 500c = 0xb40 (720 * 4)
UI Config Size:      0x110 5004 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
UI Overlay Size:     0x110 5088 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
IO Config Coord:     0x110 5008 = 0x0</code></pre></div>
<p>Note that UI Config Size and UI Overlay Size are <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
<li>
<p>For Channel 1: Set Blender Output</p>
<ul>
<li>BLD Output Size (BLD_SIZE @ BLD Offset 0x08C): BLD output size setting register</li>
<li>GLB Size (GLB_SIZE @ GLB Offset 0x00C): Global size register</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Set Blender Output
BLD Output Size: 0x110 108c = 0x59f 02cf (1439 * 16 + 719)
GLB Size:        0x110 000c = 0x59f 02cf (1439 * 16 + 719)</code></pre></div></li>
<li>
<p>Set Blender Input Pipe (N = Pipe Number, from 0 to 2 for Channels 1 to 3)</p>
<ul>
<li>BLD Pipe InSize (BLD_CH_ISIZE @ BLD Offset 0x008 + N*0x14): BLD input memory size register(N=0,1,2,3,4)</li>
<li>BLD Pipe FColor (BLD_FILL_COLOR @ BLD Offset 0x004 + N*0x14): BLD fill color register(N=0,1,2,3,4)</li>
<li>BLD Pipe Offset (BLD_CH_OFFSET @ BLD Offset 0x00C + N*0x14): BLD input memory offset register(N=0,1,2,3,4)</li>
<li>BLD Pipe Mode (BLD_CTL @ BLD Offset 0x090 ‚Äì 0x09C): BLD control register</li>
</ul>
<p>(Should <code>N*0x14</code> be <code>N*0x10</code> instead?)</p>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Set Blender Input Pipe 0 (fb0 is 720 x 1440)
BLD Pipe InSize: 0x110 1008 = 0x59f 02cf (1439 * 16 + 719)
BLD Pipe FColor: 0x110 1004 = 0xff00 0000
BLD Pipe Offset: 0x110 100c = 0x0
BLD Pipe Mode:   0x110 1090 = 0x301 0301

Channel 2: Set Blender Input Pipe 1 (fb1 is 600 x 600)
BLD Pipe InSize: 0x110 1018 = 0x257 0257 (599 &lt;&lt; 16 + 599)
BLD Pipe FColor: 0x110 1014 = 0xff00 0000
BLD Pipe Offset: 0x110 101c = 0x34 0034
BLD Pipe Mode:   0x110 1094 = 0x301 0301

Channel 3: Set Blender Input Pipe 2 (fb2 is 720 x 1440)
BLD Pipe InSize: 0x110 1028 = 0x59f 02cf (1439 * 16 + 719)
BLD Pipe FColor: 0x110 1024 = 0xff00 0000
BLD Pipe Offset: 0x110 102c = 0x0
BLD Pipe Mode:   0x110 1098 = 0x301 0301</code></pre></div>
<p>Note that BLD Pipe InSize is <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
<li>
<p>Disable Scaler (assuming we‚Äôre not using Scaler)</p>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Disable Scaler
Mixer: 0x114 0000 = 0x0

Channel 2: Disable Scaler
Mixer: 0x115 0000 = 0x0

Channel 3: Disable Scaler
Mixer: 0x116 0000 = 0x0</code></pre></div></li>
</ol>
</li>
<li>
<p>Set BLD Route and BLD FColor Control</p>
<ul>
<li>BLD Route (BLD_CH_RTCTL @ BLD Offset 0x080): BLD routing control register</li>
<li>BLD FColor Control (BLD_FILLCOLOR_CTL @ BLD Offset 0x000): BLD fill color control register</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Set BLD Route and BLD FColor Control
BLD Route:          0x110 1080 = 0x321
BLD FColor Control: 0x110 1000 = 0x701</code></pre></div></li>
<li>
<p>Apply Settings: GLB DBuff</p>
<ul>
<li>GLB DBuff (GLB_DBUFFER @ GLB Offset 0x008): Global double buffer control register</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Apply Settings
GLB DBuff: 0x110 0008 = 0x1</code></pre></div></li>
</ol>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone">(See the Complete Log)</a></p>
<p>(See Memory Mapping List and Register List at Page 90)</p>

    
</body>
</html>