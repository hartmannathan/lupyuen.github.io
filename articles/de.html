<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rendering PinePhone&#39;s Display (DE and TCON0)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rendering PinePhone's Display (DE and TCON0)" 
    data-rh="true">
<meta property="og:description" 
    content="How does Pine64 PinePhone render graphics on its LCD Display? Let's find out about the Allwinner A64 SoC's Display Engine (DE) and Timing Controller (TCON0)."
    data-rh="true">
<meta name="description" 
    content="How does Pine64 PinePhone render graphics on its LCD Display? Let's find out about the Allwinner A64 SoC's Display Engine (DE) and Timing Controller (TCON0).">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/de-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rendering PinePhone&#39;s Display (DE and TCON0)</h1>
    <nav id="TOC"><ul>
<li><a href="#display-rendering-on-pinephone">1 Display Rendering on PinePhone</a><ul></ul></li>
<li><a href="#display-engine-in-allwinner-a64">2 Display Engine in Allwinner A64</a><ul></ul></li>
<li><a href="#render-colours">3 Render Colours</a><ul></ul></li>
<li><a href="#render-mandelbrot-set">4 Render Mandelbrot Set</a><ul></ul></li>
<li><a href="#animate-madelbrot-set">5 Animate Madelbrot Set</a><ul></ul></li>
<li><a href="#render-square-overlay">6 Render Square Overlay</a><ul></ul></li>
<li><a href="#render-circle-overlay">7 Render Circle Overlay</a><ul></ul></li>
<li><a href="#test-pinephone-display-engine">8 Test PinePhone Display Engine</a><ul></ul></li>
<li><a href="#p-boot-display-code">9 p-boot Display Code</a><ul></ul></li>
<li><a href="#nuttx-display-driver-for-pinephone">10 NuttX Display Driver for PinePhone</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-overview-of-allwinner-a64-display-engine">13 Appendix: Overview of Allwinner A64 Display Engine</a><ul></ul></li>
<li><a href="#appendix-initialising-the-allwinner-a64-display-engine">14 Appendix: Initialising the Allwinner A64 Display Engine</a><ul></ul></li>
<li><a href="#appendix-programming-the-allwinner-a64-display-engine">15 Appendix: Programming the Allwinner A64 Display Engine</a><ul></ul></li></ul></nav><p>üìù <em>30 Oct 2022</em></p>
<p><img src="https://lupyuen.github.io/images/de-title.jpg" alt="PinePhone rendering Mandelbrot Set on Apache NuttX RTOS" /></p>
<p><em>PinePhone rendering Mandelbrot Set on Apache NuttX RTOS</em></p>
<p>In the last 2 articles we talked about <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> (pic above) and how we built a <strong>Display Driver</strong> for PinePhone‚Äôs MIPI Display Serial Interface‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
</ul>
<p>But our PinePhone Display Driver <strong>isn‚Äôt complete</strong>‚Ä¶ It won‚Äôt render any graphics!</p>
<p>Today we‚Äôll learn about the missing bits in our Display Driver‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs the <strong>Display Engine (DE)</strong> inside PinePhone</p>
</li>
<li>
<p>How the <strong>Timing Controller (TCON0)</strong> controls PinePhone‚Äôs LCD Display</p>
</li>
<li>
<p>How we call DE and TCON0 to <strong>render graphics</strong></p>
</li>
<li>
<p>How our new <strong>PinePhone Display Driver</strong> will support DE and TCON0</p>
</li>
</ul>
<p><em>Why are we doing this?</em></p>
<p>We‚Äôre now porting <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> to PinePhone and we have created a (barebones) <a href="https://lupyuen.github.io/articles/dsi2"><strong>Display Driver in Zig</strong></a> that initialises the LCD Display.</p>
<p>To finish the driver, we need to understand what‚Äôs inside PinePhone‚Äôs Display Engine and Timing Controller.</p>
<p>Let‚Äôs dive in and continue the journey from our (super long) <strong>NuttX Porting Journal</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/de-block1a.jpg" alt="Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)</em></a></p>
<h1 id="display-rendering-on-pinephone"><a href="#display-rendering-on-pinephone">1 Display Rendering on PinePhone</a></h1>
<p><em>Suppose we‚Äôre building our own Operating System for PinePhone‚Ä¶</em></p>
<p><em>How do we render graphics on the LCD Display?</em></p>
<p>Rendering graphics directly to PinePhone Hardware (‚ÄúBare Metal‚Äù) is more complicated than we expect!</p>
<p>Let‚Äôs walk through the steps (pic above)‚Ä¶</p>
<ol>
<li>
<p>Inside PinePhone‚Äôs <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> is a <strong>Display Engine</strong> that combines and transforms Pixel Data for display</p>
</li>
<li>
<p>The Display Engine reads the Pixel Data from <strong>Framebuffers in RAM</strong> via <strong>Direct Memory Access (DMA)</strong></p>
<p>(Up to 3 Framebuffers)</p>
</li>
<li>
<p>Inside the Display Engine is a <strong>Real-Time Mixer</strong> (RT Mixer Core 0) that handles real-time <strong>DMA, Overlay, Scaling and Blending</strong> of the Pixel Data (from the Framebuffers)</p>
<p>(We won‚Äôt need RT Mixer Core 1 today, it‚Äôs a smaller version of Core 0)</p>
</li>
<li>
<p>The Real-Time Mixer supports <strong>3 UI Channels</strong> (for graphics), all mixed together into a <strong>Single Image Frame</strong> in real time</p>
<p>(The Mixer supports Video, but we won‚Äôt use it today)</p>
</li>
<li>
<p>The successive Image Frames (generated by the Display Engine) are pumped in real time to the <a href="https://lupyuen.github.io/articles/pio#lcd-controller-tcon0"><strong>Timing Controller (TCON0)</strong></a></p>
</li>
<li>
<p>The Timing Controller pushes the Image Frames to <strong>PinePhone‚Äôs LCD Controller</strong> as a stream of pixels (over MIPI Display Serial Interface)</p>
</li>
</ol>
<p>All this happens in <strong>Real Time</strong>‚Ä¶ Any updates to the Framebuffers in RAM are <strong>pushed out instantly</strong> to the LCD Display.</p>
<p>(Super efficiently thanks to DMA!)</p>
<p><em>Why so complicated?</em></p>
<p>PinePhone‚Äôs ST7703 LCD Controller <strong>doesn‚Äôt have any RAM</strong> inside‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>‚ÄúSitronix ST7703 LCD Controller‚Äù</strong></a></li>
</ul>
<p>That‚Äôs why we need to <strong>pump a constant stream of pixels</strong> to the LCD Display via DMA, Display Engine and Timing Controller‚Ä¶ Otherwise the display stays blank!</p>
<p><a href="https://en.wikipedia.org/wiki/Video_Toaster">(Sounds a bit like the Amiga Video Toaster)</a></p>
<p>Let‚Äôs look inside the Display Engine‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-mixer1a.jpg" alt="Real-Time Mixer in A64 Display Engine (Page 22)" /></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><em>Real-Time Mixer in A64 Display Engine (Page 22)</em></a></p>
<h1 id="display-engine-in-allwinner-a64"><a href="#display-engine-in-allwinner-a64">2 Display Engine in Allwinner A64</a></h1>
<p>Recall that Allwinner A64‚Äôs Display Engine is a <strong>Real-Time Mixer</strong> that handles real-time <strong>DMA, Overlay, Scaling and Blending</strong> of the Framebuffers‚Ä¶</p>
<p>And the Display Engine pushes the output pixels to the <a href="https://lupyuen.github.io/articles/pio#lcd-controller-tcon0"><strong>Timing Controller (TCON0)</strong></a> for display on PinePhone‚Äôs LCD Display.</p>
<p>The pic above shows how the Display Engine mixes together <strong>3 UI Channels (Framebuffers)</strong> via DMA1, 2 and 3.</p>
<p>(Plus a Video Channel on DMA0, but we won‚Äôt use it today)</p>
<p><em>Is the Display Engine documented?</em></p>
<p>The official doc for the A64 Display Engine is here‚Ä¶</p>
<ul>
<li><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>Allwinner Display Engine 2.0 Specifications</strong></a></li>
</ul>
<p>Though it doesn‚Äôt describe the actual steps for programming the Display Engine.</p>
<p>In a while we‚Äôll boot <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> on PinePhone and experiment with the Display Engine, to understand it better.</p>
<p><a href="https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine">(Overview of A64 Display Engine)</a></p>
<p><em>But the Display Engine doc doesn‚Äôt mention A64?</em></p>
<p>PinePhone‚Äôs A64 Display Engine is hidden under <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>Allwinner H3 (page 22)</strong></a>, because Allwinner A64 is actually a H3 upgraded with 64-bit Arm Cores‚Ä¶</p>
<blockquote>
<p>‚ÄúThe A64 is basically an Allwinner H3 with the Cortex-A7 cores replaced with Cortex-A53 cores (ARM64 architecture). They share most of the memory map, clocks, interrupts and also uses the same IP blocks.‚Äù</p>
</blockquote>
<blockquote>
<p><a href="https://linux-sunxi.org/A64">(Source)</a></p>
</blockquote>
<p><em>Why are there 2 Mixers in the A64 Display Engine?</em></p>
<p>Maybe because A64 (or H3) was designed for <a href="https://linux-sunxi.org/H3"><strong>OTT Set-Top Boxes</strong></a> with Picture-In-Picture Overlay Video?</p>
<p>The 3 UI Overlay Channels would be super helpful for overlaying an OTT Graphical UI on top of a Video Channel.</p>
<p><a href="https://en.wikipedia.org/wiki/Pine64#History">(Wait‚Ä¶ Wasn‚Äôt Pine64 created thanks to OTT Boxes? ü§î)</a></p>
<p><img src="https://lupyuen.github.io/images/de-code1a.png" alt="Rendering simple Colour Blocks on the PinePhone Display" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214">(Source)</a></p>
<h1 id="render-colours"><a href="#render-colours">3 Render Colours</a></h1>
<p><em>How do we program the A64 Display Engine to render graphics?</em></p>
<p>Let‚Äôs begin by rendering simple <strong>Colour Blocks</strong> on the PinePhone Display‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-rgb.jpg" alt="Blue, Green, Red Blocks on PinePhone" /></p>
<p>First we <strong>allocate the Framebuffer</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/PinePhone">(PinePhone‚Äôs display resolution is 720 x 1440)</a></p>
<p>Each Pixel occupies <strong>4 bytes</strong>. (ARGB 8888 Format)</p>
<p>Then we <strong>fill the Framebuffer</strong> with Blue, Green and Red: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fill with Blue, Green and Red
for (int i = 0; i &lt; fb0_len; i++) {
  // Colours are in ARGB format
  if (i &lt; fb0_len / 4) {
    // Blue for top quarter
    fb0[i] = 0x80000080;
  } else if (i &lt; fb0_len / 2) {
    // Green for next quarter
    fb0[i] = 0x80008000;
  } else {
    // Red for lower half
    fb0[i] = 0x80800000;
  }
}</code></pre></div>
<p>Each Pixel in the Framebuffer is stored as <strong>32-bit ARGB 8888</strong>.</p>
<p>Thus <strong><code>0x8000</code> <code>8000</code></strong> means Semi-Transparent Green‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Channel</th><th>Value</th></tr></thead><tbody>
<tr><td style="text-align: left">Alpha</td><td><code>0x80</code></td></tr>
<tr><td style="text-align: left">Red</td><td><code>0x00</code></td></tr>
<tr><td style="text-align: left">Green</td><td><code>0x80</code></td></tr>
<tr><td style="text-align: left">Blue</td><td><code>0x00</code></td></tr>
</tbody></table>
</div>
<p>A64 Display Engine lets us render 3 Framebuffers as <strong>3 UI Channels</strong>.</p>
<p>This is how we allocate the 3 UI Channels: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L262">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Allocate 3 UI Channels
static struct display disp;
memset(&amp;disp, 0, sizeof(disp));
struct display *d = &amp;disp;</code></pre></div>
<p><a href="https://megous.com/git/p-boot/tree/src/display.h#n28">(<strong><code>display</code></strong> struct is defined here)</a></p>
<p>We point the <strong>First UI Channel</strong> to our Framebuffer: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L262-L271">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init UI Channel 1: (Base Channel)
// Fullscreen 720 x 1440
d-&gt;planes[0].fb_start = (uintptr_t) fb0;  // Framebuffer Address
d-&gt;planes[0].fb_pitch = 720 * 4;  // Framebuffer Pitch
d-&gt;planes[0].src_w    = 720;   // Source Width
d-&gt;planes[0].src_h    = 1440;  // Source Height
d-&gt;planes[0].dst_w    = 720;   // Dest Width
d-&gt;planes[0].dst_h    = 1440;  // Dest Height</code></pre></div>
<p>(<strong><code>fb_pitch</code></strong> is the number of bytes per row of pixels)</p>
<p>We disable the <strong>Second and Third UI Channels</strong> for now: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L299">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init UI Channel 2: (First Overlay)
// Disable Channel for now
d-&gt;planes[1].fb_start = 0;

// Init UI Channel 3: (Second Overlay)
// Disable Channel for now
d-&gt;planes[2].fb_start = 0;

// Render the UI Channels over DMA
display_commit(d);</code></pre></div>
<p>And we <strong>render the 3 UI Channels</strong>.</p>
<p>(<a href="https://megous.com/git/p-boot/tree/src/display.c#n2017"><strong><code>display_commit</code></strong></a> is defined in the p-boot Display Code, we‚Äôll come back to this)</p>
<p>That‚Äôs all! We should see the <a href="https://lupyuen.github.io/images/de-rgb.jpg"><strong>Blue, Green and Red Blocks</strong></a> like in the pic above.</p>
<p>(Not sure why there are black lines, needs investigation)</p>
<p><em>Didn‚Äôt we set the Alpha Channel to <code>0x80</code>?</em></p>
<p><strong>UI Channel 1</strong> is the Base UI Channel, so the Alpha Channel has no effect.</p>
<p>(Actually UI Channel 1 is configured as <a href="https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine"><strong>XRGB 8888</strong></a>)</p>
<p>In a while we‚Äôll set the Alpha Channels for UI Channels 2 and 3. And the UI Channels will appear as semi-transparent overlays.</p>
<p><img src="https://lupyuen.github.io/images/de-code3a.png" alt="Rendering Mandelbrot Set on PinePhone" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200">(Source)</a></p>
<h1 id="render-mandelbrot-set"><a href="#render-mandelbrot-set">4 Render Mandelbrot Set</a></h1>
<p><em>Colour Blocks are so blah. Are we sure we can render every single pixel correctly?</em></p>
<p>Let‚Äôs render something infinitely more detailed and sophisticated‚Ä¶ <a href="https://en.wikipedia.org/wiki/Mandelbrot_set"><strong>Mandelbrot Set</strong></a>!</p>
<p><img src="https://lupyuen.github.io/images/de-title.jpg" alt="Mandelbrot Set on PinePhone" /></p>
<p>Earlier we created a <strong>Fullscreen Framebuffer</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);</code></pre></div>
<p>Now we fill the Framebuffer with the <strong>Mandelbrot Set</strong>, pixel by pixel: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fill with Mandelbrot Set.
// For every pixel row...
for (int y = 0; y &lt; 1440; y++) {

  // For every pixel column...
  for (int x = 0; x &lt; 720; x++) {

    // Convert Pixel Coordinates to a Complex Number
    float cx = x_start + (y / 1440.0) * (x_end - x_start);
    float cy = y_start + (x / 720.0)  * (y_end - y_start);

    // Compute Manelbrot Set
    int m = mandelbrot(cx, cy);

    // Color depends on the number of iterations.
    // MAX_ITER is 80
    uint8_t hue = 255.0 * m / MAX_ITER;
    uint8_t saturation = 255;
    uint8_t value = (m &lt; MAX_ITER) ? 255 : 0;

    // Convert Hue / Saturation / Value to RGB
    uint32_t rgb = hsvToRgb(hue, saturation, value);

    // Set the Pixel Colour (ARGB Format)
    int p = (y * 720) + x;
    assert(p &lt; fb0_len);
    fb0[p] = 0x80000000 | rgb;
  }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L335-L432">(<strong><code>mandelbrot</code></strong> and <strong><code>hsvToRgb</code></strong> are defined here)</a></p>
<p>Then we initialise the <strong>3 UI Channels</strong> and render them. <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L299">(Like this)</a></p>
<p>The <a href="https://lupyuen.github.io/images/de-title.jpg"><strong>Mandelbrot Set</strong></a> appears on PinePhone, like in the pic above.</p>
<p>Yep we can render every single pixel precisely on PinePhone!</p>
<p><img src="https://lupyuen.github.io/images/de-code4a.png" alt="Animating the Madelbrot Set" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L299-L334">(Source)</a></p>
<h1 id="animate-madelbrot-set"><a href="#animate-madelbrot-set">5 Animate Madelbrot Set</a></h1>
<p><em>Earlier we said that updates to the Framebuffer are instantly pushed to PinePhone‚Äôs Display via DMA‚Ä¶</em></p>
<p><em>Can we prove it?</em></p>
<p>Yep let‚Äôs <strong>animate the Mandelbrot Set</strong> in our Framebuffer. And watch the updates appear instantly on PinePhone‚Äôs Display, thanks to <strong>Direct Memory Access (DMA)</strong>!</p>
<p>This is how we animate the Mandelbrot Set: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L334">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Omitted: Init UI Channels 1, 2 and 3
d-&gt;planes[0].fb_start = ...
d-&gt;planes[1].fb_start = ...
d-&gt;planes[2].fb_start = ...
...

// Render the UI Channels over DMA
display_commit(d);

// Animate the Mandelbrot Set forever.
// For every frame of animation...
for (;;) {

  // Fill with Mandelbrot Set.
  // For every pixel row...
  for (int y = 0; y &lt; 1440; y++) {

    // For every pixel column...
    for (int x = 0; x &lt; 720; x++) {</code></pre></div>
<p>In the code above, we <strong>repeatly render</strong> the Mandelbrot Set for every frame of animation.</p>
<p>We <strong>render each frame</strong> the exact same way as before‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      // Convert Pixel Coordinates to a Complex Number
      float cx = x_start + (y / 1440.0) * (x_end - x_start);
      float cy = y_start + (x / 720.0)  * (y_end - y_start);

      // Compute Manelbrot Set
      int m = mandelbrot(cx, cy);

      // Color depends on the number of iterations
      // MAX_ITER is 80
      uint8_t hue = 255.0 * m / MAX_ITER;
      uint8_t saturation = 255;
      uint8_t value = (m &lt; MAX_ITER) ? 255 : 0;

      // Convert Hue / Saturation / Value to RGB
      uint32_t rgb = hsvToRgb(hue, saturation, value);

      // Set the Pixel Colour (ARGB Format)
      int p = (y * 720) + x;
      assert(p &lt; fb0_len);
      fb0[p] = 0x80000000 | rgb;
    }
  }</code></pre></div>
<p>But now we <strong>tweak slightly the position</strong> of the Mandelbrot Set‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Zoom in to (-1.4, 0)
  float x_dest = -1.4;
  float y_dest = 0;
  x_start += (x_dest - x_start) * 0.05;
  x_end   -= (x_end  - x_dest)  * 0.05;
  y_start += (y_dest - y_start) * 0.05;
  y_end   -= (y_end  - y_dest)  * 0.05;
}</code></pre></div>
<p>Before looping back to render the next frame.</p>
<p>We should see this Animated Mandelbrot Set‚Ä¶</p>
<ul>
<li><a href="https://youtu.be/toC9iiPRwRI"><strong>Demo Video on YouTube</strong></a></li>
</ul>
<p>Thus DMA works correctly for rendering our Framebuffers on the fly!</p>
<p><em>We don‚Äôt call <code>display_commit</code> after every frame?</em></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L296-L299"><strong><code>display_commit</code></strong></a> only needs to be called once. It configures the Display Engine to read our Framebuffer directly via DMA.</p>
<p>Subsequent updates to the Framebuffer will be automatically pushed to the display over DMA.</p>
<p><img src="https://lupyuen.github.io/images/de-code5b.png" alt="Rendering a Square Overlay on PinePhone" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226">(Source)</a></p>
<h1 id="render-square-overlay"><a href="#render-square-overlay">6 Render Square Overlay</a></h1>
<p><em>Earlier we said that A64 Display Engine can render Framebuffers as Overlays. How can we do it?</em></p>
<p>The pic below shows that A64 Display Engine can render <strong>3 Framebuffers (UI Channels)</strong> as overlays, via DMA1, 2 and 3‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-mixer1a.jpg" alt="Real-Time Mixer in A64 Display Engine (Page 22)" /></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><em>Real-Time Mixer in A64 Display Engine (Page 22)</em></a></p>
<p>(Skipping DMA0 because it‚Äôs for Video only)</p>
<p>The UI Channels are rendered as overlays in a specific sequence (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>UI Channel 2</strong> (DMA2) is rendered on top of <strong>UI Channel 1</strong> (DMA1), then‚Ä¶</p>
</li>
<li>
<p><strong>UI Channel 3</strong> (DMA3) is rendered on top of <strong>UI Channel 2</strong> (DMA2)</p>
</li>
</ul>
<p>Our Mandelbrot Set is rendered on <strong>UI Channel 1</strong> (DMA1), which is the Base Channel.</p>
<p>Let‚Äôs overlay a <strong>Blue Square</strong> on <strong>UI Channel 2</strong> (DMA2).</p>
<p>First we prepare a <strong>600 x 600 Framebuffer</strong> that contains a Semi-Transparent Blue Square: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 1:
// Square 600 x 600 (4 bytes per ARGB pixel)
// fb1_len is 600 * 600
static uint32_t fb1[600 * 600];
int fb1_len = sizeof(fb1) / sizeof(fb1[0]);

// Fill with Semi-Transparent Blue
for (int i = 0; i &lt; fb1_len; i++) {
  // Colours are in ARGB format
  fb1[i] = 0x80000080;
}</code></pre></div>
<p>The new Framebuffer is a little <strong>smaller than the Screen Width</strong>. (600 pixels vs 720 pixels)</p>
<p>Thanks to <strong>Framebuffer Blending</strong> in A64 Display Engine, it‚Äôs perfectly OK to render the new Framebuffer at 600 x 600. (As a partial screen region).</p>
<p>This is how we set <strong>UI Channel 2</strong> to the 600 x 600 Framebuffer: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L283">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init UI Channel 2: (First Overlay)
// Square 600 x 600
d-&gt;planes[1].fb_start = (uintptr_t) fb1;  // Framebuffer Address
d-&gt;planes[1].fb_pitch = 600 * 4;  // Framebuffer Pitch
d-&gt;planes[1].src_w    = 600;  // Source Width
d-&gt;planes[1].src_h    = 600;  // Source Height
d-&gt;planes[1].dst_w    = 600;  // Dest Width
d-&gt;planes[1].dst_h    = 600;  // Dest Height
d-&gt;planes[1].dst_x    = 52;   // Dest X Offset
d-&gt;planes[1].dst_y    = 52;   // Dest Y Offset</code></pre></div>
<p><em>Can the Dest Width / Height be different from the Source Width / Height?</em></p>
<p>Yes, because the Display Engine supports Scaling. But we won‚Äôt do that today, to simplify our discussion.</p>
<p>Before we watch the outcome, let‚Äôs render another overlay‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-code5c.png" alt="Rendering a Circle Overlay on PinePhone" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251">(Source)</a></p>
<h1 id="render-circle-overlay"><a href="#render-circle-overlay">7 Render Circle Overlay</a></h1>
<p>Our PinePhone UI Overlay Sandwich has these goodies inside‚Ä¶</p>
<ul>
<li>
<p><strong>UI Channel 1</strong>: Mandelbrot Set (Base Channel)</p>
</li>
<li>
<p><strong>UI Channel 2</strong>: Semi-Transparent Blue Square</p>
</li>
</ul>
<p>Let‚Äôs top off our Cucumber Sandwich‚Ä¶</p>
<ul>
<li><strong>UI Channel 3</strong>: Semi-Transparent Green Circle</li>
</ul>
<p>First we fill a Fullscreen Framebuffer with a <strong>Semi-Transparent Green Circle</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init Framebuffer 2:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb2_len is 720 * 1440
static uint32_t fb2[720 * 1440];
int fb2_len = sizeof(fb2) / sizeof(fb2[0]);

// Fill with Semi-Transparent Green Circle.
// For every pixel row...
for (int y = 0; y &lt; 1440; y++) {

  // For every pixel column...
  for (int x = 0; x &lt; 720; x++) {

    // Get pixel index
    int p = (y * 720) + x;
    assert(p &lt; fb2_len);

    // Shift coordinates so that centre of screen is (0,0)
    int x_shift = x - 360;
    int y_shift = y - 720;

    // If pixel is inside circle (x^2 + y^2 &lt; radius^2)...
    // Set the pixel to Semi-Transparent Green
    if (x_shift*x_shift + y_shift*y_shift &lt; 360*360) {
      fb2[p] = 0x80008000;  // Semi-Transparent Green in ARGB Format
    } else {  // Otherwise set to Transparent Black
      fb2[p] = 0x00000000;  // Transparent Black in ARGB Format
    }
  }
}</code></pre></div>
<p>Note that pixels outside the circle are set to <strong>Transparent Black</strong>.</p>
<p>(Which makes them invisible)</p>
<p>Next we point <strong>UI Channel 3</strong> to the Fullscreen Framebuffer: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L283-L296">test_display.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init UI Channel 3: (Second Overlay)
// Fullscreen 720 x 1440 with Alpha Blending
d-&gt;planes[2].fb_start = (uintptr_t) fb2;  // Framebuffer Address
d-&gt;planes[2].fb_pitch = 720 * 4;  // Framebuffer Pitch
d-&gt;planes[2].src_w    = 720;   // Source Width
d-&gt;planes[2].src_h    = 1440;  // Source Height
d-&gt;planes[2].dst_w    = 720;   // Dest Width
d-&gt;planes[2].dst_h    = 1440;  // Dest Height
d-&gt;planes[2].dst_x    = 0;     // Dest X
d-&gt;planes[2].dst_y    = 0;     // Dest Y
d-&gt;planes[2].alpha    = 128;   // Dest Alpha</code></pre></div>
<p>Note that we set the <strong>Destination Alpha</strong> for the entire UI Channel. So our Green Circle will appear super transparent.</p>
<p>Finally we render the 3 UI Channels‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Render the UI Channels over DMA
display_commit(d);</code></pre></div>
<p>We should see the Animated Mandelbrot Set, with Blue Square and (very faint) Green Circle as Overlays. (Pic below)</p>
<p>That‚Äôs how we render 3 UI Channels (with overlay blending) on PinePhone‚Äôs Display Engine!</p>
<p>(Why the horizontal lines in the Blue Square and Green Circle?)</p>
<p><img src="https://lupyuen.github.io/images/de-overlay.jpg" alt="Mandelbrot Set with Blue Square and Green Circle as Overlays" /></p>
<p><em>Mandelbrot Set with Blue Square and Green Circle as Overlays</em></p>
<h1 id="test-pinephone-display-engine"><a href="#test-pinephone-display-engine">8 Test PinePhone Display Engine</a></h1>
<p><em>We‚Äôve seen the Test Code for Display Engine‚Ä¶ How do we run the code?</em></p>
<p>To test the A64 Display Engine, we‚Äôll boot <strong>Apache NuttX RTOS</strong> on PinePhone and run our Test App‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c"><strong>test_display.c</strong></a></li>
</ul>
<p>Follow these steps to <strong>download NuttX RTOS</strong> (with our Test App inside) to a microSD Card‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#test-pinephone-display-engine"><strong>‚ÄúTest PinePhone Display Engine‚Äù</strong></a></li>
</ul>
<p>Connect our computer to PinePhone via a <a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><strong>USB Serial Debug Cable</strong></a>. (At 115.2 kbps)</p>
<p>Boot PinePhone with NuttX RTOS in the microSD Card.</p>
<p>(NuttX won‚Äôt disturb the eMMC Flash Memory)</p>
<p>At the NuttX Shell, enter this command to run our <strong>Test App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>hello</code></pre></div>
<p>Our Test App controls the A64 Display Engine by setting the Hardware Registers (for the 3 UI Channels)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>HELLO NUTTX ON PINEPHONE!
...
Shell (NSH) NuttX-11.0.0-RC2
nsh&gt; hello
...
display_commit
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0
Channel 1: Set Overlay ...
Channel 1: Set Blender Output ...
Channel 1: Set Blender Input Pipe 0 ...
Channel 1: Disable Scaler ...
Channel 2: Set Overlay ...
Channel 2: Set Blender Input Pipe 1 ...
Channel 2: Disable Scaler ...
Channel 3: Set Overlay ...
Channel 3: Set Blender Input Pipe 2 ...
Channel 3: Disable Scaler ...
Set BLD Route and BLD FColor Control
  BLD Route:          0x1101080 = 0x321
  BLD FColor Control: 0x1101000 = 0x701
Apply Settings
  GLB DBuff: 0x1100008 = 0x1</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone">(See the Complete Log)</a></p>
<p>And the Mandelbrot Set appears on PinePhone, together with the Blue Square and Green Circle as overlays. (Pic above)</p>
<p>Yep we have successfully tested the A64 Display Engine on PinePhone! üéâ</p>
<p><em>Hmmm building the Test Code looks complicated‚Ä¶</em></p>
<p>Yeah we need a few steps to build the Test Code because we patched together a few programs to make it work‚Ä¶</p>
<ul>
<li>
<p><strong>Apache NuttX RTOS</strong> for PinePhone</p>
<p><a href="https://lupyuen.github.io/articles/uboot">(See this)</a></p>
</li>
<li>
<p><strong>Zig Driver</strong> for MIPI Display Serial Interface</p>
<p><a href="https://lupyuen.github.io/articles/dsi2">(More about this)</a></p>
</li>
<li>
<p><strong>p-boot Display Code</strong></p>
<p><a href="https://lupyuen.github.io/articles/de#p-boot-display-code">(See the next chapter)</a></p>
</li>
</ul>
<p>The steps will be a lot simpler when we have completed the  Display Engine Driver for NuttX.</p>
<p>Let‚Äôs talk about the p-boot Display Code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-run.png" alt="Running p-boot Display Code on Apache NuttX RTOS with logging" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone"><em>Running p-boot Display Code on Apache NuttX RTOS with logging</em></a></p>
<h1 id="p-boot-display-code"><a href="#p-boot-display-code">9 p-boot Display Code</a></h1>
<p><em>About the code that controls A64 Display Engine‚Ä¶ Where is <code>display_commit</code> defined?</em></p>
<p><a href="https://megous.com/git/p-boot/tree/src/display.c#n2017"><strong><code>display_commit</code></strong></a> comes from the super-helpful <a href="https://xnux.eu/p-boot/"><strong>p-boot PinePhone Bootloader</strong></a> project, which runs directly on PinePhone Hardware. (‚ÄúBare Metal‚Äù)</p>
<p>To test the A64 Display Engine on Apache NuttX RTOS, we borrowed these <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L135-L142"><strong>Source Files</strong></a> (relevant to the Display Engine) from p-boot‚Ä¶</p>
<ul>
<li><a href="https://megous.com/git/p-boot/tree/src/display.c"><strong>display.c</strong></a></li>
<li><a href="https://megous.com/git/p-boot/tree/src/pmic.c"><strong>pmic.c</strong></a></li>
<li><a href="https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c"><strong>clock_sun6i.c</strong></a></li>
<li><a href="https://megous.com/git/p-boot/tree/src/uboot/drivers/gpio/sunxi_gpio.c"><strong>sunxi_gpio.c</strong></a></li>
<li><a href="https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/pinmux.c"><strong>pinmux.c</strong></a></li>
</ul>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L115-L135">(Plus a whole bunch of Header Files)</a></p>
<p>Then we modified the above files to compile on NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip"><strong>Modified p-boot Display Code</strong></a></li>
</ul>
<p>Which lets us experiment with the A64 Display Engine on NuttX.</p>
<p><em>How does it control the A64 Display Engine?</em></p>
<p><a href="https://megous.com/git/p-boot/tree/src/display.c#n2017"><strong><code>display_commit</code></strong></a> controls the A64 Display Engine by writing to the <strong>Hardware Registers</strong> for the Display Engine.</p>
<p>The Display Engine‚Äôs Hardware Registers are described here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine"><strong>‚ÄúOverview of Allwinner A64 Display Engine‚Äù</strong></a></li>
</ul>
<p><em>But what values does <code>display_commit</code> write to the Hardware Registers?</em></p>
<p>To find out how <a href="https://megous.com/git/p-boot/tree/src/display.c#n2017"><strong><code>display_commit</code></strong></a> updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to <strong>log all Register Writes</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip"><strong>Modified p-boot Display Code</strong></a></li>
</ul>
<p>Which tells us all the <strong>Hardware Registers and their values</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0

Channel 1: Set Overlay
  UI Config Attr:      0x1103000 = 0xff000405
  UI Config Top LAddr: 0x1103010 = 0x4064a6ac
  UI Config Pitch:     0x110300c = 0xb40
  UI Config Size:      0x1103004 = 0x59f02cf
  UI Overlay Size:     0x1103088 = 0x59f02cf
  IO Config Coord:     0x1103008 = 0x0

Channel 1: Set Blender Output
  BLD Output Size: 0x110108c = 0x59f02cf
  GLB Size:        0x110000c = 0x59f02cf

Channel 1: Set Blender Input Pipe 0
  BLD Pipe InSize: 0x1101008 = 0x59f02cf
  BLD Pipe FColor: 0x1101004 = 0xff000000
  BLD Pipe Offset: 0x110100c = 0x0
  BLD Pipe Mode:   0x1101090 = 0x3010301

Channel 1: Disable Scaler
  Mixer: 0x1140000 = 0x0

Channel 2: ...</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone">(See the Complete Log)</a></p>
<p>When we study the log, we‚Äôll understand how we should <strong>program the A64 Display Engine</strong> to render the 3 UI Channels.</p>
<p>Our findings are documented here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>‚ÄúProgramming the Allwinner A64 Display Engine‚Äù</strong></a></li>
</ul>
<p>This is very helpful as we create the NuttX Display Driver for PinePhone‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Testing the NuttX Display Driver for PinePhone" /></p>
<p><a href="https://lupyuen.github.io/articles/dsi2"><em>Testing the NuttX Display Driver for PinePhone</em></a></p>
<h1 id="nuttx-display-driver-for-pinephone"><a href="#nuttx-display-driver-for-pinephone">10 NuttX Display Driver for PinePhone</a></h1>
<p><em>Once again, why are we doing all this?</em></p>
<p>We‚Äôre now porting <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> to PinePhone.</p>
<p>Someday we hope to have a <strong>fully-functional PinePhone</strong> running on NuttX RTOS‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/arm#pinephone-on-rtos"><strong>‚ÄúPinePhone on RTOS‚Äù</strong></a></li>
</ul>
<p>(Or maybe just run PinePhone on NuttX as a simple touchscreen gadget)</p>
<p>To do that, we need a <strong>NuttX Display Driver</strong>.</p>
<p>That‚Äôs why we‚Äôre probing the internals of PinePhone, to learn everything we need to build the driver.</p>
<p>We‚Äôve documented our earlier research on PinePhone‚Äôs <strong>MIPI Display Serial Interface</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></li>
</ul>
<p>Today we learnt so much about PinePhone‚Äôs <strong>A64 Display Engine</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>‚ÄúProgramming the Allwinner A64 Display Engine‚Äù</strong></a></li>
</ul>
<p>We‚Äôre all set to build the NuttX Display Driver for PinePhone!</p>
<p><em>How shall we build the PinePhone Display Driver?</em></p>
<p>We‚Äôll create the PinePhone Display Driver based on the <strong>NuttX Driver for Sitronix ST7789</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/lcd/st7789.c"><strong>nuttx/drivers/lcd/st7789.c</strong></a></li>
</ul>
<p>That‚Äôs because ST7789 is somewhat similar to PinePhone‚Äôs ST7703 LCD Controller.</p>
<p><em>But ST7789 doesn‚Äôt support Framebuffers?</em></p>
<p>Yeah for PinePhone we‚Äôll wrap the A64 DMA Framebuffers with this interface for <strong>NuttX Framebuffers</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/video/fb.h"><strong>nuttx/include/nuttx/video/fb.h</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/video/fb.c"><strong>nuttx/drivers/video/fb.c</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/lcd/lcd_framebuffer.c"><strong>nuttx/drivers/lcd/lcd_framebuffer.c</strong></a></p>
</li>
</ul>
<p>And we might get inspired by this implementation of <strong>Display Overlays</strong> in the STM32 LCD TFT Display Controller (LTDC)‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/arch/arm/src/stm32/stm32_ltdc.c"><strong>nuttx/arch/arm/src/stm32/stm32_ltdc.c</strong></a></li>
</ul>
<p>We have started the <strong>Zig Implementation</strong> of the NuttX Driver (for MIPI Display Serial Interface)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></li>
</ul>
<p>We‚Äôll add the A64 Display Engine in the next article!</p>
<p><img src="https://lupyuen.github.io/images/de-test.jpg" alt="Testing the A64 Display Engine on PinePhone" /></p>
<h1 id="notes"><a href="#notes">11 Notes</a></h1>
<ol>
<li>
<p>Some parts of the PinePhone DE and TCON0 Drivers still need to be reverse-engineered‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init"><strong>de2_init</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#tcon0_init"><strong>tcon0_init</strong></a></p>
</li>
</ol>
<h1 id="whats-next"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>I hope we learnt lots today about <strong>Display Rendering on PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs the <a href="https://lupyuen.github.io/articles/de#display-rendering-on-pinephone"><strong>Display Engine (DE)</strong></a> inside PinePhone</p>
</li>
<li>
<p>How the <a href="https://lupyuen.github.io/articles/pio#lcd-controller-tcon0"><strong>Timing Controller (TCON0)</strong></a> controls PinePhone‚Äôs LCD Display</p>
</li>
<li>
<p>How we call DE and TCON0 to <a href="https://lupyuen.github.io/articles/de#render-colours"><strong>render graphics</strong></a></p>
</li>
<li>
<p>How our new <a href="https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone"><strong>PinePhone Display Driver</strong></a> will support DE and TCON0</p>
</li>
</ul>
<p>Please join me in the next article as we create the PinePhone Display Engine Driver for <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a>!</p>
<p>Check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/ygz5kt/rendering_pinephones_display_de_and_tcon0/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Current Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/de.md"><strong>lupyuen.github.io/src/de.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/de-block1a.jpg" alt="Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)" /></p>
<p><a href="https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf"><em>Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)</em></a></p>
<h1 id="appendix-overview-of-allwinner-a64-display-engine"><a href="#appendix-overview-of-allwinner-a64-display-engine">13 Appendix: Overview of Allwinner A64 Display Engine</a></h1>
<p>The official doc for the <strong>Allwinner A64 Display Engine</strong> is here‚Ä¶</p>
<ul>
<li><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>Allwinner Display Engine 2.0 Specifications</strong></a></li>
</ul>
<p>PinePhone‚Äôs A64 Display Engine is hidden under <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><strong>Allwinner H3 (page 22)</strong></a>, because Allwinner A64 is actually a H3 upgraded with <a href="https://linux-sunxi.org/A64"><strong>64-bit Arm Cores</strong></a>.</p>
<p>(Also check out this <a href="https://linux-sunxi.org/DE2_Register_Guide"><strong>DE2 Register Guide</strong></a>)</p>
<p>Earlier we said that Allwinner A64‚Äôs Display Engine is a <strong>Real-Time Mixer</strong> that handles real-time <strong>DMA, Overlay, Scaling and Blending</strong> of the Framebuffers‚Ä¶</p>
<p>And the Display Engine pushes the output pixels to the <a href="https://lupyuen.github.io/articles/pio#lcd-controller-tcon0"><strong>Timing Controller (TCON0)</strong></a> for display on PinePhone‚Äôs LCD Display‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#display-rendering-on-pinephone"><strong>‚ÄúDisplay Rendering on PinePhone‚Äù</strong></a></li>
</ul>
<p>According to the doc, the <strong>Display Engine Base Address</strong> is <strong><code>0x0100</code> <code>0000</code></strong> <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
<p><em>What‚Äôs a Display Engine Mixer?</em></p>
<p><strong>DE RT-MIXER:</strong> <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 87)</a></p>
<blockquote>
<p>‚ÄúThe RT-mixer Core consist of dma, overlay, scaler and blender block. It supports 4 layers overlay in one pipe, and its result can scaler up or down to blender in the next processing.‚Äù</p>
</blockquote>
<p>The Display Engine has 2 Mixers: RT-MIXER0 and RT-MIXER1.</p>
<p><strong>DE RT-MIXER0</strong> has 4 Channels (DE Offset <strong><code>0x10</code> <code>0000</code></strong>, <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">DE Page 87</a>)</p>
<ul>
<li>
<p><strong>Channel 0</strong> for Video</p>
<p>(DMA0, Video Overlay, Video Scaler)</p>
</li>
<li>
<p><strong>Channels 1, 2 and 3</strong> for UI</p>
<p>(DMA1 / 2 / 3, 3 x UI Overlays, 3 x UI Scalers, 3 x UI Blenders)</p>
</li>
<li>
<p><strong>4 Overlay Layers</strong> per Channel</p>
<p>(We only use 1 Overlay Layer per Channel)</p>
</li>
<li>
<p><strong>Layer Priority</strong> is Layer 3 &gt; Layer2 &gt; Layer 1 &gt; Layer 0 <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 89)</a></p>
</li>
</ul>
<p>Our Display Engine Demo <strong>configures the 4 Channels</strong> as follows‚Ä¶</p>
<ul>
<li>
<p><strong>Channel 0</strong> is unused</p>
<p>(No video right now)</p>
</li>
<li>
<p><strong>Channel 1</strong> has Pixel Format XRGB 8888</p>
<p>(Alpha Channel is disabled)</p>
</li>
<li>
<p><strong>Channels 2 and 3</strong> have Pixel Format ARGB 8888</p>
<p>(Alpha Channel is enabled)</p>
</li>
</ul>
<p><strong>Hardware Registers</strong> for RT-MIXER0 <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 90)</a>‚Ä¶</p>
<div><table><thead><tr><th>Hardware Register</th><th>RT-MIXER0 Offset</th></tr></thead><tbody>
<tr><td><strong>GLB</strong> (Global Registers)</td><td><strong><code>0x00</code> <code>0000</code></strong></td></tr>
<tr><td><strong>BLD</strong> (Blender)</td><td><strong><code>0x00</code> <code>1000</code></strong></td></tr>
<tr><td><strong>OVL_V(CH0)</strong> (Video Overlay / Channel 0)</td><td><strong><code>0x00</code> <code>2000</code></strong></td></tr>
<tr><td><strong>OVL_UI(CH1)</strong> (UI Overlay / Channel 1)</td><td><strong><code>0x00</code> <code>3000</code></strong></td></tr>
<tr><td><strong>OVL_UI(CH2)</strong> (UI Overlay / Channel 2)</td><td><strong><code>0x00</code> <code>4000</code></strong></td></tr>
<tr><td><strong>OVL_UI(CH3)</strong> (UI Overlay / Channel 3)</td><td><strong><code>0x00</code> <code>5000</code></strong></td></tr>
<tr><td><strong>VIDEO_SCALER(CH0)</strong> (Video Scaler / Channel 0)</td><td><strong><code>0x02</code> <code>0000</code></strong></td></tr>
<tr><td><strong>UI_SCALER1(CH1)</strong> (UI Scaler / Channel 1)</td><td><strong><code>0x04</code> <code>0000</code></strong></td></tr>
<tr><td><strong>UI_SCALER2(CH2)</strong> (UI Scaler / Channel 2)</td><td><strong><code> 0x05</code> <code>0000</code></strong></td></tr>
<tr><td><strong>UI_SCALER3(CH3)</strong> (UI Scaler / Channel 3)</td><td><strong><code> 0x06</code> <code>0000</code></strong></td></tr>
<tr><td><strong>POST_PROC1</strong> (Post Processor 1)</td><td><strong><code>0x0A</code> <code>0000</code></strong></td></tr>
<tr><td><strong>POST_PROC2</strong> (Post Processor 2)</td><td><strong><code>0x0B</code> <code>0000</code></strong></td></tr>
<tr><td><strong>DMA</strong> (Direct Memory Access)</td><td><strong><code>0x0C</code> <code>0000</code></strong></td></tr>
</tbody></table>
</div>
<p>The pic below shows how DE RT-MIXER0 mixes together <strong>3 UI Channels (Framebuffers)</strong> via DMA1, 2 and 3 (plus a Video Channel on DMA0)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de-mixer1a.jpg" alt="Real-Time Mixer in A64 Display Engine (Page 22)" /></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf"><em>Real-Time Mixer in A64 Display Engine (Page 22)</em></a></p>
<p><strong>DE RT-MIXER1</strong> has 2 Channels (DE Offset <strong><code>0x20</code> <code>0000</code></strong>, <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">DE Page 23</a>)</p>
<ul>
<li>
<p><strong>Channel 0</strong> for Video </p>
<p>(DMA0, Video Overlay, Video Scaler)</p>
</li>
<li>
<p><strong>Channel 1</strong> for UI </p>
<p>(DMA1, UI Overlay, UI Scaler, UI Blender)</p>
</li>
</ul>
<p>(We don‚Äôt use RT-MIXER1 right now)</p>
<p>RT-MIXER0 and RT-MIXER1 are multiplexed to <strong>Timing Controller TCON0</strong>. <a href="https://lupyuen.github.io/images/de-block1a.jpg">(Like this)</a></p>
<p>TCON0 is connected to PinePhone‚Äôs <strong>ST7703 LCD Controller</strong> over MIPI Display Serial Interface. <a href="https://lupyuen.github.io/articles/dsi">(See this)</a></p>
<p>Hence RT-MIXER0 <strong>mixes 1 Video Channel with 3 UI Channels</strong> over DMA. And pumps the pixels continuously to ST7703 LCD Controller. (Via the Timing Controller TCON0)</p>
<p>In today‚Äôs demo we used the 3 UI Channels to render (pic below)‚Ä¶</p>
<ol>
<li>Mandelbrot Set</li>
<li>Blue Square</li>
<li>Green Circle</li>
</ol>
<p>In the following chapters we explain how the 3 UI Channels were initialised and rendered by setting the Hardware Registers for A64 Display Engine‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine"><strong>‚ÄúInitialising the Allwinner A64 Display Engine‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>‚ÄúProgramming the Allwinner A64 Display Engine‚Äù</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/de-overlay.jpg" alt="Mandelbrot Set with Blue Square and Green Circle as Overlays" /></p>
<p><a href="https://lupyuen.github.io/articles/de#test-pinephone-display-engine"><em>Mandelbrot Set with Blue Square and Green Circle as Overlays</em></a></p>
<p>We won‚Äôt use these Display Engine Features today‚Ä¶</p>
<p><strong>DE RT-WB (Write-Back Controller):</strong> <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 116)</a></p>
<blockquote>
<p>‚ÄúThe Real-time write-back controller (RT-WB) provides data capture function for display engine. It captures data from RT-mixer module, performs the image resizing function, and then write-back to SDRAM.‚Äù</p>
</blockquote>
<p>(For screen capture?)</p>
<p><strong>DE VSU (Video Scaler):</strong> <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 128)</a></p>
<blockquote>
<p>‚ÄúThe Video Scaler (VS) provides YUV format image resizing function for display engine. It receives data from overlay module, performs the image resizing function, and outputs to video post-processing modules.‚Äù</p>
</blockquote>
<p><strong>DE Rotation:</strong> <a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 137)</a></p>
<blockquote>
<p>‚ÄúThere are several types of rotation: clockwise 0/90/180/270 degree Rotation and H-Flip/V-Flip. Operation of Copy is the same as a 0 degree rotation.‚Äù</p>
</blockquote>
<h1 id="appendix-initialising-the-allwinner-a64-display-engine"><a href="#appendix-initialising-the-allwinner-a64-display-engine">14 Appendix: Initialising the Allwinner A64 Display Engine</a></h1>
<p><em>How do we initialise PinePhone‚Äôs Allwinner A64 Display Engine at startup?</em></p>
<p>As deciphered from the following logs‚Ä¶</p>
<ul>
<li>
<p><a href="https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init"><strong><code>de2_init</code> Log</strong></a> </p>
<p>(Captured from <a href="https://megous.com/git/p-boot/tree/src/display.c#n1871"><strong>p-boot <code>de2_init</code></strong></a>)</p>
</li>
<li>
<p><a href="https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#clock_set_pll_de"><strong><code>clock_set_pll_de</code> Log</strong></a></p>
<p>(Captured from <a href="https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c#n260"><strong>p-boot <code>clock_set_pll_de</code></strong></a>)</p>
</li>
</ul>
<p>Below are the steps to <strong>initialise the Allwinner A64 Display Engine</strong> at startup‚Ä¶</p>
<ol>
<li>
<p>Set <strong>High Speed SRAM</strong> to DMA Mode‚Ä¶</p>
<ul>
<li>
<p>Set <strong>BIST_DMA_CTRL_SEL</strong> to <strong>0</strong> for DMA <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a></p>
<p><a href="https://github.com/allwinner-zh/documents/raw/master/A31/A31_User_Manual_v1.3_20150510.pdf">(A31 Page 191)</a></p>
</li>
<li>
<p><strong>BIST_DMA_CTRL_SEL</strong> (Bist and DMA Control Select) is <strong>Bit 0</strong> of SRAM_CTRL_REG1</p>
</li>
<li>
<p><strong>SRAM_CTRL_REG1</strong> (SRAM Control Register 1) is at SRAM Registers Offset <strong><code>0x4</code></strong></p>
</li>
<li>
<p><strong>SRAM Registers</strong> Base Address is <strong><code>0x01C0</code> <code>0000</code></strong></p>
<p><a href="https://github.com/allwinner-zh/documents/raw/master/A31/A31_User_Manual_v1.3_20150510.pdf">(A31 Page 191)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Set SRAM for video use
  0x1c00004 = 0x0 (DMB)</code></pre></div></li>
<li>
<p>Set <strong>Display Engine PLL</strong> to 297 MHz‚Ä¶</p>
<ul>
<li>
<p>Set <strong>PLL_DE_CTRL_REG</strong> to <strong><code>0x8100</code> <code>1701</code></strong> <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a></p>
<p><strong>PLL_ENABLE</strong> (Bit 31) = 1 (Enable PLL)</p>
<p><strong>PLL_MODE_SEL</strong> (Bit 24) = 1 (Integer Mode)</p>
<p><strong>PLL_FACTOR_N</strong> (Bits 8 to 14) = 23 (N = 24)</p>
<p><strong>PLL_PRE_DIV_M</strong> (Bits 0 to 3) = 1 (M = 2)</p>
<p>(PLL Output = 24 MHz * N / M = 288 MHz, due to truncation)</p>
</li>
<li>
<p><strong>PLL_DE_CTRL_REG</strong> (PLL Display Engine Control Register) is at CCU Offset <strong><code>0x0048</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 96)</a></p>
</li>
<li>
<p><strong>CCU</strong> (Clock Control Unit) Base Address is <strong><code>0x01C2</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 81)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Setup DE2 PLL
  clock_set_pll_de: clk=297000000
  PLL10 rate = 24000000 * n / m
  0x1c20048 = 0x81001701 (DMB)</code></pre></div></li>
<li>
<p>Wait for <strong>Display Engine PLL</strong> to be set‚Ä¶</p>
<ul>
<li>Poll <strong>PLL_DE_CTRL_REG</strong> (from above) until it‚Äôs non-zero</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Setup DE2 PLL
  ...
  while (!(readl(0x1c20048) &amp; 0x10000000))</code></pre></div></li>
<li>
<p>Set <strong>Special Clock</strong> to Display Engine PLL‚Ä¶</p>
<ul>
<li>
<p>Clear <strong>DE_CLK_REG</strong> bits <strong><code>0x0300</code> <code>0000</code></strong></p>
<p>Set <strong>DE_CLK_REG</strong>   bits <strong><code>0x8100</code> <code>0000</code></strong></p>
<p><strong>SCLK_GATING</strong> (Bit 31) = 1 (Enable Special Clock)</p>
<p><strong>CLK_SRC_SEL</strong> (Bits 24 to 26) = 1 (Clock Source is Display Engine PLL)</p>
</li>
<li>
<p><strong>DE_CLK_REG</strong> (Display Engine Clock Register) is at CCU Offset <strong><code>0x0104</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 117)</a></p>
</li>
<li>
<p><strong>CCU</strong> (Clock Control Unit) Base Address is <strong><code>0x01C2</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 81)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable DE2 special clock
  clrsetbits 0x1c20104, 0x3000000, 0x81000000</code></pre></div></li>
<li>
<p>Enable <strong>AHB (AMBA High-speed Bus)</strong> for Display Engine: De-Assert Display Engine‚Ä¶</p>
<ul>
<li>
<p>Set <strong>BUS_SOFT_RST_REG1</strong> bits <strong><code>0x1000</code></strong></p>
<p><strong>DE_RST</strong> (Bit 12) = 1 (De-Assert Display Engine)</p>
</li>
<li>
<p><strong>BUS_SOFT_RST_REG1</strong> (Bus Software Reset Register 1) is at CCU Offset <code>0x02C4</code></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 140)</a></p>
</li>
<li>
<p><strong>CCU</strong> (Clock Control Unit) Base Address is <strong><code>0x01C2</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 81)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable DE2 ahb
  setbits 0x1c202c4, 0x1000</code></pre></div></li>
<li>
<p>Enable <strong>AHB (AMBA High-speed Bus)</strong> for Display Engine: Pass Display Engine‚Ä¶</p>
<ul>
<li>
<p>Set <strong>BUS_CLK_GATING_REG1</strong> bits <strong><code>0x1000</code></strong></p>
<p><strong>DE_GATING</strong> (Bit 12) = 1 (Pass Display Engine)</p>
</li>
<li>
<p><strong>BUS_CLK_GATING_REG1</strong> (Bus Clock Gating Register 1) is at CCU Offset <strong><code>0x0064</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 102)</a></p>
</li>
<li>
<p><strong>CCU</strong> (Clock Control Unit) Base Address is <strong><code>0x01C2</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf">(A64 Page 81)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable DE2 ahb
  setbits 0x1c20064, 0x1000</code></pre></div></li>
<li>
<p>Enable <strong>Clock for MIXER0</strong>: SCLK Clock Pass</p>
<ul>
<li>
<p>Set <strong>SCLK_GATE</strong> bits <strong><code>0x1</code></strong></p>
<p><strong>CORE0_SCLK_GATE</strong> (Bit 0) = 1 (Clock Pass)</p>
</li>
<li>
<p><strong>SCLK_GATE</strong> is at DE Offset <strong><code>0x000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 25)</a></p>
</li>
<li>
<p><strong>Display Engine (DE)</strong> Base Address is <strong><code>0x0100</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable clock for mixer 0, set route MIXER0-&gt;TCON0
  setbits 0x1000000, 0x1</code></pre></div></li>
<li>
<p>Enable <strong>Clock for MIXER0</strong>: HCLK Clock Reset Off</p>
<ul>
<li>
<p>Set <strong>AHB_RESET</strong> bits <strong><code>0x1</code></strong></p>
<p><strong>CORE0_HCLK_RESET</strong> (Bit 0) = 1 (Reset Off)</p>
</li>
<li>
<p><strong>AHB_RESET</strong> is at DE Offset <strong><code>0x008</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 25)</a></p>
</li>
<li>
<p><strong>Display Engine (DE)</strong> Base Address is <strong><code>0x0100</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable clock for mixer 0, set route MIXER0-&gt;TCON0
  setbits 0x1000008, 0x1</code></pre></div></li>
<li>
<p>Enable <strong>Clock for MIXER0</strong>: HCLK Clock Pass</p>
<ul>
<li>
<p>Set <strong>HCLK_GATE</strong> bits <strong><code>0x1</code></strong></p>
<p><strong>CORE0_HCLK_GATE</strong> (Bit 0) = 1 (Clock Pass)</p>
</li>
<li>
<p><strong>HCLK_GATE</strong> is at DE Offset <strong><code>0x004</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 25)</a></p>
</li>
<li>
<p><strong>Display Engine (DE)</strong> Base Address is <strong><code>0x0100</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable clock for mixer 0, set route MIXER0-&gt;TCON0
  setbits 0x1000004, 0x1</code></pre></div></li>
<li>
<p>Route <strong>MIXER0 to TCON0</strong></p>
<ul>
<li>
<p>Clear <strong>DE2TCON_MUX</strong> bits <strong><code>0x1</code></strong></p>
<p><strong>DE2TCON_MUX</strong> (Bit 0) = 0</p>
<p>(Route MIXER0 to TCON0; Route MIXER1 to TCON1)</p>
</li>
<li>
<p><strong>DE2TCON_MUX</strong> is at DE Offset <strong><code>0x010</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 26)</a></p>
</li>
<li>
<p><strong>Display Engine (DE)</strong> Base Address is <strong><code>0x0100</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Enable clock for mixer 0, set route MIXER0-&gt;TCON0
  clrbits 0x1000010, 0x1</code></pre></div></li>
<li>
<p>Clear <strong>MIXER0 Registers</strong>: GLB, BLD, Video Overlay, UI Overlay</p>
<ul>
<li>
<p>Set <strong>MIXER0</strong> Offsets <strong><code>0x0000</code></strong> - <strong><code>0x5FFF</code></strong> to 0</p>
<p><strong>GLB</strong> (Global Regisers) at MIXER0 Offset <strong><code>0x0000</code></strong></p>
<p><strong>BLD</strong> (Blender) at MIXER0 Offset <strong><code>0x1000</code></strong></p>
<p><strong>OVL_V(CH0)</strong> (Video Overlay) at MIXER0 Offset <strong><code>0x2000</code></strong></p>
<p><strong>OVL_UI(CH1)</strong> (UI Overlay 1) at MIXER0 Offset <strong><code>0x3000</code></strong></p>
<p><strong>OVL_UI(CH2)</strong> (UI Overlay 2) at MIXER0 Offset <strong><code>0x4000</code></strong></p>
<p><strong>OVL_UI(CH3)</strong> (UI Overlay 3) at MIXER0 Offset <strong><code>0x5000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 90)</a></p>
</li>
<li>
<p><strong>MIXER0</strong> is at DE Offset <strong><code>0x0010</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
</li>
<li>
<p><strong>Display Engine (DE)</strong> Base Address is <strong><code>0x0100</code> <code>0000</code></strong></p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(DE Page 24)</a></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Clear all registers
  0x1100000 to 0x1105fff = 0x0</code></pre></div></li>
<li>
<p>Disable <strong>MIXER0 Modules</strong></p>
<p>TODO</p>
<div class="example-wrap"><pre class="language-text"><code>Clear all registers
  0x1120000 = 0x0
  0x1130000 = 0x0
  0x1140000 = 0x0
  0x1150000 = 0x0
  0x11a0000 = 0x0
  0x11a2000 = 0x0
  0x11a4000 = 0x0
  0x11a6000 = 0x0
  0x11a8000 = 0x0
  0x11aa000 = 0x0
  0x11b0000 = 0x0

0x1120000
VIDEO_SCALER(CH0) 128K 0x20000
DE Page 90

Offset: 0x000 Register Name: VS_CTRL_REG
0 R/W 0x0
EN
Video Scaler enable
0: Disable
1: Enable
Note: When module disabled, the core clock to the core circuit will be gated.
DE Page 130

0x1130000
Undocumented

0x1140000
UI_SCALER1(CH1) 64K 0x40000
DE Page 90

Offset: 0x000 Register Name: UIS_CTRL_REG
0 R/W 0x0
EN
UI Scaler enable
0: Disable
1: Enable
Note: When module disabled, the core clock to the core circuit will be gated, and
the input data will be bypassed to down-stream module.
DE Page 66

0x1150000
UI_SCALER2(CH2) 64K 0x50000
DE Page 90

Offset: 0x000 Register Name: UIS_CTRL_REG
0 R/W 0x0
EN
UI Scaler enable
0: Disable
1: Enable
Note: When module disabled, the core clock to the core circuit will be gated, and
the input data will be bypassed to down-stream module.
DE Page 66

Missing: UI_SCALER3(CH3) 64K 0x60000
DE Page 90

0x11a0000
Module name Memory Range Offset Address
FCE 8K 0xA0000
DE Page 61

5.6.3.1 GCTRL_REG
Offset: 0x000 Register Name: GCTRL_REG
0 R/W 0x0
EN
FCE module enable
0: Disable
1: Enable
Note: When module disable, the clock of the calculation circuit will be gated
automatically. 
DE Page 62

0x11a2000
Module name Memory Range Offset Address
BWS 8K 0xA2000
DE Page 42

Offset: 0x000 Register Name: GCTRL_REG
0 R/W 0x0
EN
BWS module enable
0: Disable
1: Enable
Note: When module disable, the clock of the calculation circuit will be gated
automatically. 
DE Page 42

0x11a4000
Module name Memory Range Offset Address
LTI 8K 0xA4000
DE Page 71

5.8.3.1 Global control register
Offset: 0x000 Register Name: LTI_CTL
0 R/W 0x0
LTI_EN
0: LTI close
1: LTI open
DE Page 72

0x11a6000
Module name Memory Range Offset Address
PEAKING 8K 0xA6000
DE Page 80

Offset: 0x00 Register name: LP_CTRL_REG
0 R/W 0x0
EN
LP Module enable
0: Disable
1: Enable
DE Page 80

0x11a8000
Module name Memory Range Offset Address
ASE 8K 0xA8000
DE Page 40

Offset: 0x000 Register Name: ASE_CTL_REG
0 R/W 0x0
ASE_EN
0: disable
1: enable
DE Page 40

0x11aa000
Module name Memory Range Offset Address
FCC 8K 0xAA000
DE Page 56

5.5.3.1 FCC_CTRL_REG(Default Value: 0x0000_0000)
Offset: 0x000 Register Name: FCC_CTL_REG
0 R/W 0x0
Enable
Enable control
0:disable
1:enable
If the bit is disabled, the input data will by-pass to next module.

0x11b0000
Module Offset Address Memory Range
DRC 0x011b0000
DE Page 48

5.4.3.1 General control register (Default Value: 0x0000_0000)
Offset: 0x0000 Register Name: GNECTL_REG
Bit Read/Write Default/Hex Description
31 R/W 0x0
BIST_EN
BIST enable
0x0: disable
0x1: enable
DE Page 49</code></pre></div></li>
<li>
<p>Enable <strong>MIXER0</strong></p>
<p>TODO</p>
<div class="example-wrap"><pre class="language-text"><code>Enable mixer
  0x1100000 = 0x1 (DMB)

GLB 4K 0x00000
DE Page 90

Offset: 0x000 Register Name: GLB_CTL
0 R/W 0x0
EN
RT enable/disable
0: disable
1: enable
DE Page 92</code></pre></div></li>
</ol>
<p><img src="https://lupyuen.github.io/images/de-run.png" alt="Running p-boot Display Code on Apache NuttX RTOS with logging" /></p>
<p><a href="https://lupyuen.github.io/articles/de#p-boot-display-code"><em>Running p-boot Display Code on Apache NuttX RTOS with logging</em></a></p>
<h1 id="appendix-programming-the-allwinner-a64-display-engine"><a href="#appendix-programming-the-allwinner-a64-display-engine">15 Appendix: Programming the Allwinner A64 Display Engine</a></h1>
<p>We‚Äôve seen the <strong>Hardware Registers</strong> for the Allwinner A64 Display Engine‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine"><strong>‚ÄúOverview of Allwinner A64 Display Engine‚Äù</strong></a></li>
</ul>
<p>And we need to program the Hardware Registers to create the <strong>NuttX Display Driver</strong> for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone"><strong>‚ÄúNuttX Display Driver for PinePhone‚Äù</strong></a></li>
</ul>
<p><em>How will we program the Hardware Registers to render the UI Channels?</em></p>
<p>To find out how <a href="https://megous.com/git/p-boot/tree/src/display.c#n2017"><strong><code>display_commit</code></strong></a> updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to <strong>log all Register Writes</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip"><strong>Modified p-boot Display Code</strong></a></li>
</ul>
<p>Which produces a log that tells us all the <strong>Hardware Registers and their values</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone"><strong>‚ÄúTesting p-boot Display Engine on PinePhone‚Äù</strong></a></li>
</ul>
<p>After studying the log, we have identified the steps to render the 3 UI Channels with the Display Engine.</p>
<p>This is how we‚Äôll create a NuttX Driver for PinePhone‚Äôs A64 Display Engine that implements Display Rendering‚Ä¶</p>
<p><a href="https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf">(Refer to <strong>Memory Mapping List</strong> and <strong>Register List</strong> at Page 90)</a></p>
<ol>
<li>
<p><strong>Configure Blender‚Ä¶</strong></p>
<ul>
<li>
<p>BLD BkColor (<strong>BLD_BK_COLOR</strong> @ BLD Offset <code>0x88</code>): BLD background color register</p>
<p>Set to <code>0xff00</code> <code>0000</code> <em>(Why?)</em></p>
</li>
<li>
<p>BLD Premultiply (<strong>BLD_PREMUL_CTL</strong> @ BLD Offset <code>0x84</code>): BLD pre-multiply control register</p>
<p>Set to 0</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Configure Blender
BLD BkColor:     0x110 1088 = 0xff000000
BLD Premultiply: 0x110 1084 = 0x0</code></pre></div></li>
<li>
<p><strong>For Channels 1 to 3‚Ä¶</strong></p>
<ol>
<li>
<p><strong>If Channel is unused,</strong> disable Overlay, Pipe and Scaler. Skip to next Channel</p>
<ul>
<li>
<p>UI Config Attr (<strong>OVL_UI_ATTCTL</strong> @ OVL_UI Offset <code>0x00</code>): <em>OVL_UI attribute control register</em></p>
<p>Set to 0</p>
</li>
<li>
<p>Mixer (<strong>???</strong> @ <code>0x113</code> <code>0000</code> + <code>0x10000</code> * Channel)</p>
<p>Set to 0</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 2: Disable Overlay and Pipe
UI Config Attr: 0x110 4000 = 0x0

Channel 3: Disable Overlay and Pipe
UI Config Attr: 0x110 5000 = 0x0

Channel 2: Disable Scaler
Mixer: 0x115 0000 = 0x0

Channel 3: Disable Scaler
Mixer: 0x116 0000 = 0x0</code></pre></div></li>
<li>
<p>Channel 1 has Pixel Format <strong>XRGB 8888</strong>:</p>
<p><strong>OVL_V_ATTCTL ‚Üí LAY_FBFMT</strong> = <code>0x04</code></p>
<p>Channels 2 and 3 have Pixel Format <strong>ARGB 8888</strong>:</p>
<p><strong>OVL_V_ATTCTL ‚Üí LAY_FBFMT</strong> = <code>0x01</code></p>
<p><em>(See page 94)</em></p>
</li>
<li>
<p><strong>Set Overlay</strong> (Assume Layer = 0)</p>
<ul>
<li>
<p>UI Config Attr (<strong>OVL_UI_ATTCTL</strong> @ OVL_UI Offset <code>0x00</code>): <em>OVL_UI attribute control register</em></p>
<p><strong>For Channel 1:</strong> Set to <code>0xff00</code> <code>0405</code> <em>(Why?)</em></p>
<p><strong>For Channel 2:</strong> <code>0xff00</code> <code>0005</code> <em>(Why?)</em></p>
<p><strong>For Channel 3:</strong> <code>0x7f00</code> <code>0005</code> <em>(Why?)</em></p>
</li>
<li>
<p>UI Config Top LAddr (<strong>OVL_UI_TOP_LADD</strong> @ OVL_UI Offset <code>0x10</code>): <em>OVL_UI top field memory block low address register</em></p>
<p>Set to Framebuffer Address: <code>fb0</code>, <code>fb1</code> or <code>fb2</code></p>
</li>
<li>
<p>UI Config Pitch (<strong>OVL_UI_PITCH</strong> @ OVL_UI Offset <code>0x0C</code>): <em>OVL_UI memory pitch register</em></p>
<p>Set to <code>(width * 4)</code></p>
</li>
<li>
<p>UI Config Size (<strong>OVL_UI_MBSIZE</strong> @ OVL_UI Offset <code>0x04</code>): <em>OVL_UI memory block size register</em></p>
<p>Set to <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
<li>
<p>UI Overlay Size (<strong>OVL_UI_SIZE</strong> @ OVL_UI Offset <code>0x88</code>): <em>OVL_UI overlay window size register</em></p>
<p>Set to <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
<li>
<p>IO Config Coord (<strong>OVL_UI_COOR</strong> @ OVL_UI Offset <code>0x08</code>): <em>OVL_UI memory block coordinate register</em></p>
<p>Set to 0</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Set Overlay (fb0 is 720 x 1440)
UI Config Attr:      0x110 3000 = 0xff00 0405
UI Config Top LAddr: 0x110 3010 = 0x4064 a6ac (Address of fb0)
UI Config Pitch:     0x110 300c = 0xb40 (720 * 4)
UI Config Size:      0x110 3004 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
UI Overlay Size:     0x110 3088 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
IO Config Coord:     0x110 3008 = 0x0

Channel 2: Set Overlay (fb1 is 600 x 600)
UI Config Attr:      0x110 4000 = 0xff00 0005
UI Config Top LAddr: 0x110 4010 = 0x404e adac (Address of fb1)
UI Config Pitch:     0x110 400c = 0x960 (600 * 4)
UI Config Size:      0x110 4004 = 0x257 0257 (599 &lt;&lt; 16 + 599)
UI Overlay Size:     0x110 4088 = 0x257 0257 (599 &lt;&lt; 16 + 599)
IO Config Coord:     0x110 4008 = 0x0

Channel 3: Set Overlay (fb2 is 720 x 1440)
UI Config Attr:      0x110 5000 = 0x7f00 0005
UI Config Top LAddr: 0x110 5010 = 0x400f 65ac (Address of fb2)
UI Config Pitch:     0x110 500c = 0xb40 (720 * 4)
UI Config Size:      0x110 5004 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
UI Overlay Size:     0x110 5088 = 0x59f 02cf (1439 &lt;&lt; 16 + 719)
IO Config Coord:     0x110 5008 = 0x0</code></pre></div></li>
<li>
<p><strong>For Channel 1:</strong> Set Blender Output</p>
<ul>
<li>
<p>BLD Output Size (<strong>BLD_SIZE</strong> @ BLD Offset <code>0x08C</code>): <em>BLD output size setting register</em></p>
<p>Set to <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
<li>
<p>GLB Size (<strong>GLB_SIZE</strong> @ GLB Offset <code>0x00C</code>): <em>Global size register</em></p>
<p>Set to <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Set Blender Output
BLD Output Size: 0x110 108c = 0x59f 02cf (1439 * 16 + 719)
GLB Size:        0x110 000c = 0x59f 02cf (1439 * 16 + 719)</code></pre></div></li>
<li>
<p><strong>Set Blender Input Pipe</strong> (N = Pipe Number, from 0 to 2 for Channels 1 to 3)</p>
<ul>
<li>
<p>BLD Pipe InSize (<strong>BLD_CH_ISIZE</strong> @ BLD Offset <code>0x008</code> + <code>N*0x10</code>): <em>BLD input memory size register(N=0,1,2,3,4)</em></p>
<p>Set to <code>(height-1) &lt;&lt; 16 + (width-1)</code></p>
</li>
<li>
<p>BLD Pipe FColor (<strong>BLD_FILL_COLOR</strong> @ BLD Offset <code>0x004</code> + <code>N*0x10</code>): <em>BLD fill color register(N=0,1,2,3,4)</em></p>
<p>Set to <code>0xff00</code> <code>0000</code> <em>(Why?)</em></p>
</li>
<li>
<p>BLD Pipe Offset (<strong>BLD_CH_OFFSET</strong> @ BLD Offset <code>0x00C</code> + <code>N*0x10</code>): <em>BLD input memory offset register(N=0,1,2,3,4)</em></p>
<p><strong>For Channel 1:</strong> Set to 0 <em>(Why?)</em></p>
<p><strong>For Channel 2:</strong> Set to <code>0x34</code> <code>0034</code> <em>(Why?)</em></p>
<p><strong>For Channel 3:</strong> Set to 0 <em>(Why?)</em></p>
</li>
<li>
<p>BLD Pipe Mode (<strong>BLD_CTL</strong> @ BLD Offset <code>0x090</code> + <code>N*4</code>): <em>BLD control register</em></p>
<p>Set to <code>0x301</code> <code>0301</code> <em>(Why?)</em></p>
</li>
</ul>
<p><strong>Note: Log shows BLD_CH_ISIZE, BLD_FILL_COLOR and  BLD_CH_OFFSET are at <code>N*0x10</code>, but doc says <code>N*0x14</code></strong></p>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Set Blender Input Pipe 0 (fb0 is 720 x 1440)
BLD Pipe InSize: 0x110 1008 = 0x59f 02cf (1439 * 16 + 719)
BLD Pipe FColor: 0x110 1004 = 0xff00 0000
BLD Pipe Offset: 0x110 100c = 0x0
BLD Pipe Mode:   0x110 1090 = 0x301 0301

Channel 2: Set Blender Input Pipe 1 (fb1 is 600 x 600)
BLD Pipe InSize: 0x110 1018 = 0x257 0257 (599 &lt;&lt; 16 + 599)
BLD Pipe FColor: 0x110 1014 = 0xff00 0000
BLD Pipe Offset: 0x110 101c = 0x34 0034
BLD Pipe Mode:   0x110 1094 = 0x301 0301

Channel 3: Set Blender Input Pipe 2 (fb2 is 720 x 1440)
BLD Pipe InSize: 0x110 1028 = 0x59f 02cf (1439 * 16 + 719)
BLD Pipe FColor: 0x110 1024 = 0xff00 0000
BLD Pipe Offset: 0x110 102c = 0x0
BLD Pipe Mode:   0x110 1098 = 0x301 0301</code></pre></div></li>
<li>
<p><strong>Disable Scaler</strong> (Assume we‚Äôre not scaling)</p>
<ul>
<li>
<p>Mixer (<strong>???</strong> @ <code>0x113</code> <code>0000</code> + <code>0x10000</code> * Channel)</p>
<p>Set to 0</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Channel 1: Disable Scaler
Mixer: 0x114 0000 = 0x0

Channel 2: Disable Scaler
Mixer: 0x115 0000 = 0x0

Channel 3: Disable Scaler
Mixer: 0x116 0000 = 0x0</code></pre></div></li>
</ol>
</li>
<li>
<p><strong>Set BLD Route and BLD FColor Control</strong></p>
<ul>
<li>
<p>BLD Route (<strong>BLD_CH_RTCTL</strong> @ BLD Offset <code>0x080</code>): <em>BLD routing control register</em></p>
<p><strong>For 3 UI Channels:</strong> Set to <code>0x321</code> <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a> <em>(Why?)</em></p>
<p><strong>For 1 UI Channel:</strong> Set to <code>1</code> <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a> <em>(Why?)</em></p>
</li>
<li>
<p>BLD FColor Control (<strong>BLD_FILLCOLOR_CTL</strong> @ BLD Offset <code>0x000</code>): <em>BLD fill color control register</em></p>
<p><strong>For 3 UI Channels:</strong> Set to <code>0x701</code> <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a> <em>(Why?)</em></p>
<p><strong>For 1 UI Channels:</strong> Set to <code>0x101</code> <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a> <em>(Why?)</em></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>For 3 UI Channels: Set BLD Route and BLD FColor Control
BLD Route:          0x110 1080 = 0x321 (DMB)
BLD FColor Control: 0x110 1000 = 0x701 (DMB)

For 1 UI Channel: Set BLD Route and BLD FColor Control
BLD Route:          0x110 1080 = 0x1   (DMB)
BLD FColor Control: 0x110 1000 = 0x101 (DMB)</code></pre></div></li>
<li>
<p><strong>Apply Settings</strong></p>
<ul>
<li>
<p>GLB DBuff (<strong>GLB_DBUFFER</strong> @ GLB Offset <code>0x008</code>): <em>Global double buffer control register</em></p>
<p>Set to 1 <a href="https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb"><strong>(DMB)</strong></a> <em>(Why?)</em></p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>Apply Settings
GLB DBuff: 0x110 0008 = 0x1 (DMB)</code></pre></div></li>
</ol>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone">(See the Complete Log)</a></p>
<p><a href="https://megous.com/git/p-boot/tree/src/display.c#n2017">(Captured from p-boot <code>display_commit</code>)</a></p>

    
</body>
</html>