<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS in a Web Browser? Adventures with TinyEMU and VirtIO</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS in a Web Browser? Adventures with TinyEMU and VirtIO" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tinyemu-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/tinyemu.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS in a Web Browser? Adventures with TinyEMU and VirtIO</h1>
    <nav id="TOC"><ul>
<li><a href="#install-tinyemu">1 Install TinyEMU</a><ul></ul></li>
<li><a href="#risc-v-addresses-for-tinyemu">2 RISC-V Addresses for TinyEMU</a><ul></ul></li>
<li><a href="#tinyemu-config">3 TinyEMU Config</a><ul></ul></li>
<li><a href="#build-nuttx-for-tinyemu">4 Build NuttX for TinyEMU</a><ul></ul></li>
<li><a href="#run-nuttx-on-tinyemu">5 Run NuttX on TinyEMU</a><ul></ul></li>
<li><a href="#print-to-htif-console">6 Print to HTIF Console</a><ul></ul></li>
<li><a href="#print-in-nuttx-boot-code">7 Print in NuttX Boot Code</a><ul></ul></li>
<li><a href="#fix-the-nuttx-uart-driver-for-tinyemu">8 Fix the NuttX UART Driver for TinyEMU</a><ul></ul></li>
<li><a href="#boot-nuttx-in-the-web-browser">9 Boot NuttX in the Web Browser</a><ul></ul></li>
<li><a href="#virtio-console-in-tinyemu">10 VirtIO Console in TinyEMU</a><ul></ul></li>
<li><a href="#enable-virtio-and-openamp-in-nuttx">11 Enable VirtIO and OpenAMP in NuttX</a><ul></ul></li>
<li><a href="#configure-nuttx-virtio-for-tinyemu">12 Configure NuttX VirtIO for TinyEMU</a><ul></ul></li>
<li><a href="#test-tinyemu-virtio-console-with-nuttx">13 Test TinyEMU VirtIO Console with NuttX</a><ul></ul></li>
<li><a href="#inside-the-virtio-driver-for-nuttx">14 Inside the VirtIO Driver for NuttX</a><ul></ul></li>
<li><a href="#inside-the-virtio-host-for-tinyemu">15 Inside the VirtIO Host for TinyEMU</a><ul>
<li><a href="#tinyemu-virtio">15.1 TinyEMU VirtIO</a><ul></ul></li>
<li><a href="#tinyemu-virtio-console">15.2 TinyEMU VirtIO Console</a><ul></ul></li>
<li><a href="#tinyemu-virtio-mmio-queue">15.3 TinyEMU VirtIO MMIO Queue</a><ul></ul></li></ul></li>
<li><a href="#nuttx-in-kernel-mode">16 NuttX in Kernel Mode</a><ul></ul></li>
<li><a href="#whats-next">17 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-tinyemu">18 Appendix: Build NuttX for TinyEMU</a><ul></ul></li></ul></nav><p>üìù <em>15 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/tinyemu-title.png" alt="Apache NuttX RTOS in a Web Browser‚Ä¶ With TinyEMU and VirtIO" /> </p>
<p>TODO</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/"><strong>Demo of NuttX on TinyEMU</strong></a></p>
<p><a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) is a tiny operating system for 64-bit RISC-V Machines and many other platforms. (Arm, x64, ESP32, ‚Ä¶)</p>
<p><a href="https://github.com/fernandotcl/TinyEMU"><strong>TinyEMU</strong></a> is a barebones RISC-V Emulator that runs in a <a href="https://www.barebox.org/jsbarebox/?graphic=1">Web Browser</a>. (Thanks to WebAssembly)</p>
<p>Can we boot NuttX in a Web Browser, with a little help from TinyEMU? Let‚Äôs find out!</p>
<p><em>Why are we doing this?</em></p>
<p>We might run NuttX in a Web Browser and emulate the <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Ox64 BL808</strong></a> RISC-V SBC. Which is great for testing NuttX Apps like <a href="https://lupyuen.github.io/articles/nim"><strong>Nim Blinky LED</strong></a>! Or even LVGL Apps with VirtIO Framebuffer?</p>
<p>Also Imagine: A <strong>NuttX Dashboard</strong> that lights up in <strong>Real-Time</strong>, as the various NuttX Modules are activated‚Ä¶ This is all possible when NuttX runs in a Web Browser!</p>
<p>(Sorry QEMU Emulator is a bit too complex to customise)</p>
<h1 id="install-tinyemu"><a href="#install-tinyemu">1 Install TinyEMU</a></h1>
<p><em>How to run TinyEMU?</em></p>
<p>We begin by installing <a href="https://github.com/fernandotcl/TinyEMU"><strong>TinyEMU RISC-V Emulator</strong></a> at the Command Line‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install TinyEMU on Ubuntu
## https://github.com/lupyuen/TinyEMU/blob/master/.github/workflows/ci.yml#L6-L13
sudo apt install libcurl4-openssl-dev libssl-dev zlib1g-dev libsdl2-dev
git clone https://github.com/fernandotcl/TinyEMU
cd TinyEMU
make

## Install TinyEMU on macOS
## https://github.com/fernandotcl/homebrew-fernandotcl
## https://github.com/lupyuen/TinyEMU/blob/master/.github/workflows/ci.yml#L20-L29
brew tap fernandotcl/homebrew-fernandotcl
brew install --HEAD fernandotcl/fernandotcl/tinyemu
temu https://bellard.org/jslinux/buildroot-riscv64.cfg

## Check TinyEMU. Should show...
## temu version 2019-02-10, Copyright (c) 2016-2018 Fabrice Bellard
temu   
</code></pre></div>
<p><a href="https://github.com/lupyuen/TinyEMU/blob/master/.github/workflows/ci.yml">(See the <strong>Build Script</strong>)</a></p>
<p><em>What about TinyEMU for the Web Browser?</em></p>
<p>No Worries! Everything that runs in the <strong>Command Line</strong> TinyEMU‚Ä¶ Will also run in the <strong>Web Browser</strong> TinyEMU!</p>
<h1 id="risc-v-addresses-for-tinyemu"><a href="#risc-v-addresses-for-tinyemu">2 RISC-V Addresses for TinyEMU</a></h1>
<p><em>How will TinyEMU boot our Operating System?</em></p>
<p>TinyEMU is hardcoded to run at these <strong>RISC-V Addresses</strong>: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L66-L82">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define LOW_RAM_SIZE           0x00010000  // 64KB
#define RAM_BASE_ADDR          0x80000000
#define CLINT_BASE_ADDR        0x02000000
#define CLINT_SIZE             0x000c0000

#define DEFAULT_HTIF_BASE_ADDR 0x40008000
#define VIRTIO_BASE_ADDR       0x40010000
#define VIRTIO_SIZE            0x1000
#define VIRTIO_IRQ             1

#define PLIC_BASE_ADDR         0x40100000
#define PLIC_SIZE              0x00400000
#define FRAMEBUFFER_BASE_ADDR  0x41000000
</code></pre></div>
<p>Thus we‚Äôll compile our <strong>NuttX Kernel</strong> to boot at <strong><code>0x8000_0000</code></strong>.</p>
<p>TODO: We begin with the NuttX Port for QEMU 64-bit RISC-V‚Ä¶</p>
<h1 id="tinyemu-config"><a href="#tinyemu-config">3 TinyEMU Config</a></h1>
<p>TODO</p>
<p><em>What‚Äôs inside a TinyEMU Config?</em></p>
<p>RISC-V Virtual Machines for TinyEMU are configured like this: <a href="https://bellard.org/jslinux/buildroot-riscv64.cfg">buildroot-riscv64.cfg</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* VM configuration file */
{
  version: 1,
  machine: &quot;riscv64&quot;,
  memory_size: 256,
  bios: &quot;bbl64.bin&quot;,
  kernel: &quot;kernel-riscv64.bin&quot;,
  cmdline: &quot;loglevel=3 swiotlb=1 console=hvc0 root=root rootfstype=9p rootflags=trans=virtio ro TZ=${TZ}&quot;,
  fs0: { file: &quot;https://vfsync.org/u/os/buildroot-riscv64&quot; },
  eth0: { driver: &quot;user&quot; },
}
</code></pre></div>
<p><code>bbl64.bin</code> is the <a href="https://www.barebox.org">Barebox Bootloader</a>. (Similar to U-Boot)</p>
<p><em>Will NuttX go into <code>bios</code> or <code>kernel</code>?</em></p>
<p>According to <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L753-L812">copy_bios</a>, the BIOS is mandatory, the Kernel is optional.</p>
<p>Thus we put NuttX Kernel into <code>bios</code> and leave <code>kernel</code> empty.</p>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L753-L812">copy_bios</a> will load NuttX Kernel at RAM_BASE_ADDR (0x8000_0000).</p>
<h1 id="build-nuttx-for-tinyemu"><a href="#build-nuttx-for-tinyemu">4 Build NuttX for TinyEMU</a></h1>
<p>TODO</p>
<p><em>Will NuttX boot on TinyEMU?</em></p>
<p>NuttX for QEMU RISC-V is already configured to boot at 0x8000_0000: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script#L21-L27">ld.script</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  . = 0x80000000;
  .text :
    {
      _stext = . ;
</code></pre></div>
<p>So we build NuttX for QEMU RISC-V (64-bit, Flat Mode)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download WIP NuttX
git clone --branch tinyemu https://github.com/lupyuen2/wip-pinephone-nuttx nuttx
git clone --branch tinyemu https://github.com/lupyuen2/wip-pinephone-nuttx-apps apps

## Configure NuttX for QEMU RISC-V (64-bit, Flat Mode)
cd nuttx
tools/configure.sh rv-virt:nsh64
make menuconfig
## Device Drivers
##   Enable &quot;Simple AddrEnv&quot;
##   Enable &quot;Virtio Device Support&quot;

## Device Drivers &gt; Virtio Device Support
##   Enable &quot;Virtio MMIO Device Support&quot;

## Build Setup &gt; Debug Options &gt;
##   Enable Debug Features
##   Enable &quot;Debug Assertions &gt; Show Expression, Filename&quot;
##   Enable &quot;Binary Loader Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;File System Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;C Library Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;Memory Manager Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;Scheduler Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;Timer Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;IPC Debug Features &gt; Errors, Warnings, Info&quot;
##   Enable &quot;Virtio Debug Features &gt; Error, Warnings, Info&quot;

## Application Configuration &gt; Testing &gt;
##   Enable &quot;OS Test Example&quot;

## RTOS Features &gt; Tasks and Scheduling &gt;
##   Set &quot;Application Entry Point&quot; to &quot;ostest_main&quot;
##   Set &quot;Application Entry Name&quot; to &quot;ostest_main&quot;
## Save and exit menuconfig

## Build NuttX
make

## Export the Binary Image to nuttx.bin
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div><h1 id="run-nuttx-on-tinyemu"><a href="#run-nuttx-on-tinyemu">5 Run NuttX on TinyEMU</a></h1>
<p>TODO</p>
<p><em>How to boot NuttX on TinyEMU?</em></p>
<p>We create a TinyEMU Config for NuttX and run it: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/root-riscv64.cfg">root-riscv64.cfg</a></p>
<div class="example-wrap"><pre class="language-bash"><code>$ cat nuttx.cfg
/* VM configuration file */
{
  version: 1,
  machine: &quot;riscv64&quot;,
  memory_size: 256,
  bios: &quot;nuttx.bin&quot;,
}

$ temu nuttx.cfg
</code></pre></div>
<p>TinyEMU hangs, nothing happens. Let‚Äôs print something to TinyEMU HTIF Console‚Ä¶</p>
<h1 id="print-to-htif-console"><a href="#print-to-htif-console">6 Print to HTIF Console</a></h1>
<p>TODO</p>
<p><em>What‚Äôs HTIF?</em></p>
<p>From <a href="https://github.com/riscv-software-src/riscv-isa-sim/issues/364#issuecomment-607657754">RISC-V Spike Emulator</a>‚Ä¶</p>
<blockquote>
<p>HTIF is a tether between a simulation host and target, not something that‚Äôs supposed to resemble a real hardware device. It‚Äôs not a RISC-V standard; it‚Äôs a UC Berkeley standard. </p>
</blockquote>
<blockquote>
<p>Bits 63:56 indicate the ‚Äúdevice‚Äù.</p>
</blockquote>
<blockquote>
<p>Bits 55:48 indicate the ‚Äúcommand‚Äù.</p>
</blockquote>
<blockquote>
<p>Device 1 is the blocking character device.</p>
</blockquote>
<blockquote>
<p>Command 0 reads a character</p>
</blockquote>
<blockquote>
<p>Command 1 writes a character from the 8 LSBs of tohost</p>
</blockquote>
<p>TinyEMU handles HTIF Commands like this: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L129-L153">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void htif_handle_cmd(RISCVMachine *s)
{
    uint32_t device, cmd;

    device = s-&gt;htif_tohost &gt;&gt; 56;
    cmd = (s-&gt;htif_tohost &gt;&gt; 48) &amp; 0xff;
    if (s-&gt;htif_tohost == 1) {
        /* shuthost */
        printf(&quot;\nPower off.\n&quot;);
        exit(0);
    } else if (device == 1 &amp;&amp; cmd == 1) {
        uint8_t buf[1];
        buf[0] = s-&gt;htif_tohost &amp; 0xff;
        s-&gt;common.console-&gt;write_data(s-&gt;common.console-&gt;opaque, buf, 1);
        s-&gt;htif_tohost = 0;
        s-&gt;htif_fromhost = ((uint64_t)device &lt;&lt; 56) | ((uint64_t)cmd &lt;&lt; 48);
    } else if (device == 1 &amp;&amp; cmd == 0) {
        /* request keyboard interrupt */
        s-&gt;htif_tohost = 0;
    } else {
        printf(&quot;HTIF: unsupported tohost=0x%016&quot; PRIx64 &quot;\n&quot;, s-&gt;htif_tohost);
    }
}
</code></pre></div>
<p>So to print <code>1</code> (ASCII 0x31) to the HTIF Console‚Ä¶</p>
<ul>
<li>
<p>device <br> = (htif_tohost &gt;&gt; 56) <br> = 1</p>
</li>
<li>
<p>cmd <br> = (htif_tohost &gt;&gt; 48) <br> = 1</p>
</li>
<li>
<p>buf <br> = (htif_tohost &amp; 0xff) <br> = 0x31</p>
</li>
</ul>
<p>Which means we write this value to htif_tohost‚Ä¶</p>
<ul>
<li>(1 &lt;&lt; 56) | (1 &lt;&lt; 48) | 0x31 <br> = 0x0101_0000_0000_0031</li>
</ul>
<p><em>Where is htif_tohost?</em></p>
<p>According to <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L913-L927">riscv_machine_init</a> and <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L154-L178">htif_write</a>, htif_tohost is at <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L66-L82">DEFAULT_HTIF_BASE_ADDR</a>: 0x4000_8000</p>
<p>Thus we print to HTIF Console like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `1` to HTIF Console
*(volatile uint64_t *) 0x40008000 = 0x0101000000000031ul;
</code></pre></div>
<p>Let‚Äôs print something in our NuttX Boot Code‚Ä¶</p>
<h1 id="print-in-nuttx-boot-code"><a href="#print-in-nuttx-boot-code">7 Print in NuttX Boot Code</a></h1>
<p>TODO</p>
<p><em>How to print to HTIF Console in the NuttX Boot Code? (RISC-V Assembly)</em></p>
<p><a href="https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console">Based on Star64 Debug Code</a>, we code this in RISC-V Assembly‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/* Load HTIF Base Address to Register t0 */
li  t0, 0x40008000

/* Load to Register t1 the HTIF Command to print `1` */
li  t1, 0x0101000000000031
/* Store 64-bit double-word from Register t1 to HTIF Base Address, Offset 0 */
sd  t1, 0(t0)

/* Load to Register t1 the HTIF Command to print `2` */
li  t1, 0x0101000000000032
/* Store 64-bit double-word from Register t1 to HTIF Base Address, Offset 0 */
sd  t1, 0(t0)

/* Load to Register t1 the HTIF Command to print `3` */
li  t1, 0x0101000000000033
/* Store 64-bit double-word from Register t1 to HTIF Base Address, Offset 0 */
sd  t1, 0(t0)
</code></pre></div>
<p>We insert the above code into the NuttX Boot Code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L43-L61">qemu_rv_head.S</a></p>
<p><em>Does it work?</em></p>
<p>NuttX prints to the HTIF Console yay! Now we know that NuttX Boot Code is actually running on TinyEMU‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ temu nuttx.cfg
123
</code></pre></div>
<p>Let‚Äôs fix the NuttX UART Driver‚Ä¶</p>
<h1 id="fix-the-nuttx-uart-driver-for-tinyemu"><a href="#fix-the-nuttx-uart-driver-for-tinyemu">8 Fix the NuttX UART Driver for TinyEMU</a></h1>
<p>TODO</p>
<p><em>NuttX on TinyEMU has been awfully quiet. How to fix the UART Driver so that NuttX can print things?</em></p>
<p>NuttX is still running on the QEMU UART Driver (16550). Let‚Äôs make a quick patch so that we will see something in the TinyEMU HTIF Console: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/serial/uart_16550.c#L1701-L1720">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Write one character to the UART (polled)
static void u16550_putc(FAR struct u16550_s *priv, int ch) {

  // Hardcode the HTIF Base Address
  *(volatile uint64_t *) 0x40008000 = 0x0101000000000000ul | ch;

  // Previously:
  // while ((u16550_serialin(priv, UART_LSR_OFFSET) &amp; UART_LSR_THRE) == 0);
  // u16550_serialout(priv, UART_THR_OFFSET, (uart_datawidth_t)ch);
}
</code></pre></div>
<p>We skip the reading and writing of other UART Registers, because we‚Äôll patch them later: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/serial/uart_16550.c#L604-L635">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Read UART Register
static inline uart_datawidth_t u16550_serialin(FAR struct u16550_s *priv, int offset) {
  return 0; ////
  // Commented out the rest
}

// Write UART Register
static inline void u16550_serialout(FAR struct u16550_s *priv, int offset, uart_datawidth_t value) {
  // Commented out the rest
}
</code></pre></div>
<p>And we won‚Äôt wait for UART Ready, since we‚Äôre not accessing the Line Control Register: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/serial/uart_16550.c#L635-L673">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Wait until UART is not busy. This is needed before writing to Line Control Register.
// Otherwise we will get spurious interrupts on Synopsys DesignWare 8250.
static int u16550_wait(FAR struct u16550_s *priv) {
  // Nopez! No waiting for now
  return OK; ////
}
</code></pre></div>
<p>Now we see NuttX booting OK on TinyEMU yay!</p>
<div class="example-wrap"><pre class="language-text"><code>+ temu nuttx.cfg
123ABCnx_start: Entry
mm_initialize: Heap: name=Umem, start=0x80035700 size=33335552
mm_addregion: [Umem] Region 1: base=0x800359a8 size=33334864
mm_malloc: Allocated 0x800359d0, size 48
mm_malloc: Allocated 0x80035a00, size 288
mm_malloc: Allocated 0x80035b20, size 32
mm_malloc: Allocated 0x80035b40, size 720
mm_malloc: Allocated 0x80035e10, size 80
mm_malloc: Allocated 0x80035e60, size 64
mm_malloc: Allocated 0x80035ea0, size 240
mm_malloc: Allocated 0x80035f90, size 464
mm_malloc: Allocated 0x80036160, size 176
mm_malloc: Allocated 0x80036210, size 336
mm_malloc: Allocated 0x80036360, size 464
mm_malloc: Allocated 0x80036530, size 464
mm_malloc: Allocated 0x80036700, size 528
builtin_initialize: Registering Builtin Loader
elf_initialize: Registering ELF
uart_register: Registering /dev/console
mm_malloc: Allocated 0x80036910, size 80
mm_malloc: Allocated 0x80036960, size 80
uart_register: Registering /dev/ttyS0
mm_malloc: Allocated 0x800369b0, size 80
mm_malloc: Allocated 0x80036a00, size 80
mm_malloc: Allocated 0x80036a50, size 80
mm_malloc: Allocated 0x80036aa0, size 32
mm_malloc: Allocated 0x80036ac0, size 160
mm_malloc: Allocated 0x80036b60, size 32
mm_malloc: Allocated 0x80036b80, size 32
mm_malloc: Allocated 0x80036ba0, size 32
nx_start_application: Starting init thread
task_spawn: name=ostest_main entry=0x80006fde file_actions=0 attr=0x80035670 argv=0x80035668
mm_malloc: Allocated 0x80036bc0, size 272
mm_malloc: Allocated 0x80036cd0, size 288
mm_malloc: Allocated 0x80036df0, size 32
mm_malloc: Allocated 0x80036e10, size 720
mm_malloc: Allocated 0x800370e0, size 32
mm_malloc: Allocated 0x80037100, size 32
mm_malloc: Allocated 0x80037120, size 32
mm_malloc: Allocated 0x80037140, size 32
mm_malloc: Allocated 0x80037160, size 160
mm_malloc: Allocated 0x80037200, size 3088
mm_free: Freeing 0x80036b60
mm_free: Freeing 0x80036ba0
mm_free: Freeing 0x80036b80
mm_malloc: Allocated 0x80036b60, size 32
mm_malloc: Allocated 0x80036b80, size 32
mm_malloc: Allocated 0x80037e10, size 48
mm_free: Freeing 0x800370e0
mm_free: Freeing 0x80036b60
mm_free: Freeing 0x80036b80
mm_malloc: Allocated 0x800370e0, size 32
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p>Let‚Äôs boot NuttX in the Web Browser‚Ä¶</p>
<h1 id="boot-nuttx-in-the-web-browser"><a href="#boot-nuttx-in-the-web-browser">9 Boot NuttX in the Web Browser</a></h1>
<p>TODO</p>
<p><em>Will NuttX boot in the Web Browser?</em></p>
<p>Yep! WebAssembly Demo is here: <a href="https://lupyuen.github.io/nuttx-tinyemu/">Demo of NuttX on TinyEMU</a></p>
<p>WebAssembly Files are located here: <a href="https://github.com/lupyuen/nuttx-tinyemu/tree/main/docs">nuttx-tinyemu/docs</a></p>
<p><img src="https://lupyuen.github.io/images/tinyemu-title.png" alt="Apache NuttX RTOS in the Web Browser: TinyEMU with VirtIO" /></p>
<p>We copied the TinyEMU Config and NuttX Kernel to the Web Server‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy to Web Server: NuttX Config, Kernel, Disassembly (for troubleshooting)
cp nuttx.cfg ../nuttx-tinyemu/docs/root-riscv64.cfg
cp nuttx.bin ../nuttx-tinyemu/docs/
cp nuttx.S ../nuttx-tinyemu/docs/
</code></pre></div>
<p>The other files were provided by <a href="https://bellard.org/tinyemu/">TinyEMU</a>‚Ä¶</p>
<ul>
<li><a href="https://bellard.org/tinyemu/jslinux-2019-12-21.tar.gz">jslinux-2019-12-21.tar.gz</a>: Precompiled JSLinux demo</li>
</ul>
<p><em>How to test this locally?</em></p>
<p>To test on our computer, we need to install a Local Web Server (because our Web Browser won‚Äôt load WebAssembly Files from the File System)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Based on https://github.com/TheWaWaR/simple-http-server
$ cargo install simple-http-server
$ git clone https://github.com/lupyuen/nuttx-tinyemu
$ simple-http-server nuttx-tinyemu/docs
</code></pre></div>
<p>Then browse to‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>http://0.0.0.0:8000/index.html
</code></pre></div>
<p><em>But there‚Äôs no Console Input?</em></p>
<p>To do Console Input, we need to implement VirtIO Console in our NuttX UART Driver‚Ä¶</p>
<h1 id="virtio-console-in-tinyemu"><a href="#virtio-console-in-tinyemu">10 VirtIO Console in TinyEMU</a></h1>
<p>TODO</p>
<p><em>How will we implement Console Input / Output in NuttX TinyEMU?</em></p>
<p>TinyEMU supports VirtIO for proper Console Input and Output‚Ä¶</p>
<ul>
<li>
<p><a href="https://bellard.org/tinyemu/readme.txt">TinyEMU support for VirtIO</a></p>
</li>
<li>
<p><a href="https://wiki.osdev.org/Virtio">Virtio - OSDev Wiki</a></p>
</li>
<li>
<p><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/csd01/virtio-v1.2-csd01.html">Virtual I/O Device (VIRTIO) Spec, Version 1.2</a></p>
</li>
<li>
<p><a href="https://projectacrn.github.io/latest/developer-guides/hld/virtio-console.html">About VirtIO Console</a></p>
</li>
</ul>
<p>And NuttX supports VirtIO, based on OpenAMP‚Ä¶</p>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=_8CpLNEWxfo">Running NuttX with VirtIO on QEMU</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=CYMkAv-WjQg">NuttX VirtIO Framework and Future Works</a></p>
</li>
<li>
<p><a href="https://www.openampproject.org/docs/whitepapers/Introduction_to_OpenAMPlib_v1.1a.pdf">Intro to OpenAMP</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/boards/risc-v/qemu-rv/rv-virt/configs/knetnsh64/defconfig#L52">knetnsh64: NuttX for QEMU RISC-V with VirtIO</a></p>
</li>
</ul>
<p>But let‚Äôs create a simple VirtIO Console Driver for NuttX with OpenAMP‚Ä¶</p>
<ul>
<li>
<p>Create Queue: Call OpenAMP <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L49">virtqueue_create</a></p>
<p>(See <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-mmio.c#L349-L414">virtio_mmio_create_virtqueue</a> or <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtio.c#L96-L142">virtio_create_virtqueues</a>)</p>
</li>
<li>
<p>Send Data: Call OpenAMP <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L83C1-L138">virtqueue_add_buffer</a></p>
<p>(See <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L310-L345">virtio_serial_dmasend</a>)</p>
</li>
<li>
<p>Start Processing: Call OpenAMP <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L321-L336">virtqueue_kick</a></p>
<p>(See <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L310-L345">virtio_serial_dmasend</a>)</p>
</li>
</ul>
<p>This will help us understand the inner workings of VirtIO and OpenAMP! But first we enable VirtIO and OpenAMP in NuttX‚Ä¶</p>
<h1 id="enable-virtio-and-openamp-in-nuttx"><a href="#enable-virtio-and-openamp-in-nuttx">11 Enable VirtIO and OpenAMP in NuttX</a></h1>
<p>TODO</p>
<p><em>How do we call VirtIO and OpenAMP?</em></p>
<p>To enable VirtIO and OpenAMP in NuttX:</p>
<div class="example-wrap"><pre class="language-text"><code>make menuconfig
## Device Drivers
##   Enable &quot;Simple AddrEnv&quot;
##   Enable &quot;Virtio Device Support&quot;

## Device Drivers &gt; Virtio Device Support
##   Enable &quot;Virtio MMIO Device Support&quot;

## Build Setup &gt; Debug Options &gt;
##   Enable &quot;Virtio Debug Features &gt; Error, Warnings, Info&quot;
</code></pre></div>
<p><em>Why ‚ÄúSimple AddrEnv‚Äù?</em></p>
<p><code>up_addrenv_va_to_pa</code> is defined in <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/misc/addrenv.c#L89-L112">drivers/misc/addrenv.c</a>. So we need <code>CONFIG_DEV_SIMPLE_ADDRENV</code> (Simple AddrEnv)</p>
<p>Otherwise we see this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>riscv64-unknown-elf-ld: nuttx/staging/libopenamp.a(io.o): in function `metal_io_phys_to_offset_&#39;:
nuttx/openamp/libmetal/lib/system/nuttx/io.c:105: undefined reference to `up_addrenv_pa_to_va&#39;
riscv64-unknown-elf-ld: nuttx/staging/libopenamp.a(io.o): in function `metal_io_offset_to_phys_&#39;:
nuttx/openamp/libmetal/lib/system/nuttx/io.c:99: undefined reference to `up_addrenv_va_to_pa&#39;
</code></pre></div>
<p>Now we configure NuttX VirtIO‚Ä¶</p>
<h1 id="configure-nuttx-virtio-for-tinyemu"><a href="#configure-nuttx-virtio-for-tinyemu">12 Configure NuttX VirtIO for TinyEMU</a></h1>
<p>TODO</p>
<p><em>How to make NuttX VirtIO talk to TinyEMU?</em></p>
<p>Previously we saw the TinyEMU config: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L66-L82">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define VIRTIO_BASE_ADDR 0x40010000
#define VIRTIO_SIZE      0x1000
#define VIRTIO_IRQ       1
</code></pre></div>
<p>Now we set the VirtIO Parameters for TinyEMU in NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/boards/risc-v/qemu-rv/rv-virt/src/qemu_rv_appinit.c#L41-L49">qemu_rv_appinit.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define QEMU_VIRTIO_MMIO_BASE    0x40010000 // VIRTIO_BASE_ADDR. Previously: 0x10001000
#define QEMU_VIRTIO_MMIO_REGSIZE 0x1000     // VIRTIO_SIZE
#ifdef CONFIG_ARCH_USE_S_MODE
#  define QEMU_VIRTIO_MMIO_IRQ   26 // TODO: Should this be 1? (VIRTIO_IRQ)
#else
#  define QEMU_VIRTIO_MMIO_IRQ   28 // TODO: Should this be 1? (VIRTIO_IRQ)
#endif
#define QEMU_VIRTIO_MMIO_NUM     1  // Number of VirtIO Devices. Previously: 8
</code></pre></div>
<p>With these settings, VirtIO and OpenAMP will start OK on NuttX yay!</p>
<div class="example-wrap"><pre class="language-text"><code>virtio_mmio_init_device: VIRTIO version: 2 device: 3 vendor: ffff
mm_malloc: Allocated 0x80046a90, size 48
test_virtio: 
mm_malloc: Allocated 0x80046ac0, size 848
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p>Which means NuttX VirtIO + OpenAMP has successfully validated the Magic Number from TinyEMU. (Otherwise NuttX will halt)</p>
<p><em>How does it work?</em></p>
<p>At NuttX Startup: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/boards/risc-v/qemu-rv/rv-virt/src/qemu_rv_appinit.c#L77-L123">board_app_initialize</a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/boards/risc-v/qemu-rv/rv-virt/src/qemu_rv_appinit.c#L54-L73">qemu_virtio_register_mmio_devices</a> (to register all VirtIO MMIO Devices) which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/virtio/virtio-mmio.c#L809-L932">virtio_register_mmio_device</a> 
(to register a VirtIO MMIO Device, explained below)</p>
</li>
</ul>
<p>Let‚Äôs create a VirtIO Queue for the VirtIO Console and send some data‚Ä¶</p>
<h1 id="test-tinyemu-virtio-console-with-nuttx"><a href="#test-tinyemu-virtio-console-with-nuttx">13 Test TinyEMU VirtIO Console with NuttX</a></h1>
<p>TODO</p>
<p><em>NuttX has started VirtIO and OpenAMP and they talk nicely to TinyEMU. What next?</em></p>
<p>We dig around NuttX and we see NuttX creating a VirtIO Queue for VirtIO Console: <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L445-L511">virtio_serial_init</a> calls‚Ä¶</p>
<ul>
<li>OpenAMP <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtio.c#L96-L142">virtio_create_virtqueues</a> (create data queues, explained below)</li>
</ul>
<p>Also we see NuttX sending data to VirtIO Console: <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L310-L345">virtio_serial_dmasend</a> calls‚Ä¶</p>
<ul>
<li>
<p>OpenAMP <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L83C1-L138">virtqueue_add_buffer</a> (send data to queue) and‚Ä¶</p>
<p>OpenAMP <a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L321-L336">virtqueue_kick</a> (start queue processing, explained below)</p>
</li>
</ul>
<p>Let‚Äôs do all these in our NuttX Test Code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/virtio/virtio-mmio.c#L870-L925">virtio-mmio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Testing: Init VirtIO Device
  // Based on virtio_serial_init
  // https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L445-L511

  struct virtio_device *vdev = &amp;vmdev-&gt;vdev;
  DEBUGASSERT(vdev != NULL);

  virtio_set_status(vdev, VIRTIO_CONFIG_STATUS_DRIVER);
  virtio_set_features(vdev, 0);
  virtio_set_status(vdev, VIRTIO_CONFIG_FEATURES_OK);

  #define VIRTIO_SERIAL_RX           0
  #define VIRTIO_SERIAL_TX           1
  #define VIRTIO_SERIAL_NUM          2
  const char *vqnames[VIRTIO_SERIAL_NUM];
  vqnames[VIRTIO_SERIAL_RX]   = &quot;virtio_serial_rx&quot;;
  vqnames[VIRTIO_SERIAL_TX]   = &quot;virtio_serial_tx&quot;;

  vq_callback callbacks[VIRTIO_SERIAL_NUM];
  callbacks[VIRTIO_SERIAL_RX] = NULL; // TODO: virtio_serial_rxready;
  callbacks[VIRTIO_SERIAL_TX] = NULL; // TODO: virtio_serial_txdone;
  ret = virtio_create_virtqueues(vdev, 0, VIRTIO_SERIAL_NUM, vqnames,
                                 callbacks);
  DEBUGASSERT(ret &gt;= 0);
  virtio_set_status(vdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);

  // Testing: Send data to VirtIO Device
  // Based on virtio_serial_dmasend
  // https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L310-L345

  DEBUGASSERT(vdev-&gt;vrings_info != NULL);
  struct virtqueue *vq = vdev-&gt;vrings_info[VIRTIO_SERIAL_TX].vq;
  DEBUGASSERT(vq != NULL);

  /* Set the virtqueue buffer */
  static char *HELLO_MSG = &quot;Hello VirtIO from NuttX!\r\n&quot;;
  struct virtqueue_buf vb[2];
  vb[0].buf = HELLO_MSG;
  vb[0].len = strlen(HELLO_MSG);
  int num = 1;

  /* Get the total send length */
  uintptr_t len = strlen(HELLO_MSG);

  // TODO: What&#39;s this?
  // if (xfer-&gt;nlength != 0)
  //   {
  //     vb[1].buf = xfer-&gt;nbuffer;
  //     vb[1].len = xfer-&gt;nlength;
  //     num = 2;
  //   }

  /* Add buffer to TX virtiqueue and notify the VirtIO Host */
  virtqueue_add_buffer(vq, vb, num, 0, (FAR void *)len);
  virtqueue_kick(vq);  
  // End of Testing
</code></pre></div>
<p><em>Does it work?</em></p>
<p>Yep NuttX prints correctly to TinyEMU‚Äôs VirtIO Console yay!</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/"><strong>Demo of NuttX on TinyEMU: lupyuen.github.io/nuttx-tinyemu</strong></a></p>
<div class="example-wrap"><pre class="language-text"><code>+ temu nuttx.cfg
123ABCnx_start: Entry
builtin_initialize: Registering Builtin Loader
elf_initialize: Registering ELF
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
nx_start_application: Starting init thread
task_spawn: name=nsh_main entry=0x8000756e file_actions=0 attr=0x80043e80 argv=0x80043e78
virtio_mmio_init_device: VIRTIO version: 2 device: 3 vendor: ffff
Hello VirtIO from NuttX!
nx_start: CPU0: Beginning Idle Loop
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8805f8f21dfae237bc06dfbda210628b">(See the Complete Log)</a></p>
<p>Up Next: Implement Console Input / Output with the NuttX Serial Driver for VirtIO</p>
<p>But for now: Let‚Äôs look inside our VirtIO Guest (NuttX) and VirtIO Host (TinyEMU)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tinyemu-title.png" alt="Apache NuttX RTOS in the Web Browser: TinyEMU with VirtIO" /></p>
<h1 id="inside-the-virtio-driver-for-nuttx"><a href="#inside-the-virtio-driver-for-nuttx">14 Inside the VirtIO Driver for NuttX</a></h1>
<p>TODO</p>
<p><em>How does VirtIO Guest work in NuttX?</em></p>
<p>NuttX VirtIO Driver is based on OpenAMP with MMIO‚Ä¶</p>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=_8CpLNEWxfo">Running NuttX with VirtIO on QEMU</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=CYMkAv-WjQg">NuttX VirtIO Framework and Future Works</a></p>
</li>
</ul>
<p>At NuttX Startup: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/boards/risc-v/qemu-rv/rv-virt/src/qemu_rv_appinit.c#L77-L123">board_app_initialize</a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/boards/risc-v/qemu-rv/rv-virt/src/qemu_rv_appinit.c#L54-L73">qemu_virtio_register_mmio_devices</a> (to register all VirtIO MMIO Devices) which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/tinyemu/drivers/virtio/virtio-mmio.c#L809-L932">virtio_register_mmio_device</a> 
(to register a VirtIO MMIO Device) which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-mmio.c#L740-L805">virtio_mmio_init_device</a> which passes‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-mmio.c#L234-L254">g_virtio_mmio_dispatch</a> which contains‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-mmio.c#L419">virtio_mmio_create_virtqueues</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-mmio.c#L349-L414">virtio_mmio_create_virtqueue</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L49">virtqueue_create</a> (OpenAMP)</p>
</li>
</ul>
<p>To create a VirtIO Queue for VirtIO Console: <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L530">virtio_serial_probe</a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L445-L511">virtio_serial_init</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtio.c#L96-L142">virtio_create_virtqueues</a> (OpenAMP)</p>
</li>
</ul>
<p>To send data to VirtIO Console: <a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L245">virtio_serial_send</a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L345-L357">virtio_serial_dmatxavail</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/serial/serial_dma.c#L86-L125">uart_xmitchars_dma</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/drivers/virtio/virtio-serial.c#L310-L345">virtio_serial_dmasend</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L83C1-L138">virtqueue_add_buffer</a> (OpenAMP) and‚Ä¶</p>
<p><a href="https://github.com/OpenAMP/open-amp/blob/main/lib/virtio/virtqueue.c#L321-L336">virtqueue_kick</a> (OpenAMP)</p>
</li>
</ul>
<h1 id="inside-the-virtio-host-for-tinyemu"><a href="#inside-the-virtio-host-for-tinyemu">15 Inside the VirtIO Host for TinyEMU</a></h1>
<p>TODO</p>
<p><em>How does VirtIO Host work in TinyEMU?</em></p>
<p>Let‚Äôs look inside the implementation of VirtIO in TinyEMU‚Ä¶</p>
<h2 id="tinyemu-virtio"><a href="#tinyemu-virtio">15.1 TinyEMU VirtIO</a></h2>
<p>TODO</p>
<p>TinyEMU supports these VirtIO Devices:</p>
<ul>
<li>
<p>Console Device</p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L979-L1133">Block Device</a></p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L1133-L1259">Network Device</a></p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L1361-L1645">Input Device</a></p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L1645-L2649">9P Filesystem Device</a></p>
</li>
</ul>
<p>The Device IDs are: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L219-L297">virtio_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>switch(device_id) {
case 1: /* net */ ...
case 2: /* block */ ...
case 3: /* console */ ...
case 9: /* Network Device */ ...
case 18: /* Input Device */ ...
</code></pre></div>
<p>TinyEMU supports VirtIO over MMIO and PCI:</p>
<ul>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L37">MMIO addresses</a></p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L66">PCI registers</a></p>
</li>
</ul>
<p>TinyEMU Guests (like NuttX) are required to check the <a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L617">VIRTIO_MMIO_MAGIC_VALUE</a> that‚Äôs returned by the TinyEMU Host.</p>
<h2 id="tinyemu-virtio-console"><a href="#tinyemu-virtio-console">15.2 TinyEMU VirtIO Console</a></h2>
<p>TODO</p>
<p>From above: VirtIO Console is Device ID 3. Here‚Äôs how it works‚Ä¶</p>
<p>At TinyEMU Startup: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L952">riscv_machine_init</a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L1347-L1361">virtio_console_init</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L219-L297">virtio_init</a> with Device ID 3</p>
</li>
</ul>
<p>To print to VirtIO Console: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/jsemu.c#L304-L348">virt_machine_run (js)</a> and <a href="https://github.com/fernandotcl/TinyEMU/blob/master/temu.c#L545-L610">virt_machine_run (temu)</a> call‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L1317-L1337">virtio_console_write_data</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L451-L459">memcpy_to_queue</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L380">memcpy_to_from_queue</a></p>
</li>
</ul>
<p>Which will access‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L97-L107">QueueState</a>: For desc_addr, avail_addr, used_addr</p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L111-L118">VIRTIODesc</a>: For <a href="https://wiki.osdev.org/Virtio#Virtual_Queue_Descriptor">VirtualQueue::Buffers[QueueSize]</a></p>
</li>
</ul>
<p>TinyEMU Console Device:</p>
<ul>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.h#L108">console device decl</a></p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L1261">console device impl</a></p>
</li>
</ul>
<h2 id="tinyemu-virtio-mmio-queue"><a href="#tinyemu-virtio-mmio-queue">15.3 TinyEMU VirtIO MMIO Queue</a></h2>
<p>TODO</p>
<p>TinyEMU Guest (like NuttX) is required to set the VirtIO Queue Desc / Avail / Used.</p>
<p>This is how TinyEMU accesses the VirtIO MMIO Queue: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L645">virtio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>case VIRTIO_MMIO_QUEUE_SEL:
    val = s-&gt;queue_sel;
    break;
case VIRTIO_MMIO_QUEUE_NUM_MAX:
    val = MAX_QUEUE_NUM;
    break;
case VIRTIO_MMIO_QUEUE_NUM:
    val = s-&gt;queue[s-&gt;queue_sel].num;
    break;
case VIRTIO_MMIO_QUEUE_DESC_LOW:
    val = s-&gt;queue[s-&gt;queue_sel].desc_addr;
    break;
case VIRTIO_MMIO_QUEUE_AVAIL_LOW:
    val = s-&gt;queue[s-&gt;queue_sel].avail_addr;
    break;
case VIRTIO_MMIO_QUEUE_USED_LOW:
    val = s-&gt;queue[s-&gt;queue_sel].used_addr;
    break;
#if VIRTIO_ADDR_BITS == 64
case VIRTIO_MMIO_QUEUE_DESC_HIGH:
    val = s-&gt;queue[s-&gt;queue_sel].desc_addr &gt;&gt; 32;
    break;
case VIRTIO_MMIO_QUEUE_AVAIL_HIGH:
    val = s-&gt;queue[s-&gt;queue_sel].avail_addr &gt;&gt; 32;
    break;
case VIRTIO_MMIO_QUEUE_USED_HIGH:
    val = s-&gt;queue[s-&gt;queue_sel].used_addr &gt;&gt; 32;
    break;
#endif
</code></pre></div>
<p>To Select and Notify the Queue:</p>
<ul>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L741">VIRTIO_MMIO_QUEUE_SEL</a></p>
</li>
<li>
<p><a href="https://github.com/fernandotcl/TinyEMU/blob/master/virtio.c#L781">VIRTIO_MMIO_QUEUE_NOTIFY</a></p>
</li>
</ul>
<h1 id="nuttx-in-kernel-mode"><a href="#nuttx-in-kernel-mode">16 NuttX in Kernel Mode</a></h1>
<p>TODO</p>
<p><em>Right now we‚Äôre running NuttX in Flat Mode‚Ä¶</em></p>
<p><em>Can NuttX run in Kernel Mode on TinyEMU?</em></p>
<p>NuttX Kernel Mode requires <a href="https://lupyuen.github.io/articles/semihost#semihosting-on-nuttx-qemu">RISC-V Semihosting</a> to access the NuttX Apps Filesystem. Which is supported by QEMU but not TinyEMU.</p>
<p>But we can <a href="https://lupyuen.github.io/articles/app#initial-ram-disk">Append the Initial RAM Disk</a> to the NuttX Kernel. So yes it‚Äôs possible to run NuttX in Kernel Mode with TinyEMU, with some additional <a href="https://lupyuen.github.io/articles/app#mount-the-initial-ram-disk">Mounting Code</a>.</p>
<h1 id="whats-next"><a href="#whats-next">17 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tinyemu.md"><strong>lupyuen.github.io/src/tinyemu.md</strong></a></p>
<h1 id="appendix-build-nuttx-for-tinyemu"><a href="#appendix-build-nuttx-for-tinyemu">18 Appendix: Build NuttX for TinyEMU</a></h1>
<p>TODO</p>
<p>In this article, we compiled a Work-In-Progress Version of <strong>Apache NuttX RTOS for QEMU RISC-V (64-bit)</strong> that has Minor Fixes for Nim‚Ä¶</p>
<p>TODO</p>
<p>TODO: Then we download and build NuttX for <strong>QEMU RISC-V (64-bit)</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for QEMU RISC-V (64-bit)
cd nuttx
tools/configure.sh rv-virt:nsh64

## Build NuttX
make

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Script</strong>)</a></p>
<p>TODO: <a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa">(See the <strong>Build Log</strong>)</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>TODO: This produces the NuttX ELF Image <strong><code>nuttx</code></strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU RISC-V Emulator (64-bit) with NuttX RTOS
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>TODO: To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>

    
</body>
</html>