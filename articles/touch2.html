<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Touch Panel</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Touch Panel" 
    data-rh="true">
<meta property="og:description" 
    content="All about the Capacitive Touch Panel of Pine64 PinePhone... And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="All about the Capacitive Touch Panel of Pine64 PinePhone... And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/touch2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Touch Panel</h1>
    <nav id="TOC"><ul>
<li><a href="#goodix-gt917s-touch-panel">1 Goodix GT917S Touch Panel</a><ul></ul></li>
<li><a href="#read-the-product-id">2 Read the Product ID</a><ul></ul></li>
<li><a href="#poll-the-touch-panel">3 Poll the Touch Panel</a><ul></ul></li>
<li><a href="#read-a-touch-point">4 Read a Touch Point</a><ul></ul></li>
<li><a href="#attach-our-interrupt-handler">5 Attach our Interrupt Handler</a><ul></ul></li>
<li><a href="#handle-interrupts-from-touch-panel">6 Handle Interrupts from Touch Panel</a><ul></ul></li>
<li><a href="#nuttx-touch-panel-driver">7 NuttX Touch Panel Driver</a><ul></ul></li>
<li><a href="#lvgl-calls-our-driver">8 LVGL Calls Our Driver</a><ul></ul></li>
<li><a href="#whats-next">9 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>14 Jan 2023</em></p>
<p><img src="https://lupyuen.github.io/images/touch2-title.png" alt="Apache NuttX RTOS reads the PinePhone Touch Panel" /></p>
<p>We‚Äôre porting <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) to <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></li>
</ul>
<p>Now we can render <a href="https://lupyuen.github.io/articles/fb#lvgl-graphics-library"><strong>LVGL Graphical User Interfaces</strong></a>‚Ä¶ But it won‚Äôt work yet with <strong>Touch Input</strong>!</p>
<p>Let‚Äôs talk about the <strong>Capacitive Touch Panel</strong> inside PinePhone‚Ä¶</p>
<ul>
<li>
<p>How it‚Äôs <strong>connected to PinePhone</strong></p>
<p>(Over I2C)</p>
</li>
<li>
<p>How we read <strong>Touch Points</strong></p>
<p>(Polling vs Interrupts)</p>
</li>
<li>
<p>How we created the <strong>Touch Panel Driver</strong> for NuttX</p>
<p>(Despite the missing docs)</p>
</li>
<li>
<p>And how we call the driver from <strong>LVGL Apps</strong></p>
<p><a href="https://www.youtube.com/shorts/xE9U5IQPmlg">(Watch the Demo on YouTube)</a></p>
</li>
</ul>
<p>We begin with the internals of the Touch Panel‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-schematic1.jpg" alt="Capacitive Touch Panel in PinePhone Schematic (Pages 9 and 11)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>Capacitive Touch Panel in PinePhone Schematic (Pages 9 and 11)</em></a></p>
<h1 id="goodix-gt917s-touch-panel"><a href="#goodix-gt917s-touch-panel">1 Goodix GT917S Touch Panel</a></h1>
<p>Inside PinePhone is the <strong>Goodix GT917S Capacitive Touch Panel</strong> (CTP) that talks over I2C.</p>
<p>According to the <a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><strong>PinePhone Schematic</strong></a> Pages 9 and 11 (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>Touch Panel Interrupt</strong> (CTP-INT) is at <strong>PH4</strong></p>
<p>(Touch Panel fires an interrupt at PH4 when it‚Äôs touched)</p>
</li>
<li>
<p><strong>Touch Panel Reset</strong> (CTP-RST) is at <strong>PH11</strong></p>
<p>(We toggle PH11 to reset the Touch Panel)</p>
</li>
<li>
<p><strong>Touch Panel I2C</strong> (SCK / SDA) is at <strong>TWI0</strong></p>
<p>(That‚Äôs the port for Two Wire Interface, compatible with I2C)</p>
</li>
</ul>
<p><em>What are PH4 and PH11?</em></p>
<p>Just think of them as GPIOs on the Allwinner A64 SoC.</p>
<p>(Allwinner calls them PIOs)</p>
<p><em>Does it need special power?</em></p>
<p>Please remember to <strong>power up LDO (3.3V)</strong> through the Power Management Integrated Circuit‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lcd#power-on-lcd-panel"><strong>‚ÄúPower On LCD Panel‚Äù</strong></a></li>
</ul>
<p>PinePhone‚Äôs Touch Panel doesn‚Äôt seem to be the Power-Saving type like <a href="https://lupyuen.github.io/articles/touch#cst816s-touch-panel"><strong>PineTime‚Äôs CST816S</strong></a>.</p>
<p><em>How do we program the Touch Panel?</em></p>
<p>The datasheet doesn‚Äôt say much about programming the Touch Panel‚Ä¶</p>
<ul>
<li><a href="https://files.pine64.org/doc/datasheet/pinephone/GT917S-Datasheet.pdf"><strong>GT917S Datasheet</strong></a></li>
</ul>
<p>So we‚Äôll create the driver by replicating the <strong>I2C Read / Write Operations</strong> from the official Android Driver <a href="https://github.com/goodix/gt9xx_driver_android/blob/master/gt9xx.c"><strong>gt9xx.c</strong></a>.</p>
<p>(Or the unofficial simpler driver <a href="https://github.com/DiveInEmbedded/GT911-Touch-driver/blob/main/Core/Src/GT911.c"><strong>GT911.c</strong></a>)</p>
<p><em>So PinePhone‚Äôs Touch Panel is actually undocumented?</em></p>
<p>Yeah it‚Äôs strangely common for Touch Panels to be undocumented.</p>
<p>(Just like PineTime‚Äôs <a href="https://lupyuen.github.io/articles/touch#cst816s-touch-panel"><strong>CST816S Touch Panel</strong></a>)</p>
<p>Let‚Äôs experiment with PinePhone‚Äôs Touch Panel to understand how it works‚Ä¶</p>
<p><a href="https://patents.google.com/patent/US7663607B2/en">(I think Touch Panels are poorly documented because of Apple‚Äôs patent on Multitouch)</a></p>
<p><img src="https://lupyuen.github.io/images/touch2-code2a.png" alt="Reading the Product ID from Touch Panel" /></p>
<h1 id="read-the-product-id"><a href="#read-the-product-id">2 Read the Product ID</a></h1>
<p><em>What‚Äôs the simplest thing we can do with PinePhone‚Äôs Touch Panel?</em></p>
<p>Let‚Äôs read the <strong>Product ID</strong> from the Touch Panel.</p>
<p>We experimented with the Touch Panel (Bare Metal with NuttX) and discovered these <strong>I2C Settings</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>I2C Address</strong> is <strong><code>0x5D</code></strong></p>
</li>
<li>
<p><strong>I2C Frequency</strong> is <strong>400 kHz</strong></p>
<p>(What‚Äôs the max?)</p>
</li>
<li>
<p><strong>I2C Register Addresses</strong> are 16-bit</p>
<p>(Send MSB before LSB, so we should swap the bytes)</p>
</li>
<li>
<p>Reading I2C Register <strong><code>0x8140</code></strong> (Product ID) will return the bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>39 31 37 53</code></pre></div>
<p>Which is ASCII for ‚Äú<strong><code>917S</code></strong>‚Äù</p>
<p>(Goodix GT917S Touch Panel)</p>
</li>
</ul>
<p>Based on the above settings, we wrote this <strong>Test Code</strong> that runs in the NuttX Kernel: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c4991b1503387d57821d94a549425bcd8f268841/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L316-L355">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Read Product ID from Touch Panel over I2C
static void touch_panel_read(
  struct i2c_master_s *i2c  // NuttX I2C Bus (Port TWI0)
) {
  uint32_t freq = 400000;  // I2C Frequency: 400 kHz
  uint16_t addr = 0x5d;    // Default I2C Address for Goodix GT917S
  uint16_t reg  = 0x8140;  // Register Address: Read Product ID

  // Swap the Register Address, MSB first
  uint8_t regbuf[2] = {
    reg &gt;&gt; 8,   // First Byte: MSB
    reg &amp; 0xff  // Second Byte: LSB
  };

  // Erase the Receive Buffer (4 bytes)
  uint8_t buf[4];
  memset(buf, 0xff, sizeof(buf));

  // Compose the I2C Messages
  struct i2c_msg_s msgv[2] = {
    // Send the 16-bit Register Address (MSB first)
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = 0,
      .buffer    = regbuf,
      .length    = sizeof(regbuf)
    },
    // Receive the Register Data (4 bytes)
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = I2C_M_READ,
      .buffer    = buf,
      .length    = sizeof(buf)
    }
  };

  // Execute the I2C Transfer
  int ret = I2C_TRANSFER(i2c, msgv, 2);
  DEBUGASSERT(ret == OK);

  // Dump the Receive Buffer
  infodumpbuffer(&quot;buf&quot;, buf, buflen);
  // Shows &quot;39 31 37 53&quot; or &quot;917S&quot;
}</code></pre></div>
<p>This is what we see (with TWI0 Logging Enabled)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code3a.png" alt="Read Product ID from Touch Panel" /></p>
<p>Yep the I2C Response is correct‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>39 31 37 53</code></pre></div>
<p>Which is ASCII for ‚Äú<strong><code>917S</code></strong>‚Äù!</p>
<p>(Goodix GT917S Touch Panel)</p>
<p><em>How‚Äôs the code above called by NuttX Kernel?</em></p>
<p>Read on to find out how we poll the Touch Panel‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code1a.png" alt="Polling the Touch Panel" /></p>
<h1 id="poll-the-touch-panel"><a href="#poll-the-touch-panel">3 Poll the Touch Panel</a></h1>
<p><em>We need to handle interrupts triggered by the Touch Panel right?</em></p>
<p>To detect Touch Events, we‚Äôll need to <strong>handle the interrupts</strong> triggered by Touch Panel.</p>
<p>Based on our research, PinePhone‚Äôs <strong>Touch Panel Interrupt</strong> (CTP-INT) is connected at <strong>PH4</strong>.</p>
<p>But to simplify our first experiment, <strong>let‚Äôs poll PH4</strong>. (Instead of handling interrupts)</p>
<p><em>How do we poll PH4?</em></p>
<p>We read PH4 as a <strong>GPIO Input</strong>. When we touch the Touch Panel, PH4 goes from <strong>Low to High</strong>.</p>
<p>This is how we poll PH4: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L283-L317">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Test Touch Panel Interrupt by Polling as GPIO Input.
// Touch Panel Interrupt (CTP-INT) is at PH4.
// We configure it for GPIO Input.
#define CTP_INT (PIO_INPUT | PIO_PORT_PIOH | PIO_PIN4)

// Poll for Touch Panel Interrupt (PH4) by reading as GPIO Input
void touch_panel_initialize(
  struct i2c_master_s *i2c  // NuttX I2C Bus (Port TWI0)
) {

  // Configure the Touch Panel Interrupt for GPIO Input
  int ret = a64_pio_config(CTP_INT);
  DEBUGASSERT(ret == 0);

  // Poll the Touch Panel Interrupt as GPIO Input
  bool prev_val = false;
  for (int i = 0; i &lt; 6000; i++) {  // Poll for 60 seconds

    // Read the GPIO Input
    bool val = a64_pio_read(CTP_INT);

    // If value has changed...
    if (val != prev_val) {

      // Print the transition
      if (val) { up_putc(&#39;+&#39;); }  // PH4 goes Low to High
      else     { up_putc(&#39;-&#39;); }  // PH4 goes High to Low
      prev_val = val;

      // If PH4 has just transitioned from Low to High...
      if (val) {

        // Read the Touch Panel over I2C
        touch_panel_read(i2c);
      }
    }

    // Wait a while
    up_mdelay(10);
  }
}</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L174-L344">(<strong>a64_pio_config</strong> configures PH4 as an Input Pin)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L390-L420">(<strong>a64_pio_read</strong> reads PH4 as an Input Pin)</a></p>
<p>The loop above watches for PH4 shifting from <strong>Low to High</strong>‚Ä¶</p>
<ul>
<li>
<p>When PH4 shifts from <strong>Low to High</strong>, we print ‚Äú<strong><code>+</code></strong>‚Äù</p>
</li>
<li>
<p>When PH4 shifts from <strong>High to Low</strong>, we print ‚Äú<strong><code>-</code></strong>‚Äù</p>
</li>
<li>
<p>After shifting from <strong>Low to High</strong>, we call <a href="https://lupyuen.github.io/articles/touch2#read-product-id"><strong>touch_panel_read</strong></a> to read the Touch Panel</p>
<p><a href="https://lupyuen.github.io/articles/touch2#read-product-id">(Which we‚Äôve seen earlier)</a></p>
</li>
</ul>
<p>Thus our simple loop simulates an <strong>Interrupt Handler</strong>!</p>
<p><em>How do we open the I2C Port?</em></p>
<p>This is how we <strong>open the I2C Port</strong> on NuttX, and pass it to the above loop: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L158-L170">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Open Allwinner A64 Port TWI0 for I2C
struct i2c_master_s *i2c =
  a64_i2cbus_initialize(0);  // 0 for TWI0

// Pass the I2C Port to the above loop
touch_panel_initialize(i2c);</code></pre></div>
<p>We insert this code at the end of the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L57-L175"><strong>PinePhone Bringup Function</strong></a>, so that NuttX Kernel will run it at the end of startup.</p>
<p>(Yes it sounds hacky, but it‚Äôs a simple way to do Kernel Experiments)</p>
<p>Now that we have simulated an Interrupt Handler, let‚Äôs read a Touch Point!</p>
<p><img src="https://lupyuen.github.io/images/touch2-code4a.png" alt="Reading a Touch Point" /></p>
<h1 id="read-a-touch-point"><a href="#read-a-touch-point">4 Read a Touch Point</a></h1>
<p><em>When the Touch Panel is touched, how do we read the Touch Coordinates?</em></p>
<p>Based on the <a href="https://github.com/DiveInEmbedded/GT911-Touch-driver/blob/main/Core/Src/GT911.c"><strong>Reference Code</strong></a>, here are the steps to <strong>read a Touch Point</strong>‚Ä¶</p>
<ol>
<li>
<p>Read the <strong>Touch Panel Status</strong> (1 byte) at I2C Register <strong><code>0x814E</code></strong></p>
<p><strong>Status Code</strong> is <strong>Bit 7</strong> of Touch Panel Status</p>
<p><strong>Touched Points</strong> is <strong>Bits 0 to 3</strong> of Touch Panel Status</p>
</li>
<li>
<p>If <strong>Status Code</strong> is non-zero and <strong>Touched Points</strong> is 1 or more‚Ä¶</p>
<p>Read the <strong>Touch Coordinates</strong> (6 bytes) at I2C Register <strong><code>0x8150</code></strong></p>
<p><strong>First 2 Bytes</strong> (LSB First) are the <strong>X Coordinate</strong> (0 to 720)</p>
<p><strong>Next 2 Bytes</strong> (LSB First) are the <strong>Y Coordinate</strong> (0 to 1440)</p>
</li>
<li>
<p>To stop the Touch Interrupt, set the <strong>Touch Panel Status</strong> to 0‚Ä¶</p>
<p>Write 0 to I2C Register <strong><code>0x814E</code></strong></p>
</li>
</ol>
<p>(This won‚Äôt support Multitouch, more about this later)</p>
<p>Here is our code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L338-L370">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// I2C Registers for Touch Panel
#define GOODIX_READ_COORD_ADDR 0x814E  // Touch Panel Status
#define GOODIX_POINT1_X_ADDR   0x8150  // First Touch Point

// Read Touch Panel over I2C
static void touch_panel_read(
  struct i2c_master_s *i2c  // NuttX I2C Bus (Port TWI0)
) {

  // Read the Touch Panel Status
  uint8_t status[1];
  touch_panel_i2c_read(      // Read from I2C Touch Panel...
    i2c,                     // NuttX I2C Bus (Port TWI0)
    GOODIX_READ_COORD_ADDR,  // I2C Register: 0x814E
    status,                  // Receive Buffer
    sizeof(status)           // Buffer Size
  );
  // Receives &quot;81&quot;

  // Decode the Status Code and the Touched Points
  const uint8_t status_code    = status[0] &amp; 0x80;  // Set to 0x80
  const uint8_t touched_points = status[0] &amp; 0x0f;  // Set to 0x01

  if (status_code != 0 &amp;&amp;     // If Status Code is OK and...
      touched_points &gt;= 1) {  // Touched Points is 1 or more

    // Read the First Touch Coordinates
    uint8_t touch[6];
    touch_panel_i2c_read(    // Read from I2C Touch Panel...
      i2c,                   // NuttX I2C Bus (Port TWI0)
      GOODIX_POINT1_X_ADDR,  // I2C Register: 0x8150
      touch,                 // Receive Buffer
      sizeof(touch)          // Buffer Size
    );
    // Receives &quot;92 02 59 05 1b 00&quot;

    // Decode the Touch Coordinates
    const uint16_t x = touch[0] + (touch[1] &lt;&lt; 8);
    const uint16_t y = touch[2] + (touch[3] &lt;&lt; 8);
    _info(&quot;touch x=%d, y=%d\n&quot;, x, y);
    // Shows &quot;touch x=658, y=1369&quot;
  }

  // Set the Touch Panel Status to 0
  touch_panel_set_status(i2c, 0);
}</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L372-L415">(<strong>touch_panel_i2c_read</strong> reads from the I2C Touch Panel)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L417-L447">(<strong>touch_panel_set_status</strong> sets the I2C Touch Panel Status)</a></p>
<p>Let‚Äôs run the code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-run1a.png" alt="Reading Touch Points with Polling" /></p>
<p>When we tap the screen, we see ‚Äú<strong><code>-+</code></strong>‚Äù which means that PH4 has shifted from Low to High.</p>
<p>Followed by the reading of the <strong>Touch Panel Status</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>-+
twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
buf (0x40a8fd08):
0000  81                                               .               </code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b1ed009961c4202133879b760cb22833">(Source)</a></p>
<p>Touch Panel Status is <strong><code>0x81</code></strong>.  Which means the status is OK and there‚Äôs <strong>One Touch Point</strong> detected.</p>
<p>Our code reads the <strong>Touch Coordinates</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
buf (0x40a8fd20):
0000  92 02 59 05 1b 00                                ..Y...          
touch_panel_read: touch x=658, y=1369</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b1ed009961c4202133879b760cb22833">(Source)</a></p>
<p>This says that the Touch Point is at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>x=658, y=1369</code></pre></div>
<p>Which is quite close to the Lower Right Corner. (Screen size is 720 x 1440)</p>
<p>Yep we can read the Touch Coordinates correctly, through polling! (But not so efficiently)</p>
<p>Let‚Äôs handle interrupts from the Touch Panel‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code5a.png" alt="Attaching our Interrupt Handler" /></p>
<h1 id="attach-our-interrupt-handler"><a href="#attach-our-interrupt-handler">5 Attach our Interrupt Handler</a></h1>
<p><em>We‚Äôve done polling with the Touch Panel‚Ä¶</em></p>
<p><em>How do we handle interrupts from the Touch Panel?</em></p>
<p>In the previous section we‚Äôve read the Touch Panel by polling‚Ä¶ Which is easier but inefficient.</p>
<p>Now we do a proper <strong>Interrupt Handler</strong> for the Touch Panel. This is how we attach our Interrupt Handler to PH4 in NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L255-L328">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Touch Panel Interrupt (CTP-INT) is at PH4
#define CTP_INT ( \
  PIO_EINT      | \  /* PIO External Interrupt */
  PIO_PORT_PIOH | \  /* PIO Port H */
  PIO_PIN4        \  /* PIO Pin 4 */
)

// Register the Interrupt Handler for Touch Panel
void touch_panel_initialize(void) {

  // Attach the PIO Interrupt Handler for Port PH
  int ret = irq_attach(     // Attach a NuttX Interrupt Handler...
    A64_IRQ_PH_EINT,        // Interrupt Number for Port PH: 53
    touch_panel_interrupt,  // Interrupt Handler
    NULL                    // Argument for Interrupt Handler
  );
  DEBUGASSERT(ret == OK);

  // Enable the PIO Interrupt for Port PH.
  // A64_IRQ_PH_EINT is 53.
  up_enable_irq(A64_IRQ_PH_EINT);

  // Configure the Touch Panel Interrupt for Pin PH4
  ret = a64_pio_config(CTP_INT);
  DEBUGASSERT(ret == 0);

  // Enable the Touch Panel Interrupt for Pin PH4
  ret = a64_pio_irqenable(CTP_INT);
  DEBUGASSERT(ret == 0);
}</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L174-L344">(<strong>a64_pio_config</strong> configures PH4 as an Interrupt Pin)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L420-L440">(<strong>a64_pio_irqenable</strong> enables interrupts on Pin PH4)</a></p>
<p><em>Why call both up_enable_irq and a64_pio_irqenable?</em></p>
<p>Allwinner A64 does Two-Tier Interrupts, by Port and Pin‚Ä¶</p>
<ul>
<li>
<p>First we enable interrupts for <strong>Port PH</strong></p>
<p>(By calling <strong>up_enable_irq</strong>)</p>
</li>
<li>
<p>Then we enable interrupts for <strong>Pin PH4</strong></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L420-L440">(By calling <strong>a64_pio_irqenable</strong>)</a></p>
</li>
</ul>
<p>Which means that our Interrupt Handler will be shared by <strong>all Pins on Port PH</strong>.</p>
<p>(When we enable them in future)</p>
<p><em>What‚Äôs touch_panel_interrupt?</em></p>
<p><strong>touch_panel_interrupt</strong> is our Interrupt Handler. Let‚Äôs do a simple one‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Interrupt Handler for Touch Panel
static int touch_panel_interrupt(int irq, void *context, void *arg) {

  // Print something when interrupt is triggered
  up_putc(&#39;.&#39;);
  return OK;
}</code></pre></div>
<p>This Interrupt Handler simply prints ‚Äú<strong><code>.</code></strong>‚Äù whenever the Touch Panel triggers an interrupt.</p>
<p><em>It‚Äôs OK to call up_putc in an Interrupt Handler?</em></p>
<p>Yep it‚Äôs perfectly OK, because <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_serial.c#L619-L649"><strong>up_putc</strong></a> simply writes to the UART Register. (It won‚Äôt trigger another interrupt)</p>
<p><img src="https://lupyuen.github.io/images/touch2-run2a.png" alt="Touch Panel triggers our Interrupt Handler Non-Stop" /></p>
<p><em>What happens when we run this?</em></p>
<p>When we run the code, it generates a <strong>never-ending stream</strong> of ‚Äú<strong><code>.</code></strong>‚Äù characters‚Ä¶</p>
<p><strong>Without us touching</strong> the screen! (Pic above)</p>
<p><em>Is this a bad thing?</em></p>
<p>Yes it‚Äôs terrible! This means that the Touch Panel fires Touch Input Interrupts continuously‚Ä¶</p>
<p><strong>NuttX will be overwhelmed</strong> handling Touch Input Interrupts 100% of the time. No time for other tasks!</p>
<p>We‚Äôll fix this by <strong>throttling the interrupts</strong> from the Touch Panel. Here‚Äôs how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code6a.png" alt="Handling Interrupts from Touch Panel" /></p>
<h1 id="handle-interrupts-from-touch-panel"><a href="#handle-interrupts-from-touch-panel">6 Handle Interrupts from Touch Panel</a></h1>
<p>TODO</p>
<p><em>Is our Interrupt Handler code correct?</em></p>
<p>Yep our Interrupt Handler code is correct! But through our experiments we discovered one thing‚Ä¶</p>
<p>To stop the repeated Touch Input Interrupts, we need to set the <strong>Touch Panel Status to 0</strong>! Like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L470-L500">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// When the Touch Input Interrupt is triggered...
// Set the Touch Panel Status to 0
touch_panel_set_status(i2c, 0);
...

#define GOODIX_READ_COORD_ADDR 0x814E  // Touch Panel Status (Read / Write)
#define CTP_FREQ 400000  // I2C Frequency: 400 kHz
#define CTP_I2C_ADDR 0x5d  // Default I2C Address for Goodix GT917S

// Set the Touch Panel Status
static int touch_panel_set_status(
  struct i2c_master_s *i2c,  // I2C Bus
  uint8_t status  // Status value to be set
) {
  uint16_t reg = GOODIX_READ_COORD_ADDR;  // I2C Register
  uint32_t freq = CTP_FREQ;  // 400 kHz
  uint16_t addr = CTP_I2C_ADDR;  // Default I2C Address for Goodix GT917S
  uint8_t buf[3] = {
    reg &gt;&gt; 8,    // Swap the bytes
    reg &amp; 0xff,  // Swap the bytes
    status
  };

  // Compose the I2C Message
  struct i2c_msg_s msgv[1] =
  {
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = 0,
      .buffer    = buf,
      .length    = sizeof(buf)
    }
  };

  // Execute the I2C Transfer
  const int msgv_len = sizeof(msgv) / sizeof(msgv[0]);
  int ret = I2C_TRANSFER(i2c, msgv, msgv_len);
  if (ret &lt; 0) { _err(&quot;I2C Error: %d\n&quot;, ret); return ret; }
  return OK;
}</code></pre></div>
<p><em>So we set the Touch Panel Status inside our Interrupt Handler?</em></p>
<p>But Interrupt Handlers aren‚Äôt allowed to make I2C Calls!</p>
<p>We need to <strong>forward the Interrupt</strong> to a Background Thread to handle. Like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L237-L253">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Interrupt Handler for Touch Panel
static int gt9xx_isr_handler(int irq, FAR void *context, FAR void *arg)
{
   FAR struct gt9xx_dev_s *priv = (FAR struct gt9xx_dev_s *)arg;

 // Set the Interrupt Pending Flag
  irqstate_t flags = enter_critical_section();
  priv-&gt;int_pending = true;
  leave_critical_section(flags);

  // Notify the Poll Waiters
  poll_notify(priv-&gt;fds, GT9XX_NPOLLWAITERS, POLLIN);
  return 0;
}</code></pre></div>
<p>This notifies the File Descriptors <code>fds</code> that are waiting for Touch Input Interrupts to be triggered.</p>
<p>When the File Descriptor is notified, the Background Thread will become unblocked, and can call I2C to read the Touch Input.</p>
<p>Right now we don‚Äôt have a Background Thread, so we poll and wait for the Touch Input Interrupt to be triggered: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L293-L309">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Poll for Touch Panel Interrupt
  // TODO: Move this
  for (int i = 0; i &lt; 6000; i++) {  // Poll for 60 seconds

    // If Touch Panel Interrupt has been triggered...
    if (priv-&gt;int_pending) {

      // Read the Touch Panel over I2C
      touch_panel_read(i2c_dev);

      // Reset the Interrupt Pending Flag
      priv-&gt;int_pending = false;
    }

    // Wait a while
    up_mdelay(10);  // 10 milliseconds
  }</code></pre></div>
<p>And it works!</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
a64_pio_config: cfgaddr=0x1c208fc, intaddr=0x1c20a40, value=0x0, shift=16
touch_panel_initialize: v=0x10, m=0x10, a=0x1c20a50      
buf (0x40a8fd20):
0000  39 31 37 53                                      917S            
buf (0x40a8fd10):
0000  81                                               .               
buf (0x40a8fd28):
0000  19 01 e6 02 2a 00                                ....*.          
touch_panel_read: touch x=281, y=742
...     
buf (0x40a8fd20):
0000  39 31 37 53                                      917S            
buf (0x40a8fd10):
0000  81                                               .               
buf (0x40a8fd28):
0000  81 02 33 00 25 00                                ..3.%.          
touch_panel_read: touch x=641, y=51
...
buf (0x40a8fd20):
0000  39 31 37 53                                      917S            
buf (0x40a8fd10):
0000  81                                               .               
buf (0x40a8fd28):
0000  0f 00 72 05 14 00                                ..r...          
touch_panel_read: touch x=15, y=1394</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/91a37a4b54f75f7386374a30821dc1b2">(Source)</a></p>
<p>Let‚Äôs move this code into the NuttX Touch Panel Driver for PinePhone‚Ä¶</p>
<p>TODO14</p>
<p><img src="https://lupyuen.github.io/images/touch2-run3a.png" alt="TODO" /></p>
<h1 id="nuttx-touch-panel-driver"><a href="#nuttx-touch-panel-driver">7 NuttX Touch Panel Driver</a></h1>
<p>TODO</p>
<p>We moved the code above into the NuttX Touch Panel Driver for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c">drivers/input/gt9xx.c</a></li>
</ul>
<p>This is how we start the driver when NuttX boots: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L197-L204">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define CTP_I2C_ADDR 0x5d  // Default I2C Address for Goodix GT917S
ret = gt9xx_register(&quot;/dev/input0&quot;, i2c, CTP_I2C_ADDR, &amp;g_pinephone_gt9xx);</code></pre></div>
<p>And it works with the LVGL Demo App! Now we need to optimise the rendering‚Ä¶</p>
<ul>
<li><a href="https://www.youtube.com/shorts/xE9U5IQPmlg">Watch the Demo on YouTube</a></li>
</ul>
<h1 id="lvgl-calls-our-driver"><a href="#lvgl-calls-our-driver">8 LVGL Calls Our Driver</a></h1>
<p>TODO: Optimise rendering</p>
<p>TODO: Limitations: Multitouch, swipe, LVGL support</p>
<h1 id="whats-next"><a href="#whats-next">9 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Meanwhile please check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3"><strong>‚ÄúNuttX RTOS for PinePhone: MIPI Display Serial Interface‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de3"><strong>‚ÄúNuttX RTOS for PinePhone: Display Engine‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lcd"><strong>‚ÄúNuttX RTOS for PinePhone: LCD Panel‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/touch2.md"><strong>lupyuen.github.io/src/touch2.md</strong></a></p>

    
</body>
</html>