<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Touch Panel</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Touch Panel" 
    data-rh="true">
<meta property="og:description" 
    content="All about the Capacitive Touch Panel of Pine64 PinePhone... And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="All about the Capacitive Touch Panel of Pine64 PinePhone... And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/touch2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Touch Panel</h1>
    <nav id="TOC"><ul>
<li><a href="#pinephone-touch-panel">1 PinePhone Touch Panel</a><ul></ul></li>
<li><a href="#handle-interrupts-from-touch-panel">2 Handle Interrupts from Touch Panel</a><ul></ul></li>
<li><a href="#nuttx-touch-panel-driver-for-pinephone">3 NuttX Touch Panel Driver for PinePhone</a><ul></ul></li>
<li><a href="#whats-next">4 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>14 Jan 2023</em></p>
<p><img src="https://lupyuen.github.io/images/touch2-title.png" alt="TODO" /></p>
<p>Suppose we‚Äôre running <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>‚Ä¶</p>
<p>TODO: All about the Capacitive Touch Panel of Pine64 PinePhone‚Ä¶ And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS</p>
<p><img src="https://lupyuen.github.io/images/touch2-schematic1.jpg" alt="Capacitive Touch Panel in PinePhone Schematic (Pages 9 and 11)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>Capacitive Touch Panel in PinePhone Schematic (Pages 9 and 11)</em></a></p>
<h1 id="pinephone-touch-panel"><a href="#pinephone-touch-panel">1 PinePhone Touch Panel</a></h1>
<p>TODO</p>
<p>Now that we can render LVGL Graphical User Interfaces, let‚Äôs handle Touch Input!</p>
<p>Here‚Äôs everything we know about PinePhone‚Äôs Touch Panel‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pio#touch-panel"><strong>‚ÄúTouch Panel‚Äù</strong></a></li>
</ul>
<p>According to our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c4991b1503387d57821d94a549425bcd8f268841/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L316-L355"><strong>Test Code</strong></a>‚Ä¶</p>
<ul>
<li>
<p><strong>I2C Address</strong> is <strong>0x5D</strong></p>
</li>
<li>
<p><strong>I2C Frequency</strong> is <strong>400 kHz</strong></p>
<p>(What‚Äôs the max?)</p>
</li>
<li>
<p><strong>I2C Register Addresses</strong> are 16-bit</p>
<p>(Send MSB before LSB, so we should swap the bytes)</p>
</li>
<li>
<p>Reading I2C Register <strong>0x8140</strong> (Product ID) will return the bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>39 31 37 53</code></pre></div>
<p>Which is ASCII for ‚Äú<strong><code>917S</code></strong>‚Äù</p>
<p>(Goodix GT917S Touch Panel)</p>
</li>
</ul>
<p>This is how we read the Product ID from the Touch Panel: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c4991b1503387d57821d94a549425bcd8f268841/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L316-L355">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Product ID (LSB 4 bytes)
#define GOODIX_REG_ID 0x8140

// Read Touch Panel over I2C
static void touch_panel_read(struct i2c_master_s *i2c)
{
  uint32_t freq = 400000;  // 400 kHz
  uint16_t addr = 0x5d;  // Default I2C Address for Goodix GT917S
  uint16_t reg = GOODIX_REG_ID;  // Read Product ID
  uint8_t regbuf[2] = { reg &gt;&gt; 8, reg &amp; 0xff };  // Flip the bytes

  // Erase the receive buffer
  uint8_t buf[4];
  ssize_t buflen = sizeof(buf);
  memset(buf, 0xff, sizeof(buf));

  // Compose the I2C Messages
  struct i2c_msg_s msgv[2] =
  {
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = 0,
      .buffer    = regbuf,
      .length    = sizeof(regbuf)
    },
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = I2C_M_READ,
      .buffer    = buf,
      .length    = buflen
    }
  };

  // Execute the I2C Transfer
  int ret = I2C_TRANSFER(i2c, msgv, 2);
  if (ret &lt; 0) { _err(&quot;I2C Error: %d\n&quot;, ret); return; }

  // Dump the receive buffer
  infodumpbuffer(&quot;buf&quot;, buf, buflen);
  // Shows &quot;39 31 37 53&quot; or &quot;917S&quot;
}</code></pre></div>
<p>To detect Touch Events, we‚Äôll need to handle the Interrupts triggered by Touch Panel.</p>
<p>Based on our research, PinePhone‚Äôs Touch Panel Interrupt (CTP-INT) is connected at PH4. </p>
<p>Right now we poll PH4 (instead of handling interrupts) because it‚Äôs easier: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L283-L317">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Test Touch Panel Interrupt by Polling as GPIO Input.
// Touch Panel Interrupt (CTP-INT) is at PH4.
// Configure for GPIO Input
#define CTP_INT (PIO_INPUT | PIO_PORT_PIOH | PIO_PIN4)

static void touch_panel_read(struct i2c_master_s *i2c);

// Poll for Touch Panel Interrupt (PH4) by reading as GPIO Input
void touch_panel_initialize(struct i2c_master_s *i2c)
{

  // Configure the Touch Panel Interrupt for GPIO Input
  int ret = a64_pio_config(CTP_INT);
  DEBUGASSERT(ret == 0);

  // Poll the Touch Panel Interrupt as GPIO Input
  bool prev_val = false;
  for (int i = 0; i &lt; 6000; i++) {  // Poll for 60 seconds

    // Read the GPIO Input
    bool val = a64_pio_read(CTP_INT);

    // If value has changed...
    if (val != prev_val) {

      // Print the value
      if (val) { up_putc(&#39;+&#39;); }
      else     { up_putc(&#39;-&#39;); }
      prev_val = val;

      // If we have just transitioned from Low to High...
      if (val) {

        // Read the Touch Panel over I2C
        touch_panel_read(i2c);
      }
    }

    // Wait a while
    up_mdelay(10);
  }
}</code></pre></div>
<p>To read the Touch Coordinates, we do this: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L338-L370">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define GOODIX_REG_ID 0x8140
#define GOODIX_READ_COORD_ADDR 0x814E
#define GOODIX_POINT1_X_ADDR 0x8150

// Read Touch Panel over I2C
static void touch_panel_read(struct i2c_master_s *i2c)
{
  // Read the Product ID
  uint8_t id[4];
  touch_panel_i2c_read(i2c, GOODIX_REG_ID, id, sizeof(id));
  // Shows &quot;39 31 37 53&quot; or &quot;917S&quot;

  // Read the Touch Panel Status
  uint8_t status[1];
  touch_panel_i2c_read(i2c, GOODIX_READ_COORD_ADDR, status, sizeof(status));
  // Shows &quot;81&quot;

  const uint8_t status_code    = status[0] &amp; 0x80;  // Set to 0x80
  const uint8_t touched_points = status[0] &amp; 0x0f;  // Set to 0x01

  if (status_code != 0 &amp;&amp;  // If Touch Panel Status is OK and...
      touched_points &gt;= 1) {  // Touched Points is 1 or more

    // Read the First Touch Coordinates
    uint8_t touch[6];
    touch_panel_i2c_read(i2c, GOODIX_POINT1_X_ADDR, touch, sizeof(touch));
    // Shows &quot;92 02 59 05 1b 00&quot;

    // Decode the Touch Coordinates
    const uint16_t x = touch[0] + (touch[1] &lt;&lt; 8);
    const uint16_t y = touch[2] + (touch[3] &lt;&lt; 8);
    _info(&quot;touch x=%d, y=%d\n&quot;, x, y);
    // Shows &quot;touch x=658, y=1369&quot;
  }

  // Set the Touch Panel Status to 0
  touch_panel_set_status(i2c, 0);
}</code></pre></div>
<p>When we touch PinePhone near the Lower Right Corner, we see the Touch Coordinates x=658, y=1369 (which is quite close to the 720 x 1440 screen size)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>twi_transfer: TWI0 count: 1
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_wait: TWI0 Awakened with result: 0
-+twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
buf (0x40a8fd18):
0000  39 31 37 53                                      917S            
twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
buf (0x40a8fd08):
0000  81                                               .               
twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
buf (0x40a8fd20):
0000  92 02 59 05 1b 00                                ..Y...          
touch_panel_read: touch x=658, y=1369</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b1ed009961c4202133879b760cb22833">(Source)</a></p>
<p>Yep we can read the Touch Coordinates correctly, with polling! (But not so efficient)</p>
<p>Let‚Äôs handle Interrupts from the Touch Panel‚Ä¶</p>
<h1 id="handle-interrupts-from-touch-panel"><a href="#handle-interrupts-from-touch-panel">2 Handle Interrupts from Touch Panel</a></h1>
<p>TODO</p>
<p>In the previous section we‚Äôve read the Touch Panel by Polling. Which is easier but inefficient.</p>
<p>Eventually we‚Äôll use an Interrupt Handler to monitor Touch Panel Interrupts. This is how we monitor PH4 for interrupts: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L255-L328">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Touch Panel Interrupt (CTP-INT) is at PH4
#define CTP_INT (PIO_EINT | PIO_PORT_PIOH | PIO_PIN4)

// Register the Interrupt Handler for Touch Panel
void touch_panel_initialize(void) {

  // Attach the PIO Interrupt Handler for Port PH
  if (irq_attach(A64_IRQ_PH_EINT, touch_panel_interrupt, NULL) &lt; 0) {
    _err(&quot;irq_attach failed\n&quot;);
    return ERROR;
  }

  // Enable the PIO Interrupt for Port PH
  up_enable_irq(A64_IRQ_PH_EINT);

  // Configure the Touch Panel Interrupt
  int ret = a64_pio_config(CTP_INT);
  DEBUGASSERT(ret == 0);

  // Enable the Touch Panel Interrupt
  ret = a64_pio_irqenable(CTP_INT);
  DEBUGASSERT(ret == 0);
}

// Interrupt Handler for Touch Panel
static int touch_panel_interrupt(int irq, void *context, void *arg) {

  // Print something when interrupt is triggered
  up_putc(&#39;.&#39;);
  return OK;
}</code></pre></div>
<p>When we run this code, it generates a non-stop stream of ‚Äú.‚Äù characters.</p>
<p>Which means that the Touch Input Interrupt is generated continuously. Without touching the screen!</p>
<p><em>Is our Interrupt Handler code correct?</em></p>
<p>Yep our Interrupt Handler code is correct! But through our experiments we discovered one thing‚Ä¶</p>
<p>To stop the repeated Touch Input Interrupts, we need to set the <strong>Touch Panel Status to 0</strong>! Like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L470-L500">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// When the Touch Input Interrupt is triggered...
// Set the Touch Panel Status to 0
touch_panel_set_status(i2c, 0);
...

#define GOODIX_READ_COORD_ADDR 0x814E  // Touch Panel Status (Read / Write)
#define CTP_FREQ 400000  // I2C Frequency: 400 kHz
#define CTP_I2C_ADDR 0x5d  // Default I2C Address for Goodix GT917S

// Set the Touch Panel Status
static int touch_panel_set_status(
  struct i2c_master_s *i2c,  // I2C Bus
  uint8_t status  // Status value to be set
) {
  uint16_t reg = GOODIX_READ_COORD_ADDR;  // I2C Register
  uint32_t freq = CTP_FREQ;  // 400 kHz
  uint16_t addr = CTP_I2C_ADDR;  // Default I2C Address for Goodix GT917S
  uint8_t buf[3] = {
    reg &gt;&gt; 8,    // Swap the bytes
    reg &amp; 0xff,  // Swap the bytes
    status
  };

  // Compose the I2C Message
  struct i2c_msg_s msgv[1] =
  {
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = 0,
      .buffer    = buf,
      .length    = sizeof(buf)
    }
  };

  // Execute the I2C Transfer
  const int msgv_len = sizeof(msgv) / sizeof(msgv[0]);
  int ret = I2C_TRANSFER(i2c, msgv, msgv_len);
  if (ret &lt; 0) { _err(&quot;I2C Error: %d\n&quot;, ret); return ret; }
  return OK;
}</code></pre></div>
<p><em>So we set the Touch Panel Status inside our Interrupt Handler?</em></p>
<p>But Interrupt Handlers aren‚Äôt allowed to make I2C Calls!</p>
<p>We need to <strong>forward the Interrupt</strong> to a Background Thread to handle. Like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L237-L253">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Interrupt Handler for Touch Panel
static int gt9xx_isr_handler(int irq, FAR void *context, FAR void *arg)
{
   FAR struct gt9xx_dev_s *priv = (FAR struct gt9xx_dev_s *)arg;

 // Set the Interrupt Pending Flag
  irqstate_t flags = enter_critical_section();
  priv-&gt;int_pending = true;
  leave_critical_section(flags);

  // Notify the Poll Waiters
  poll_notify(priv-&gt;fds, GT9XX_NPOLLWAITERS, POLLIN);
  return 0;
}</code></pre></div>
<p>This notifies the File Descriptors <code>fds</code> that are waiting for Touch Input Interrupts to be triggered.</p>
<p>When the File Descriptor is notified, the Background Thread will become unblocked, and can call I2C to read the Touch Input.</p>
<p>Right now we don‚Äôt have a Background Thread, so we poll and wait for the Touch Input Interrupt to be triggered: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L293-L309">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Poll for Touch Panel Interrupt
  // TODO: Move this
  for (int i = 0; i &lt; 6000; i++) {  // Poll for 60 seconds

    // If Touch Panel Interrupt has been triggered...
    if (priv-&gt;int_pending) {

      // Read the Touch Panel over I2C
      touch_panel_read(i2c_dev);

      // Reset the Interrupt Pending Flag
      priv-&gt;int_pending = false;
    }

    // Wait a while
    up_mdelay(10);  // 10 milliseconds
  }</code></pre></div>
<p>And it works!</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
a64_pio_config: cfgaddr=0x1c208fc, intaddr=0x1c20a40, value=0x0, shift=16
touch_panel_initialize: v=0x10, m=0x10, a=0x1c20a50      
buf (0x40a8fd20):
0000  39 31 37 53                                      917S            
buf (0x40a8fd10):
0000  81                                               .               
buf (0x40a8fd28):
0000  19 01 e6 02 2a 00                                ....*.          
touch_panel_read: touch x=281, y=742
...     
buf (0x40a8fd20):
0000  39 31 37 53                                      917S            
buf (0x40a8fd10):
0000  81                                               .               
buf (0x40a8fd28):
0000  81 02 33 00 25 00                                ..3.%.          
touch_panel_read: touch x=641, y=51
...
buf (0x40a8fd20):
0000  39 31 37 53                                      917S            
buf (0x40a8fd10):
0000  81                                               .               
buf (0x40a8fd28):
0000  0f 00 72 05 14 00                                ..r...          
touch_panel_read: touch x=15, y=1394</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/91a37a4b54f75f7386374a30821dc1b2">(Source)</a></p>
<p>Let‚Äôs move this code into the NuttX Touch Panel Driver for PinePhone‚Ä¶</p>
<h1 id="nuttx-touch-panel-driver-for-pinephone"><a href="#nuttx-touch-panel-driver-for-pinephone">3 NuttX Touch Panel Driver for PinePhone</a></h1>
<p>TODO</p>
<p>We moved the code above into the NuttX Touch Panel Driver for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c">drivers/input/gt9xx.c</a></li>
</ul>
<p>This is how we start the driver when NuttX boots: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L197-L204">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define CTP_I2C_ADDR 0x5d  // Default I2C Address for Goodix GT917S
ret = gt9xx_register(&quot;/dev/input0&quot;, i2c, CTP_I2C_ADDR, &amp;g_pinephone_gt9xx);</code></pre></div>
<p>And it works with the LVGL Demo App! Now we need to optimise the rendering‚Ä¶</p>
<ul>
<li><a href="https://www.youtube.com/shorts/xE9U5IQPmlg">Watch the Demo on YouTube</a></li>
</ul>
<h1 id="whats-next"><a href="#whats-next">4 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Meanwhile please check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3"><strong>‚ÄúNuttX RTOS for PinePhone: MIPI Display Serial Interface‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de3"><strong>‚ÄúNuttX RTOS for PinePhone: Display Engine‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lcd"><strong>‚ÄúNuttX RTOS for PinePhone: LCD Panel‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/touch2.md"><strong>lupyuen.github.io/src/touch2.md</strong></a></p>

    
</body>
</html>