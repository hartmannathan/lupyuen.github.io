<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Touch Panel</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Touch Panel" 
    data-rh="true">
<meta property="og:description" 
    content="All about the Capacitive Touch Panel of Pine64 PinePhone... And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="All about the Capacitive Touch Panel of Pine64 PinePhone... And how we created the PinePhone Touch Panel Driver for Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/touch2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Touch Panel</h1>
    <nav id="TOC"><ul>
<li><a href="#goodix-gt917s-touch-panel">1 Goodix GT917S Touch Panel</a><ul></ul></li>
<li><a href="#read-the-product-id">2 Read the Product ID</a><ul></ul></li>
<li><a href="#poll-the-touch-panel">3 Poll the Touch Panel</a><ul></ul></li>
<li><a href="#read-a-touch-point">4 Read a Touch Point</a><ul></ul></li>
<li><a href="#attach-our-interrupt-handler">5 Attach our Interrupt Handler</a><ul></ul></li>
<li><a href="#handle-interrupts-from-touch-panel">6 Handle Interrupts from Touch Panel</a><ul></ul></li>
<li><a href="#test-our-interrupt-handler">7 Test our Interrupt Handler</a><ul></ul></li>
<li><a href="#nuttx-touch-panel-driver">8 NuttX Touch Panel Driver</a><ul></ul></li>
<li><a href="#lvgl-calls-our-driver">9 LVGL Calls Our Driver</a><ul></ul></li>
<li><a href="#driver-limitations">10 Driver Limitations</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-nuttx-touch-panel-driver-for-pinephone">12 Appendix: NuttX Touch Panel Driver for PinePhone</a><ul>
<li><a href="#register-touch-panel-driver">12.1 Register Touch Panel Driver</a><ul></ul></li>
<li><a href="#open-the-touch-panel">12.2 Open the Touch Panel</a><ul></ul></li>
<li><a href="#read-a-touch-sample">12.3 Read a Touch Sample</a><ul></ul></li>
<li><a href="#interrupt-handler">12.4 Interrupt Handler</a><ul></ul></li>
<li><a href="#setup-poll-for-touch-sample">12.5 Setup Poll for Touch Sample</a><ul></ul></li>
<li><a href="#close-the-touch-panel">12.6 Close the Touch Panel</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>14 Jan 2023</em></p>
<p><img src="https://lupyuen.github.io/images/touch2-title.png" alt="Apache NuttX RTOS reads the PinePhone Touch Panel" /></p>
<p>We‚Äôre porting <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) to <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></li>
</ul>
<p>Now we can render <a href="https://lupyuen.github.io/articles/fb#lvgl-graphics-library"><strong>LVGL Graphical User Interfaces</strong></a>‚Ä¶ But it won‚Äôt work yet with <strong>Touch Input</strong>!</p>
<p>Let‚Äôs talk about the <strong>Capacitive Touch Panel</strong> inside PinePhone‚Ä¶</p>
<ul>
<li>
<p>How it‚Äôs <strong>connected to PinePhone</strong></p>
<p>(Over I2C)</p>
</li>
<li>
<p>How we read <strong>Touch Points</strong></p>
<p>(Polling vs Interrupts)</p>
</li>
<li>
<p>How we created the <strong>Touch Panel Driver</strong> for NuttX</p>
<p>(Despite the missing docs)</p>
</li>
<li>
<p>And how we call the driver from <strong>LVGL Apps</strong></p>
<p><a href="https://www.youtube.com/shorts/APge9bTt-ho">(Watch the Demo on YouTube)</a></p>
</li>
</ul>
<p>We begin with the internals of the Touch Panel‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-schematic1.jpg" alt="Capacitive Touch Panel in PinePhone Schematic (Pages 9 and 11)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>Capacitive Touch Panel in PinePhone Schematic (Pages 9 and 11)</em></a></p>
<h1 id="goodix-gt917s-touch-panel"><a href="#goodix-gt917s-touch-panel">1 Goodix GT917S Touch Panel</a></h1>
<p>Inside PinePhone is the <strong>Goodix GT917S Capacitive Touch Panel</strong> (CTP) that talks over I2C.</p>
<p>According to the <a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><strong>PinePhone Schematic</strong></a> Pages 9 and 11 (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>Touch Panel Interrupt</strong> (CTP-INT) is at <strong>PH4</strong></p>
<p>(Touch Panel fires an interrupt at PH4 when it‚Äôs touched)</p>
</li>
<li>
<p><strong>Touch Panel Reset</strong> (CTP-RST) is at <strong>PH11</strong></p>
<p>(We toggle PH11 to reset the Touch Panel)</p>
</li>
<li>
<p><strong>Touch Panel I2C</strong> (SCK / SDA) is at <strong>TWI0</strong></p>
<p>(That‚Äôs the port for Two Wire Interface, compatible with I2C)</p>
</li>
</ul>
<p><em>What are PH4 and PH11?</em></p>
<p>Just think of them as GPIOs on the Allwinner A64 SoC.</p>
<p>(Allwinner calls them PIOs)</p>
<p><em>Does it need special power?</em></p>
<p>Please remember to <strong>power up LDO (3.3V)</strong> through the Power Management Integrated Circuit‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lcd#power-on-lcd-panel"><strong>‚ÄúPower On LCD Panel‚Äù</strong></a></li>
</ul>
<p>PinePhone‚Äôs Touch Panel doesn‚Äôt seem to be the Power-Saving type like <a href="https://lupyuen.github.io/articles/touch#cst816s-touch-panel"><strong>PineTime‚Äôs CST816S</strong></a>.</p>
<p><em>How do we program the Touch Panel?</em></p>
<p>The datasheet doesn‚Äôt say much about programming the Touch Panel‚Ä¶</p>
<ul>
<li><a href="https://files.pine64.org/doc/datasheet/pinephone/GT917S-Datasheet.pdf"><strong>GT917S Datasheet</strong></a></li>
</ul>
<p>So we‚Äôll create the driver by replicating the <strong>I2C Read / Write Operations</strong> from the official Android Driver <a href="https://github.com/goodix/gt9xx_driver_android/blob/master/gt9xx.c"><strong>gt9xx.c</strong></a>.</p>
<p>(Or the unofficial simpler driver <a href="https://github.com/DiveInEmbedded/GT911-Touch-driver/blob/main/Core/Src/GT911.c"><strong>GT911.c</strong></a>)</p>
<p><em>So PinePhone‚Äôs Touch Panel is actually undocumented?</em></p>
<p>Yeah it‚Äôs strangely common for Touch Panels to be undocumented.</p>
<p>(Just like PineTime‚Äôs <a href="https://lupyuen.github.io/articles/touch#cst816s-touch-panel"><strong>CST816S Touch Panel</strong></a>)</p>
<p>Let‚Äôs experiment with PinePhone‚Äôs Touch Panel to understand how it works‚Ä¶</p>
<p><a href="https://patents.google.com/patent/US7663607B2/en">(I think Touch Panels are poorly documented because of Apple‚Äôs patent on Multitouch)</a></p>
<p><img src="https://lupyuen.github.io/images/touch2-code2a.png" alt="Reading the Product ID from Touch Panel" /></p>
<h1 id="read-the-product-id"><a href="#read-the-product-id">2 Read the Product ID</a></h1>
<p><em>What‚Äôs the simplest thing we can do with PinePhone‚Äôs Touch Panel?</em></p>
<p>Let‚Äôs read the <strong>Product ID</strong> from the Touch Panel.</p>
<p>We experimented with the Touch Panel (Bare Metal with NuttX) and discovered these <strong>I2C Settings</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>I2C Address</strong> is <strong><code>0x5D</code></strong></p>
</li>
<li>
<p><strong>I2C Frequency</strong> is <strong>400 kHz</strong></p>
<p>(What‚Äôs the max?)</p>
</li>
<li>
<p><strong>I2C Register Addresses</strong> are 16-bit</p>
<p>(Send MSB before LSB, so we should swap the bytes)</p>
</li>
<li>
<p>Reading I2C Register <strong><code>0x8140</code></strong> (Product ID) will return the bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>39 31 37 53</code></pre></div>
<p>Which is ASCII for ‚Äú<strong><code>917S</code></strong>‚Äù</p>
<p>(Goodix GT917S Touch Panel)</p>
</li>
</ul>
<p>Based on the above settings, we wrote this <strong>Test Code</strong> that runs in the NuttX Kernel: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c4991b1503387d57821d94a549425bcd8f268841/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L316-L355">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Read Product ID from Touch Panel over I2C
static void touch_panel_read(
  struct i2c_master_s *i2c  // NuttX I2C Bus (Port TWI0)
) {
  uint32_t freq = 400000;  // I2C Frequency: 400 kHz
  uint16_t addr = 0x5d;    // Default I2C Address for Goodix GT917S
  uint16_t reg  = 0x8140;  // Register Address: Read Product ID

  // Swap the Register Address, MSB first
  uint8_t regbuf[2] = {
    reg &gt;&gt; 8,   // First Byte: MSB
    reg &amp; 0xff  // Second Byte: LSB
  };

  // Erase the Receive Buffer (4 bytes)
  uint8_t buf[4];
  memset(buf, 0xff, sizeof(buf));

  // Compose the I2C Messages
  struct i2c_msg_s msgv[2] = {
    // Send the 16-bit Register Address (MSB first)
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = 0,
      .buffer    = regbuf,
      .length    = sizeof(regbuf)
    },
    // Receive the Register Data (4 bytes)
    {
      .frequency = freq,
      .addr      = addr,
      .flags     = I2C_M_READ,
      .buffer    = buf,
      .length    = sizeof(buf)
    }
  };

  // Execute the I2C Transfer
  int ret = I2C_TRANSFER(i2c, msgv, 2);
  DEBUGASSERT(ret == OK);

  // Dump the Receive Buffer
  infodumpbuffer(&quot;buf&quot;, buf, buflen);
  // Shows &quot;39 31 37 53&quot; or &quot;917S&quot;
}</code></pre></div>
<p>This is what we see (with TWI0 Logging Enabled)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code3a.png" alt="Read Product ID from Touch Panel" /></p>
<p>Yep the I2C Response is correct‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>39 31 37 53</code></pre></div>
<p>Which is ASCII for ‚Äú<strong><code>917S</code></strong>‚Äù!</p>
<p>(Goodix GT917S Touch Panel)</p>
<p><em>How‚Äôs the code above called by NuttX Kernel?</em></p>
<p>Read on to find out how we poll the Touch Panel and read the Product ID‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code1a.png" alt="Polling the Touch Panel" /></p>
<h1 id="poll-the-touch-panel"><a href="#poll-the-touch-panel">3 Poll the Touch Panel</a></h1>
<p><em>PinePhone‚Äôs Touch Panel will trigger interrupts right?</em></p>
<p>To detect Touch Events, we‚Äôll need to <strong>handle the interrupts</strong> triggered by Touch Panel.</p>
<p>Based on our research, PinePhone‚Äôs <strong>Touch Panel Interrupt</strong> (CTP-INT) is connected at <strong>PH4</strong>.</p>
<p>But to simplify our first experiment, <strong>let‚Äôs poll PH4</strong>. (Instead of handling interrupts)</p>
<p><em>How do we poll PH4?</em></p>
<p>We read PH4 as a <strong>GPIO Input</strong>. When we touch the Touch Panel, PH4 goes from <strong>Low to High</strong>.</p>
<p>This is how we poll PH4: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L283-L317">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Test Touch Panel Interrupt by Polling as GPIO Input.
// Touch Panel Interrupt (CTP-INT) is at PH4.
// We configure it for GPIO Input.
#define CTP_INT (PIO_INPUT | PIO_PORT_PIOH | PIO_PIN4)

// Poll for Touch Panel Interrupt (PH4) by reading as GPIO Input
void touch_panel_initialize(
  struct i2c_master_s *i2c  // NuttX I2C Bus (Port TWI0)
) {

  // Configure the Touch Panel Interrupt for GPIO Input
  int ret = a64_pio_config(CTP_INT);
  DEBUGASSERT(ret == OK);

  // Poll the Touch Panel Interrupt as GPIO Input
  bool prev_val = false;
  for (int i = 0; i &lt; 6000; i++) {  // Poll for 60 seconds

    // Read the GPIO Input
    bool val = a64_pio_read(CTP_INT);

    // If value has changed...
    if (val != prev_val) {

      // Print the transition
      if (val) { up_putc(&#39;+&#39;); }  // PH4 goes Low to High
      else     { up_putc(&#39;-&#39;); }  // PH4 goes High to Low
      prev_val = val;

      // If PH4 has just transitioned from Low to High...
      if (val) {

        // Read the Touch Panel over I2C
        touch_panel_read(i2c);
      }
    }

    // Wait a while
    up_mdelay(10);
  }
}</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L174-L344">(<strong>a64_pio_config</strong> configures PH4 as an Input Pin)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L390-L420">(<strong>a64_pio_read</strong> reads PH4 as an Input Pin)</a></p>
<p>The loop above watches for PH4 shifting from <strong>Low to High</strong>‚Ä¶</p>
<ul>
<li>
<p>When PH4 shifts from <strong>Low to High</strong>, we print ‚Äú<strong><code>+</code></strong>‚Äù</p>
</li>
<li>
<p>When PH4 shifts from <strong>High to Low</strong>, we print ‚Äú<strong><code>-</code></strong>‚Äù</p>
</li>
<li>
<p>After shifting from <strong>Low to High</strong>, we call <a href="https://lupyuen.github.io/articles/touch2#read-product-id"><strong>touch_panel_read</strong></a> to read the Touch Panel</p>
<p><a href="https://lupyuen.github.io/articles/touch2#read-product-id">(Which we‚Äôve seen earlier)</a></p>
</li>
</ul>
<p>Thus our simple loop simulates an <strong>Interrupt Handler</strong>!</p>
<p><em>How do we open the I2C Port?</em></p>
<p>On NuttX, this is how we <strong>open the I2C Port</strong> and pass it to the above loop: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L158-L170">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Open Allwinner A64 Port TWI0 for I2C
struct i2c_master_s *i2c =
  a64_i2cbus_initialize(0);  // 0 for TWI0

// Pass the I2C Port to the above loop
touch_panel_initialize(i2c);</code></pre></div>
<p>We insert this code at the end of the <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L57-L175"><strong>PinePhone Bringup Function</strong></a>, so that NuttX Kernel will run it at the end of startup.</p>
<p>(Yes it sounds hacky, but it‚Äôs a simple way to do Kernel Experiments)</p>
<p>Now that we‚Äôve simulated an Interrupt Handler, let‚Äôs read a Touch Point!</p>
<p><img src="https://lupyuen.github.io/images/touch2-code4a.png" alt="Reading a Touch Point" /></p>
<h1 id="read-a-touch-point"><a href="#read-a-touch-point">4 Read a Touch Point</a></h1>
<p><em>When the Touch Panel is touched, how do we read the Touch Coordinates?</em></p>
<p>Based on the <a href="https://github.com/DiveInEmbedded/GT911-Touch-driver/blob/main/Core/Src/GT911.c"><strong>Reference Code</strong></a>, here are the steps to <strong>read a Touch Point</strong>‚Ä¶</p>
<ol>
<li>
<p>Read the <strong>Touch Panel Status</strong> (1 byte) at I2C Register <strong><code>0x814E</code></strong></p>
<p><strong>Status Code</strong> is <strong>Bit 7</strong> of Touch Panel Status</p>
<p><strong>Touched Points</strong> is <strong>Bits 0 to 3</strong> of Touch Panel Status</p>
</li>
<li>
<p>If <strong>Status Code</strong> is non-zero and <strong>Touched Points</strong> is 1 or more‚Ä¶</p>
<p>Read the <strong>Touch Coordinates</strong> (6 bytes) at I2C Register <strong><code>0x8150</code></strong></p>
<p><strong>First 2 Bytes</strong> (LSB First) are the <strong>X Coordinate</strong> (0 to 720)</p>
<p><strong>Next 2 Bytes</strong> (LSB First) are the <strong>Y Coordinate</strong> (0 to 1440)</p>
</li>
<li>
<p>To stop the Touch Interrupt, set the <strong>Touch Panel Status</strong> to 0‚Ä¶</p>
<p>Write 0 to I2C Register <strong><code>0x814E</code></strong></p>
</li>
</ol>
<p>(This won‚Äôt support Multitouch, more about this later)</p>
<p>Here is our code: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L338-L370">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// I2C Registers for Touch Panel
#define GTP_READ_COORD_ADDR 0x814E  // Touch Panel Status
#define GTP_POINT1          0x8150  // First Touch Point

// Read Touch Panel over I2C
static void touch_panel_read(
  struct i2c_master_s *i2c  // NuttX I2C Bus (Port TWI0)
) {

  // Read the Touch Panel Status
  uint8_t status[1];
  touch_panel_i2c_read(   // Read from I2C Touch Panel...
    i2c,                  // NuttX I2C Bus (Port TWI0)
    GTP_READ_COORD_ADDR,  // I2C Register: 0x814E
    status,               // Receive Buffer
    sizeof(status)        // Buffer Size
  );
  // Receives &quot;81&quot;

  // Decode the Status Code and the Touched Points
  const uint8_t status_code    = status[0] &amp; 0x80;  // Set to 0x80
  const uint8_t touched_points = status[0] &amp; 0x0f;  // Set to 0x01

  if (status_code != 0 &amp;&amp;     // If Status Code is OK and...
      touched_points &gt;= 1) {  // Touched Points is 1 or more

    // Read the First Touch Coordinates
    uint8_t touch[6];
    touch_panel_i2c_read(  // Read from I2C Touch Panel...
      i2c,                 // NuttX I2C Bus (Port TWI0)
      GTP_POINT1,          // I2C Register: 0x8150
      touch,               // Receive Buffer
      sizeof(touch)        // Buffer Size
    );
    // Receives &quot;92 02 59 05 1b 00&quot;

    // Decode the Touch Coordinates
    const uint16_t x = touch[0] + (touch[1] &lt;&lt; 8);
    const uint16_t y = touch[2] + (touch[3] &lt;&lt; 8);
    _info(&quot;touch x=%d, y=%d\n&quot;, x, y);
    // Shows &quot;touch x=658, y=1369&quot;
  }

  // Set the Touch Panel Status to 0
  touch_panel_set_status(i2c, 0);
}</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L372-L415">(<strong>touch_panel_i2c_read</strong> reads from the I2C Touch Panel)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/e249049370d21a988912f2fb95a21514863dfe8a/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L417-L447">(<strong>touch_panel_set_status</strong> sets the I2C Touch Panel Status)</a></p>
<p>Let‚Äôs run the code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-run1a.png" alt="Reading Touch Points with Polling" /></p>
<p>When we tap the screen, we see ‚Äú<strong><code>-+</code></strong>‚Äù which means that PH4 has shifted from Low to High.</p>
<p>Followed by the reading of the <strong>Touch Panel Status</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>-+
twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
0000  81                                               .               </code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b1ed009961c4202133879b760cb22833">(Source)</a></p>
<p>Touch Panel Status is <strong><code>0x81</code></strong>.  Which means the status is OK and there‚Äôs <strong>One Touch Point</strong> detected.</p>
<p>Our code reads the <strong>Touch Coordinates</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>twi_transfer: TWI0 count: 2
twi_wait: TWI0 Waiting...
twi_put_addr: TWI address 7bits+r/w = 0xba
twi_put_addr: TWI address 7bits+r/w = 0xbb
twi_wait: TWI0 Awakened with result: 0
0000  92 02 59 05 1b 00                                ..Y...          
touch_panel_read: touch x=658, y=1369</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b1ed009961c4202133879b760cb22833">(Source)</a></p>
<p>This says that the Touch Point is at‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>x=658, y=1369</code></pre></div>
<p>Which is quite close to the Lower Right Corner. (Screen size is 720 x 1440)</p>
<p>Yep we can read the Touch Coordinates correctly, through polling! (But not so efficiently)</p>
<p>Let‚Äôs handle interrupts from the Touch Panel‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code5a.png" alt="Attaching our Interrupt Handler" /></p>
<h1 id="attach-our-interrupt-handler"><a href="#attach-our-interrupt-handler">5 Attach our Interrupt Handler</a></h1>
<p><em>We‚Äôve done polling with the Touch Panel‚Ä¶</em></p>
<p><em>How do we handle interrupts from the Touch Panel?</em></p>
<p>In the previous section we‚Äôve read the Touch Panel by polling‚Ä¶ Which is easier but inefficient.</p>
<p>Now we do a proper <strong>Interrupt Handler</strong> for the Touch Panel. This is how we attach our Interrupt Handler to PH4 in NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L255-L328">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Touch Panel Interrupt (CTP-INT) is at PH4
#define CTP_INT ( \
  PIO_EINT      | \  /* PIO External Interrupt */
  PIO_PORT_PIOH | \  /* PIO Port H */
  PIO_PIN4        \  /* PIO Pin 4 */
)

// Register the Interrupt Handler for Touch Panel
void touch_panel_initialize(void) {

  // Attach the PIO Interrupt Handler for Port PH
  int ret = irq_attach(     // Attach a NuttX Interrupt Handler...
    A64_IRQ_PH_EINT,        // Interrupt Number for Port PH: 53
    touch_panel_interrupt,  // Interrupt Handler
    NULL                    // Argument for Interrupt Handler
  );
  DEBUGASSERT(ret == OK);

  // Enable the PIO Interrupt for Port PH.
  // A64_IRQ_PH_EINT is 53.
  up_enable_irq(A64_IRQ_PH_EINT);

  // Configure the Touch Panel Interrupt for Pin PH4
  ret = a64_pio_config(CTP_INT);
  DEBUGASSERT(ret == OK);

  // Enable the Touch Panel Interrupt for Pin PH4
  ret = a64_pio_irqenable(CTP_INT);
  DEBUGASSERT(ret == OK);
}</code></pre></div>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L174-L344">(<strong>a64_pio_config</strong> configures PH4 as an Interrupt Pin)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L420-L440">(<strong>a64_pio_irqenable</strong> enables interrupts on Pin PH4)</a></p>
<p><em>Why call both up_enable_irq and a64_pio_irqenable?</em></p>
<p>Allwinner A64 does Two-Tier Interrupts, by Port and Pin‚Ä¶</p>
<ul>
<li>
<p>First we enable interrupts for <strong>Port PH</strong></p>
<p>(By calling <strong>up_enable_irq</strong>)</p>
</li>
<li>
<p>Then we enable interrupts for <strong>Pin PH4</strong></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_pio.c#L420-L440">(By calling <strong>a64_pio_irqenable</strong>)</a></p>
</li>
</ul>
<p>Which means that our Interrupt Handler will be shared by <strong>all Pins on Port PH</strong>.</p>
<p>(When we enable them in future)</p>
<p><em>What‚Äôs touch_panel_interrupt?</em></p>
<p><strong>touch_panel_interrupt</strong> is our Interrupt Handler. Let‚Äôs do a simple one‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Interrupt Handler for Touch Panel
static int touch_panel_interrupt(int irq, void *context, void *arg) {

  // Print something when interrupt is triggered
  up_putc(&#39;.&#39;);
  return OK;
}</code></pre></div>
<p>This Interrupt Handler simply prints ‚Äú<strong><code>.</code></strong>‚Äù whenever the Touch Panel triggers an interrupt.</p>
<p><em>It‚Äôs OK to call up_putc in an Interrupt Handler?</em></p>
<p>Yep it‚Äôs perfectly OK, because <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_serial.c#L619-L649"><strong>up_putc</strong></a> simply writes to the UART Register. (It won‚Äôt trigger another interrupt)</p>
<p>Let‚Äôs test our simple Interrupt Handler‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-run2a.png" alt="Touch Panel triggers our Interrupt Handler Non-Stop" /></p>
<p><em>What happens when we run our code?</em></p>
<p>When we run the code, it generates a <strong>never-ending stream</strong> of ‚Äú<strong><code>.</code></strong>‚Äù characters‚Ä¶</p>
<p><strong>Without us touching</strong> the screen! (Pic above)</p>
<p><em>Is this a bad thing?</em></p>
<p>Yes it‚Äôs terrible! This means that the Touch Panel fires Touch Input Interrupts continuously‚Ä¶</p>
<p><strong>NuttX will be overwhelmed</strong> handling Touch Input Interrupts 100% of the time. No time for other tasks!</p>
<p>We‚Äôll fix this by <strong>throttling the interrupts</strong> from the Touch Panel. Here‚Äôs how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-code6a.png" alt="Handling Interrupts from Touch Panel" /></p>
<h1 id="handle-interrupts-from-touch-panel"><a href="#handle-interrupts-from-touch-panel">6 Handle Interrupts from Touch Panel</a></h1>
<p><em>Touch Panel fires too many interrupts‚Ä¶</em></p>
<p><em>How do we stop it?</em></p>
<p>In our Interrupt Handler, let‚Äôs <strong>disable the Touch Panel Interrupt</strong> if we‚Äôre still waiting for it to be processed: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L840-L888">gt9xx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Interrupt Handler for Touch Panel, with Throttling and Forwarding
static int gt9xx_isr_handler(int irq, FAR void *context, FAR void *arg) {

  // Print &quot;.&quot; when Interrupt Handler is triggered
  up_putc(&#39;.&#39;);

  // Get the Touch Panel Device
  FAR struct gt9xx_dev_s *priv = (FAR struct gt9xx_dev_s *)arg;

  // If the Touch Panel Interrupt has not been processed...
  if (priv-&gt;int_pending) { 

    // Disable the Touch Panel Interrupt
    priv-&gt;board-&gt;irq_enable(priv-&gt;board, false); 
  }</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L72-L99">(<strong>gt9xx_dev_s</strong> is the Touch Panel Device)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L560-L584">(<strong>irq_enable</strong> calls <strong>pinephone_gt9xx_irq_enable</strong> to disable the interrupt)</a></p>
<p>Our Interrupt Handler won‚Äôt actually read the Touch Coordinates. (Because Interrupt Handlers can‚Äôt make I2C calls)</p>
<p>Instead our Interrupt Handler <strong>notifies the Background Thread</strong> that there‚Äôs a Touch Event waiting to be processed‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Set the Interrupt Pending Flag
  irqstate_t flags = enter_critical_section();
  priv-&gt;int_pending = true;
  leave_critical_section(flags);

  // Notify the Poll Waiters
  poll_notify(  // Notify these File Descriptors...
    priv-&gt;fds,  // File Descriptors to notify
    1,          // Max 1 File Descriptor supported
    POLLIN      // Poll Event to be notified
  );
  return 0;
}</code></pre></div>
<p>The Background Thread calls <strong><code>poll()</code></strong>, suspends itself and <strong>waits for the notification</strong> before processing the Touch Event over I2C.</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L728-L840">(Thanks to <strong>gt9xx_poll</strong>)</a></p>
<p>Let‚Äôs test our new and improved Interrupt Handler‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch2-run3a.png" alt="Testing our Interrupt Handler" /></p>
<h1 id="test-our-interrupt-handler"><a href="#test-our-interrupt-handler">7 Test our Interrupt Handler</a></h1>
<p><em>How do we test our Interrupt Handler?</em></p>
<p>We could start a Background Thread that will be notified when the screen is touched‚Ä¶</p>
<p>Or we can run a simple loop that checks whether the <strong>Interrupt Pending Flag is set</strong> by our Interrupt Handler.</p>
<p>Let‚Äôs test the simple way: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/c3eccc67d879806a015ae592205e641dcffa7d09/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L293-L309">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Poll for Touch Panel Interrupt
for (int i = 0; i &lt; 6000; i++) {  // Poll for 60 seconds

  // If Touch Panel Interrupt has been triggered...
  if (priv-&gt;int_pending) {

    // Read the Touch Panel over I2C
    touch_panel_read(i2c_dev);

    // Reset the Interrupt Pending Flag
    priv-&gt;int_pending = false;
  }

  // Wait a while
  up_mdelay(10);  // 10 milliseconds
}</code></pre></div>
<p>Note that we call <a href="https://lupyuen.github.io/articles/touch2#read-a-touch-point"><strong>touch_panel_read</strong></a> to read the Touch Coordinates. (After the Touch Interrupt has been triggered)</p>
<p>And it works! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>0000  81                                               .               
0000  19 01 e6 02 2a 00                                ....*.          
touch_panel_read: touch x=281, y=742

0000  81                                               .               
0000  81 02 33 00 25 00                                ..3.%.          
touch_panel_read: touch x=641, y=51

0000  81                                               .               
0000  0f 00 72 05 14 00                                ..r...          
touch_panel_read: touch x=15, y=1394</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/91a37a4b54f75f7386374a30821dc1b2">(Source)</a></p>
<p>The log shows that we‚Äôve read the Touch Panel Status <strong><code>0x81</code></strong>, followed by the Touch Coordinates. Yep we‚Äôve tested our Interrupt Handler successfully!</p>
<p>Now we move this code into the NuttX Touch Panel Driver for PinePhone‚Ä¶</p>
<h1 id="nuttx-touch-panel-driver"><a href="#nuttx-touch-panel-driver">8 NuttX Touch Panel Driver</a></h1>
<p><em>What‚Äôs inside our NuttX Touch Panel Driver for PinePhone?</em></p>
<p>We took the code from above and wrapped it inside our <strong>NuttX Touch Panel Driver</strong> for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c"><strong>nuttx/drivers/input/gt9xx.c</strong></a></li>
</ul>
<p>NuttX Apps will access our driver at <strong>/dev/input0</strong>, which exposes the following <strong>File Operations</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L114-L132">gt9xx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// File Operations supported by the Touch Panel
struct file_operations g_gt9xx_fileops = {
  gt9xx_open,   // Open the Touch Panel
  gt9xx_close,  // Close the Touch Panel
  gt9xx_read,   // Read a Touch Sample
  gt9xx_poll    // Setup Poll for Touch Sample</code></pre></div>
<p>NuttX Apps will call these Touch Panel Operations through the POSIX Standard Functions <strong><code>open()</code></strong>, <strong><code>close()</code></strong>, <strong><code>read()</code></strong> and <strong><code>poll()</code></strong>.</p>
<p>(Later we‚Äôll see how LVGL Apps do this)</p>
<p><em>How do we start the Touch Panel Driver?</em></p>
<p>This is how we <strong>start the Touch Panel Driver</strong> when NuttX boots: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L197-L204">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Default I2C Address for Goodix GT917S
#define CTP_I2C_ADDR 0x5d

// Register the Touch Panel Driver
ret = gt9xx_register(
  &quot;/dev/input0&quot;,      // Device Path
  i2c,                // I2C Bus
  CTP_I2C_ADDR,       // I2C Address of Touch Panel
  &amp;g_pinephone_gt9xx  // Callbacks for PinePhone Operations
);
DEBUGASSERT(ret == OK);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/touch2#register-touch-panel-driver">(<strong>gt9xx_register</strong> comes from our Touch Panel Driver)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L64-L74">(<strong>g_pinephone_gt9xx</strong> defines the Interrupt Callbacks)</a></p>
<p>The Touch Panel operations are explained in the Appendix‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/touch2#register-touch-panel-driver"><strong>‚ÄúRegister Touch Panel Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch2#open-the-touch-panel"><strong>‚ÄúOpen the Touch Panel‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch2#read-a-touch-sample"><strong>‚ÄúRead a Touch Sample‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch2#interrupt-handler"><strong>‚ÄúInterrupt Handler‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch2#setup-poll-for-touch-sample"><strong>‚ÄúSetup Poll for Touch Sample‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch2#close-the-touch-panel"><strong>‚ÄúClose the Touch Panel‚Äù</strong></a></p>
</li>
</ul>
<p><em>The driver code looks familiar?</em></p>
<p>We borrowed the logic from the NuttX Driver for <a href="https://github.com/apache/nuttx/blob/master/drivers/input/cypress_mbr3108.c"><strong>Cypress MBR3108</strong></a>.</p>
<p>(Which is also an I2C Input Device)</p>
<p>Let‚Äôs test our Touch Panel Driver with a NuttX App‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/fb-lvgl3.jpg" alt="LVGL Demo App on PinePhone" /></p>
<h1 id="lvgl-calls-our-driver"><a href="#lvgl-calls-our-driver">9 LVGL Calls Our Driver</a></h1>
<p><em>Have we tested our driver with NuttX Apps?</em></p>
<p>Our NuttX Touch Panel Driver works great with the <a href="https://github.com/lvgl/lvgl/tree/v8.3.3/demos/widgets"><strong>LVGL Demo App</strong></a>! (Pic above)</p>
<ul>
<li>
<p><a href="https://www.youtube.com/shorts/APge9bTt-ho"><strong>Watch the Demo on YouTube</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/fc88153b915894dbdaefcb5a916232fe">(See the Debug Log)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v11.0.1">(Download the Binaries)</a></p>
</li>
</ul>
<p>Here are the <strong>LVGL Settings</strong> for NuttX‚Ä¶</p>
<ol>
<li>
<p>Enable ‚Äú<strong>Application Configuration</strong> &gt; <strong>Graphics Support</strong> &gt; <strong>Light and Versatile Graphics Library (LVGL)</strong>‚Äù</p>
</li>
<li>
<p>Enable ‚Äú<strong>LVGL</strong> &gt; <strong>Enable Framebuffer Port</strong>‚Äù</p>
</li>
<li>
<p>Enable ‚Äú<strong>LVGL</strong> &gt; <strong>Enable Touchpad Port</strong>‚Äù</p>
</li>
<li>
<p>Browse into ‚Äú<strong>LVGL</strong> &gt; <strong>LVGL Configuration</strong>‚Äù</p>
<ul>
<li>
<p>In ‚Äú<strong>Color Settings</strong>‚Äù</p>
<p>Set <strong>Color Depth</strong> to ‚Äú<strong>32: ARGB8888</strong>‚Äù</p>
</li>
<li>
<p>In ‚Äú<strong>Memory settings</strong>‚Äù</p>
<p>Set <strong>Size of Memory</strong> to <strong>64</strong></p>
</li>
<li>
<p>In ‚Äú<strong>HAL Settings</strong>‚Äù</p>
<p>Set <strong>Default Dots Per Inch</strong> to <strong>300</strong></p>
</li>
<li>
<p>In ‚Äú<strong>Demos</strong>‚Äù</p>
<p>Enable ‚Äú<strong>Show Some Widgets</strong>‚Äù</p>
</li>
</ul>
</li>
<li>
<p>Enable ‚Äú<strong>Application Configuration</strong> &gt; <strong>Examples</strong> &gt; <strong>LVGL Demo</strong>‚Äù</p>
</li>
</ol>
<p>Also we need to set in <strong><code>.config</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_LV_TICK_CUSTOM=y
CONFIG_LV_TICK_CUSTOM_INCLUDE=&quot;port/lv_port_tick.h&quot;</code></pre></div>
<p>Which is advised by <a href="https://github.com/apache/nuttx-apps/pull/1341#issuecomment-1375742962"><strong>FASTSHIFT</strong></a>‚Ä¶</p>
<blockquote>
<p>‚ÄúThe tick of LVGL should not be placed in the same thread as the rendering, because the execution time of <code>lv_timer_handler</code> is not deterministic, which will cause a large error in LVGL tick.‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúWe should let LVGL use the system timestamp provided by <code>lv_port_tick</code>, just need to set two options (above)‚Äù</p>
</blockquote>
<p><a href="https://github.com/FASTSHIFT">(Thank you so much <strong>FASTSHIFT</strong>!)</a></p>
<p><em>How does LVGL call our Touch Panel Driver?</em></p>
<p>The LVGL App begins by <strong>opening our Touch Panel Driver</strong> at <strong>/dev/input0</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/graphics/lvgl/port/lv_port_touchpad.c#L134-L178">lv_port_touchpad.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// From lv_port_touchpad_init()...
// Open the Touch Panel Device
int fd = open(
  &quot;/dev/input0&quot;,         // Path of Touch Panel Device
  O_RDONLY | O_NONBLOCK  // Read-Only Access
);</code></pre></div>
<p>The app runs an <strong>Event Loop</strong> that periodically reads a <strong>Touch Sample</strong> from our driver: <a href="https://github.com/apache/nuttx-apps/blob/master/graphics/lvgl/port/lv_port_touchpad.c#L56-L99">lv_port_touchpad.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// From touchpad_read()...
// Struct for Touch Sample
struct touch_sample_s sample;

// Read a Touch Sample from Touch Panel
read(
  fd,       // File Descriptor from `open(&quot;/dev/input0&quot;)`
  &amp;sample,  // Touch Sample
  sizeof(struct touch_sample_s)  // Size of Touch Sample
);</code></pre></div>
<p>A Touch Sample contains <strong>0 or 1 Touch Points</strong>. <a href="https://lupyuen.github.io/articles/touch2#read-a-touch-sample">(See this)</a></p>
<p>(The Read Operation above is <strong>Non-Blocking</strong>. It returns 0 Touch Points if the screen hasn‚Äôt been touched)</p>
<p>We extract the <strong>First Touch Point</strong> (inside the Touch Sample) and return it to LVGL: <a href="https://github.com/apache/nuttx-apps/blob/master/graphics/lvgl/port/lv_port_touchpad.c#L56-L99">lv_port_touchpad.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// From touchpad_read()...
// Get the First Touch Event from the Touch Sample
uint8_t touch_flags = sample.point[0].flags;

// If the Touch Event is Touch Down or Touch Move...
if (touch_flags &amp; TOUCH_DOWN || touch_flags &amp; TOUCH_MOVE) {
  // Report it as LVGL Press with the Touch Coordinates
  touchpad_obj-&gt;last_state = LV_INDEV_STATE_PR;
  touchpad_obj-&gt;last_x = sample.point[0].x;
  touchpad_obj-&gt;last_y = sample.point[0].y;
  ...
} else if (touch_flags &amp; TOUCH_UP) {
  // If the Touch Event is Touch Up,
  // report it as LVGL Release
  touchpad_obj-&gt;last_state = LV_INDEV_STATE_REL;
}</code></pre></div>
<p>And that‚Äôs how LVGL polls our driver to handle Touch Events!</p>
<p>(The polling is not so efficient, but it works!)</p>
<p><em>How to create our own LVGL Touchscreen App?</em></p>
<p>Inside our NuttX Project, look for the <strong>LVGL Demo Source Code</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lvgl/lvgl/blob/v8.3.3/demos/widgets/lv_demo_widgets.c#L202-L528">apps/graphics/lvgl/lvgl/ demos/widgets/lv_demo_widgets.c</a></li>
</ul>
<p>Modify the function <a href="https://github.com/lvgl/lvgl/blob/v8.3.3/demos/widgets/lv_demo_widgets.c#L202-L528"><strong>lv_demo_widgets</strong></a> to create our own <strong>LVGL Widgets</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Create a Button, set the Width and Height
void lv_demo_widgets(void) {
  lv_obj_t *btn = lv_btn_create(lv_scr_act());
  lv_obj_set_height(btn, LV_SIZE_CONTENT);
  lv_obj_set_width(btn, 120);
}</code></pre></div>
<p>For details, check out the <a href="https://docs.lvgl.io/master/widgets/index.html"><strong>LVGL Widget Docs</strong></a></p>
<p><em>Can we improve the rendering speed?</em></p>
<p>Yep we need to <a href="https://lupyuen.github.io/articles/fb#fix-missing-pixels"><strong>flush the CPU Cache</strong></a> to fix a rendering issue with the Allwinner A64 Display Engine.</p>
<p>This ought to improve the rendering speed and make LVGL more responsive.</p>
<p><a href="https://lupyuen.github.io/articles/fb#fix-missing-pixels">(More about this)</a></p>
<h1 id="driver-limitations"><a href="#driver-limitations">10 Driver Limitations</a></h1>
<p><em>Are there any limitations in our NuttX Touch Panel Driver for PinePhone?</em></p>
<p>Yep our <strong>driver has limitations</strong>, since the Touch Panel Hardware is poorly documented‚Ä¶</p>
<ul>
<li>
<p>Our driver doesn‚Äôt support <strong>Multitouch and Swiping</strong>.</p>
<p>Someday we might fix this when we decipher the (undocumented) <a href="https://github.com/goodix/gt9xx_driver_android/blob/master/gt9xx.c"><strong>Official Android Driver</strong></a>.</p>
<p>(2,000 lines of code!)</p>
</li>
<li>
<p>But the <a href="https://lupyuen.github.io/articles/touch2#lvgl-calls-our-driver"><strong>LVGL Demo</strong></a> doesn‚Äôt support Multitouch either.</p>
<p>(So we might put on hold for now)</p>
</li>
<li>
<p>PinePhone‚Äôs Touch Panel triggers <a href="https://lupyuen.github.io/articles/touch2#attach-our-interrupt-handler"><strong>Excessive Interrupts</strong></a>.</p>
<p>Again we‚Äôll have to decipher the (still undocumented) <a href="https://github.com/goodix/gt9xx_driver_android/blob/master/gt9xx.c"><strong>Official Android Driver</strong></a> to fix this.</p>
</li>
<li>
<p>Note to Future Self: <strong><code>poll()</code></strong> won‚Äôt work correctly for awaiting Touch Points!</p>
<p>That‚Äôs because we throttle the <a href="https://lupyuen.github.io/articles/touch2#handle-interrupts-from-touch-panel"><strong>Touch Panel Interrupts</strong></a>. When we block on a <strong><code>poll()</code></strong> for Touch Points, the interrupts might get dropped and the unblock might never happen.</p>
<p><a href="https://lupyuen.github.io/articles/touch2#setup-poll-for-touch-sample">(More about polling)</a></p>
</li>
<li>
<p>The <a href="https://lupyuen.github.io/articles/touch2#lvgl-calls-our-driver"><strong>LVGL Demo</strong></a> doesn‚Äôt call <strong><code>poll()</code></strong>, it only calls non-blocking <strong><code>read()</code></strong>.</p>
<p>So we‚Äôre good for now.</p>
</li>
</ul>
<p><em>Maybe we didn‚Äôt set the Touch Panel Status correctly? Causing the Excessive Interrupts?</em></p>
<p>We checked that the <strong>Touch Panel Status</strong> was correctly set to 0 after every interrupt. <a href="https://gist.github.com/lupyuen/726110f8d24416584fe232330ffb1683">(See this)</a></p>
<p><a href="https://gist.github.com/lupyuen/726110f8d24416584fe232330ffb1683">(But why does Status <code>0x81</code> change to <code>0x80</code> instead of 0?)</a></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Meanwhile please check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pio"><strong>‚ÄúNuttX RTOS for PinePhone: Blinking the LEDs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi2"><strong>‚ÄúNuttX RTOS for PinePhone: Display Driver in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de"><strong>‚ÄúRendering PinePhone‚Äôs Display (DE and TCON0)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de2"><strong>‚ÄúNuttX RTOS for PinePhone: Render Graphics in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi3"><strong>‚ÄúNuttX RTOS for PinePhone: MIPI Display Serial Interface‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/de3"><strong>‚ÄúNuttX RTOS for PinePhone: Display Engine‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lcd"><strong>‚ÄúNuttX RTOS for PinePhone: LCD Panel‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/touch2.md"><strong>lupyuen.github.io/src/touch2.md</strong></a></p>
<h1 id="appendix-nuttx-touch-panel-driver-for-pinephone"><a href="#appendix-nuttx-touch-panel-driver-for-pinephone">12 Appendix: NuttX Touch Panel Driver for PinePhone</a></h1>
<p><em>What‚Äôs inside our NuttX Touch Panel Driver for PinePhone?</em></p>
<p>We took the code from above and wrapped it inside our <strong>NuttX Touch Panel Driver</strong> for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c"><strong>nuttx/drivers/input/gt9xx.c</strong></a></li>
</ul>
<p>NuttX Apps will access our driver at <strong>/dev/input0</strong>, which exposes the following <strong>File Operations</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L114-L132">gt9xx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// File Operations supported by the Touch Panel
struct file_operations g_gt9xx_fileops = {
  gt9xx_open,   // Open the Touch Panel
  gt9xx_close,  // Close the Touch Panel
  gt9xx_read,   // Read a Touch Sample
  gt9xx_poll    // Setup Poll for Touch Sample</code></pre></div>
<p>NuttX Apps will call these Touch Panel Operations through the POSIX Standard Functions <strong><code>open()</code></strong>, <strong><code>close()</code></strong>, <strong><code>read()</code></strong> and <strong><code>poll()</code></strong>.</p>
<p><em>How do we start the Touch Panel Driver?</em></p>
<p>This is how we <strong>start the Touch Panel Driver</strong> when NuttX boots: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L197-L204">pinephone_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Default I2C Address for Goodix GT917S
#define CTP_I2C_ADDR 0x5d

// Register the Touch Panel Driver
ret = gt9xx_register(
  &quot;/dev/input0&quot;,      // Device Path
  i2c,                // I2C Bus
  CTP_I2C_ADDR,       // I2C Address of Touch Panel
  &amp;g_pinephone_gt9xx  // Callbacks for PinePhone Operations
);
DEBUGASSERT(ret == OK);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/touch2#register-touch-panel-driver">(<strong>gt9xx_register</strong> comes from our Touch Panel Driver)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L64-L74">(<strong>g_pinephone_gt9xx</strong> defines the Interrupt Callbacks)</a></p>
<p><em>The driver code looks familiar?</em></p>
<p>We borrowed the logic from the NuttX Driver for <a href="https://github.com/apache/nuttx/blob/master/drivers/input/cypress_mbr3108.c"><strong>Cypress MBR3108</strong></a>.</p>
<p>(Which is also an I2C Input Device)</p>
<p>Let‚Äôs talk about the Touch Panel operations‚Ä¶</p>
<h2 id="register-touch-panel-driver"><a href="#register-touch-panel-driver">12.1 Register Touch Panel Driver</a></h2>
<p>At startup, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L197-L204"><strong>pinephone_bringup</strong></a> registers our Touch Panel Driver at <strong>/dev/input0</strong> by calling‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L892-L961"><strong>gt9xx_register: Register Touch Panel Driver</strong></a></li>
</ul>
<p>Which will‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise the Struct</strong> for Touch Panel </p>
</li>
<li>
<p><strong>Register the Touch Panel Driver</strong> with NuttX</p>
<p>(At <strong>/dev/input0</strong>)</p>
</li>
<li>
<p><strong>Attach the Interrupt Handler</strong> with NuttX</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L541-L560">(Implemented as <strong>pinephone_gt9xx_irq_attach</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#attach-our-interrupt-handler">(As explained earlier)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#interrupt-handler">(Interrupt Handler is <strong>gt9xx_isr_handler</strong>)</a></p>
</li>
<li>
<p><strong>Disable Interrupts</strong> from the Touch Panel</p>
<p>(We‚Äôll enable interrupts when we open the Touch Panel)</p>
</li>
</ol>
<p>Now watch what happens when a NuttX App opens the Touch Panel‚Ä¶</p>
<h2 id="open-the-touch-panel"><a href="#open-the-touch-panel">12.2 Open the Touch Panel</a></h2>
<p>When a NuttX App calls <strong><code>open()</code></strong> on <strong>/dev/input0</strong>, NuttX invokes this operation on our driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L575-L662"><strong>gt9xx_open: Open the Touch Panel</strong></a></li>
</ul>
<p>Inside the <strong>Open Operation</strong> we‚Ä¶</p>
<ol>
<li>
<p><strong>Power On</strong> the Touch Panel</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L584-L590">(Implemented as <strong>pinephone_gt9xx_set_power</strong>)</a></p>
</li>
<li>
<p><strong>Probe the Touch Panel</strong> on the I2C Bus, to verify that it exists</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L291-L328">(Implemented as <strong>gt9xx_probe_device</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#read-the-product-id">(Which reads the <strong>Product ID</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L136-L213">(By calling <strong>gt9xx_i2c_read</strong>)</a></p>
</li>
<li>
<p><strong>Enable Interrupts</strong> from the Touch Panel</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L560-L584">(Implemented as <strong>pinephone_gt9xx_irq_enable</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#attach-our-interrupt-handler">(As explained earlier)</a></p>
</li>
</ol>
<p>The <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L575-L662"><strong>Actual Flow</strong></a> looks more complicated because we do <strong>Reference Counting</strong>.</p>
<p>(We do the above steps only on the first call to <strong><code>open()</code></strong>)</p>
<p>Let‚Äôs read some touch data‚Ä¶</p>
<h2 id="read-a-touch-sample"><a href="#read-a-touch-sample">12.3 Read a Touch Sample</a></h2>
<p><em>What‚Äôs a Touch Sample?</em></p>
<p>When a NuttX App reads data from our Touch Panel, it passes a <strong>Touch Sample Struct</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Struct for Touch Sample
struct touch_sample_s sample;

// Read a Touch Sample from Touch Panel
read(
  fd,       // File Descriptor from `open(&quot;/dev/input0&quot;)`
  &amp;sample,  // Touch Sample
  sizeof(struct touch_sample_s)  // Size of Touch Sample
);</code></pre></div>
<p><a href="https://github.com/apache/nuttx-apps/blob/master/graphics/lvgl/port/lv_port_touchpad.c#L60-L70">(Source)</a></p>
<p>A Touch Sample contains <strong>One Touch Point</strong> (by default): <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/input/touchscreen.h#L129-L149">touchscreen.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Touch Sample Struct
struct touch_sample_s {
  int npoints;  // Number of Touch Points in point[]
  struct touch_point_s point[1];  // Touch Points of length npoints
};</code></pre></div>
<p>A <strong>Touch Point</strong> contains the X and Y Coordinates, also indicates whether it‚Äôs Touch Up or Touch Down: <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/input/touchscreen.h#L112-L129">touchscreen.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Touch Point Struct
struct touch_point_s {
  uint8_t  id;     // Identifies the finger touched (Multitouch)
  uint8_t  flags;  // Touch Up or Touch Down
  int16_t  x;      // X Coordinate of the Touch Point
  int16_t  y;      // Y Coordinate of the Touch Point
  ...</code></pre></div>
<p>When the app calls <strong><code>read()</code></strong>, NuttX Kernel calls our driver at‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L451-L575"><strong>gt9xx_read: Read a Touch Sample</strong></a></li>
</ul>
<p>Which works like so‚Ä¶</p>
<ol>
<li>
<p><strong>Enable Interrupts</strong> from the Touch Panel</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L560-L584">(Implemented as <strong>pinephone_gt9xx_irq_enable</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#attach-our-interrupt-handler">(As explained earlier)</a></p>
</li>
<li>
<p>If the <strong>Last Result</strong> was <strong>Touch Down</strong>‚Ä¶</p>
<p>We return the Last Touch Point, now changed to <strong>Touch Up</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/touch2#lvgl-calls-our-driver">(We simulate the Touch Up because our LVGL Demo expects it)</a></p>
</li>
<li>
<p>If the <strong>Last Result</strong> was <strong>NOT Touch Down</strong>‚Ä¶</p>
<p>And the <strong>Interrupt Pending Flag</strong> has been set‚Ä¶</p>
<p>We clear the flag, <strong>read the Touch Point</strong> from the Touch Panel and return it.</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L362-L451">(Implemented as <strong>gt9xx_read_touch_data</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#read-a-touch-point">(As explained earlier)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L328-L362">(Which calls <strong>gt9xx_set_status</strong> to set the status)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L213-L291">(Which calls <strong>gt9xx_i2c_write</strong> to write over I2C)</a></p>
</li>
</ol>
<p>Since our driver doesn‚Äôt support Multitouch, the Read Operation will return <strong>either 0 or 1 Touch Points</strong>.</p>
<p>PinePhone‚Äôs Touch Panel fires spurious interrupts, so it‚Äôs possible that <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L362-L451"><strong>gt9xx_read_touch_data</strong></a> will return No Touch Points.</p>
<p>Let‚Äôs talk about the Interrupt Pending Flag‚Ä¶</p>
<h2 id="interrupt-handler"><a href="#interrupt-handler">12.4 Interrupt Handler</a></h2>
<p>This is our <strong>Interrupt Handler</strong> for Touch Panel Interrupts‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L840-L888"><strong>gt9xx_isr_handler: Interrupt Handler</strong></a></li>
</ul>
<p>Inside the Interrupt Handler we‚Ä¶</p>
<ol>
<li>
<p><strong>Throttle the Excessive Interrupts</strong>‚Ä¶</p>
<p>If the <strong>Interrupt Pending Flag</strong> has been set, we <strong>Disable Interrupts</strong>.</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L560-L584">(Implemented as <strong>pinephone_gt9xx_irq_enable</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#handle-interrupts-from-touch-panel">(As explained earlier)</a></p>
</li>
<li>
<p>Set the <strong>Interrupt Pending Flag</strong></p>
<p>(Which is protected by a NuttX Critical Section)</p>
</li>
<li>
<p>Notify the <strong>Poll Waiters</strong> (Background Threads)</p>
<p><a href="https://lupyuen.github.io/articles/touch2#handle-interrupts-from-touch-panel">(As explained earlier)</a></p>
</li>
</ol>
<p>Now we talk about the Poll Waiters‚Ä¶</p>
<h2 id="setup-poll-for-touch-sample"><a href="#setup-poll-for-touch-sample">12.5 Setup Poll for Touch Sample</a></h2>
<p>A NuttX App calls <strong><code>poll()</code></strong> to set up (or tear down) a <strong>Poll for Touch Sample</strong>.</p>
<p>This enables the app to suspend itself and <strong>block until a Touch Panel Interrupt</strong> has been triggered. (And there‚Äôs a Touch Point available)</p>
<p>When an app calls <strong><code>poll()</code></strong>, the NuttX Kernel calls our driver at‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L728-L840"><strong>gt9xx_poll: Setup Poll for Touch Sample</strong></a></li>
</ul>
<p>Inside the function we‚Ä¶</p>
<ol>
<li>
<p><strong>Enable Interrupts</strong> from the Touch Panel</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L560-L584">(Implemented as <strong>pinephone_gt9xx_irq_enable</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch2#attach-our-interrupt-handler">(As explained earlier)</a></p>
</li>
<li>
<p><strong>For Poll Setup:</strong></p>
<ul>
<li>
<p>We find an Available Slot for the <strong>Poll Waiter</strong></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L72-L99">(Poll Waiter Slots are defined in <strong>gt9xx_dev_s</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/Kconfig#L501-L522">(<strong>INPUT_GT9XX_NPOLLWAITERS</strong> is the max number of slots, set to 1)</a></p>
</li>
<li>
<p>We <strong>bind the Poll Struct</strong> and this Slot</p>
</li>
<li>
<p>If <strong>Interrupt Pending</strong> is set, we notify the Poll Waiters</p>
</li>
</ul>
</li>
<li>
<p><strong>For Poll Teardown</strong>: We unbind the Poll Setup</p>
</li>
</ol>
<h2 id="close-the-touch-panel"><a href="#close-the-touch-panel">12.6 Close the Touch Panel</a></h2>
<p>When a NuttX App calls <strong><code>close()</code></strong> on <strong>/dev/input0</strong>, NuttX invokes this operation on our driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/drivers/input/gt9xx.c#L662-L728"><strong>gt9xx_close: Close the Touch Panel</strong></a></li>
</ul>
<p>Inside the <strong>Close Operation</strong> we‚Ä¶</p>
<ol>
<li>
<p><strong>Disable Interrupts</strong> from the Touch Panel</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L560-L584">(Implemented as <strong>pinephone_gt9xx_irq_enable</strong>)</a></p>
</li>
<li>
<p><strong>Power Off</strong> the Touch Panel</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/touch2/boards/arm64/a64/pinephone/src/pinephone_bringup.c#L584-L590">(Implemented as <strong>pinephone_gt9xx_set_power</strong>)</a></p>
</li>
</ol>
<p>We do this only if the <strong>Reference Count</strong> decrements to 0.</p>
<p>(Which indicates the final <strong><code>close()</code></strong> for our driver)</p>

    
</body>
</html>