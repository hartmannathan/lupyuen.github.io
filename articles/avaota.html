<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/avaota-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/avaota.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)</h1>
    <nav id="rustdoc"><ul>
<li><a href="#boot-linux-on-our-sbc" title="Boot Linux on our SBC">1 Boot Linux on our SBC</a><ul></ul></li>
<li><a href="#nuttx-kernel-build-for-arm64-qemu" title="NuttX Kernel Build for Arm64 QEMU">2 NuttX Kernel Build for Arm64 QEMU</a><ul></ul></li>
<li><a href="#boot-nuttx-kernel-on-our-sbc" title="Boot NuttX Kernel on our SBC">3 Boot NuttX Kernel on our SBC</a><ul></ul></li>
<li><a href="#print-to-uart-in-arm64-assembly" title="Print to UART in Arm64 Assembly">4 Print to UART in Arm64 Assembly</a><ul></ul></li>
<li><a href="#set-the-start-address" title="Set the Start Address">5 Set the Start Address</a><ul></ul></li>
<li><a href="#uart-driver-for-16550" title="UART Driver for 16550">6 UART Driver for 16550</a><ul></ul></li>
<li><a href="#build-nuttx-for-avaota-a1" title="Build NuttX for Avaota-A1">7 Build NuttX for Avaota-A1</a><ul></ul></li>
<li><a href="#passwordless-sudo" title="Passwordless Sudo">8 Passwordless Sudo</a><ul></ul></li>
<li><a href="#arm64-memory-management-unit" title="Arm64 Memory Management Unit">9 Arm64 Memory Management Unit</a><ul></ul></li>
<li><a href="#fix-the-nuttx-memory-map" title="Fix the NuttX Memory Map">10 Fix the NuttX Memory Map</a><ul></ul></li>
<li><a href="#arm64-global-interrupt-controller" title="Arm64 Global Interrupt Controller">11 Arm64 Global Interrupt Controller</a><ul></ul></li>
<li><a href="#nuttx-apps-filesystem" title="NuttX Apps Filesystem">12 NuttX Apps Filesystem</a><ul></ul></li>
<li><a href="#fix-the-uart-interrupt" title="Fix the UART Interrupt">13 Fix the UART Interrupt</a><ul></ul></li>
<li><a href="#todo" title="TODO">14 TODO</a><ul></ul></li>
<li><a href="#boot-nuttx-for-avaota-a1" title="Boot NuttX for Avaota-A1">15 Boot NuttX for Avaota-A1</a><ul></ul></li>
<li><a href="#allwinner-a527-docs" title="Allwinner A527 Docs">16 Allwinner A527 Docs</a><ul></ul></li>
<li><a href="#work-in-progress" title="Work In Progress">17 Work In Progress</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">18 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-nuttx-apps-filesystem" title="Appendix: NuttX Apps Filesystem">19 Appendix: NuttX Apps Filesystem</a><ul></ul></li>
<li><a href="#appendix-mount-the-ram-disk" title="Appendix: Mount the RAM Disk">20 Appendix: Mount the RAM Disk</a><ul></ul></li></ul></nav><p>üìù <em>9 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/avaota-title.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<span style="font-size:80%">
<p><a href="https://youtu.be/PxaMcmMAzlM"><em>(Watch the Demo on YouTube)</em></a></p>
</span>
<p>TODO</p>
<p><em>Why are we doing this?</em></p>
<ul>
<li>Anyone porting NuttX from <strong>QEMU to Real SBC</strong>? This walkthrough shall be mighty helpful!</li>
</ul>
<p>TI ported NuttX to a simpler A527 board, the Avaota-A1 SBC by PINE64 ($55): https://pine64.com/product/yuzuki-avaota-a1-single-board-computer-4gb-32gb/</p>
<p>Avaota-A1 SBC is Open Source Hardware (CERN OHL Licensed). PINE64 sells it today, maybe we‚Äôll see more manufacturers with the same design: https://github.com/AvaotaSBC/Avaota-A1</p>
<p>I think NuttX on Avaota-A1 (Allwinner A527) will be super interesting because:</p>
<p>(1) It‚Äôs one of the first ports of Arm64 in NuttX Kernel Build (NXP i.MX93 might be another?)</p>
<p>(2) We‚Äôll run it as PR Test Bot for Validating Arm64 PRs</p>
<p>(3) PR Test Bot will be fully automated thanks to SDWire MicroSD Mux: https://lupyuen.org/articles/testbot3.html</p>
<p>Next article I‚Äôll explain how I ported NuttX from QEMU Arm64 (knsh) to Avaota-A1, completed within 24 hours.</p>
<p>Octa-Core CPU</p>
<p>Here‚Äôs the story</p>
<p>Build NuttX for
Port NuttX to</p>
<p>Schematic: https://github.com/AvaotaSBC/Avaota-A1/blob/master/hardware/v1.4/01_SCH/SCH_Avaota%20Pi%20A_2024-05-20.pdf</p>
<h1 id="boot-linux-on-our-sbc"><a class="doc-anchor" href="#boot-linux-on-our-sbc">¬ß</a>1 Boot Linux on our SBC</h1>
<p>Nifty Trick for Booting NuttX on <strong>Any Arm64 SBC</strong> (RISC-V too)</p>
<ul>
<li>
<p><strong>Arm64 Bootloader</strong> <em>(U-Boot / SyterKit)</em> will boot Linux by loading the <strong><code>Image</code></strong> file</p>
<p><em>(Containing the Linux Kernel)</em></p>
</li>
<li>
<p>Thus we <strong>‚ÄúHijack‚Äù the <code>Image</code> File</strong>, replace it by <strong>NuttX Kernel</strong></p>
</li>
<li>
<p>Which means <strong>NuttX Kernel</strong> shall look and feel like a <strong>Linux Kernel</strong></p>
</li>
<li>
<p>That‚Äôs why we have a <a href="TODO"><strong>Linux Kernel Header</strong></a> at the top of NuttX</p>
</li>
</ul>
<p>To begin, we observe our SBC and its <em>Natural Behaviour</em>: How does it <strong>Boot Linux?</strong></p>
<p>TODO: Download</p>
<p>TODO: MicroSD</p>
<p>TODO: Load Address</p>
<p>TODO: LCD Screen too</p>
<p>Download the <a href="https://github.com/AvaotaSBC/AvaotaOS/releases"><strong>Latest AvaotaOS Release</strong></a> <em>(Ubuntu Noble GNOME)</em> and uncompress it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>wget https://github.com/AvaotaSBC/AvaotaOS/releases/download/0.3.0.4/AvaotaOS-0.3.0.4-noble-gnome-arm64-avaota-a1.img.xz
xz -d AvaotaOS-0.3.0.4-noble-gnome-arm64-avaota-a1.img.xz</code></pre></div>
<p>Write the <strong><code>.img</code></strong> file to a MicroSD with <a href="https://etcher.balena.io/"><strong>Balena Etcher</strong></a>.</p>
<p>We‚Äôll overwrite the <code>Image</code> file by <code>nuttx.bin</code>‚Ä¶</p>
<h1 id="nuttx-kernel-build-for-arm64-qemu"><a class="doc-anchor" href="#nuttx-kernel-build-for-arm64-qemu">¬ß</a>2 NuttX Kernel Build for Arm64 QEMU</h1>
<p>Follow these steps to Build and Run NuttX for <a href="TODO"><strong>Arm64 QEMU (Kernel Build)</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX Kernel (NuttX Kernel Build)
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Build NuttX Apps (NuttX Kernel Build)
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Boot NuttX on QEMU
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>Check that it works‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p>TODO: Why Kernel Build</p>
<h1 id="boot-nuttx-kernel-on-our-sbc"><a class="doc-anchor" href="#boot-nuttx-kernel-on-our-sbc">¬ß</a>3 Boot NuttX Kernel on our SBC</h1>
<p>TODO: Kernel Only, no apps</p>
<p>TODO: 28 MB Linux Kernel</p>
<p><a href="https://gist.github.com/lupyuen/6c0607daa0a8f37bda37cc80e76259ee">Build Log</a></p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -l /TODO
total 40261
-rwxr-xr-x 1 root root    78769 Feb 22 01:06 bl31.bin
-rwxr-xr-x 1 root root   180233 Feb 21 22:21 config-5.15.154-ga464bc4feaff
drwxr-xr-x 3 root root      512 Feb 21 22:56 dtb
drwxr-xr-x 2 root root      512 Feb 22 01:06 extlinux
-rwxr-xr-x 1 root root 27783176 Mar  7 21:24 Image
-rwxr-xr-x 1 root root   180228 Feb 22 01:06 scp.bin
-rwxr-xr-x 1 root root    12960 Feb 22 01:06 splash.bin
-rwxr-xr-x 1 root root  5193581 Feb 21 22:21 System.map-5.15.154-ga464bc4feaff
-rwxr-xr-x 1 root root  6497300 Feb 22 01:06 uInitrd</code></pre></div>
<p>TODO: We‚Äôll overwrite the <code>Image</code> file by <code>nuttx.bin</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mv /TODO/Image /TODO/Image.old
cp nuttx.bin /TODO/Image
ls -l /TODO/Image
## Should be a lot smaller
umount /TODO</code></pre></div>
<p>Nothing happens. We do some logging‚Ä¶</p>
<h1 id="print-to-uart-in-arm64-assembly"><a class="doc-anchor" href="#print-to-uart-in-arm64-assembly">¬ß</a>4 Print to UART in Arm64 Assembly</h1>
<p><em>Is NuttX actually booting?</em></p>
<p>Let‚Äôs print something. <strong>UART0 Base Address</strong> is here‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">UART0</td><td style="text-align: left"><em>0x0250_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>16550 Transmit Register is at <strong>Offset 0</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x0000</em></td><td style="text-align: left">UART_THR <em>(Transmit Holding Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0004</em></td><td style="text-align: left">UART_DLH <em>(Divisor Latch High Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0008</em></td><td style="text-align: left">UART_IIR <em>(Interrupt Identity Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x000C</em></td><td style="text-align: left">UART_LCR <em>(Line Control)</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>Which means we can <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333"><strong>Print to UART</strong></a> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `123` to UART0
*(volatile uint8_t *) 0x02500000 = &#39;1&#39;;
*(volatile uint8_t *) 0x02500000 = &#39;2&#39;;
*(volatile uint8_t *) 0x02500000 = &#39;3&#39;;</code></pre></div>
<p>But let‚Äôs do it in <strong>Arm64 Assembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/be2f1c55aa24eda9cd8652aa0bf38251335e9d01">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Bootloader starts NuttX here */
__start:
  add x13, x18, #0x16 /* &quot;MZ&quot;: Magic Number for Linux Kernel Header */
  b   real_start      /* Jump to Executable Code      */
  ...                 /* Omitted: Linux Kernel Header */

/* Executable Code begins here */
/* We print `123` to UART0     */
real_start:

  /* Load UART0 Base Address into Register X15 */
  mov  x15, #0x02500000

  /* Load character `1` into Register W16 */
  mov  w16, #0x31

  /* Store the lower byte from Register W16 (`1`) to UART0 Base Address */
  strb w16, [x15]

  /* Load and Store the lower byte from Register W16 (`2`) to UART0 Base Address */
  mov  w16, #0x32
  strb w16, [x15]

  /* Load and Store the lower byte from Register W16 (`3`) to UART0 Base Address */
  mov  w16, #0x33
  strb w16, [x15]</code></pre></div>
<p>Rebuild NuttX and recopy <strong><code>nuttx.bin</code></strong> to MicroSD, overwriting the <strong><code>Image</code></strong> file. NuttX boot and <a href="https://gist.github.com/lupyuen/14188c44049a14e3581523c593fdf2d8"><strong>prints <code>123</code> yay</strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast
123</code></pre></div>
<p>(Ignore the <em>opteed_fast</em> error)</p>
<p><em>Why print in Arm64 Assembly? Why not C?</em></p>
<ol>
<li>
<p>Arm64 Assembly is the <strong>very first thing that boots</strong> when Bootloader starts NuttX</p>
</li>
<li>
<p>This happens <strong>before anything complicated</strong> begins: UART Driver, Memory Management Unit, Task Scheduler, ‚Ä¶</p>
</li>
<li>
<p>The Arm64 Assembly above is <strong>Address-Independent Code</strong>: It will execute at Any Arm64 Address</p>
</li>
</ol>
<p>Next we move our code and make it Address-Dependent‚Ä¶</p>
<h1 id="set-the-start-address"><a class="doc-anchor" href="#set-the-start-address">¬ß</a>5 Set the Start Address</h1>
<p><em>NuttX boots a tiny bit on our SBC. Where‚Äôs the rest?</em></p>
<p>Our SBC boots NuttX at a different address from QEMU. We fix the <strong>Start Address</strong> inside NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
123</code></pre></div>
<ol>
<li>
<p>Remember the <a href="TODO"><strong>Boot Log</strong></a> from earlier? It says that the <a href="https://github.com/YuzukiHD/SyterKit"><strong>SyterKit Bootloader</strong></a> starts NuttX at <strong>Address <code>0x4080_0000</code></strong>. We fix it here: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c38e1f7c014e1af648a33847fc795930ba995bca">ld-kernel.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY {
  /* Previously: QEMU boots at 0x4028_0000 */
  dram (rwx)  : ORIGIN = 0x40800000, LENGTH = 2M

  /* Previously: QEMU Paged Memory is at 0x4028_0000 */
  pgram (rwx) : ORIGIN = 0x40A00000, LENGTH = 4M   /* w/ cache */
}</code></pre></div></li>
<li>
<p>Since we changed the <strong>Paged Memory Pool</strong> <em>(pgram)</em>, we update <em>CONFIG_ARCH_PGPOOL_PBASE</em> and <em>CONFIG_ARCH_PGPOOL_VBASE</em> too: <a href="https://github.com/lupyuen2/wip-nuttx/commit/eb33ac06f88dda557bc8ac97bec7d6cbad4ccb86">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Physical Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_PBASE=0x40A00000

## Virtual Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_VBASE=0x40A00000</code></pre></div></li>
<li>
<p>NuttX QEMU declares the <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45"><strong>RAM Size as 128 MB</strong></a> <em>(CONFIG_RAMBANK1_SIZE)</em>. We set <em>CONFIG_RAM_SIZE</em> to match <em>CONFIG_RAMBANK1_SIZE</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c8fbc5b86c2bf1dd7b8243b301b0790115c9c4ca">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## RAM Size is a paltry 128 MB
CONFIG_RAM_SIZE=134217728</code></pre></div>
<p><em>(Kinda tiny, but sufficient)</em></p>
</li>
<li>
<p><strong>Linux Kernel Header</strong> needs patching. We set the <strong>Image Load Offset</strong> to <em>0x80_0000</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/be2f1c55aa24eda9cd8652aa0bf38251335e9d01">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Bootloader starts NuttX here, followed by Linux Kernel Header */
__start:
  ...
  /* Image Load Offset from Start of RAM          */
  /* Previously: QEMU set this to 0x480000 (why?) */
  .quad 0x800000</code></pre></div></li>
</ol>
<p>That‚Äôs because‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/blob/avaota/boards/arm64/qemu/qemu-armv8a/configs/knsh/defconfig#L85"><strong>Start of RAM</strong></a> is <em>0x4000_0000</em></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_RAM_START=0x40000000</code></pre></div></li>
<li>
<p>Bootloader starts NuttX at <em>0x4080_0000</em></p>
</li>
<li>
<p>Subtract the above to get <strong>Image Load Offset</strong>: <em>0x80_0000</em></p>
</li>
</ul>
<p>With these fixes, our C Code in NuttX shall boot correctly.</p>
<p>TODO: LCD also</p>
<h1 id="uart-driver-for-16550"><a class="doc-anchor" href="#uart-driver-for-16550">¬ß</a>6 UART Driver for 16550</h1>
<p><em>Our C Code can print to UART now?</em></p>
<p>To watch the <strong>Boot Progress</strong> <em>(Sesame Street-style)</em>, we can print primitively to UART like this: <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// 0x0250_0000 is the UART0 Base Address
void arm64_boot_primary_c_routine(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;A&#39;;
  arm64_chip_boot();
  ...

void arm64_chip_boot(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;;
  arm64_mmu_init(true);  // Init the Memory Mgmt Unit

  *(volatile uint8_t *) 0x02500000 = &#39;C&#39;;
  arm64_enable_mte();    // TODO

  *(volatile uint8_t *) 0x02500000 = &#39;D&#39;;
  qemu_board_initialize();  // Init the Board

  *(volatile uint8_t *) 0x02500000 = &#39;E&#39;;
  arm64_earlyserialinit();  // Init the Serial Driver

  *(volatile uint8_t *) 0x02500000 = &#39;F&#39;;
  syslog_rpmsg_init_early(...);  // Init the System Logger

  *(volatile uint8_t *) 0x02500000 = &#39;G&#39;;
  up_perf_init(..);  // Init the Performance Counters</code></pre></div>
<p>Beyond Big Bird: We need the <strong>16550 UART Driver</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>NuttX Boot Code</strong> <em>(Arm64 Assembly)</em> will print to UART. We patch it: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-60cebb895326dea641e32d31ff39511acf127a30c9ac8f275590e7524737366e">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address and Baud Rate for 16550 UART
#define UART1_BASE_ADDRESS          0x02500000
#define EARLY_UART_PL011_BAUD_RATE  115200</code></pre></div></li>
<li>
<p><strong>NuttX Boot Code</strong> will drop UART Output, unless we wait for UART Ready: <a href="https://github.com/lupyuen2/wip-nuttx/commit/544323e7c0e66c4df0d1312d4837147d420bc19d">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Wait for 16550 UART to be ready to transmit
* xb: Register that contains the UART Base Address
* wt: Scratch register number */
.macro early_uart_ready xb, wt
1:
  ldrh  \wt, [\xb, #0x14] /* UART_LSR (Line Status Register) */
  tst   \wt, #0x20        /* Check THRE (TX Holding Register Empty) */
  b.eq  1b                /* Wait for the UART to be ready (THRE=1) */
.endm</code></pre></div>
<p><a href="TODO"><em>(Thanks to PinePhone)</em></a></p>
</li>
<li>
<p>QEMU uses PL011 UART. We switch to <strong>16550 UART</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-aefbee7ddc3221be7383185346b81cff77d382eb6f308ecdccb44466d0437108">qemu_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Switch from PL011 UART (QEMU) to 16550 UART
#include &lt;nuttx/serial/uart_16550.h&gt;

// Enable the 16550 Console UART at Startup
void arm64_earlyserialinit(void) {
  // Previously for QEMU: pl011_earlyserialinit
  u16550_earlyserialinit();
}

// TODO
void arm64_serialinit(void) {
  // Previous for QEMU: pl011_serialinit
  u16550_serialinit();
}</code></pre></div></li>
<li>
<p><strong>16550 UART</strong> shall be configured: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x02500000
CONFIG_16550_UART0_CLOCK=198144000
CONFIG_16550_UART0_IRQ=125
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y</code></pre></div></li>
<li>
<p><strong>PL011 UART</strong> shall be removed: <a href="https://github.com/lupyuen2/wip-nuttx/commit/8fc8ed6ba84cfea86184f61d9c4d7c8e21329987">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Remove PL011 UART from NuttX Config:
## CONFIG_UART1_BASE=0x9000000
## CONFIG_UART1_IRQ=33
## CONFIG_UART1_PL011=y
## CONFIG_UART1_SERIAL_CONSOLE=y
## CONFIG_UART_PL011=y</code></pre></div></li>
<li>
<p><strong>16550_UART0_CLOCK</strong> isn‚Äôt quite correct, we‚Äôll <a href="TODO"><strong>fix it later</strong></a>. Meanwhile we disable the <strong>UART Clock Configuration</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-f208234edbfb636de240a0fef1c85f9cecb37876d5bc91ffb759f70a1e96b1d1">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// We disable the UART Clock Configuration...
static int u16550_setup(FAR struct uart_dev_s *dev) { ...
#ifdef TODO  // We&#39;ll fix it later
  // Enter DLAB=1
  u16550_serialout(priv, UART_LCR_OFFSET, (lcr | UART_LCR_DLAB));

  // Omitted: Set the UART Baud Divisor
  // ...

  // Clear DLAB
  u16550_serialout(priv, UART_LCR_OFFSET, lcr);
#endif</code></pre></div></li>
</ol>
<p>Same old drill: Rebuild, recopy and reboot NuttX. We see plenty more <a href="https://gist.github.com/lupyuen/563ed00d3f6e9f7fb9b27268d4eae26b"><strong>debug output yay</strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
AB</code></pre></div>
<p>OK the repeated rebuilding, recopying and rebooting of NuttX is getting really tiresome. Let‚Äôs automate‚Ä¶</p>
<h1 id="build-nuttx-for-avaota-a1"><a class="doc-anchor" href="#build-nuttx-for-avaota-a1">¬ß</a>7 Build NuttX for Avaota-A1</h1>
<p><em>What if we could rebuild-recopy-reboot NuttX‚Ä¶ In One Single Script?</em></p>
<p><a href="https://youtu.be/PxaMcmMAzlM">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p>Well thankfully we have a <strong>MicroSD Multiplexer</strong> that will make MicroSD Swapping a lot easier! (Not forgetting our <a href="https://lupyuen.github.io/articles/testbot#power-up-our-oz64-sbc"><strong>Smart Power Plug</strong></a>)</p>
<p>Our Avaota-A1 SBC is connected to SDWire MicroSD Multiplexer and Smart Power Plug (pic above). So our Build Script will do <strong>everything</strong> for us:</p>
<ul>
<li>
<p>Copy NuttX to MicroSD</p>
</li>
<li>
<p>Swap MicroSD from our Test PC to SBC</p>
</li>
<li>
<p>Power up SBC and boot NuttX!</p>
</li>
</ul>
<p>See the Build Script:</p>
<ul>
<li>https://gist.github.com/lupyuen/a4ac110fb8610a976c0ce2621cbb8587</li>
</ul>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX and Apps (NuttX Kernel Build)
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch avaota
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch avaota
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate the Initial RAM Disk
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to the NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Get the Home Assistant Token, copied from http://localhost:8123/profile/security
## token=xxxx
set +x  ##  Disable echo
. $HOME/home-assistant-token.sh
set -x  ##  Enable echo

set +x  ##  Disable echo
echo &quot;----- Power Off the SBC&quot;
curl \
    -X POST \
    -H &quot;Authorization: Bearer $token&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_power_off&quot;}&#39; \
    http://localhost:8123/api/services/automation/trigger
set -x  ##  Enable echo

## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

set +x  ##  Disable echo
echo &quot;----- Power On the SBC&quot;
curl \
    -X POST \
    -H &quot;Authorization: Bearer $token&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_power_on&quot;}&#39; \
    http://localhost:8123/api/services/automation/trigger
set -x  ##  Enable echo

## Wait for SBC to finish booting
sleep 30

set +x  ##  Disable echo
echo &quot;----- Power Off the SBC&quot;
curl \
    -X POST \
    -H &quot;Authorization: Bearer $token&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_power_off&quot;}&#39; \
    http://localhost:8123/api/services/automation/trigger
set -x  ##  Enable echo</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6c0607daa0a8f37bda37cc80e76259ee">(See the <strong>Build Log</strong>)</a></p>
<p>(<strong>copy-image.sh</strong> is explained below)</p>
<h1 id="passwordless-sudo"><a class="doc-anchor" href="#passwordless-sudo">¬ß</a>8 Passwordless Sudo</h1>
<p>Let‚Äôs make our Build-Test Cycle quicker. We do Passwordless Sudo for flipping our SDWire Mux</p>
<p>SDWire Mux needs plenty of Sudo Passwords to flip the mux, mount the filesystem, copy to MicroSD.</p>
<p>Let‚Äôs make it Sudo Password-Less with visudo: https://help.ubuntu.com/community/Sudoers</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the Sudoers Editor
sudo visudo

## Add this line:
user ALL=(ALL) NOPASSWD: /home/user/copy-image.sh</code></pre></div>
<p>Edit /home/user/copy-image.sh‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>set -e  ## Exit when any command fails
set -x  ## Echo commands
whoami  ## I am root!

## Copy /tmp/Image to MicroSD
sd-mux-ctrl --device-serial=sd-wire_02-09 --ts
sleep 5
mkdir -p /tmp/sda1
mount /dev/sda1 /tmp/sda1
cp /tmp/Image /tmp/sda1/
ls -l /tmp/sda1

## Unmount MicroSD and flip it to the Test Device (Avaota-A1 SBC)
umount /tmp/sda1
sd-mux-ctrl --device-serial=sd-wire_02-09 --dut</code></pre></div>
<p>(Remember to <code>chmod +x /home/user/copy-image.sh</code>)</p>
<p>Now we can run copy-image.sh without a password yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Sudo will NOT prompt for password yay!
sudo /home/user/copy-image.sh

## Also works over SSH: Copy NuttX Image to MicroSD
## No password needed for sudo yay!
scp nuttx.bin thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/a4ac110fb8610a976c0ce2621cbb8587">(See the <strong>Build Script</strong>)</a></p>
<h1 id="arm64-memory-management-unit"><a class="doc-anchor" href="#arm64-memory-management-unit">¬ß</a>9 Arm64 Memory Management Unit</h1>
<p>Earlier we saw NuttX <a href="TODO"><strong>stuck at ‚Äú<code>AB</code>‚Äù</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
AB</code></pre></div>
<p>Which says that NuttX is stuck inside <strong>arm64_mmu_init</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// 0x0250_0000 is the UART0 Base Address
void arm64_boot_primary_c_routine(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;A&#39;;
  arm64_chip_boot();
  ...

// `AB` means that NuttX is stuck inside arm64_mmu_init()
void arm64_chip_boot(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;;
  arm64_mmu_init(true);  // Init the Memory Mgmt Unit

  // Stuck above, never came here
  *(volatile uint8_t *) 0x02500000 = &#39;C&#39;;
  arm64_enable_mte();    // TODO</code></pre></div>
<p><em>What‚Äôs arm64_mmu_init?</em></p>
<p>NuttX calls <strong>arm64_mmu_init</strong> to initialise the Arm64 <strong>Memory Management Unit (MMU)</strong>. We add some logs inside: <a href="https://github.com/lupyuen2/wip-nuttx/pull/96/files#diff-230f2ffd9be0a8ce48d4c9fb79df8f003b0c31fa0a18b6c0876ede5b4e334bb9">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable debugging for MMU.
#define CONFIG_MMU_ASSERT 1
#define CONFIG_MMU_DEBUG  1
#define trace_printf _info

// We fix the debug output, changing `%lux` to `%p`
static void init_xlat_tables(const struct arm_mmu_region *region) {
  ...
  sinfo(&quot;mmap: virt %p phys %p size %p\n&quot;, virt, phys, size);

// To enable the MMU at EL1...
static void enable_mmu_el1(unsigned int flags) {
  ...
  // Ensure these changes are seen before MMU is enabled
  _info(&quot;UP_MB&quot;);
  UP_MB();

  // Enable the MMU and Data Cache
  _info(&quot;Enable the MMU and data cache&quot;);
  write_sysreg(value | SCTLR_M_BIT | SCTLR_C_BIT, sctlr_el1);

  // Ensure the MMU Enable takes effect immediately
  _info(&quot;UP_ISB&quot;);
  UP_ISB();</code></pre></div>
<p>And we Enable the Logs for <strong>Scheduler and Memory Manager</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/pull/96/files#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Enable Logging for Memory Manager
CONFIG_DEBUG_MM=y
CONFIG_DEBUG_MM_ERROR=y
CONFIG_DEBUG_MM_INFO=y
CONFIG_DEBUG_MM_WARN=y

## Enable Logging for Scheduler
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y</code></pre></div>
<p>Ah OK we‚Äôre stuck just before <a href="https://gist.github.com/lupyuen/544a5d8f3fab2ab7c9d06d2e1583f362"><strong>Enabling the MMU and Data Cache</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>arm64_mmu_init: xlat tables:
arm64_mmu_init: base table(L0): 0x4083c000, 512 entries
arm64_mmu_init: 0: 0x40832000
arm64_mmu_init: 1: 0x40833000
arm64_mmu_init: 2: 0x40834000
arm64_mmu_init: 3: 0x40835000
arm64_mmu_init: 4: 0x40836000
arm64_mmu_init: 5: 0x40837000
arm64_mmu_init: 6: 0x40838000
arm64_mmu_init: 7: 0x40839000
arm64_mmu_init: 8: 0x4083a000
arm64_mmu_init: 9: 0x4083b000
setup_page_tables:
init_xlat_tables: mmap: virt 0x7000000 phys 0x7000000 size 0x20000000
set_pte_table_desc:
set_pte_table_desc: 0x4083c000: [Table] 0x40832000
set_pte_table_desc:
set_pte_table_desc: 0x40832000: [Table] 0x40833000
init_xlat_tables: mmap: virt 0x40000000 phys 0x40000000 size 0x8000000
set_pte_table_desc:
set_pte_table_desc: 0x40832008: [Table] 0x40834000
init_xlat_tables: mmap: virt 0x4010000000 phys 0x4010000000 size 0x10000000
set_pte_table_desc:
set_pte_table_desc: 0x40832800: [Table] 0x40835000
init_xlat_tables: mmap: virt 0x8000000000 phys 0x8000000000 size 0x8000000000
init_xlat_tables: mmap: virt 0x3eff0000 phys 0x3eff0000 size 0x10000
set_pte_table_desc:
set_pte_table_desc: 0x40833fb8: [Table] 0x40836000
init_xlat_tables: mmap: virt 0x40800000 phys 0x40800000 size 0x2a000
split_pte_block_desc: Splitting existing PTE 0x40834020(L2)
set_pte_table_desc:
set_pte_table_desc: 0x40834020: [Table] 0x40837000
init_xlat_tables: mmap: virt 0x4082a000 phys 0x4082a000 size 0x6000
init_xlat_tables: mmap: virt 0x40830000 phys 0x40830000 size 0x13000
init_xlat_tables: mmap: virt 0x40a00000 phys 0x40a00000 size 0x400000
enable_mmu_el1:
enable_mmu_el1: UP_MB
enable_mmu_el1: Enable the MMU and data cache</code></pre></div>
<p>Something sus about the above <a href="https://gist.github.com/lupyuen/544a5d8f3fab2ab7c9d06d2e1583f362"><strong>Mystery Addresses</strong></a>, what are they?</p>
<p>
<div><table><thead><tr><th style="text-align: center">Virtual</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><em>0x0700_0000</em></td><td style="text-align: center">0x0700_0000</td><td style="text-align: center"><em>0x2000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x4000_0000</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x40_1000_0000</em></td><td style="text-align: center">0x40_1000_0000</td><td style="text-align: center"><em>0x1000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x80_0000_0000</em></td><td style="text-align: center">0x80_0000_0000</td><td style="text-align: center"><em>0x80_0000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x3EFF_0000</em></td><td style="text-align: center">0x3EFF_0000</td><td style="text-align: center"><em>0x0001_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x4080_0000</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: center"><em>0x4082_A000</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: center"><em>0x4083_0000</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: center"><em>0x40A0_0000</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<h1 id="fix-the-nuttx-memory-map"><a class="doc-anchor" href="#fix-the-nuttx-memory-map">¬ß</a>10 Fix the NuttX Memory Map</h1>
<p><em>Arm64 MMU won‚Äôt turn on. Maybe our Memory Map is incorrect?</em></p>
<p>Let‚Äôs verify our <strong>Memory Map</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 42</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Module</strong></td><td style="text-align: left"><strong>Address</strong></td></tr>
<tr><td style="text-align: left">Boot ROM &amp; SRAM</td><td style="text-align: left"><em>0x0000_0000</em> to ‚Ä¶</td></tr>
<tr><td style="text-align: left">PCIE</td><td style="text-align: left"><em>0x2000_0000</em> to <em>0x2FFF_FFFF</em></td></tr>
<tr><td style="text-align: left">DRAM</td><td style="text-align: left"><em>0x4000_0000</em> to ‚Ä¶</td></tr>
</tbody></table>
</div></div>
</p>
<p>How does this compare with NuttX? We do extra logging for <strong>Memory Management Unit (MMU)</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/9488ecb5d8eb199bdbe16adabef483cf9cf04843">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Log the Names of the Memory Regions
static void init_xlat_tables(const struct arm_mmu_region *region) { ...
  _info(&quot;name=%s\n&quot;, region-&gt;name);
  sinfo(&quot;mmap: virt %p phys %p size %p\n&quot;, virt, phys, size);</code></pre></div>
<p>Ah much clearer! Now we see the <strong>Names of Memory Regions</strong>‚Ä¶</p>
<p>
<div><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>DEVICE_REGION</em></td><td style="text-align: center">0x0700_0000</td><td style="text-align: center"><em>0x2000_0000</em></td></tr>
<tr><td style="text-align: left"><em>DRAM0_S0</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_CFG</em></td><td style="text-align: center">0x40_1000_0000</td><td style="text-align: center"><em>0x1000_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_MEM</em></td><td style="text-align: center">0x80_0000_0000</td><td style="text-align: center"><em>0x80_0000_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_IO</em></td><td style="text-align: center">0x3EFF_0000</td><td style="text-align: center"><em>0x0001_0000</em></td></tr>
<tr><td style="text-align: left"><em>nx_code</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: left"><em>nx_rodata</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: left"><em>nx_data</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: left"><em>nx_pgpool</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p>Two Tweaks‚Ä¶</p>
<ul>
<li>
<p><strong>DEVICE_REGION</strong>: This says I/O Memory Space ends at <em>0x2700_0000</em>. Based on the earlier <strong>A527 Memory Map</strong>, we extend this to <em>0x4000_0000 (1 GB)</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45">qemu/chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fix the I/O Memory Space: Base Address and Size
#define CONFIG_DEVICEIO_BASEADDR 0x00000000
#define CONFIG_DEVICEIO_SIZE     MB(1024)

// We don&#39;t need PCI, for now
// #define CONFIG_PCI_CFG_BASEADDR 0x4010000000
// #define CONFIG_PCI_CFG_SIZE     MB(256)
// #define CONFIG_PCI_MEM_BASEADDR 0x8000000000
// #define CONFIG_PCI_MEM_SIZE     GB(512)
// #define CONFIG_PCI_IO_BASEADDR  0x3eff0000
// #define CONFIG_PCI_IO_SIZE      KB(64)</code></pre></div></li>
<li>
<p><strong>PCI</strong>: Let‚Äôs remove these for now: <a href="https://github.com/lupyuen2/wip-nuttx/commit/ca273d05e015089a33072997738bf588b899f8e7">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct arm_mmu_region g_mmu_regions[] = {
  ...
  // We don&#39;t need PCI, for now
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_CFG&quot;, ...
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_MEM&quot;, ...
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_IO&quot;, ...</code></pre></div></li>
</ul>
<p>The rest are hunky dory‚Ä¶</p>
<ul>
<li>
<p>TODO <strong>DRAM0_S0</strong> says that RAM Address Space ends at <em>0x4800_0000 (128 MB)</em>. Which is kinda small, let‚Äôs embiggen.</p>
</li>
<li>
<p><strong>nx_code</strong> <em>(0x4080_0000)</em>: Kernel Code begins here</p>
</li>
<li>
<p><strong>nx_rodata</strong> <em>(0x4082_A000)</em>: Read-Only Data for Kernel</p>
</li>
<li>
<p><strong>nx_data</strong> <em>(0x4083_0000)</em>: Read-Write Data for Kernel</p>
</li>
<li>
<p><strong>nx_pgpool</strong> <em>(0x40A0_0000)</em>: Remember the <strong>Paged Memory Pool</strong>? This will be dished out as <strong>Virtual Memory</strong> to NuttX Apps</p>
</li>
</ul>
<p>Rebuild, recopy, reboot NuttX. Our Memory Map looks <a href="https://gist.github.com/lupyuen/ad4cec0dee8a21f3f404144be180fa14"><strong>much better now</strong></a>‚Ä¶</p>
<p>
<div><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>DEVICE_REGION</em></td><td style="text-align: center">0x0000_0000</td><td style="text-align: center"><em>0x4000_0000</em></td></tr>
<tr><td style="text-align: left"><em>DRAM0_S0</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: left"><em>nx_code</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: left"><em>nx_rodata</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: left"><em>nx_data</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: left"><em>nx_pgpool</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p>Though it crashes elsewhere‚Ä¶</p>
<h1 id="arm64-global-interrupt-controller"><a class="doc-anchor" href="#arm64-global-interrupt-controller">¬ß</a>11 Arm64 Global Interrupt Controller</h1>
<p><em>Why is NuttX failing with an Undefined Instruction?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>gic_validate_dist_version: No GIC version detect
arm64_gic_initialize: no distributor detected, giving up ret=-19
...
nx_start_application: Starting init task: /system/bin/init
arm64_el1_undef: Undefined instruction at 0x408276e4, dump:
Assertion failed panic: at file: common/arm64_fatal.c:572</code></pre></div>
<p>Yeah this failure is <a href="https://gist.github.com/lupyuen/3a7d1e791ac14905532db2d768ae230f"><strong>totally misleading</strong></a>. Real Culprit: NuttX couldn‚Äôt <strong>Init the GIC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>No GIC version detect
No distributor detected, giving up</code></pre></div>
<p><em>What‚Äôs this GIC?</em></p>
<p>It‚Äôs the Arm64 <a href="TODO"><strong>Generic Interrupt Controller (GIC)</strong></a>, version 3. GIC will‚Ä¶</p>
<ul>
<li>
<p>Receive <strong>I/O Interrupts</strong></p>
<p><em>(Like keypresses)</em></p>
</li>
<li>
<p>And forward them to an <strong>Arm64 CPU Core</strong> for processing</p>
<p><em>(Works like RISC-V PLIC)</em></p>
</li>
</ul>
<p>GIC is here‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">GIC</td><td style="text-align: left"><em>0x0340_0000</em></td></tr>
</tbody></table>
</div>
<p>With these <strong>GIC Registers</strong>, handling 8 Arm64 Cores‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x00_0000</em></td><td style="text-align: left">GICD_CTLR  <em>(Distributor Control Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x06_0000</em></td><td style="text-align: left">GICR_CTLR_C0  <em>(Redistributor Control Register, Core 0)</em></td></tr>
<tr><td style="text-align: center"><em>0x08_0000</em></td><td style="text-align: left">GICR_CTLR_C1  <em>(Ditto, Core 1)</em></td></tr>
<tr><td style="text-align: center"><em>0x0A_0000</em></td><td style="text-align: left">GICR_CTLR_C2  <em>(Ditto, Core 2)</em></td></tr>
<tr><td style="text-align: center"><em>0x0C_0000</em></td><td style="text-align: left">GICR_CTLR_C3  <em>(Ditto, Core 3)</em></td></tr>
<tr><td style="text-align: center"><em>0x0E_0000</em></td><td style="text-align: left">GICR_CTLR_C4  <em>(Ditto, Core 4)</em></td></tr>
<tr><td style="text-align: center"><em>0x10_0000</em></td><td style="text-align: left">GICR_CTLR_C5  <em>(Ditto, Core 5)</em></td></tr>
<tr><td style="text-align: center"><em>0x12_0000</em></td><td style="text-align: left">GICR_CTLR_C6  <em>(Ditto, Core 6)</em></td></tr>
<tr><td style="text-align: center"><em>0x14_0000</em></td><td style="text-align: left">GICR_CTLR_C7  <em>(Ditto, Core 7)</em></td></tr>
<tr><td style="text-align: center"><em>0x16_0000</em></td><td style="text-align: left">GICDA_CTLR  <em>(Ditto, Core 1)</em></td></tr>
</tbody></table>
</div>
<p>Based on the above, we set the <strong>Addresses of GICD and GICR</strong> <em>(Distributor / Redistributor)</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/f3a26dbba69a0714bc91d0c345b8fba5e0835b76">qemu/chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address of GIC Distributor and Redistributor
#define CONFIG_GICD_BASE   0x3400000
#define CONFIG_GICR_BASE   0x3460000

// Spaced 0x20000 bytes per Arm64 Core
#define CONFIG_GICR_OFFSET 0x20000</code></pre></div>
<p>Remember to <a href="https://github.com/lupyuen2/wip-nuttx/commit/10c7173b142f4a0480d742688c72499b76f66f83"><strong>Disable Memory Manager Logging</strong></a>. NuttX GIC Driver <a href="https://gist.github.com/lupyuen/3c587ac0f32be155c8f9a9e4ca18676c"><strong>complains no more</strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>## SPI = Physical Interrupt Signal (not the typical SPI)
gic_validate_dist_version:
  GICv3 version detect
  GICD_TYPER = 0x7b0408
  256 SPIs implemented</code></pre></div><h1 id="nuttx-apps-filesystem"><a class="doc-anchor" href="#nuttx-apps-filesystem">¬ß</a>12 NuttX Apps Filesystem</h1>
<p><em>Are we done yet?</em></p>
<p>If we‚Äôre doing a <strong>Simple NuttX Port</strong> <em>(Flat Build)</em>: Congrats just fix the <a href="TODO"><strong>UART Interrupt</strong></a> and we‚Äôre done!</p>
<p>However we‚Äôre doing <strong>NuttX Kernel Build</strong>. Which <a href="https://gist.github.com/lupyuen/3c587ac0f32be155c8f9a9e4ca18676c"><strong>needs more work</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nx_start_application:
  Starting init task: /system/bin/init
arm64_el1_undef:
  Undefined instruction at 0x408274a4
Assertion failed panic:
  common/arm64_fatal.c:572</code></pre></div>
<p><em>What‚Äôs /system/bin/init? Why is it failing?</em></p>
<p><em>/system/bin/init</em> is <strong>NSH Shell</strong>. That‚Äôs how NuttX Kernel Build works: It loads NuttX Apps from a <strong>Local Filesystem</strong>. <em>(Instead of binding Apps into Kernel)</em></p>
<p>We bundle the NuttX Apps together into a <strong>ROM FS Filesystem</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p>Then we package NuttX Kernel + NuttX Apps into a <strong>NuttX Image</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p><a href="TODO">(See the <strong>Build Script</strong>)</a></p>
<p>When NuttX Boots: It will find the ROM FS Filesystem, and Mount it as a <strong>RAM Disk</strong>. Which will allow NuttX Kernel to start <strong>NSH Shell</strong> and other NuttX Apps. Everything is explained here‚Ä¶</p>
<ul>
<li>TODO: Appendix</li>
</ul>
<p>NSH Prompt still missing? It won‚Äôt appear until we fix the UART Interrupt‚Ä¶</p>
<h1 id="fix-the-uart-interrupt"><a class="doc-anchor" href="#fix-the-uart-interrupt">¬ß</a>13 Fix the UART Interrupt</h1>
<p>One Last Thing: Fix the <strong>UART Interrupt</strong> and we‚Äôre done!</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: center">Page 256</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Interrupt Number</strong></td><td style="text-align: center"><strong>Interrupt Source</strong></td></tr>
<tr><td style="text-align: center">34</td><td style="text-align: center">UART0</td></tr>
</tbody></table>
</div></div>
</p>
<p>This is how we set the <strong>UART0 Interrupt</strong> and watch for keypresses: <a href="https://github.com/lupyuen2/wip-nuttx/commit/cd6da8f5378eb493528e57c61f887b6585ab8eaf#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the UART0 Interrupt to 34
CONFIG_16550_UART0_IRQ=34</code></pre></div>
<p>To Wrap Up: We Disable Logging for <a href="https://github.com/lupyuen2/wip-nuttx/commit/6c5c1a5f9fb1c939d8e75a5e9544b1a5261165ee"><strong>Memory Manager and Scheduler</strong></a>. And <a href="https://github.com/lupyuen2/wip-nuttx/commit/e5c1b0449d3764d63d447eb96eb7186a27f77c88"><strong>Disable MMU Debugging</strong></a>.</p>
<p><strong>NSH Prompt</strong> finally appears. And <strong>OSTest completes successfully</strong> yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c2248e7537ca98333d47e33b232217b6">(See the <strong>Complete Log</strong>)</a></p>
<p><em>Very odd. NSH Prompt won‚Äôt appear if UART Interrupt is disabled?</em></p>
<p>That‚Äôs because NSH runs as a <strong>NuttX App in User Space</strong>. When NSH Shell prints this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt;</code></pre></div>
<p>It calls the <strong>Serial Driver</strong>. Which will wait for a <strong>UART Interrupt</strong> to signal that the Transmit Buffer is empty and available. Thus if UART Interrupt is disabled, nothing gets printed in NuttX Apps. <a href="TODO">(Explained here)</a></p>
<h1 id="todo"><a class="doc-anchor" href="#todo">¬ß</a>14 TODO</h1>
<p><img src="https://lupyuen.org/images/testbot2-flow3.jpg" alt="Apache NuttX RTOS for Avaota-A1 SBC (Allwinner A527 SoC)" /></p>
<p><em>How about booting and testing NuttX on Avaota-A1 SBC?</em></p>
<p>Exactly! Here‚Äôs why Avaota-A1 SBC should run NuttX‚Ä¶</p>
<ul>
<li>
<p><strong>Avaota-A1</strong> has the latest Octa-Core Arm64 SoC: <strong>Allwinner A527</strong></p>
<p><em>(Bonus: There‚Äôs a tiny RISC-V Core inside)</em></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode"><strong>NuttX Kernel Build</strong></a> sounds ideal for Allwinner A527 SoC</p>
<p><em>(Instead of the restrictive Flat Build)</em></p>
</li>
<li>
<p><strong>Avaota-A1</strong> could be the first Arm64 Port of NuttX Kernel Build</p>
<p><a href="https://github.com/apache/nuttx/pull/15556"><em>(NXP i.MX93 might be another)</em></a></p>
</li>
<li>
<p><strong>SDWire MicroSD Multiplexer</strong>: Avaota SBC was previously the <strong>Test Server</strong>, now it becomes the <strong>Test Device</strong></p>
<p><em>(Porting NuttX gets a lot quicker)</em></p>
</li>
<li>
<p><strong>Open-Source RTOS</strong> <em>(NuttX)</em> tested on <strong>Open-Source Hardware</strong> <em>(Avaota-A1)</em> ‚Ä¶ Perfectly sensible!</p>
</li>
</ul>
<p>We‚Äôll take the NuttX Kernel Build for <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/knsh/defconfig"><strong>QEMU Arm64</strong></a>, boot it on Avaota-A1 SBC. We‚Äôre making terrific progress with <strong>NuttX on Avaota SBC</strong>‚Ä¶</p>
<p><img src="https://lupyuen.org/images/testbot3-port.png" alt="NuttX on Avaota-A1" /></p>
<p><em>Isn‚Äôt it faster to port NuttX with U-Boot TFTP?</em></p>
<p>Yeah for RISC-V Ports we boot <a href="https://lupyuen.github.io/articles/starpro64#boot-nuttx-over-tftp"><strong>NuttX over TFTP</strong></a>. But Avaota U-Boot <a href="https://gist.github.com/lupyuen/366f1ffefc8231670ffd58a3b88ae8e5"><strong>doesn‚Äôt support TFTP</strong></a>, so it‚Äôs back to MicroSD sigh. (Pic below)</p>
<h1 id="boot-nuttx-for-avaota-a1"><a class="doc-anchor" href="#boot-nuttx-for-avaota-a1">¬ß</a>15 Boot NuttX for Avaota-A1</h1>
<p><a href="https://youtu.be/PxaMcmMAzlM">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p>NuttX boots to NSH Shell. And passes OSTest yay!</p>
<p>Here‚Äôs the latest NuttX Boot Log:</p>
<ul>
<li>https://gist.github.com/lupyuen/c2248e7537ca98333d47e33b232217b6</li>
</ul>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-text"><code>[    0.000255][I]  _____     _           _____ _ _
[    0.006320][I] |   __|_ _| |_ ___ ___|  |  |_| |_
[    0.012456][I] |__   | | |  _| -_|  _|    -| | _|
[    0.018566][I] |_____|_  |_| |___|_| |__|__|_|_|
[    0.024719][I]       |___|
[    0.030820][I] ***********************************
[    0.036948][I]  SyterKit v0.4.0 Commit: e4c0651
[    0.042781][I]  github.com/YuzukiHD/SyterKit
[    0.048882][I] ***********************************
[    0.054992][I]  Built by: arm-none-eabi-gcc 13.2.1
[    0.061119][I]
[    0.063943][I] Model: AvaotaSBC Avaota A1 board.
[    0.069856][I] Core: Arm Octa-Core Cortex-A55 v65 r2p0
[    0.076356][I] Chip SID = 0300ff1071c048247590d120506d1ed4
[    0.083280][I] Chip type = A527M000000H Chip Version = 2
[    0.091391][I] PMU: Found AXP717 PMU, Addr 0x35
[    0.098200][I] PMU: Found AXP323 PMU
[    0.112870][I] DRAM BOOT DRIVE INFO: V0.6581
[    0.118326][I] Set DRAM Voltage to 1160mv
[    0.123524][I] DRAM_VCC set to 1160 mv
[    0.247920][I] DRAM retraining ten
[    0.266135][I] [AUTO DEBUG]32bit,2 ranks training success!
[    0.296290][I] Soft Training Version: T2.0
[    1.819657][I] [SOFT TRAINING] CLK=1200M Stable memtest pass
[    1.826565][I] DRAM CLK =1200 MHZ
[    1.830992][I] DRAM Type =8 (3:DDR3,4:DDR4,6:LPDDR2,7:LPDDR3,8:LPDDR4)
[    1.843100][I] DRAM SIZE =4096 MBytes, para1 = 310a, para2 = 10001000, tpr13 = 6061
[    1.853431][I] DRAM simple test OK.
[    1.858011][I] Init DRAM Done, DRAM Size = 4096M
[    2.278300][I] SMHC: sdhci0 controller initialized
[    2.305826][I]   Capacity: 59.48GB
[    2.310439][I] SHMC: SD card detected
[    2.319537][I] FATFS: read bl31.bin addr=48000000
[    2.339744][I] FATFS: read in 13ms at 5.92MB/S
[    2.345498][I] FATFS: read scp.bin addr=48100000
[    2.374729][I] FATFS: read in 22ms at 8.00MB/S
[    2.380481][I] FATFS: read extlinux/extlinux.conf addr=40020000
[    2.389436][I] FATFS: read in 1ms at 0.29MB/S
[    2.395095][I] FATFS: read splash.bin addr=40080000
[    2.403142][I] FATFS: read in 1ms at 12.66MB/S
[    3.193943][I] FATFS: read /Image addr=40800000
[    3.341455][I] FATFS: read in 143ms at 8.86MB/S
[    3.347308][I] FATFS: read /dtb/allwinner/sun55i-t527-avaota-a1.dtb addr=40400000
[    3.400140][I] FATFS: read in 19ms at 7.46MB/S
[    3.405891][I] FATFS: read /uInitrd addr=43000000
[    4.113508][I] FATFS: read in 702ms at 9.04MB/S
[    4.119356][I] Initrd load 0x43000000, Size 0x00632414
[    5.376346][W] FDT: bootargs is null, using extlinux.conf append.
[    5.688989][I] EXTLINUX: load extlinux done, now booting...
[    5.695984][I] ATF: Kernel addr: 0x40800000
[    5.701523][I] ATF: Kernel DTB addr: 0x40400000
[    5.891085][I] disable mmu ok...
[    5.895615][I] disable dcache ok...
[    5.900478][I] disable icache ok...
[    5.905342][I] free interrupt ok...
NOTICE:  BL31: v2.5(debug):9241004a9
NOTICE:  BL31: Built : 13:37:46, Nov 16 2023
NOTICE:  BL31: No DTB found.
NOTICE:  [SCP] :wait arisc ready....
NOTICE:  [SCP] :arisc version: []
NOTICE:  [SCP] :arisc startup ready
NOTICE:  [SCP] :arisc startup notify message feedback
NOTICE:  [SCP] :sunxi-arisc driver is starting
ERROR:   Error initializing runtime service opteed_fast
123- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
ABarm64_mmu_init:
setup_page_tables:
enable_mmu_el1:
enable_mmu_el1: UP_MB
enable_mmu_el1: Enable the MMU and data cache
up_allocate_kheap: CONFIG_RAM_END=0x48000000, g_idle_topstack=0x40847000
qemu_bringup:
mount_ramdisk:
nx_start_application: ret=0
board_app_initialize:

NuttShell (NSH) NuttX-12.4.0
nsh&gt; uname -a
NuttX 12.4.0 6c5c1a5f9f-dirty Mar  8 2025 21:57:02 arm64 qemu-armv8a
nsh&gt; free
      total       used       free    maxused    maxfree  nused  nfree name
  125538304      33848  125504456      52992  125484976     58      5 Kmem
    4194304     245760    3948544               3948544               Page
nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK            STACK    USED FILLED COMMAND
    0     0   0 FIFO     Kthread   - Ready              0000000000000000 0008176 0000928  11.3%  Idle_Task
    1     0 192 RR       Kthread   - Waiting  Semaphore 0000000000000000 0008112 0000992  12.2%  hpwork 0x40834568 0x408345b8
    2     0 100 RR       Kthread   - Waiting  Semaphore 0000000000000000 0008112 0000992  12.2%  lpwork 0x408344e8 0x40834538
    4     4 100 RR       Task      - Running            0000000000000000 0008128 0002192  26.9%  /system/bin/init
nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-           0 console
 crw-rw-rw-           0 null
 brw-rw-rw-    16777216 ram0
 crw-rw-rw-           0 ttyS0
 crw-rw-rw-           0 zero
nsh&gt; hello
Hello, World!!
nsh&gt; getprime
Set thread priority to 10
Set thread policy to SCHED_RR
Start thread #0
thread #0 started, looking for primes &lt; 10000, doing 10 run(s)
thread #0 finished, found 1230 primes, last one was 9973
Done
getprime took 162 msec
nsh&gt; hello
Hello, World!!
nsh&gt; getprime
Set thread priority to 10
Set thread policy to SCHED_RR
Start thread #0
thread #0 started, looking for primes &lt; 10000, doing 10 run(s)
thread #0 finished, found 1230 primes, last one was 9973
Done
getprime took 162 msec
nsh&gt; ostest
...
Final memory usage:
VARIABLE  BEFORE   AFTER
======== ======== ========
arena        a000    26000
ordblks         2        4
mxordblk     6ff8    1aff8
uordblks     27e8     6700
fordblks     7818    1f900
user_main: Exiting
ostest_main: Exiting with status 0
nsh&gt;</code></pre></div></span>
<p>How did we get here? Let‚Äôs walk through the steps‚Ä¶</p>
<h1 id="allwinner-a527-docs"><a class="doc-anchor" href="#allwinner-a527-docs">¬ß</a>16 Allwinner A527 Docs</h1>
<p>We used these docs (A527 is a variant of A523)</p>
<ul>
<li>https://linux-sunxi.org/A523</li>
<li>https://linux-sunxi.org/File:A527_Datasheet_V0.93.pdf</li>
<li>https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf</li>
</ul>
<h1 id="work-in-progress"><a class="doc-anchor" href="#work-in-progress">¬ß</a>17 Work In Progress</h1>
<p>We take NuttX for Arm64 QEMU knsh (Kernel Build) and tweak it iteratively for Avaota-A1 SBC, based on Allwinner A527 SoC‚Ä¶</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>18 What‚Äôs Next</h1>
<p>TODO</p>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-starpro64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for StarPro64 EIC7700X‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Other Project: ‚ÄúNuttX for Oz64 SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>Older Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/avaota.md"><strong>lupyuen.org/src/avaota.md</strong></a></p>
<h1 id="appendix-nuttx-apps-filesystem"><a class="doc-anchor" href="#appendix-nuttx-apps-filesystem">¬ß</a>19 Appendix: NuttX Apps Filesystem</h1>
<p>https://github.com/lupyuen2/wip-nuttx/pull/97/files</p>
<p>arch/arm64/src/qemu/qemu_boot.c</p>
<p>https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-be208bc5be54608eca3885cf169183ede375400c559700bb423c81d7b2787431</p>
<div class="example-wrap"><pre class="language-c"><code>extern uint8_t __ramdisk_start[];
extern uint8_t __ramdisk_size[];

/****************************************************************************
 * Name: qemu_copy_overlap
 *
 * Description:
 *   Copy an overlapping memory region.  dest overlaps with src + count.
 *
 * Input Parameters:
 *   dest  - Destination address
 *   src   - Source address
 *   count - Number of bytes to copy
 *
 ****************************************************************************/

static void qemu_copy_overlap(uint8_t *dest, const uint8_t *src,
                              size_t count)
{
  uint8_t *d = dest + count - 1;
  const uint8_t *s = src + count - 1;

  if (dest &lt;= src)
    {
      _err(&quot;dest and src should overlap&quot;);
      PANIC();
    }

  while (count--)
    {
      volatile uint8_t c = *s;  /* Prevent compiler optimization */
      *d = c;
      d--;
      s--;
    }
} 

/****************************************************************************
 * Name: qemu_copy_ramdisk
 *
 * Description:
 *   Copy the RAM Disk from NuttX Image to RAM Disk Region.
 *
 ****************************************************************************/

static void qemu_copy_ramdisk(void)
{
  char header[8] __attribute__((aligned(8))) = &quot;-rom1fs-&quot;;
  const uint8_t *limit = (uint8_t *)g_idle_topstack + (256 * 1024);
  uint8_t *ramdisk_addr = NULL;
  uint8_t *addr;
  uint32_t size;

  /* After _edata, search for &quot;-rom1fs-&quot;. This is the RAM Disk Address.
   * Limit search to 256 KB after Idle Stack Top.
   */

  binfo(&quot;_edata=%p, _sbss=%p, _ebss=%p, idlestack_top=%p\n&quot;,
        (void *)_edata, (void *)_sbss, (void *)_ebss,
        (void *)g_idle_topstack);
  for (addr = g_idle_topstack; addr &lt; limit; addr += 8)
    {
      if (addr == _edata) { _info(&quot;addr=%p, header=%p, sizeof(header)=%d\n&quot;, addr, header, sizeof(header)); } ////
      if (memcmp(addr, header, sizeof(header)) == 0)
        {
          ramdisk_addr = addr;
          break;
        }
    }

  /* Stop if RAM Disk is missing */

  binfo(&quot;ramdisk_addr=%p\n&quot;, ramdisk_addr);
  if (ramdisk_addr == NULL)
    {
      _err(&quot;Missing RAM Disk. Check the initrd padding.&quot;);
      PANIC();
    }

  /* RAM Disk must be after Idle Stack, to prevent overwriting */

  // if (ramdisk_addr &lt;= (uint8_t *)g_idle_topstack)
  //   {
  //     const size_t pad = (size_t)g_idle_topstack - (size_t)ramdisk_addr;
  //     _err(&quot;RAM Disk must be after Idle Stack. Increase initrd padding &quot;
  //           &quot;by %d bytes.&quot;, pad);
  //     PANIC();
  //   }

  /* Read the Filesystem Size from the next 4 bytes (Big Endian) */

  size = (ramdisk_addr[8] &lt;&lt; 24) + (ramdisk_addr[9] &lt;&lt; 16) +
         (ramdisk_addr[10] &lt;&lt; 8) + ramdisk_addr[11] + 0x1f0;
  binfo(&quot;size=%d\n&quot;, size);

  /* Filesystem Size must be less than RAM Disk Memory Region */

  if (size &gt; (size_t)__ramdisk_size)
    {
      _err(&quot;RAM Disk Region too small. Increase by %ul bytes.\n&quot;,
            size - (size_t)__ramdisk_size);
      PANIC();
    }

  /* Copy the RAM Disk from NuttX Image to RAM Disk Region.
   * __ramdisk_start overlaps with ramdisk_addr + size.
   */

  qemu_copy_overlap(__ramdisk_start, ramdisk_addr, size);
}

void arm64_chip_boot(void)
{
  /* Copy the RAM Disk */

  qemu_copy_ramdisk();
  /* MAP IO and DRAM, enable MMU. */

  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;; ////
  arm64_mmu_init(true);</code></pre></div>
<p>boards/arm64/qemu/qemu-armv8a/configs/knsh/defconfig</p>
<p>https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64</p>
<div class="example-wrap"><pre class="language-bash"><code>## CONFIG_FS_HOSTFS=y
## CONFIG_ARM64_SEMIHOSTING_HOSTFS=y
## CONFIG_ARM64_SEMIHOSTING_HOSTFS_CACHE_COHERENCE=y

## CONFIG_INIT_MOUNT_DATA=&quot;fs=../apps&quot;
## CONFIG_INIT_MOUNT_FSTYPE=&quot;hostfs&quot;
## CONFIG_INIT_MOUNT_SOURCE=&quot;&quot;
## CONFIG_INIT_MOUNT_TARGET=&quot;/system&quot;


CONFIG_BOARDCTL_ROMDISK=y
CONFIG_BOARD_LATE_INITIALIZE=y
CONFIG_INIT_MOUNT_TARGET=&quot;/system/bin&quot;</code></pre></div>
<p>boards/arm64/qemu/qemu-armv8a/scripts/ld-kernel.script</p>
<p>https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-f0706cd747d2f1be1eeb64d50821afb1e25d5bb26e964e2679268a83dcff0afc</p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY
{
  dram (rwx)    : ORIGIN = 0x40800000, LENGTH = 2M
  pgram (rwx)   : ORIGIN = 0x40A00000, LENGTH = 4M    /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x40E00000, LENGTH = 16M   /* w/ cache */
}

/* Application ramdisk */

__ramdisk_start = ORIGIN(ramdisk);
__ramdisk_size  = LENGTH(ramdisk);
__ramdisk_end   = ORIGIN(ramdisk) + LENGTH(ramdisk);</code></pre></div>
<p>boards/arm64/qemu/qemu-armv8a/src/qemu_bringup.c</p>
<p>https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-f8d388b76b0b37563184a5a174f18970ff6771d6a048e0e792967ab265d6f7eb</p>
<div class="example-wrap"><pre class="language-c"><code>/* RAM Disk Definition */

#define SECTORSIZE   512
#define NSECTORS(b)  (((b) + SECTORSIZE - 1) / SECTORSIZE)
#define RAMDISK_DEVICE_MINOR 0

/****************************************************************************
 * Name: mount_ramdisk
 *
 * Description:
 *  Mount a RAM Disk defined in ld.script to /dev/ramX.  The RAM Disk
 *  contains a ROMFS filesystem with applications that can be spawned at
 *  runtime.
 *
 * Returned Value:
 *   OK is returned on success.
 *   -ERRORNO is returned on failure.
 *
 ****************************************************************************/

static int mount_ramdisk(void)
{
  _info(&quot;\n&quot;); ////
  int ret;
  struct boardioc_romdisk_s desc;

  desc.minor    = RAMDISK_DEVICE_MINOR;
  desc.nsectors = NSECTORS((ssize_t)__ramdisk_size);
  desc.sectsize = SECTORSIZE;
  desc.image    = __ramdisk_start;

  ret = boardctl(BOARDIOC_ROMDISK, (uintptr_t)&amp;desc);
  if (ret &lt; 0)
    {
      syslog(LOG_ERR, &quot;Ramdisk register failed: %s\n&quot;, strerror(errno));
      syslog(LOG_ERR, &quot;Ramdisk mountpoint /dev/ram%d\n&quot;,
             RAMDISK_DEVICE_MINOR);
      syslog(LOG_ERR, &quot;Ramdisk length %lu, origin %lx\n&quot;,
             (ssize_t)__ramdisk_size, (uintptr_t)__ramdisk_start);
    }

  return ret;
}

int qemu_bringup(void)
{
  /* Mount the RAM Disk */

  mount_ramdisk();</code></pre></div>
<p>Remove HostFS for Semihosting</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/40c4ab530dad2b7db0f354a2fa4b5e0f5263fb4e</li>
</ul>
<p>OK the Initial Filesystem is no longer available:</p>
<ul>
<li>https://gist.github.com/lupyuen/e74c29049f20c76a2c4fe6f863d55507</li>
</ul>
<p>Add the Initial RAM Disk</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/cf5fe66b97f4526fb8dfc993415ac04ce96f4c13</li>
</ul>
<p>Enable Logging for RAM Disk</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/60007f1b97b6af4445c793904c30d65ebbebb337</li>
</ul>
<p><code>default_fatal_handler: (IFSC/DFSC) for Data/Instruction aborts: alignment fault</code></p>
<ul>
<li>https://gist.github.com/lupyuen/f10af7903461f44689203d0e02fb9949</li>
</ul>
<p>Our RAM Disk Copier is accessing misligned addresses. Let‚Äôs fix the alignment‚Ä¶</p>
<p>Align RAM Disk Address to 8 bytes. Search from Idle Stack Top instead of EDATA.</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/07d9c387a7cb06ccec53e20eecd0c4bb9bad7109</li>
</ul>
<p>Log the Mount Error</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/38538f99333868f85b67e2cb22958fe496e285d6</li>
</ul>
<p>Mounting of ROMFS fails</p>
<ul>
<li>https://gist.github.com/lupyuen/d12e44f653d5c5597ecae6845e49e738</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>nx_start_application: ret=-15
dump_assert_info: Assertion failed : at file: init/nx_bringup.c:361</code></pre></div>
<p>Which is‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define ENOTBLK             15
#define ENOTBLK_STR         &quot;Block device required&quot;</code></pre></div>
<p>Why is /dev/ram0 not a Block Device?</p>
<div class="example-wrap"><pre class="language-c"><code>$ grep INIT .config
# CONFIG_BOARDCTL_FINALINIT is not set
# CONFIG_INIT_NONE is not set
CONFIG_INIT_FILE=y
CONFIG_INIT_ARGS=&quot;&quot;
CONFIG_INIT_STACKSIZE=8192
CONFIG_INIT_PRIORITY=100
CONFIG_INIT_FILEPATH=&quot;/system/bin/init&quot;
CONFIG_INIT_MOUNT=y
CONFIG_INIT_MOUNT_SOURCE=&quot;/dev/ram0&quot;
CONFIG_INIT_MOUNT_TARGET=&quot;/system/bin&quot;
CONFIG_INIT_MOUNT_FSTYPE=&quot;romfs&quot;
CONFIG_INIT_MOUNT_FLAGS=0x1
CONFIG_INIT_MOUNT_DATA=&quot;&quot;</code></pre></div>
<p>We check the logs‚Ä¶</p>
<p>Enable Filesystem Logging</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/cc4dffd60fd223a7c1f6b513dc99e1fa98a48496</li>
</ul>
<p><code>Failed to find /dev/ram0</code></p>
<ul>
<li>https://gist.github.com/lupyuen/805c2be2a3333a90c96926a26ec2d8cc</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>find_blockdriver: pathname=&quot;/dev/ram0&quot;
find_blockdriver: ERROR: Failed to find /dev/ram0
nx_mount: ERROR: Failed to find block driver /dev/ram0
nx_start_application: ret=-15</code></pre></div>
<p>Is /dev/ram0 created? Ah we forgot to Mount the RAM Disk!</p>
<h1 id="appendix-mount-the-ram-disk"><a class="doc-anchor" href="#appendix-mount-the-ram-disk">¬ß</a>20 Appendix: Mount the RAM Disk</h1>
<p>Let‚Äôs mount the RAM Disk‚Ä¶</p>
<p>Mount the RAM Disk</p>
<ul>
<li>https://github.com/lupyuen2/wip-nuttx/commit/65ae74507e95189e96816161b0c1a820722ca8a2</li>
</ul>
<p>/system/bin/init starts successfully yay!</p>
<ul>
<li>https://gist.github.com/lupyuen/ccb645efa72f6793743c033fade0b3ac</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>qemu_bringup:
mount_ramdisk:
nx_start_application: ret=0
nx_start_application: Starting init task: /system/bin/init
nxtask_activate: /system/bin/init pid=4,TCB=0x408469f0
nxtask_exit: AppBringUp pid=3,TCB=0x40846190
board_app_initialize:
nx_start: CPU0: Beginning Idle Loop</code></pre></div>
    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>