<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: LVGL Terminal for NSH Shell</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: LVGL Terminal for NSH Shell" 
    data-rh="true">
<meta property="og:description" 
    content="Let's build a Terminal App for PinePhone... With LVGL and Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's build a Terminal App for PinePhone... With LVGL and Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/terminal-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: LVGL Terminal for NSH Shell</h1>
    <nav id="TOC"><ul>
<li><a href="#lvgl-terminal-for-nuttx">1 LVGL Terminal for NuttX</a><ul></ul></li>
<li><a href="#pipe-a-command-to-nsh-shell">2 Pipe a Command to NSH Shell</a><ul>
<li><a href="#create-the-pipes">2.1 Create the Pipes</a><ul></ul></li>
<li><a href="#connect-the-pipes">2.2 Connect the Pipes</a><ul></ul></li>
<li><a href="#create-the-task">2.3 Create the Task</a><ul></ul></li>
<li><a href="#test-the-pipes">2.4 Test the Pipes</a><ul></ul></li></ul></li>
<li><a href="#poll-for-nsh-output">3 Poll for NSH Output</a><ul></ul></li>
<li><a href="#timer-for-lvgl-terminal">4 Timer for LVGL Terminal</a><ul></ul></li>
<li><a href="#render-terminal-with-lvgl-widgets">5 Render Terminal with LVGL Widgets</a><ul></ul></li>
<li><a href="#set-terminal-font-to-monospace">6 Set Terminal Font to Monospace</a><ul></ul></li>
<li><a href="#handle-input-from-lvgl-keyboard">7 Handle Input from LVGL Keyboard</a><ul></ul></li>
<li><a href="#handle-output-from-nsh-shell">8 Handle Output from NSH Shell</a><ul></ul></li>
<li><a href="#lvgl-programming-in-zig">9 LVGL Programming in Zig</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>3 Feb 2023</em></p>
<p><img src="https://lupyuen.github.io/images/terminal-title.jpg" alt="LVGL Terminal App on PinePhone with Apache NuttX RTOS" /></p>
<p><a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) now boots on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> and runs <strong>Touchscreen Apps</strong>!</p>
<p>Today we‚Äôll look inside a Touchscreen App that will be useful for NuttX Developers‚Ä¶ Our <strong>Terminal App for NSH Shell</strong>. (Pic above)</p>
<p><a href="https://www.youtube.com/watch?v=WdiXaMK8cNw">(Watch the Demo on YouTube)</a></p>
<p><em>What‚Äôs NSH Shell?</em></p>
<p><a href="https://nuttx.apache.org/docs/latest/applications/nsh/index.html"><strong>NuttShell (NSH)</strong></a> is the Command-Line Interface for NuttX. (Works like a Linux Shell)</p>
<p>Previously we needed a special <a href="https://lupyuen.github.io/articles/lvgl2#appendix-boot-apache-nuttx-rtos-on-pinephone"><strong>Serial Cable</strong></a> to access NSH Shell on PinePhone‚Ä¶</p>
<p>Now we can run NSH Commands <strong>through the Touchscreen</strong>! (Pic above)</p>
<p>(Super helpful for testing new NuttX Features on PinePhone!)</p>
<p>Read on to find out how we‚Ä¶</p>
<ul>
<li>
<p><strong>Pipe a Command</strong> to NSH Shell</p>
</li>
<li>
<p>Poll for <strong>NSH Output</strong></p>
</li>
<li>
<p><strong>Render the Terminal</strong> with LVGL Widgets</p>
</li>
<li>
<p><strong>Handle Input</strong> from LVGL Keyboard</p>
</li>
<li>
<p><strong>Handle Output</strong> from NSH Shell</p>
</li>
</ul>
<p>And how we might simplify the LVGL coding with the <strong>Zig Programming Language</strong>.</p>
<p><em>What‚Äôs NuttX? Why run it on PinePhone?</em></p>
<p>If we‚Äôre new to NuttX, here‚Äôs a gentle intro‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/terminal-flow.jpg" alt="Flow of LVGL Terminal for PinePhone on Apache NuttX RTOS" /></p>
<h1 id="lvgl-terminal-for-nuttx"><a href="#lvgl-terminal-for-nuttx">1 LVGL Terminal for NuttX</a></h1>
<p>Before we dive in, let‚Äôs walk through the internals of our <strong>LVGL Terminal App for NuttX</strong> (pic above)‚Ä¶</p>
<ol>
<li>
<p>We start the <strong>NSH Shell</strong> as a NuttX Task</p>
<p>(Which will execute our NSH Commands)</p>
</li>
<li>
<p>An NSH Command is entered through the <strong>LVGL Keyboard Widget</strong></p>
<p>(Which goes to the <strong>Input Text Area Widget</strong>)</p>
<p>Let‚Äôs say we type this NSH Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ls
</code></pre></div></li>
<li>
<p>When the Enter Key is pressed, we send the NSH Command <strong><code>ls</code></strong> to the <strong>NSH Input Pipe</strong></p>
</li>
<li>
<p>Which delivers the NSH Command to the <strong>NSH Shell</strong></p>
</li>
<li>
<p>NSH Shell <strong>executes our NSH Command</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls
</code></pre></div></li>
<li>
<p>NSH Shell produces some Text Output, which is pushed to the <strong>NSH Output Pipe</strong></p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls
dev/
var/
</code></pre></div></li>
<li>
<p>We run an <strong>LVGL Timer</strong> that periodically polls the NSH Output Pipe for Text Output</p>
</li>
<li>
<p>When it detects the Text Output, the LVGL Timer reads the data‚Ä¶</p>
<p>And renders the output in the <strong>Output Text Area Widget</strong>.</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls
dev/
var/
</code></pre></div></li>
</ol>
<p>It looks like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-demo.jpg" alt="LVGL Terminal for PinePhone on Apache NuttX RTOS" /></p>
<p><em>Whoa that looks complicated!</em></p>
<p>Yeah. But we‚Äôll explain everything in this article‚Ä¶</p>
<ul>
<li>
<p>How we start a <strong>NuttX Task</strong></p>
</li>
<li>
<p>What are <strong>NuttX Pipes</strong> and how we use them</p>
</li>
<li>
<p>How we render <strong>LVGL Widgets</strong> and handle events</p>
</li>
</ul>
<p>And eventually we‚Äôll understand the Source Code‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c"><strong>github.com/lupyuen/lvglterm</strong></a></p>
<p><a href="https://github.com/lupyuen/lvglterm">(How to compile LVGL Terminal)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/releases/tag/nuttx-12.0.2">(Download the NuttX Image for PinePhone)</a></p>
</li>
</ul>
<p>We begin by starting the NSH Task and piping a command to NSH Shell‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow2.jpg" alt="Pipe a Command to NSH Shell" /></p>
<h1 id="pipe-a-command-to-nsh-shell"><a href="#pipe-a-command-to-nsh-shell">2 Pipe a Command to NSH Shell</a></h1>
<p>Our Terminal App needs to‚Ä¶</p>
<ul>
<li>
<p>Start the <strong>NuttX Task</strong> for NSH Shell</p>
<p>(Which will execute our NSH Commands)</p>
</li>
<li>
<p>Redirect the <strong>NSH Shell Input</strong></p>
<p>(To receive the NSH Commands that we typed)</p>
</li>
<li>
<p>Redirect the <strong>NSH Shell Output</strong></p>
<p>(To render the output of NSH Commands)</p>
</li>
</ul>
<p>We‚Äôll redirect the NSH Input and Output with <strong>NuttX Pipes</strong>.</p>
<p>(Which will work like Linux Pipes)</p>
<p>Let‚Äôs find out how‚Ä¶</p>
<h2 id="create-the-pipes"><a href="#create-the-pipes">2.1 Create the Pipes</a></h2>
<p><em>How will we create the NuttX Pipes?</em></p>
<p>This is how we <strong>create a NuttX Pipe</strong> for NSH Input: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L146-L178">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Create the NuttX Pipe for NSH Input
int nsh_stdin[2];
int ret = pipe(nsh_stdin);

// Check for error
if (ret &lt; 0) {
  _err(&quot;stdin pipe failed: %d\n&quot;, errno); return;
}
</code></pre></div>
<p>NSH Shell will receive NSH Commands through this Pipe.</p>
<p><em>Why two elements in nsh_stdin?</em></p>
<p>That‚Äôs because a NuttX Pipe has <strong>Two Endpoints</strong> (in and out)‚Ä¶</p>
<ul>
<li>
<p><strong><code>nsh_stdin[0]</code></strong> reads from the Pipe</p>
</li>
<li>
<p><strong><code>nsh_stdin[1]</code></strong> writes to the Pipe</p>
</li>
</ul>
<p>NuttX Pipes are <strong>Unidirectional</strong>‚Ä¶ Don‚Äôt mix up the endpoints!</p>
<p>To remind ourselves, we define the <strong>Read and Write Endpoints</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// pipe[0] for reading, pipe[1] for writing
#define READ_PIPE  0
#define WRITE_PIPE 1
</code></pre></div>
<p>We do the same to create the NuttX Pipes for <strong>NSH Output</strong> and <strong>NSH Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Create the NuttX Pipe for NSH Output
int nsh_stdout[2];
ret = pipe(nsh_stdout);
if (ret &lt; 0) { _err(&quot;stdout pipe failed: %d\n&quot;, errno); return; }

// Create the NuttX Pipe for NSH Error
int nsh_stderr[2];
ret = pipe(nsh_stderr);
if (ret &lt; 0) { _err(&quot;stderr pipe failed: %d\n&quot;, errno); return; }
</code></pre></div>
<p>There‚Äôs a reason why we call <strong><code>_err</code></strong> instead of <strong><code>printf</code></strong>, we‚Äôll find out next‚Ä¶</p>
<h2 id="connect-the-pipes"><a href="#connect-the-pipes">2.2 Connect the Pipes</a></h2>
<p><em>How will we connect the pipes to NSH Shell?</em></p>
<p>In a while we‚Äôll start the NuttX Task for NSH Shell. But before that, we need some plumbing to <strong>connect the NuttX Pipes</strong>.</p>
<p>First we close the streams for <strong>Standard Input, Output and Error</strong>: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L146-L178">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Close stdin, stdout and stderr
close(0);
close(1);
close(2);
</code></pre></div>
<p>That‚Äôs because NSH Shell will <strong>inherit our Standard I/O</strong> streams later.</p>
<p>Next we <strong>redirect the Standard I/O</strong> streams to the NuttX Pipes that we‚Äôve created earlier‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Redirect stdin, stdout and stderr to our NuttX Pipes.
// READ_PIPE is 0, WRITE_PIPE is 1
dup2(nsh_stdin[READ_PIPE],   0);  // Redirect stdin
dup2(nsh_stdout[WRITE_PIPE], 1);  // Redirect stdout
dup2(nsh_stderr[WRITE_PIPE], 2);  // Redirect stderr
</code></pre></div>
<p>When we do this, <strong>Standard I/O will no longer work</strong> with the NuttX Console.</p>
<p>Instead, all Standard I/O will go to our NuttX Pipes.</p>
<p><em>So printf will no longer print to the NuttX Console?</em></p>
<p>Exactly! That‚Äôs why we call <strong><code>_err</code></strong> and <strong><code>_info</code></strong> in this article.</p>
<p>These functions are <strong>hardwired to the NuttX Console</strong>. They will continue to work after we have redirected the Standard I/O streams.</p>
<h2 id="create-the-task"><a href="#create-the-task">2.3 Create the Task</a></h2>
<p>Our plumbing is done, let‚Äôs <strong>create the NuttX Task</strong> for NSH Shell: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L146-L178">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Arguments for the NuttX Task
char *argv[] = { NULL };

// Create a NuttX Task for NSH Shell
pid_t pid = task_create(
  &quot;NSH Console&quot;,  // Task Name
  100,            // Task Priority
  CONFIG_DEFAULT_TASK_STACKSIZE,  // Task Stack Size
  nsh_consolemain,  // Task Function
  argv              // Task Arguments
);

// Check for error
if (pid &lt; 0) { _err(&quot;task_create failed: %d\n&quot;, errno); return; }

// For Debugging: Wait a while for NSH Shell to start
sleep(1);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/chatgpt#fix-the-task-arguments">(More about <strong>argv</strong>)</a></p>
<p>NSH Shell inherits our Standard I/O streams, which we‚Äôve redirected to our NuttX Pipes.</p>
<p>We‚Äôre ready to test this!</p>
<h2 id="test-the-pipes"><a href="#test-the-pipes">2.4 Test the Pipes</a></h2>
<p>Finally we add some <strong>Test Code</strong> to verify that everything works: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a9d67c135c458088946ed35c1b24be1b4aee3553/examples/lvgldemo/lvgldemo.c#L292-L338">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Send a command to NSH stdin
const char cmd[] = &quot;ls\r&quot;;
ret = write(   // Write to the stream...
  nsh_stdin[WRITE_PIPE],  // NSH stdin (WRITE_PIPE is 1)
  cmd,         // Data to be written
  sizeof(cmd)  // Number of bytes
);

// Wait a while for NSH Shell to execute our command
sleep(1);
</code></pre></div>
<p>The code above sends the <strong><code>ls</code></strong> command to NSH Shell, by writing to our NuttX Pipe for <strong>NSH Standard Input</strong>.</p>
<p>NSH Shell <strong>runs the command</strong> and generates the command output.</p>
<p>We <strong>read the output</strong> from NSH Shell‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Read the output from NSH stdout.
// TODO: This will block if there&#39;s nothing to read.
static char buf[64];
ret = read(        // Read from the stream...
  nsh_stdout[READ_PIPE],  // NSH stdout (READ_PIPE is 0)
  buf,             // Buffer to be read
  sizeof(buf) - 1  // Buffer size (needs terminating null)
);

// Print the output
if (ret &gt; 0) {
  buf[ret] = 0;
  _info(&quot;%s\n&quot;, buf);
}
</code></pre></div>
<p>And it works! Here‚Äôs the NSH Shell auto-running the <strong><code>ls</code></strong> command received via our NuttX Pipe‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.0.0
nsh&gt; ls
/:
 dev/
 var/
nsh&gt; 
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a9d67c135c458088946ed35c1b24be1b4aee3553/examples/lvgldemo/lvgldemo.c#L340-L390">(See the Complete Log)</a></p>
<p><em>What about NSH Error Output?</em></p>
<p>Normally we do this to read the <strong>NSH Error Output</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Warning: This will block!
#ifdef NOTUSED
  // Read the output from NSH stderr.
  // TODO: This will block if there&#39;s nothing to read.
  ret = read(        // Read from the stream...
    nsh_stderr[READ_PIPE],  // NSH stderr (READ_PIPE is 0)
    buf,             // Buffer to be read
    sizeof(buf) - 1  // Buffer size (needs terminating null)
  );

  // Print the output
  if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
#endif
</code></pre></div>
<p>But there‚Äôs a problem‚Ä¶</p>
<p>Calling <strong><code>read()</code></strong> on <strong><code>nsh_stderr</code></strong> will block the execution if there‚Äôs <strong>no NSH Error Output</strong> ready to be read!</p>
<p>(Same for <strong><code>nsh_stdout</code></strong>) </p>
<p>Instead let‚Äôs check if there‚Äôs NSH Output ready to be read. We do this by calling <strong><code>poll()</code></strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow5.jpg" alt="Poll for NSH Output" /></p>
<h1 id="poll-for-nsh-output"><a href="#poll-for-nsh-output">3 Poll for NSH Output</a></h1>
<p>In the previous section we started an NSH Shell that will execute NSH Commands that we pipe to it‚Ä¶</p>
<p>But there‚Äôs a problem: Calling <strong><code>read()</code></strong> on <strong><code>nsh_stdout</code></strong> will block if there‚Äôs no NSH Output to be read.</p>
<p>(We can‚Äôt block our LVGL App, since LVGL needs to handle User Interface Events periodically)</p>
<p><strong>Solution:</strong> We call <strong><code>has_input</code></strong> to check if NSH Shell has data ready to be read, before we actually read the data: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L192-L245">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// If NSH stdout has data to be read...
if (has_input(nsh_stdout[READ_PIPE])) {

  // Read the data from NSH stdout
  static char buf[64];
  ret = read(
    nsh_stdout[READ_PIPE],
    buf,
    sizeof(buf) - 1
  );

  // Print the data
  if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L192-L245">(We do the same for <strong><code>nsh_stderr</code></strong>)</a></p>
<p><strong><code>has_input</code></strong> calls <strong><code>poll()</code></strong> on <strong><code>nsh_stdout</code></strong> to check if NSH Shell has data ready to be read: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L350-L391">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Return true if the File Descriptor has data to be read
static bool has_input(
  int fd  // File Descriptor to be checked
) {
  // Define the Poll Struct
  struct pollfd fdp;
  fdp.fd     = fd;      // File Descriptor to be checked
  fdp.events = POLLIN;  // Check for Input

  // Poll the File Descriptor for Input
  int ret = poll(
    &amp;fdp,  // File Descriptors
    1,     // Number of File Descriptors
    0      // Poll Timeout (Milliseconds)
  );
</code></pre></div>
<p>Note that we set the <strong>Poll Timeout</strong> to 0.</p>
<p>Thus <strong><code>poll()</code></strong> returns immediately with the result, without blocking.</p>
<p>We decode the result of <strong><code>poll()</code></strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if (ret &gt; 0) {
    // If Poll is OK and there&#39;s Input...
    if ((fdp.revents &amp; POLLIN) != 0) {
      // Report that there&#39;s Input
      _info(&quot;has input: fd=%d\n&quot;, fd);
      return true;
    }

    // Else report No Input
    _info(&quot;no input: fd=%d\n&quot;, fd);
    return false;

  } else if (ret == 0) {
    // If Timeout, report No Input
    _info(&quot;timeout: fd=%d\n&quot;, fd);
    return false;

  } else if (ret &lt; 0) {
    // Handle Error
    _err(&quot;poll failed: %d, fd=%d\n&quot;, ret, fd);
    return false;
  }
</code></pre></div>
<p><em>What happens when we run this?</em></p>
<p>If NSH Shell has data waiting to be read, <strong><code>has_input</code></strong> returns True‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>has_input: has input: fd=8
</code></pre></div>
<p>And if there‚Äôs nothing waiting to be read, <strong><code>has_input</code></strong> returns False (due to timeout)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>has_input: timeout: fd=8
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L403-L556">(See the Complete Log)</a></p>
<p>We‚Äôve solved our problem of Blocking Reads from NSH Output, by polling for NSH Output!</p>
<p>This polling for NSH Output needs to be done in an LVGL Timer, here‚Äôs why‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow6.jpg" alt="Timer for LVGL Terminal" /></p>
<h1 id="timer-for-lvgl-terminal"><a href="#timer-for-lvgl-terminal">4 Timer for LVGL Terminal</a></h1>
<p><em>How will we poll for NSH Output and display it?</em></p>
<p>We started an NSH Shell that will execute NSH Commands that we pipe to it.</p>
<p>Now we need to periodically <strong>poll for NSH Output</strong>, and write the output to the LVGL display.</p>
<p>Every couple of milliseconds we‚Ä¶</p>
<ul>
<li>
<p><strong>Poll the NSH Shell</strong> to check if it has output data</p>
</li>
<li>
<p><strong>Read the output</strong> from NSH Shell</p>
</li>
<li>
<p><strong>Display the output</strong> in an LVGL Widget</p>
</li>
</ul>
<p>We do this with an <a href="https://docs.lvgl.io/master/overview/timer.html"><strong>LVGL Timer</strong></a> that‚Äôs triggered every 100 milliseconds: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L178-L188">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Create an LVGL Terminal that will let us
// interact with NuttX NSH Shell
static void create_terminal(void) {

  // Create an LVGL Timer to poll for output from NSH Shell
  lv_timer_t *timer = lv_timer_create(
    timer_callback,  // Callback Function
    100,             // Timer Period (Milliseconds)
    &amp;user_data       // Callback Data
  );
</code></pre></div>
<p>(<strong>user_data</strong> is unused for now)</p>
<p><strong>timer_callback</strong> is our Callback Function for the LVGL Timer.</p>
<p>Inside the callback, we poll for NSH Output, read the output and display it: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L192-L245">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback Function for LVGL Timer
static void timer_callback(lv_timer_t *timer) {

  // If NSH stdout has data to be read...
  if (has_input(nsh_stdout[READ_PIPE])) {

    // Read the output from NSH stdout
    static char buf[64];
    int ret = read(
      nsh_stdout[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );

    // Add to NSH Output Text Area
    if (ret &gt; 0) {
      buf[ret] = 0;
      remove_escape_codes(buf, ret);
      lv_textarea_add_text(output, buf);
    }
  }
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/terminal#poll-for-nsh-output">(We‚Äôve seen <strong>has_input</strong> earlier)</a></p>
<p><a href="https://docs.lvgl.io/master/widgets/textarea.html#_CPPv420lv_textarea_add_textP8lv_obj_tPKc">(<strong>lv_textarea_add_text</strong> comes from LVGL)</a></p>
<p>We‚Äôll talk about <strong>remove_escape_codes</strong> in a while.</p>
<p><em>How do we test this Timer Callback?</em></p>
<p>Without LVGL Widgets, testing the LVGL Timer Callback will be tricky. Here‚Äôs how we tested by manipulating the LVGL Timer‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#poll-for-nsh-output-in-lvgl-timer"><strong>‚ÄúPoll for NSH Output in LVGL Timer‚Äù</strong></a></li>
</ul>
<p><em>Why poll for NSH Output? Why not run a Background Thread that will block on NSH Output?</em></p>
<p>Even if we ran a Background Thread that will block until NSH Output is available, we still need to write the NSH Output to an <strong>LVGL Widget for display</strong>.</p>
<p>But LVGL is <a href="https://docs.lvgl.io/master/porting/os.html#tasks-and-threads"><strong>NOT Thread-Safe</strong></a>. Thus we need a Mutex to lock the LVGL Widget, which gets messy.</p>
<p>For now, it‚Äôs simpler to run an LVGL Timer to poll for NSH Output.</p>
<p>Now that our Background Processing is ready, let‚Äôs render the LVGL Widgets for our terminal‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow3.jpg" alt="Render Terminal with LVGL Widgets" /></p>
<h1 id="render-terminal-with-lvgl-widgets"><a href="#render-terminal-with-lvgl-widgets">5 Render Terminal with LVGL Widgets</a></h1>
<p><em>How will we render the Terminal with LVGL?</em></p>
<p>Our Terminal will have 3 LVGL Widgets‚Ä¶</p>
<ul>
<li>
<p><a href="https://docs.lvgl.io/master/widgets/textarea.html"><strong>LVGL Text Area Widget</strong></a> that shows the <strong>NSH Output</strong></p>
<p>(At the top)</p>
</li>
<li>
<p><a href="https://docs.lvgl.io/master/widgets/textarea.html"><strong>LVGL Text Area Widget</strong></a> for <strong>NSH Input</strong>, to enter commands</p>
<p>(At the middle)</p>
</li>
<li>
<p><a href="https://docs.lvgl.io/master/widgets/keyboard.html"><strong>LVGL Keyboard Widget</strong></a> for typing commands into <strong>NSH Input</strong></p>
<p>(At the bottom)</p>
</li>
</ul>
<p>Like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl2-terminal2.jpg" alt="LVGL Terminal App" /></p>
<p>This is how we create the 3 LVGL Widgets: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L269-L299">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// LVGL Text Area Widgets for NSH Input and Output
static lv_obj_t *input;
static lv_obj_t *output;

// Create the LVGL Widgets for the LVGL Terminal
static void create_widgets(void) {

  // Create an LVGL Keyboard Widget
  lv_obj_t *kb = lv_keyboard_create(
    lv_scr_act()  // Parent is Active Screen
  );
</code></pre></div>
<p>In the code above, we begin by creating the <a href="https://docs.lvgl.io/master/widgets/keyboard.html"><strong>LVGL Keyboard Widget</strong></a>.</p>
<p>Next we create the <a href="https://docs.lvgl.io/master/widgets/textarea.html"><strong>LVGL Text Area Widget</strong></a> to display the <strong>NSH Output</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Create an LVGL Text Area Widget for NSH Output
  output = lv_textarea_create(
    lv_scr_act()  // Parent is Active Screen
  );

  // Align the Widget
  lv_obj_align(
    output,  // LVGL Text Area Widget for NSH Output
    LV_ALIGN_TOP_LEFT,  // From Top Left
    TERMINAL_MARGIN,    // Shift 10 pixels left
    TERMINAL_MARGIN     // Shift 10 pixels down
  );

  // Set the Default Text
  lv_textarea_set_placeholder_text(output, &quot;Hello&quot;);

  // Set the Widget Size
  lv_obj_set_size(
    output,  // LVGL Text Area Widget for NSH Output
    TERMINAL_WIDTH,  // Width
    OUTPUT_HEIGHT    // Height
  );
</code></pre></div>
<p>(We‚Äôll come back to <strong>TERMINAL_MARGIN</strong> and other constants)</p>
<p>Then we create another <a href="https://docs.lvgl.io/master/widgets/textarea.html"><strong>LVGL Text Area Widget</strong></a> to show the <strong>NSH Input</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Create an LVGL Text Area Widget for NSH Input
  input = lv_textarea_create(
    lv_scr_act()  // Parent is Active Screen
  );

  // Align the Widget
  lv_obj_align(
    input,  // LVGL Text Area Widget for NSH Input
    LV_ALIGN_TOP_LEFT,  // From Top Left
    TERMINAL_MARGIN,    // Shift 10 pixels left
    OUTPUT_HEIGHT + 2 * TERMINAL_MARGIN  // Shift 10 pixels below NSH Output
  );

  // Set the Widget Size
  lv_obj_set_size(
    input,  // LVGL Text Area Widget for NSH Input
    TERMINAL_WIDTH,  // Width
    INPUT_HEIGHT     // Height
  );
</code></pre></div>
<p>We <strong>register a Callback Function</strong> for NSH Input, to detect the pressing of the Enter Key‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Register the Callback Function for NSH Input
  lv_obj_add_event_cb(
    input,  // LVGL Text Area Widget for NSH Input
    input_callback,  // Callback Function
    LV_EVENT_ALL,    // Callback for All Events
    kb               // Callback Argument (Keyboard)
  );
</code></pre></div>
<p><strong>input_callback</strong> is the Callback Function for NSH Input. Which we‚Äôll cover in a while.</p>
<p>Finally we set the <strong>Keyboard Widget to populate</strong> the NSH Input Text Area‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Set the Keyboard to populate the NSH Input Text Area
  lv_keyboard_set_textarea(
    kb,    // LVGL Keyboard Widget
    input  // LVGL Text Area Widget for NSH Input
  );
}
</code></pre></div>
<p>That‚Äôs how we create the 3 LVGL Widgets for our Terminal App!</p>
<p><em>What‚Äôs TERMINAL_MARGIN? And the other constants?</em></p>
<p>We define <strong>TERMINAL_MARGIN</strong> (and the other constants) based on the <strong>Screen Layout</strong> of our Terminal App: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L249-L269">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// PinePhone LCD Panel Width and Height (pixels)
#define PINEPHONE_LCD_PANEL_WIDTH  720
#define PINEPHONE_LCD_PANEL_HEIGHT 1440

// Margin of 10 pixels all around
#define TERMINAL_MARGIN 10

// Terminal Width is LCD Width minus Left and Right Margins
#define TERMINAL_WIDTH  (PINEPHONE_LCD_PANEL_WIDTH - 2 * TERMINAL_MARGIN)

// Keyboard is Lower Half of LCD.
// Terminal Height is Upper Half of LCD minus Top and Bottom Margins.
#define TERMINAL_HEIGHT ((PINEPHONE_LCD_PANEL_HEIGHT / 2) - 2 * TERMINAL_MARGIN)

// Height of Input Text Area
#define INPUT_HEIGHT 100

// Height of Output Text Area is Terminal Height minus Input Height minus Middle Margin
#define OUTPUT_HEIGHT (TERMINAL_HEIGHT - INPUT_HEIGHT - TERMINAL_MARGIN)
</code></pre></div>
<p><em>But the Screen Width and Height are hardcoded for PinePhone?</em></p>
<p>Yeah this code won‚Äôt render correctly on devices other than PinePhone.</p>
<p>Soon we‚Äôll switch to <a href="https://docs.lvgl.io/master/layouts/flex.html"><strong>LVGL Flex Layout</strong></a> so that the LVGL Widgets will be <strong>Auto-Positioned</strong>, based on the Screen Size of our device.</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/term2/examples/lvglterm/lvglterm.c#L215-L276">(Preview of LVGL Flex Layout)</a></p>
<p>Note that we‚Äôre using the LVGL Default Font for all 3 LVGL Widgets. Which has a problem‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl2-terminal2.jpg" alt="Set Default Font to Monospace" /></p>
<h1 id="set-terminal-font-to-monospace"><a href="#set-terminal-font-to-monospace">6 Set Terminal Font to Monospace</a></h1>
<p>Like any Terminal App, our LVGL Terminal looks nicer with a <a href="https://en.wikipedia.org/wiki/Monospaced_font"><strong>Monospaced Font</strong></a>. (Instead of a Proportional Font)</p>
<p><em>So we change the Default LVGL Font to a Monospaced Font?</em></p>
<p>But watch what happens if we change the LVGL Default Font from Montserrat 20 (Proportional) to <strong>UNSCII 16 (Monospaced)</strong>‚Ä¶</p>
<p>The LVGL Keyboard has <strong>missing symbols!</strong> Enter, Backspace, ‚Ä¶</p>
<p>The <strong>symbols are undefined</strong> in the UNSCII 16 Font. (Pic above)</p>
<p>Thus we set the LVGL Default Font back to Montserrat 20.</p>
<p>And instead we set the <strong>Font Style for NSH Input and Output</strong> to UNSCII 16: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L269-L299">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Set the Font Style for NSH Input and Output to a Monospaced Font
static lv_style_t terminal_style;
lv_style_init(&amp;terminal_style);
lv_style_set_text_font(&amp;terminal_style, &amp;lv_font_unscii_16);

// Create an LVGL Text Area Widget for NSH Output
output = lv_textarea_create(lv_scr_act());
// Set the Font Style for NSH Output
lv_obj_add_style(output, &amp;terminal_style, 0);
...

// Create an LVGL Text Area Widget for NSH Input
input = lv_textarea_create(lv_scr_act());
// Set the Font Style for NSH Input
lv_obj_add_style(input, &amp;terminal_style, 0);
...
</code></pre></div>
<p>Now we see the LVGL Keyboard without missing symbols (when rendered with Montserrat 20)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-title.jpg" alt="Set Terminal Font to Monospace" /></p>
<p>Let‚Äôs look at our Callback Function for NSH Input‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow4.jpg" alt="Handle Input from LVGL Keyboard" /></p>
<h1 id="handle-input-from-lvgl-keyboard"><a href="#handle-input-from-lvgl-keyboard">7 Handle Input from LVGL Keyboard</a></h1>
<p><em>How will we check if the Enter Key has been pressed?</em></p>
<p>Remember earlier we <strong>registered a Callback Function</strong> for NSH Input Text Area, to detect the pressing of the Enter Key: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L269-L299">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Register the Callback Function for NSH Input
lv_obj_add_event_cb(
  input,  // LVGL Text Area Widget for NSH Input
  input_callback,  // Callback Function
  LV_EVENT_ALL,    // Callback for All Events
  kb               // Callback Argument (Keyboard)
);
</code></pre></div>
<p><strong>input_callback</strong> is the Callback Function for NSH Input.</p>
<p>It waits for the Enter Key to be pressed, then it sends the typed command to <strong>NSH Shell via the NuttX Pipe</strong>: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L299-L350">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback Function for NSH Input Text Area
static void input_callback(lv_event_t *e) {

  // Decode the LVGL Event
  const lv_event_code_t code = lv_event_get_code(e);

  // If NSH Input Text Area has been updated...
  if (code == LV_EVENT_VALUE_CHANGED) {

    // Get the Keyboard Widget from the LVGL Event
    const lv_obj_t *kb = lv_event_get_user_data(e);

    // Get the Button Index of the Key Pressed
    const uint16_t id = lv_keyboard_get_selected_btn(kb);

    // Get the Text of the Key Pressed
    const char *key = lv_keyboard_get_btn_text(kb, id);
</code></pre></div>
<p>The <strong>Enter Key</strong> has a Text Label of <a href="https://github.com/lupyuen/lvglterm/blob/f3e9e7f4d53e49303e8dbeaa2b8a8497699404a0/lvglterm.c#L515-L517"><strong><code>EF</code> <code>A2</code> <code>A2</code></strong></a>.</p>
<p>We match the Key Pressed with that label‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    // If Key Pressed is Enter...
    if (key[0] == 0xef &amp;&amp; key[1] == 0xa2 &amp;&amp; key[2] == 0xa2) {

      // Read the NSH Input
      const char *cmd = lv_textarea_get_text(input);
      if (cmd == NULL || cmd[0] == 0) { return; }

      // Send the Command to NSH stdin
      int ret = write(
        nsh_stdin[WRITE_PIPE],
        cmd,
        strlen(cmd)
      );

      // Erase the NSH Input
      lv_textarea_set_text(input, &quot;&quot;);
    }
  }
}
</code></pre></div>
<p>And we send the NSH Input Text to the NSH Shell for execution.</p>
<p>(The NSH Input Text is already terminated by a <a href="https://github.com/lupyuen/lvglterm/blob/f3e9e7f4d53e49303e8dbeaa2b8a8497699404a0/lvglterm.c#L518-L519"><strong>Newline Character <code>0x0A</code></strong></a>, which works fine with NSH Shell)</p>
<p>The command runs in NSH Shell and produces some Output Text. Which is handled by our LVGL Timer Callback Function‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow6.jpg" alt="Timer for LVGL Terminal" /></p>
<h1 id="handle-output-from-nsh-shell"><a href="#handle-output-from-nsh-shell">8 Handle Output from NSH Shell</a></h1>
<p>Earlier we‚Äôve created an LVGL Timer that <strong>polls periodically for output</strong> generated by NSH Shell‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/terminal#timer-for-lvgl-terminal"><strong>‚ÄúTimer for LVGL Terminal‚Äù</strong></a></li>
</ul>
<p>If it detects NSH Output, the LVGL Timer Callback Function writes the output to the <strong>NSH Output Text Area</strong>: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L192-L245">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback Function for LVGL Timer
static void timer_callback(lv_timer_t *timer) {

  // If NSH stdout has data to be read...
  if (has_input(nsh_stdout[READ_PIPE])) {

    // Read the output from NSH stdout
    static char buf[64];
    int ret = read(
      nsh_stdout[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );

    // Add to NSH Output Text Area
    if (ret &gt; 0) {
      buf[ret] = 0;
      remove_escape_codes(buf, ret);
      lv_textarea_add_text(output, buf);
    }
  }
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/terminal#poll-for-nsh-output">(We‚Äôve seen <strong>has_input</strong> earlier)</a></p>
<p><a href="https://docs.lvgl.io/master/widgets/textarea.html#_CPPv420lv_textarea_add_textP8lv_obj_tPKc">(<strong>lv_textarea_add_text</strong> comes from LVGL)</a></p>
<p><em>What‚Äôs remove_escape_codes?</em></p>
<p>NSH is configured to work with VT100 and ANSI Terminals. So the NSH Output will contain <a href="https://en.wikipedia.org/wiki/ANSI_escape_code"><strong>ANSI Escape Codes</strong></a> like‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; &lt;ESC&gt;[K
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvglterm/blob/f3e9e7f4d53e49303e8dbeaa2b8a8497699404a0/lvglterm.c#L453-L455">(Source)</a></p>
<p>Which is the ANSI Command for <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#CSIsection"><strong>‚ÄúErase In Line‚Äù</strong></a>. (Clear to the end of line)</p>
<p><a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L391-L404"><strong>remove_escape_codes</strong></a> searches for Escape Codes in the NSH Output and replaces them by spaces.</p>
<p>That‚Äôs why we see 3 spaces between the <strong><code>nsh&gt;</code></strong> prompt and the NSH Command.</p>
<p><a href="https://lupyuen.github.io/images/terminal-title.jpg">(Like this)</a></p>
<p><em>But the NSH Output looks laggy‚Ä¶</em></p>
<p>Yeah we used an <a href="https://docs.lvgl.io/latest/en/html/widgets/textarea.html"><strong>LVGL Text Area</strong></a> to render the NSH Output. Which is probably not optimal for scrollable, static text.</p>
<p>An <a href="https://docs.lvgl.io/latest/en/html/widgets/label.html"><strong>LVGL Label Widget</strong></a> might work better.</p>
<p><a href="https://docs.lvgl.io/latest/en/html/widgets/label.html#very-long-texts">(Remember to set <strong>LV_LABEL_LONG_TXT_HINT</strong>)</a></p>
<p>Also we might have to change polling to <strong>Multithreaded Blocking</strong>.</p>
<p>Which means we need Mutexes to lock the LVGL Widgets.</p>
<p><img src="https://lupyuen.github.io/images/terminal-zig1.jpg" alt="LVGL Programming in Zig" /></p>
<h1 id="lvgl-programming-in-zig"><a href="#lvgl-programming-in-zig">9 LVGL Programming in Zig</a></h1>
<p><em>As we add more features to our LVGL Terminal‚Ä¶</em></p>
<p><em>Will it become too complex to extend and maintain?</em></p>
<p>It might! That‚Äôs why we should consider coding our LVGL Terminal App in the <a href="https://ziglang.org/"><strong>Zig Programming Language</strong></a>.</p>
<p><em>LVGL works with Zig?</em></p>
<p>Yep! The pic above shows an <strong>LVGL Program in Zig</strong> that runs OK with PinePhone and NuttX.</p>
<p>To simpify the code, we created a simple <strong>LVGL Wrapper in Zig</strong> that makes LVGL feel more ‚Äúobject-oriented‚Äù.</p>
<p><a href="https://github.com/lupyuen/pinephone-lvgl-zig">(More about this)</a></p>
<p><img src="https://lupyuen.github.io/images/terminal-zig2.jpg" alt="Compiling an LVGL Program in Zig" /></p>
<p><em>How will we compile our LVGL Program in Zig?</em></p>
<p><em>Do we need to manually import every single LVGL Function from C?</em></p>
<p>Zig Compiler automatically <strong>imports all LVGL Functions</strong> from C into Zig!</p>
<p>The pic above shows how we compile our LVGL Program in Zig. Which will auto-import all LVGL Functions from the C Header Files.</p>
<p><a href="https://github.com/lupyuen/pinephone-lvgl-zig#build-lvgl-zig-app">(More about this)</a></p>
<p><img src="https://lupyuen.github.io/images/terminal-chatgpt.jpg" alt="Sorry ChatGPT‚Ä¶ Please try harder" /></p>
<p><a href="https://lupyuen.github.io/articles/chatgpt"><em>Sorry ChatGPT‚Ä¶ Please try harder</em></a></p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>Now we can run NuttX Console Apps on PinePhone, without a Serial Cable!</p>
<p>I hope this will make it a little easier to experiment with NuttX on PinePhone. Lemme know what you‚Äôre building!</p>
<p>Meanwhile please check out the other articles on NuttX for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/10rfyip/nuttx_rtos_for_pinephone_lvgl_terminal_for_nsh/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=34621805"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/terminal.md"><strong>lupyuen.github.io/src/terminal.md</strong></a></p>

    
</body>
</html>