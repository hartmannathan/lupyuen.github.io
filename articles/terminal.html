<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: LVGL Terminal for NSH Shell</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: LVGL Terminal for NSH Shell" 
    data-rh="true">
<meta property="og:description" 
    content="Let's build a Terminal App for PinePhone... With LVGL and Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's build a Terminal App for PinePhone... With LVGL and Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/terminal-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: LVGL Terminal for NSH Shell</h1>
    <nav id="TOC"><ul>
<li><a href="#lvgl-terminal-for-nuttx">1 LVGL Terminal for NuttX</a><ul></ul></li>
<li><a href="#pipe-a-command-to-nsh-shell">2 Pipe a Command to NSH Shell</a><ul>
<li><a href="#create-the-pipes">2.1 Create the Pipes</a><ul></ul></li>
<li><a href="#connect-the-pipes">2.2 Connect the Pipes</a><ul></ul></li>
<li><a href="#create-the-task">2.3 Create the Task</a><ul></ul></li>
<li><a href="#test-the-pipes">2.4 Test the Pipes</a><ul></ul></li></ul></li>
<li><a href="#poll-for-nsh-output">3 Poll for NSH Output</a><ul></ul></li>
<li><a href="#timer-for-lvgl-terminal">4 Timer for LVGL Terminal</a><ul></ul></li>
<li><a href="#poll-for-nsh-output-in-lvgl-timer">5 Poll for NSH Output in LVGL Timer</a><ul></ul></li>
<li><a href="#render-terminal-with-lvgl-widgets">6 Render Terminal with LVGL Widgets</a><ul></ul></li>
<li><a href="#set-terminal-font-to-monospace">7 Set Terminal Font to Monospace</a><ul></ul></li>
<li><a href="#handle-input-from-lvgl-keyboard">8 Handle Input from LVGL Keyboard</a><ul></ul></li>
<li><a href="#handle-output-from-nsh-shell">9 Handle Output from NSH Shell</a><ul></ul></li>
<li><a href="#performance">10 Performance</a><ul></ul></li>
<li><a href="#lvgl-programming-in-zig">11 LVGL Programming in Zig</a><ul></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>3 Feb 2023</em></p>
<p><img src="https://lupyuen.github.io/images/terminal-title.jpg" alt="LVGL Terminal App on PinePhone with Apache NuttX RTOS" /></p>
<p><a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) now boots on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> and runs <strong>Touchscreen Apps</strong>!</p>
<p>Today we‚Äôll look inside a Touchscreen App that will be useful for NuttX Developers‚Ä¶ Our <strong>Terminal App for NSH Shell</strong>. (Pic above)</p>
<p><a href="https://www.youtube.com/watch?v=WdiXaMK8cNw">(Watch the Demo on YouTube)</a></p>
<p><em>What‚Äôs NSH Shell?</em></p>
<p><strong>Nutt Shell (NSH)</strong> is the Command-Line Interface for NuttX. (Works like a Linux Shell)</p>
<p>Previously we needed a special <a href="https://lupyuen.github.io/articles/lvgl2#appendix-boot-apache-nuttx-rtos-on-pinephone"><strong>Serial Cable</strong></a> to access NSH Shell on PinePhone‚Ä¶</p>
<p>Now we can run NSH Commands <strong>through the Touchscreen</strong>! (Pic above)</p>
<p>(Super helpful for testing new NuttX Features on PinePhone!)</p>
<p>Read on to find out how we‚Ä¶</p>
<ul>
<li>
<p><strong>Pipe a Command</strong> to NSH Shell</p>
</li>
<li>
<p>Poll for <strong>NSH Output</strong></p>
</li>
<li>
<p><strong>Render the Terminal</strong> with LVGL Widgets</p>
</li>
<li>
<p><strong>Handle Input</strong> from LVGL Keyboard</p>
</li>
<li>
<p><strong>Handle Output</strong> from NSH Shell</p>
</li>
</ul>
<p>And how we might simplify the LVGL coding with the <strong>Zig Programming Language</strong>.</p>
<p><em>What‚Äôs NuttX? Why run it on PinePhone?</em></p>
<p>If we‚Äôre new to NuttX, here‚Äôs a gentle intro‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/what"><strong>‚ÄúNuttX RTOS for PinePhone: What is it?‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/terminal-flow.jpg" alt="Flow of LVGL Terminal for PinePhone on Apache NuttX RTOS" /></p>
<h1 id="lvgl-terminal-for-nuttx"><a href="#lvgl-terminal-for-nuttx">1 LVGL Terminal for NuttX</a></h1>
<p>Before we dive in, let‚Äôs walk through the internals of our <strong>LVGL Terminal App for NuttX</strong> (pic above)‚Ä¶</p>
<ol>
<li>
<p>We start the <strong>NSH Shell</strong> as a NuttX Task</p>
<p>(Which will execute our NSH Commands)</p>
</li>
<li>
<p>An NSH Command is entered through the <strong>LVGL Keyboard Widget</strong></p>
<p>(Which goes to the <strong>Input Text Area Widget</strong>)</p>
</li>
<li>
<p>When the Enter Key is pressed, we send the NSH Command to the <strong>NSH Input Pipe</strong></p>
</li>
<li>
<p>Which delivers the NSH Command to the <strong>NSH Shell</strong></p>
</li>
<li>
<p>NSH Shell <strong>executes our NSH Command</strong></p>
</li>
<li>
<p>NSH Shell produces some Text Output, which is pushed to the <strong>NSH Output Pipe</strong></p>
</li>
<li>
<p>We run an <strong>LVGL Timer</strong> that periodically polls the NSH Output Pipe for Text Output</p>
</li>
<li>
<p>When it detects the Text Output, the LVGL Timer reads the data‚Ä¶</p>
<p>And renders the output in the <strong>Output Text Area Widget</strong>.</p>
</li>
</ol>
<p><em>Whoa that looks complicated!</em></p>
<p>Yeah. But we‚Äôll explain everything in this article‚Ä¶</p>
<ul>
<li>
<p>How we start a <strong>NuttX Task</strong></p>
</li>
<li>
<p>What are <strong>NuttX Pipes</strong> and how we use them</p>
</li>
<li>
<p>How we render <strong>LVGL Widgets</strong> and handle events</p>
</li>
</ul>
<p>And eventually we‚Äôll understand the Source Code‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c"><strong>github.com/lupyuen/lvglterm</strong></a></p>
<p><a href="https://github.com/lupyuen/lvglterm">(How to compile LVGL Terminal)</a></p>
</li>
</ul>
<p>We begin by starting the NSH Task and piping a command to NSH Shell‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow2.jpg" alt="Flow of LVGL Terminal for PinePhone on Apache NuttX RTOS" /></p>
<h1 id="pipe-a-command-to-nsh-shell"><a href="#pipe-a-command-to-nsh-shell">2 Pipe a Command to NSH Shell</a></h1>
<p>Our Terminal App needs to‚Ä¶</p>
<ul>
<li>
<p>Start the <strong>NuttX Task</strong> for NSH Shell</p>
<p>(Which will execute our NSH Commands)</p>
</li>
<li>
<p>Redirect the <strong>NSH Shell Input</strong></p>
<p>(To receive the NSH Commands that we typed)</p>
</li>
<li>
<p>Redirect the <strong>NSH Shell Output</strong></p>
<p>(To render the output of NSH Commands)</p>
</li>
</ul>
<p>We‚Äôll redirect the NSH Input and Output with <strong>NuttX Pipes</strong>.</p>
<p>(Which will work like Linux Pipes)</p>
<p>Let‚Äôs find out how‚Ä¶</p>
<h2 id="create-the-pipes"><a href="#create-the-pipes">2.1 Create the Pipes</a></h2>
<p><em>How will we create the NuttX Pipes?</em></p>
<p>This is how we <strong>create a NuttX Pipe</strong> for NSH Input: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L146-L178">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Create the NuttX Pipe for NSH Input
int nsh_stdin[2];
int ret = pipe(nsh_stdin);

// Check for error
if (ret &lt; 0) {
  _err(&quot;stdin pipe failed: %d\n&quot;, errno); return;
}
</code></pre></div>
<p>NSH Shell will receive NSH Commands through this Pipe.</p>
<p><em>Why two elements in nsh_stdin?</em></p>
<p>That‚Äôs because a NuttX Pipe has <strong>Two Endpoints</strong> (in and out)‚Ä¶</p>
<ul>
<li>
<p><strong><code>nsh_stdin[0]</code></strong> reads from the Pipe</p>
</li>
<li>
<p><strong><code>nsh_stdin[1]</code></strong> writes to the Pipe</p>
</li>
</ul>
<p>NuttX Pipes are <strong>Unidirectional</strong>‚Ä¶ Don‚Äôt mix up the endpoints!</p>
<p>To remind ourselves, we define the <strong>Read and Write Endpoints</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// pipe[0] for reading, pipe[1] for writing
#define READ_PIPE  0
#define WRITE_PIPE 1
</code></pre></div>
<p>We do the same to create the NuttX Pipes for <strong>NSH Output</strong> and <strong>NSH Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Create the NuttX Pipe for NSH Output
int nsh_stdout[2];
ret = pipe(nsh_stdout);
if (ret &lt; 0) { _err(&quot;stdout pipe failed: %d\n&quot;, errno); return; }

// Create the NuttX Pipe for NSH Error
int nsh_stderr[2];
ret = pipe(nsh_stderr);
if (ret &lt; 0) { _err(&quot;stderr pipe failed: %d\n&quot;, errno); return; }
</code></pre></div>
<p>There‚Äôs a reason why we call <strong><code>_err</code></strong> instead of <strong><code>printf</code></strong>, we‚Äôll find out next‚Ä¶</p>
<h2 id="connect-the-pipes"><a href="#connect-the-pipes">2.2 Connect the Pipes</a></h2>
<p><em>How will we connect the pipes to NSH Shell?</em></p>
<p>In a while we‚Äôll start the NuttX Task for NSH Shell. But before that, we need some plumbing to <strong>connect the NuttX Pipes</strong>.</p>
<p>First we close the streams for <strong>Standard Input, Output and Error</strong>: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L146-L178">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Close stdin, stdout and stderr
close(0);
close(1);
close(2);
</code></pre></div>
<p>That‚Äôs because NSH Shell will <strong>inherit our Standard I/O</strong> streams later.</p>
<p>Next we <strong>redirect the Standard I/O</strong> streams to the NuttX Pipes that we‚Äôve created earlier‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Redirect stdin, stdout and stderr to our NuttX Pipes.
// READ_PIPE is 0, WRITE_PIPE is 1
dup2(nsh_stdin[READ_PIPE],   0);  // Redirect stdin
dup2(nsh_stdout[WRITE_PIPE], 1);  // Redirect stdout
dup2(nsh_stderr[WRITE_PIPE], 2);  // Redirect stderr
</code></pre></div>
<p>When we do this, <strong>Standard I/O will no longer work</strong> with the NuttX Console.</p>
<p>Instead, we‚Äôll have to read and write our NuttX Pipes.</p>
<p><em>So printf will no longer print to the NuttX Console?</em></p>
<p>Exactly! That‚Äôs why we call <strong><code>_err</code></strong> and <strong><code>_info</code></strong> in this article.</p>
<p>These functions are <strong>hardwired to the NuttX Console</strong>. They will continue to work after we have redirected the Standard I/O streams.</p>
<h2 id="create-the-task"><a href="#create-the-task">2.3 Create the Task</a></h2>
<p>Our plumbing is done, let‚Äôs <strong>create the NuttX Task</strong> for NSH Shell: <a href="https://github.com/lupyuen/lvglterm/blob/main/lvglterm.c#L146-L178">lvglterm.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Arguments for the NuttX Task
char *argv[] = { NULL };

// Create a NuttX Task for NSH Shell
pid_t pid = task_create(
  &quot;NSH Console&quot;,  // Task Name
  100,            // Task Priority
  CONFIG_DEFAULT_TASK_STACKSIZE,  // Task Stack Size
  nsh_consolemain,  // Task Function
  argv              // Task Arguments
);

// Check for error
if (pid &lt; 0) { _err(&quot;task_create failed: %d\n&quot;, errno); return; }

// For Debugging: Wait a while for NSH Shell to start
sleep(1);
</code></pre></div>
<p>NSH Shell inherits our Standard I/O streams, which we‚Äôve redirected to our NuttX Pipes.</p>
<p>We‚Äôre ready to test this!</p>
<h2 id="test-the-pipes"><a href="#test-the-pipes">2.4 Test the Pipes</a></h2>
<p>Finally we add some <strong>Test Code</strong> to verify that everything works: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a9d67c135c458088946ed35c1b24be1b4aee3553/examples/lvgldemo/lvgldemo.c#L292-L338">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Send a command to NSH stdin
const char cmd[] = &quot;ls\r&quot;;
ret = write(   // Write to the stream...
  nsh_stdin[WRITE_PIPE],  // NSH stdin (WRITE_PIPE is 1)
  cmd,         // Data to be written
  sizeof(cmd)  // Number of bytes
);

// Wait a while for NSH Shell to execute our command
sleep(1);
</code></pre></div>
<p>The code above sends the <strong><code>ls</code></strong> command to NSH Shell, by writing to our NuttX Pipe for <strong>NSH Standard Input</strong>.</p>
<p>NSH Shell <strong>runs the command</strong> and generates the command output.</p>
<p>We <strong>read the output</strong> from NSH Shell‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Read the output from NSH stdout.
// TODO: This will block if there&#39;s nothing to read.
static char buf[64];
ret = read(        // Read from the stream...
  nsh_stdout[READ_PIPE],  // NSH stdout (READ_PIPE is 0)
  buf,             // Buffer to be read
  sizeof(buf) - 1  // Buffer size (needs terminating null)
);

// Print the output
if (ret &gt; 0) {
  buf[ret] = 0;
  _info(&quot;%s\n&quot;, buf);
}
</code></pre></div>
<p>And it works! Here‚Äôs the NSH Shell auto-running the <strong><code>ls</code></strong> command received via our NuttX Pipe‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.0.0
nsh&gt; ls
/:
 dev/
 var/
nsh&gt; 
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a9d67c135c458088946ed35c1b24be1b4aee3553/examples/lvgldemo/lvgldemo.c#L340-L390">(See the Complete Log)</a></p>
<p><em>What about NSH Error Output?</em></p>
<p>Normally we‚Äôll do this to read the <strong>NSH Error Output</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Warning: This will block!
#ifdef NOTUSED
  // Read the output from NSH stderr.
  // TODO: This will block if there&#39;s nothing to read.
  ret = read(        // Read from the stream...
    nsh_stderr[READ_PIPE],  // NSH stderr (READ_PIPE is 0)
    buf,             // Buffer to be read
    sizeof(buf) - 1  // Buffer size (needs terminating null)
  );

  // Print the output
  if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
#endif
</code></pre></div>
<p>But there‚Äôs a problem‚Ä¶</p>
<p>Calling <strong><code>read()</code></strong> on <strong><code>nsh_stderr</code></strong> will block the execution if there‚Äôs no NSH Output ready to be read!</p>
<p>(Same for <strong><code>nsh_stdout</code></strong>) </p>
<p>Instead let‚Äôs check if there‚Äôs NSH Output ready to be read. We do this by calling <strong><code>poll()</code></strong>‚Ä¶</p>
<h1 id="poll-for-nsh-output"><a href="#poll-for-nsh-output">3 Poll for NSH Output</a></h1>
<p>TODO</p>
<p>In the previous section we started an NSH Shell that will execute NSH Commands that we pipe to it.</p>
<p>But there‚Äôs a problem: Calling <code>read()</code> on <code>nsh_stdout</code> will block if there‚Äôs no NSH Output to be read. And we can‚Äôt block our LVGL App, since it needs to handle UI Events periodically.</p>
<p>Solution: We call <code>has_input</code> to check if there‚Äôs NSH Output ready to be read, before reading the output: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L330-L353">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Read the output from NSH stdout
  static char buf[64];
  if (has_input(nsh_stdout[READ_PIPE])) {
    ret = read(
      nsh_stdout[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );
    if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
  }

  // Read the output from NSH stderr
  if (has_input(nsh_stderr[READ_PIPE])) {
    ret = read(    
      nsh_stderr[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );
    if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
  }
</code></pre></div>
<p><code>has_input</code> calls <code>poll()</code> on <code>nsh_stdout</code> to check if there‚Äôs NSH Output ready to be read: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L358-L397">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Return true if the File Descriptor has data to be read
static bool has_input(int fd) {

  // Poll the File Descriptor for Input
  struct pollfd fdp;
  fdp.fd = fd;
  fdp.events = POLLIN;
  int ret = poll(
    (struct pollfd *)&amp;fdp,  // File Descriptors
    1,  // Number of File Descriptors
    0   // Poll Timeout (Milliseconds)
  );

  if (ret &gt; 0) {
    // If Poll is OK and there is Input...
    if ((fdp.revents &amp; POLLIN) != 0) {
      // Report that there&#39;s Input
      _info(&quot;has input: fd=%d\n&quot;, fd);
      return true;
    }

    // Else report No Input
    _info(&quot;no input: fd=%d\n&quot;, fd);
    return false;

  } else if (ret == 0) {
    // Ignore Timeout
    _info(&quot;timeout: fd=%d\n&quot;, fd);
    return false;

  } else if (ret &lt; 0) {
    // Handle Error
    _err(&quot;poll failed: %d, fd=%d\n&quot;, ret, fd);
    return false;
  }

  // Never comes here
  DEBUGASSERT(false);
  return false;
}
</code></pre></div>
<p><code>has_input</code> returns True if there‚Äôs NSH Output waiting to be read‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>has_input: has input: fd=8
</code></pre></div>
<p>And <code>has_input</code> returns False (due to timeout) if there‚Äôs nothing waiting to be read‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>has_input: timeout: fd=8
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L403-L556">(See the Complete Log)</a></p>
<p>This polling needs to be done in an LVGL Timer, here‚Äôs why‚Ä¶</p>
<h1 id="timer-for-lvgl-terminal"><a href="#timer-for-lvgl-terminal">4 Timer for LVGL Terminal</a></h1>
<p>TODO</p>
<p>In the previous sections we started an NSH Shell that will execute NSH Commands that we pipe to it.</p>
<p>Our LVGL Terminal for NSH Shell shall periodically check for output from the NSH Shell, and write the output to the LVGL Display‚Ä¶</p>
<ul>
<li>
<p>Every couple of milliseconds‚Ä¶</p>
<ul>
<li>
<p>We call <code>poll()</code> to check if NSH Shell has output data</p>
</li>
<li>
<p>We read the output from NSH Shell</p>
</li>
<li>
<p>We display the NSH Output in an LVGL Label Widget</p>
</li>
</ul>
</li>
</ul>
<p>We‚Äôll do this with an <a href="https://docs.lvgl.io/master/overview/timer.html">LVGL Timer</a> like so: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/2f591f4e2589298caf6613ba409d667be61a9881/examples/lvgldemo/lvgldemo.c#L257-L269">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Create an LVGL Terminal that will let us interact with NuttX NSH Shell
void test_terminal(void) {

  // Create an LVGL Timer to poll for output from NSH Shell
  static uint32_t user_data = 10;
  lv_timer_t *timer = lv_timer_create(
    my_timer,   // Callback
    5000,       // Timer Period (Milliseconds)
    &amp;user_data  // Callback Data
  );
</code></pre></div>
<p><code>my_timer</code> is our Timer Callback Function: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/2f591f4e2589298caf6613ba409d667be61a9881/examples/lvgldemo/lvgldemo.c#L350-L363">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback for LVGL Timer
void my_timer(lv_timer_t *timer) {

  // Get the Callback Data
  uint32_t *user_data = timer-&gt;user_data;
  _info(&quot;my_timer called with callback data: %d\n&quot;, *user_data);
  *user_data += 1;

  // TODO: Call poll() to check if NSH Stdout has output to be read

  // TODO: Read the NSH Stdout

  // TODO: Write the NSH Output to LVGL Label Widget
}
</code></pre></div>
<p>When we run this, LVGL calls our Timer Callback Function every 5 seconds‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>my_timer: my_timer called with callback data: 10
my_timer: my_timer called with callback data: 11
my_timer: my_timer called with callback data: 12
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/2f591f4e2589298caf6613ba409d667be61a9881/examples/lvgldemo/lvgldemo.c#L369-L436">(See the Complete Log)</a></p>
<p><em>Why poll for NSH Output? Why not run a Background Thread that will block on NSH Output?</em></p>
<p>If we ran a Background Thread that will block until NSH Output is available, we still need to write the NSH Output to an LVGL Widget for display.</p>
<p>But LVGL is NOT Thread-Safe. Thus we need a Mutex to lock the LVGL Widgets, which gets messy.</p>
<p>For now, it‚Äôs simpler to run an LVGL Timer to poll for NSH Output.</p>
<p>Let‚Äôs add the polling to the LVGL Timer Callback‚Ä¶</p>
<h1 id="poll-for-nsh-output-in-lvgl-timer"><a href="#poll-for-nsh-output-in-lvgl-timer">5 Poll for NSH Output in LVGL Timer</a></h1>
<p>TODO</p>
<p>In the previous section we‚Äôve created an LVGL Timer that‚Äôs triggered periodically.</p>
<p>Inside the LVGL Timer Callback, let‚Äôs poll the NSH Output and check if there‚Äôs any output to be read: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L309-L356">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback for LVGL Timer
static void my_timer(lv_timer_t *timer) {
  ...
  // Read the output from NSH stdout
  static char buf[64];
  DEBUGASSERT(nsh_stdout[READ_PIPE] != 0);
  if (has_input(nsh_stdout[READ_PIPE])) {
    ret = read(
      nsh_stdout[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );
    _info(&quot;read nsh_stdout: %d\n&quot;, ret);
    if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
  }

  // Read the output from NSH stderr
  DEBUGASSERT(nsh_stderr[READ_PIPE] != 0);
  if (has_input(nsh_stderr[READ_PIPE])) {
    ret = read(    
      nsh_stderr[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );
    _info(&quot;read nsh_stderr: %d\n&quot;, ret);
    if (ret &gt; 0) { buf[ret] = 0; _info(&quot;%s\n&quot;, buf); }
  }

  // TODO: Write the NSH Output to LVGL Label Widget
</code></pre></div>
<p>NSH won‚Äôt emit any output until we run some NSH Commands. So let‚Äôs trigger some NSH Commands inside the LVGL Timer Callback: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L309-L356">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback for LVGL Timer
static void my_timer(lv_timer_t *timer) {

  // Get the Callback Data
  uint32_t *user_data = timer-&gt;user_data;
  _info(&quot;my_timer called with callback data: %d\n&quot;, *user_data);
  *user_data += 1;

  // Send a command to NSH stdin
  if (*user_data % 5 == 0) {
    const char cmd[] = &quot;ls\r&quot;;
    DEBUGASSERT(nsh_stdin[WRITE_PIPE] != 0);
    ret = write(
      nsh_stdin[WRITE_PIPE],
      cmd,
      sizeof(cmd)
    );
    _info(&quot;write nsh_stdin: %d\n&quot;, ret);
  }
  
  // Read the output from NSH stdout
  ...
</code></pre></div>
<p>When we run this, we see the LVGL Timer Callback sending NSH Commands and printing the NSH Output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>my_timer: my_timer called with callback data: 10
has_input: has input: fd=8
my_timer: read nsh_stdout: 63
my_timer: createWidgetsWrapped: start
createWidgetsWrapped: end
NuttShel
has_input: timeout: fd=10
my_timer: my_timer called with callback data: 11
has_input: has input: fd=8
my_timer: read nsh_stdout: 29
my_timer: l (NSH) NuttX-12.0.0
nsh&gt; 
has_input: timeout: fd=10
my_timer: my_timer called with callback data: 12
has_input: timeout: fd=8
has_input: timeout: fd=10
my_timer: my_timer called with callback data: 13
has_input: timeout: fd=8
has_input: timeout: fd=10
my_timer: my_timer called with callback data: 14
my_timer: write nsh_stdin: 4
has_input: timeout: fd=8
has_input: timeout: fd=10
my_timer: my_timer called with callback data: 15
has_input: has input: fd=8
my_timer: read nsh_stdout: 33
my_timer: ls
/:
 dev/
 proc/
 var/
nsh&gt; 
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/c30e1968d5106794f435882af69dfb7b1858d694/examples/lvgldemo/lvgldemo.c#L403-L556">(See the Complete Log)</a></p>
<p>Now that our background processing is ready, let‚Äôs render the LVGL Widgets for our terminal‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow3.jpg" alt="Render Terminal with LVGL Widgets" /></p>
<h1 id="render-terminal-with-lvgl-widgets"><a href="#render-terminal-with-lvgl-widgets">6 Render Terminal with LVGL Widgets</a></h1>
<p>TODO: Adopt Flex so it works with other devices</p>
<p>Our LVGL Terminal will have 3 LVGL Widgets‚Ä¶</p>
<ul>
<li>
<p><a href="https://docs.lvgl.io/master/widgets/textarea.html">LVGL Text Area Widget</a> that shows the NSH Output</p>
<p>(At the top)</p>
</li>
<li>
<p><a href="https://docs.lvgl.io/master/widgets/textarea.html">LVGL Text Area Widget</a> for NSH Input, to enter commands</p>
<p>(At the middle)</p>
</li>
<li>
<p><a href="https://docs.lvgl.io/master/widgets/keyboard.html">LVGL Keyboard Widget</a> for typing commands into NSH Input</p>
<p>(At the bottom)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lvgl2-terminal2.jpg" alt="Set Default Font to Monospace" /></p>
<p>This is how we render the 3 LVGL Widgets: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a37872d85c865557bee740cecd6adc35ae3197d2/examples/lvgldemo/lvgldemo.c#L374-L415">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// PinePhone LCD Panel Width and Height (pixels)
#define PINEPHONE_LCD_PANEL_WIDTH  720
#define PINEPHONE_LCD_PANEL_HEIGHT 1440

// Margin of 10 pixels all around
#define TERMINAL_MARGIN 10

// Terminal Width is LCD Width minus Left and Right Margins
#define TERMINAL_WIDTH  (PINEPHONE_LCD_PANEL_WIDTH - 2 * TERMINAL_MARGIN)

// Keyboard is Lower Half of LCD.
// Terminal Height is Upper Half of LCD minus Top and Bottom Margins.
#define TERMINAL_HEIGHT ((PINEPHONE_LCD_PANEL_HEIGHT / 2) - 2 * TERMINAL_MARGIN)

// Height of Input Text Area
#define INPUT_HEIGHT 100

// Height of Output Text Area is Terminal Height minus Input Height minus Middle Margin
#define OUTPUT_HEIGHT (TERMINAL_HEIGHT - INPUT_HEIGHT - TERMINAL_MARGIN)

// Create the LVGL Widgets for the LVGL Terminal.
// Based on https://docs.lvgl.io/master/widgets/keyboard.html#keyboard-with-text-area
static void create_widgets(void) {

  // Create an LVGL Keyboard Widget
  lv_obj_t *kb = lv_keyboard_create(lv_scr_act());

  // Create an LVGL Text Area Widget for NSH Output
  output = lv_textarea_create(lv_scr_act());
  lv_obj_align(output, LV_ALIGN_TOP_LEFT, TERMINAL_MARGIN, TERMINAL_MARGIN);
  lv_textarea_set_placeholder_text(output, &quot;Hello&quot;);
  lv_obj_set_size(output, TERMINAL_WIDTH, OUTPUT_HEIGHT);

  // Create an LVGL Text Area Widget for NSH Input
  input = lv_textarea_create(lv_scr_act());
  lv_obj_align(input, LV_ALIGN_TOP_LEFT, TERMINAL_MARGIN, OUTPUT_HEIGHT + 2 * TERMINAL_MARGIN);
  lv_obj_add_event_cb(input, input_callback, LV_EVENT_ALL, kb);
  lv_obj_set_size(input, TERMINAL_WIDTH, INPUT_HEIGHT);

  // Set the Keyboard to populate the NSH Input Text Area
  lv_keyboard_set_textarea(kb, input);
}
</code></pre></div>
<p><code>input_callback</code> is the Callback Function for our LVGL Keyboard. Which we‚Äôll cover in a while.</p>
<p>Note that we‚Äôre using the LVGL Default Font for all 3 LVGL Widgets. Which has a problem‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-widget.jpg" alt="Render Terminal with LVGL Widgets" /></p>
<h1 id="set-terminal-font-to-monospace"><a href="#set-terminal-font-to-monospace">7 Set Terminal Font to Monospace</a></h1>
<p>TODO</p>
<p>Our LVGL Terminal looks nicer with a Monospace Font.</p>
<p>But watch what happens if we change the LVGL Default Font from Montserrat 20 (proportional) to UNSCII 16 (monospace)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl2-terminal2.jpg" alt="Set Default Font to Monospace" /></p>
<p>The LVGL Keyboard has missing symbols! Enter, Backspace, ‚Ä¶</p>
<p>Thus we set the LVGL Default Font back to Montserrat 20.</p>
<p>And instead we set the Font Style for NSH Input and Output to UNSCII 16: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/58537ff2c0111e89c4bbe23a5683dc561fad6881/examples/lvgldemo/lvgldemo.c#L405-L422">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  // Set the Font Style for NSH Input and Output to a Monospaced Font
  static lv_style_t terminal_style;
  lv_style_init(&amp;terminal_style);
  lv_style_set_text_font(&amp;terminal_style, &amp;lv_font_unscii_16);

  // Create an LVGL Text Area Widget for NSH Output
  output = lv_textarea_create(lv_scr_act());
  lv_obj_add_style(output, &amp;terminal_style, 0);
  ...

  // Create an LVGL Text Area Widget for NSH Input
  input = lv_textarea_create(lv_scr_act());
  lv_obj_add_style(input, &amp;terminal_style, 0);
  ...
</code></pre></div>
<p>Now we see the LVGL Keyboard without missing symbols (pic below)‚Ä¶</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=WdiXaMK8cNw">Watch the Demo on YouTube</a></li>
</ul>
<p>Let‚Äôs look at our Callback Function for the LVGL Keyboard‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl2-terminal3.jpg" alt="Set Terminal Font to Monospace" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/terminal-flow4.jpg" alt="Flow of LVGL Terminal for PinePhone on Apache NuttX RTOS" /></p>
<h1 id="handle-input-from-lvgl-keyboard"><a href="#handle-input-from-lvgl-keyboard">8 Handle Input from LVGL Keyboard</a></h1>
<p>TODO</p>
<p>Here‚Äôs the Callback Function that handles input from the LVGL Keyboard.</p>
<p>It waits for the Enter key to be pressed, then it sends the typed command to NSH Shell via a POSIX Pipe: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a37872d85c865557bee740cecd6adc35ae3197d2/examples/lvgldemo/lvgldemo.c#L417-L466">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback Function for NSH Input Text Area.
// Based on https://docs.lvgl.io/master/widgets/keyboard.html#keyboard-with-text-area
static void input_callback(lv_event_t *e) {
  int ret;

  // Decode the LVGL Event
  const lv_event_code_t code = lv_event_get_code(e);

  // If Enter has been pressed, send the Command to NSH Input
  if (code == LV_EVENT_VALUE_CHANGED) {

    // Get the Keyboard Widget from the LVGL Event
    const lv_obj_t *kb = lv_event_get_user_data(e);
    DEBUGASSERT(kb != NULL);

    // Get the Button Index of the Keyboard Button Pressed
    const uint16_t id = lv_keyboard_get_selected_btn(kb);

    // Get the Text of the Keyboard Button
    const char *key = lv_keyboard_get_btn_text(kb, id);
    if (key == NULL) { return; }

    // If Enter is pressed...
    if (key[0] == 0xef &amp;&amp; key[1] == 0xa2 &amp;&amp; key[2] == 0xa2) {

      // Read the NSH Input
      DEBUGASSERT(input != NULL);
      const char *cmd = lv_textarea_get_text(input);
      if (cmd == NULL || cmd[0] == 0) { return; }

      // Send the Command to NSH stdin
      DEBUGASSERT(nsh_stdin[WRITE_PIPE] != 0);
      ret = write(
        nsh_stdin[WRITE_PIPE],
        cmd,
        strlen(cmd)
      );

      // Erase the NSH Input
      lv_textarea_set_text(input, &quot;&quot;);
    }
  }
}
</code></pre></div>
<p>The command runs in NSH Shell and produces NSH Output. Which is handled by the LVGL Timer Callback Function‚Ä¶</p>
<h1 id="handle-output-from-nsh-shell"><a href="#handle-output-from-nsh-shell">9 Handle Output from NSH Shell</a></h1>
<p>TODO</p>
<p>Our LVGL Timer Callback Function checks periodically whether there‚Äôs any NSH Output waiting to be processed.</p>
<p>If there‚Äôs NSH Output, the Callback Function writes the output to the NSH Output Text Area:
<a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/a37872d85c865557bee740cecd6adc35ae3197d2/examples/lvgldemo/lvgldemo.c#L320-L372">lvgldemo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Callback Function for LVGL Timer.
// Based on https://docs.lvgl.io/master/overview/timer.html#create-a-timer
static void timer_callback(lv_timer_t *timer) {

  // Read the output from NSH stdout
  static char buf[64];
  DEBUGASSERT(nsh_stdout[READ_PIPE] != 0);
  if (has_input(nsh_stdout[READ_PIPE])) {
    ret = read(
      nsh_stdout[READ_PIPE],
      buf,
      sizeof(buf) - 1
    );
    if (ret &gt; 0) {
      // Add to NSH Output Text Area
      buf[ret] = 0;
      remove_escape_codes(buf, ret);
      DEBUGASSERT(output != NULL);
      lv_textarea_add_text(output, buf);
    }
  }
</code></pre></div>
<p><code>remove_escape_codes</code> searches for Escape Codes in the NSH Output and replaces them by spaces.</p>
<p>That‚Äôs why we see 3 spaces between the <code>nsh&gt;</code> prompt and the NSH Command‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl2-terminal3.jpg" alt="3 spaces between the nsh&gt; prompt and the NSH Command" /></p>
<h1 id="performance"><a href="#performance">10 Performance</a></h1>
<p>TODO: Change polling to blocking, multithreading</p>
<p>TODO: Text Area probably not optimal for scrolling. Label might work better</p>
<p><img src="https://lupyuen.github.io/images/terminal-zig1.jpg" alt="LVGL Programming in Zig" /></p>
<h1 id="lvgl-programming-in-zig"><a href="#lvgl-programming-in-zig">11 LVGL Programming in Zig</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/terminal-zig2.jpg" alt="Compiling an LVGL Program in Zig" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/terminal-chatgpt.jpg" alt="Sorry ChatGPT‚Ä¶ Please try harder" /></p>
<p><em>Sorry ChatGPT‚Ä¶ Please try harder</em></p>
<h1 id="whats-next"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Please check out the other articles on NuttX for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/terminal.md"><strong>lupyuen.github.io/src/terminal.md</strong></a></p>

    
</body>
</html>