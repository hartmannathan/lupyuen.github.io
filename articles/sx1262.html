<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>LoRa SX1262 on Apache NuttX OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="LoRa SX1262 on Apache NuttX OS" 
    data-rh="true">
<meta property="og:description" 
    content="Porting the LoRa Driver for Semtech SX1262 from Linux to Apache NuttX OS... And testing it on PineDio Stack BL604 RISC-V Board"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/sx1262-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">LoRa SX1262 on Apache NuttX OS</h1>
    <nav id="TOC"><ul>
<li><a href="#small-steps">1 Small Steps</a><ul>
<li><a href="#lorawan-support">1.1 LoRaWAN Support</a><ul></ul></li>
<li><a href="#lora-sx1262-library">1.2 LoRa SX1262 Library</a><ul></ul></li>
<li><a href="#library-vs-driver">1.3 Library vs Driver</a><ul></ul></li></ul></li>
<li><a href="#connect-sx1262-transceiver">2 Connect SX1262 Transceiver</a><ul></ul></li>
<li><a href="#read-sx1262-registers">3 Read SX1262 Registers</a><ul>
<li><a href="#build-the-firmware">3.1 Build the Firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">3.2 Run the Firmware</a><ul></ul></li>
<li><a href="#source-files">3.3 Source Files</a><ul></ul></li></ul></li>
<li><a href="#lora-parameters">4 LoRa Parameters</a><ul>
<li><a href="#initialise-lora-sx1262">4.1 Initialise LoRa SX1262</a><ul></ul></li></ul></li>
<li><a href="#transmit-lora-message">5 Transmit LoRa Message</a><ul>
<li><a href="#run-the-firmware-1">5.1 Run the Firmware</a><ul></ul></li>
<li><a href="#spectrum-analysis-with-sdr">5.2 Spectrum Analysis with SDR</a><ul></ul></li></ul></li>
<li><a href="#receive-lora-message">6 Receive LoRa Message</a><ul>
<li><a href="#run-the-firmware-2">6.1 Run the Firmware</a><ul></ul></li></ul></li>
<li><a href="#spi-interface">7 SPI Interface</a><ul>
<li><a href="#initialise-spi">7.1 Initialise SPI</a><ul></ul></li>
<li><a href="#transfer-spi">7.2 Transfer SPI</a><ul></ul></li>
<li><a href="#transmit-message">7.3 Transmit Message</a><ul></ul></li>
<li><a href="#receive-message">7.4 Receive Message</a><ul></ul></li>
<li><a href="#spi-in-action">7.5 SPI In Action</a><ul></ul></li></ul></li>
<li><a href="#gpio-interface">8 GPIO Interface</a><ul>
<li><a href="#initialise-gpio">8.1 Initialise GPIO</a><ul></ul></li>
<li><a href="#start-dio1-thread">8.2 Start DIO1 Thread</a><ul></ul></li>
<li><a href="#handle-dio1-interrupt">8.3 Handle DIO1 Interrupt</a><ul></ul></li>
<li><a href="#read-dio1-state">8.4 Read DIO1 State</a><ul></ul></li>
<li><a href="#check-busy-state">8.5 Check Busy State</a><ul></ul></li></ul></li>
<li><a href="#multithreading-with-nimble-porting-layer">9 Multithreading with NimBLE Porting Layer</a><ul>
<li><a href="#event-queue">9.1 Event Queue</a><ul></ul></li>
<li><a href="#event-loop">9.2 Event Loop</a><ul></ul></li></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-spi-and-gpio-device-paths">12 Appendix: SPI and GPIO Device Paths</a><ul></ul></li>
<li><a href="#appendix-create-a-nuttx-library">13 Appendix: Create a NuttX Library</a><ul>
<li><a href="#update-makefiles-and-kconfig">13.1 Update Makefiles and Kconfig</a><ul></ul></li>
<li><a href="#enable-library">13.2 Enable Library</a><ul></ul></li>
<li><a href="#verify-library">13.3 Verify Library</a><ul></ul></li></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">14 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#build-nuttx">14.1 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx">14.2 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx">14.3 Run NuttX</a><ul></ul></li></ul></li>
<li><a href="#appendix-radio-functions">15 Appendix: Radio Functions</a><ul>
<li><a href="#radioinit-initialise-lora-module">15.1 RadioInit: Initialise LoRa Module</a><ul></ul></li>
<li><a href="#radiosetchannel-set-lora-frequency">15.2 RadioSetChannel: Set LoRa Frequency</a><ul></ul></li>
<li><a href="#radiosettxconfig-set-transmit-configuration">15.3 RadioSetTxConfig: Set Transmit Configuration</a><ul></ul></li>
<li><a href="#radiosetrxconfig-set-receive-configuration">15.4 RadioSetRxConfig: Set Receive Configuration</a><ul></ul></li>
<li><a href="#radiosend-transmit-message">15.5 RadioSend: Transmit Message</a><ul></ul></li>
<li><a href="#radiorx-receive-message">15.6 RadioRx: Receive Message</a><ul></ul></li>
<li><a href="#radioirqprocess-process-transmit-and-receive-interrupts">15.7 RadioIrqProcess: Process Transmit and Receive Interrupts</a><ul>
<li><a href="#transmit-done">15.7.1 Transmit Done</a><ul></ul></li>
<li><a href="#receive-done">15.7.2 Receive Done</a><ul></ul></li>
<li><a href="#cad-done">15.7.3 CAD Done</a><ul></ul></li>
<li><a href="#transmit--receive-timeout">15.7.4 Transmit / Receive Timeout</a><ul></ul></li>
<li><a href="#preamble-detected">15.7.5 Preamble Detected</a><ul></ul></li>
<li><a href="#sync-word-valid">15.7.6 Sync Word Valid</a><ul></ul></li>
<li><a href="#header-valid">15.7.7 Header Valid</a><ul></ul></li>
<li><a href="#header-error">15.7.8 Header Error</a><ul></ul></li>
<li><a href="#radioondioirq">15.7.9 RadioOnDioIrq</a><ul></ul></li></ul></li>
<li><a href="#radiosleep-switch-to-sleep-mode">15.8 RadioSleep: Switch to Sleep Mode</a><ul></ul></li></ul></li>
<li><a href="#appendix-gpio-pin-type-issue">16 Appendix: GPIO Pin Type Issue</a><ul></ul></li>
<li><a href="#appendix-nimble-callout-issue">17 Appendix: NimBLE Callout Issue</a><ul></ul></li>
<li><a href="#appendix-previous-sx1262-library">18 Appendix: Previous SX1262 Library</a><ul></ul></li></ul></nav><p>üìù <em>22 Dec 2021</em></p>
<p><img src="https://lupyuen.github.io/images/sx1262-title.jpg" alt="PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)" /></p>
<p><em>PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)</em></p>
<p><strong>LoRa</strong> is an awesome wireless technology for IoT that will transmit <strong>small packets over super long distances</strong>‚Ä¶</p>
<p><a href="https://lora-developers.semtech.com/documentation/tech-papers-and-guides/lora-and-lorawan/">(Up to 5 km or 3 miles in urban areas‚Ä¶ 15 km or 10 miles in rural areas!)</a></p>
<p>Let‚Äôs port LoRa to <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX OS!</strong></a></p>
<p><a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/">(More about LoRa)</a></p>
<p><em>Doesn‚Äôt NuttX support LoRa already?</em></p>
<p>Yep NuttX has a standalone LoRa Driver for <strong>Semtech SX1276 Transceiver</strong> (Radio Transmitter + Receiver)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/tree/master/drivers/wireless/lpwan/sx127x"><strong>NuttX SX127x Driver</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx-apps/tree/master/examples/sx127x_demo"><strong>NuttX SX127x Demo</strong></a></p>
</li>
</ul>
<p>(That doesn‚Äôt work with LoRaWAN yet)</p>
<p>Today we build a NuttX Driver for the (newer) <a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262"><strong>Semtech SX1262 Transceiver</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/tree/lorawan"><strong>SX1262 Library</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-apps/tree/master/examples/sx1262_test"><strong>SX1262 Test App</strong></a></p>
</li>
</ul>
<p>Our LoRa SX1262 Driver shall be tested on Bouffalo Lab‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 and BL604 RISC-V SoCs</strong></a>.</p>
<p>(It will probably run on <strong>ESP32</strong>, since we‚Äôre calling standard NuttX Interfaces)</p>
<p>Eventually our LoRa SX1262 Driver will support the <strong>LoRaWAN Wireless Protocol</strong>.</p>
<p><em>How useful is LoRaWAN? Will we be using it?</em></p>
<p>Our LoRa SX1262 Driver will work perfectly fine for unsecured <strong>Point-to-Point Wireless Communication</strong>.</p>
<p>But if we need to <strong>relay data packets</strong> securely to a Local Area Network or to the internet, we need <strong>LoRaWAN</strong>.</p>
<p><a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/">(More about LoRaWAN)</a></p>
<h1 id="small-steps"><a class="doc-anchor" href="#small-steps">¬ß</a>1 Small Steps</h1>
<p><em>So today we‚Äôll build the NuttX Drivers for LoRa SX1262 and LoRaWAN?</em></p>
<p>Not quite. Implementing LoRa AND LoRaWAN is a complex endeavour.</p>
<p>Thus we break the implementation into small steps‚Ä¶</p>
<ul>
<li>
<p>Today we do the <strong>SX1262 Library</strong> (top right)</p>
</li>
<li>
<p>And we test with our <strong>LoRa App</strong> (top left)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/sx1262-library.jpg" alt="Porting LoRaWAN to NuttX OS" /></p>
<ul>
<li>
<p>In the next article we‚Äôll do the <strong>LoRaWAN Library</strong> and test with our <strong>LoRaWAN App</strong></p>
</li>
<li>
<p>Eventually we shall wrap the SX1262 and LoRaWAN Libraries as <strong>NuttX Drivers</strong></p>
<p>(Because that‚Äôs the proper design for NuttX)</p>
</li>
</ul>
<h2 id="lorawan-support"><a class="doc-anchor" href="#lorawan-support">¬ß</a>1.1 LoRaWAN Support</h2>
<p><em>Why is LoRaWAN so complex?</em></p>
<p>LoRaWAN works <strong>slightly differently across the world regions</strong>, to comply with Local Wireless Regulations: Radio Frequency, Maximum Airtime (Duty Cycle), <a href="https://lupyuen.github.io/articles/lorawan#appendix-lora-carrier-sensing">Listen Before Talk</a>, ‚Ä¶</p>
<p>Thus we should port <strong>Semtech‚Äôs LoRaWAN Stack</strong> to NuttX with <strong>minimal changes</strong>, in case of future updates. (Like for new regions)</p>
<p>This also means that we should port <strong>Semtech‚Äôs SX1262 Driver</strong> to NuttX as-is, because of the dependencies between the LoRaWAN Stack and the SX1262 Driver.</p>
<h2 id="lora-sx1262-library"><a class="doc-anchor" href="#lora-sx1262-library">¬ß</a>1.2 LoRa SX1262 Library</h2>
<p><em>Where did the LoRa SX1262 code come from?</em></p>
<p>Our LoRa SX1262 Library originated from <strong>Semtech‚Äôs Reference Implementation</strong> of SX1262 Driver (29 Mar 2021)‚Ä¶</p>
<ul>
<li><a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x"><strong>LoRaMac-node/radio/sx126x</strong></a></li>
</ul>
<p>Which we ported to <strong>Linux</strong> and <strong>BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262/tree/lorawan"><strong>lupyuen/lora-sx1262 (lorawan branch)</strong></a></li>
</ul>
<p>And we‚Äôre porting now to <strong>NuttX</strong>.</p>
<p>(Because porting Linux code to NuttX is straightforward)</p>
<p><em>How did we create the LoRa SX1262 Library?</em></p>
<p>We followed the steps below to create <strong>‚Äúnuttx/libs/libsx1262‚Äù</strong> by cloning a NuttX Library‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sx1262#appendix-create-a-nuttx-library"><strong>‚ÄúCreate a NuttX Library‚Äù</strong></a></li>
</ul>
<p>Then we replaced the ‚Äúlibsx1262‚Äù folder by a <strong>Git Submodule</strong> that contains our LoRa SX1262 code‚Ä¶ </p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx/nuttx/libs
rm -r libsx1262
git rm -r libsx1262
git submodule add --branch nuttx https://github.com/lupyuen/lora-sx1262 libsx1262
</code></pre></div>
<p>Note that we‚Äôre using the older <strong>‚Äúnuttx‚Äù</strong> branch of the ‚Äúlora_sx1262‚Äù repo, which <a href="https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library"><strong>doesn‚Äôt use GPIO Interface and NimBLE Porting Layer</strong></a>. (And doesn‚Äôt support LoRaWAN)</p>
<h2 id="library-vs-driver"><a class="doc-anchor" href="#library-vs-driver">¬ß</a>1.3 Library vs Driver</h2>
<p><em>NuttX Libraries vs Drivers‚Ä¶ What‚Äôs the difference?</em></p>
<p>Our LoRa SX1262 code is initially packaged as a <strong>NuttX Library</strong> (instead of NuttX Driver) because‚Ä¶</p>
<ul>
<li>
<p>NuttX Libraries are <strong>easier to code and troubleshoot</strong></p>
</li>
<li>
<p>NuttX Libraries may be called by <strong>NuttX Apps AND NuttX Drivers</strong></p>
<p>(So we can test our library with a NuttX App)</p>
</li>
</ul>
<p>Eventually our LoRa SX1262 code shall be packaged as a <strong>NuttX Driver</strong>‚Ä¶</p>
<ul>
<li>
<p>Our code shall run inside NuttX OS, which means‚Ä¶</p>
</li>
<li>
<p>Our driver needs to expose an <strong>ioctl()</strong> interface to NuttX Apps</p>
<p>(Which will be cumbersome to code)</p>
</li>
</ul>
<p>Check out the <strong>ioctl()</strong> interface for the existing SX1276 Driver in NuttX: <a href="https://github.com/apache/nuttx/blob/master/drivers/wireless/lpwan/sx127x/sx127x.c#L954-L1162"><strong>sx127x.c</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-plan2.jpg" alt="SPI Test Driver" /></p>
<p><em>But how will our library access the NuttX SPI Interface?</em></p>
<p>The NuttX SPI Interface is accessible by NuttX Drivers, but not NuttX Apps.</p>
<p>Thankfully in the previous article we have created an <strong>SPI Test Driver ‚Äú/dev/spitest0‚Äù</strong> that exposes the SPI Interface to NuttX Apps (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2"><strong>‚ÄúSPI on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p>For now we‚Äôll call this SPI Test Driver in our LoRa SX1262 Library.</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio1.jpg" alt="Inside PineDio Stack BL604" /></p>
<h1 id="connect-sx1262-transceiver"><a class="doc-anchor" href="#connect-sx1262-transceiver">¬ß</a>2 Connect SX1262 Transceiver</h1>
<p>Our code has been configured for <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> and its onboard SX1262 Transceiver. (Pic above)</p>
<p>Based on this schematic for PineDio Stack BL604 (version 2)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio3.png" alt="SX1262 Interface on PineDio Stack" /></p>
</blockquote>
<p>We have configured the following <strong>BL604 Pin Definitions</strong> in <a href="https://github.com/lupyuen/nuttx/blob/sx1262/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95">board.h</a></p>
<div><table><thead><tr><th style="text-align: center">SX1262</th><th style="text-align: center">BL604 Pin</th><th style="text-align: left">NuttX Pin</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>MOSI</strong></td><td style="text-align: center">GPIO 13</td><td style="text-align: left">BOARD_SPI_MOSI</td></tr>
<tr><td style="text-align: center"><strong>MISO</strong></td><td style="text-align: center">GPIO 0</td><td style="text-align: left">BOARD_SPI_MISO</td></tr>
<tr><td style="text-align: center"><strong>SCK</strong></td><td style="text-align: center">GPIO 11</td><td style="text-align: left">BOARD_SPI_CLK</td></tr>
<tr><td style="text-align: center"><strong>CS</strong></td><td style="text-align: center">GPIO 15</td><td style="text-align: left">BOARD_GPIO_OUT1</td></tr>
<tr><td style="text-align: center"><strong>BUSY</strong></td><td style="text-align: center">GPIO 10</td><td style="text-align: left">BOARD_GPIO_IN1</td></tr>
<tr><td style="text-align: center"><strong>DIO1</strong></td><td style="text-align: center">GPIO 19</td><td style="text-align: left">BOARD_GPIO_INT1</td></tr>
<tr><td style="text-align: center"><strong>NRESET</strong></td><td style="text-align: center">GPIO 18</td><td style="text-align: left">Not assigned yet</td></tr>
</tbody></table>
</div><div class="example-wrap"><pre class="language-c"><code>/* Busy Pin for PineDio SX1262 */

#define BOARD_GPIO_IN1    (GPIO_INPUT | GPIO_FLOAT | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN10)

/* SPI Chip Select for PineDio SX1262 */

#define BOARD_GPIO_OUT1   (GPIO_OUTPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN15)

/* GPIO Interrupt (DIO1) for PineDio SX1262 */

#define BOARD_GPIO_INT1   (GPIO_INPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN19)

/* SPI Configuration: Chip Select is unused because we control via GPIO instead */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN8)  /* Unused */
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN13)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN11)
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<p>GPIO Output <strong>BOARD_GPIO_OUT1</strong> becomes our <strong>SPI Chip Select</strong>. <a href="https://lupyuen.github.io/articles/spi2#control-chip-select-with-gpio">(See this)</a></p>
<p><strong>BOARD_GPIO_IN1</strong> (Busy Pin) and <strong>BOARD_GPIO_INT1</strong> (DIO1) will be used for LoRaWAN in the next article.</p>
<p><strong>For BL602:</strong> Connect SX1262 to <a href="https://lupyuen.github.io/articles/spi2#connect-sx1262">these pins</a>. Copy the BL602 Pin Definitions from <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L36-L92">board.h</a> to‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>boards/risc-v/bl602/bl602evb/include/board.h
</code></pre></div>
<p><strong>For ESP32:</strong> Connect SX1262 to <a href="https://lupyuen.github.io/articles/spi2#connect-sx1262">these pins</a></p>
<p>Before testing, remember to connect the <strong>LoRa Antenna</strong>‚Ä¶ </p>
<p>(So we don‚Äôt fry the SX1262 Transceiver as we charge up the Power Amplifier)</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio10a.jpg" alt="PineDio Stack BL604 with Antenna" /></p>
<p><em>What are these SX1262 pins: DIO1, BUSY and NRESET?</em></p>
<p><strong>DIO1</strong> is used by SX1262 to signal that a LoRa Packet has been received.</p>
<p><strong>BUSY</strong> is tells us if SX1262 is busy.</p>
<p><strong>NRESET</strong> is toggled to reset the SX1262 module.</p>
<p>Although our SX1262 Library doesn‚Äôt use these pins, it works somewhat OK for sending and receiving LoRa Messages.</p>
<p>(We‚Äôll learn why in a while)</p>
<p><img src="https://lupyuen.github.io/images/sx1262-read2.png" alt="Reading SX1262 Registers" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L155-L171">(Source)</a></p>
<h1 id="read-sx1262-registers"><a class="doc-anchor" href="#read-sx1262-registers">¬ß</a>3 Read SX1262 Registers</h1>
<p><em>What‚Äôs the simplest way to test our SX1262 Library?</em></p>
<p>To test whether our SX1262 Library is sending SPI Commands correctly to the SX1262 Transceiver, we can read the <strong>SX1262 Registers</strong>.</p>
<p>Here‚Äôs how: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L155-L171">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main Function
int main(int argc, FAR char *argv[]) {
  //  Read SX1262 registers 0x00 to 0x0F
  read_registers();
  return 0;
}

/// Read SX1262 registers
static void read_registers(void) {
  //  Init the SPI port
  SX126xIoInit();

  //  Read and print the first 16 registers: 0 to 15
  for (uint16_t addr = 0; addr &lt; 0x10; addr++) {
    //  Read the register
    uint8_t val = SX126xReadRegister(addr);

    //  Print the register value
    printf(&quot;Register 0x%02x = 0x%02x\n&quot;, addr, val);
  }
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L75-L94">(<strong>SX126xIoInit</strong> is defined here)</a></p>
<p>In our Test App we call <strong>read_registers</strong> and <strong>SX126xReadRegister</strong> to read a bunch of SX1262 Registers. (<code>0x00</code> to <code>0x0F</code>)</p>
<p>In our SX1262 Library, <strong>SX126xReadRegister</strong> calls <strong>SX126xReadRegisters</strong> and <strong>sx126x_read_register</strong> to read each register: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L286-L299">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Read an SX1262 Register at the specified address
uint8_t SX126xReadRegister(uint16_t address) {
  //  Read one register and return the value
  uint8_t data;
  SX126xReadRegisters(address, &amp;data, 1);
  return data;
}

/// Read one or more SX1262 Registers at the specified address.
/// `size` is the number of registers to read.
void SX126xReadRegisters(uint16_t address, uint8_t *buffer, uint16_t size) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady();

  //  Read the SX1262 registers
  int rc = sx126x_read_register(NULL, address, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy();
}
</code></pre></div>
<p>(We‚Äôll see <strong>SX126xCheckDeviceReady</strong> and <strong>SX126xWaitOnBusy</strong> in a while)</p>
<p><strong>sx126x_read_register</strong> reads a register by sending the Read Register Command to SX1262 over SPI: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L556-L565">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Send a Read Register Command to SX1262 over SPI
/// and return the results in `buffer`. `size` is the
/// number of registers to read.
static int sx126x_read_register(const void* context, const uint16_t address, uint8_t* buffer, const uint8_t size) {
  //  Reserve 4 bytes for our SX1262 Command Buffer
  uint8_t buf[SX126X_SIZE_READ_REGISTER] = { 0 };

  //  Init the SX1262 Command Buffer
  buf[0] = RADIO_READ_REGISTER;       //  Command ID (0x1D)
  buf[1] = (uint8_t) (address &gt;&gt; 8);  //  MSB of Register ID
  buf[2] = (uint8_t) (address &gt;&gt; 0);  //  LSB of Register ID
  buf[3] = 0;                         //  Unused

  //  Transmit the Command Buffer over SPI 
  //  and receive the Result Buffer
  int status = sx126x_hal_read( 
    context,  //  Context (unsued)
    buf,      //  Command Buffer
    SX126X_SIZE_READ_REGISTER,  //  Command Buffer Size: 4 bytes
    buffer,   //  Result Buffer
    size,     //  Result Buffer Size
    NULL      //  Status not required
  );
  return status;
}
</code></pre></div>
<p>(More about <strong>sx126x_hal_read</strong> later)</p>
<p>This transmits the following <strong>Read Register Command</strong> to SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>1d 00 08 00 00 
</code></pre></div>
<p>(<code>0x1D</code> is the Command ID, <code>0x08</code> is the Register ID)</p>
<p>SX1262 responds with‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a2 a2 a2 a2 80 
</code></pre></div>
<p>The last byte is the <strong>Register Value</strong>: <code>0x80</code></p>
<h2 id="build-the-firmware"><a class="doc-anchor" href="#build-the-firmware">¬ß</a>3.1 Build the Firmware</h2>
<p>Let‚Äôs build the modified NuttX Firmware that contains our <strong>LoRa SX1262 Library and Test App</strong>‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the modified source code‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive --branch sx1262 https://github.com/lupyuen/nuttx nuttx
git clone --recursive --branch sx1262 https://github.com/lupyuen/nuttx-apps apps
</code></pre></div>
<p>Note that we‚Äôre using the older <strong>‚Äúsx1262‚Äù</strong> branches of the NuttX OS and NuttX Apps repos, which <a href="https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library"><strong>don‚Äôt use GPIO Interface and NimBLE Porting Layer</strong></a>. (And don‚Äôt support LoRaWAN)</p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features">(<strong>For PineDio Stack BL604:</strong> The SX1262 Library and Test App are already preinstalled)</a></p>
</li>
<li>
<p>Edit <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L100-L101"><strong>apps/examples/sx1262_test_main.c</strong></a> and uncomment‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define READ_REGISTERS
</code></pre></div></li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Edit the Build Config
make menuconfig 
</code></pre></div></li>
<li>
<p>Enable the <strong>GPIO Driver</strong> in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#enable-gpio-driver"><strong>‚ÄúEnable GPIO Driver‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-menu7a.png" alt="Enable the GPIO Driver" /></p>
</li>
<li>
<p>Enable the <strong>SPI Peripheral</strong> and <strong>SPI Character Driver</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-debug.jpg" alt="Enable SPI" /></p>
</li>
<li>
<p>Enable our <strong>SPI Test Driver</strong> ‚Äú/dev/spitest0‚Äù‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver6.png" alt="Select SPI Test Driver" /></p>
</li>
<li>
<p>Enable <strong>GPIO and SPI Logging</strong> for easier troubleshooting‚Ä¶</p>
<p>(Might be good to uncheck <strong>‚ÄúGPIO Informational Output‚Äù</strong> and <strong>‚ÄúSPI Informational Output‚Äù</strong>)</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-logging"><strong>‚ÄúEnable Logging‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver4.png" alt="Enable Logging" /></p>
</li>
<li>
<p>Enable our <strong>SX1262 Library</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#enable-library"><strong>‚ÄúEnable Library‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone7.png" alt="Enable Library" /></p>
</li>
<li>
<p>Enable our <strong>SX1262 Test App</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong> ‚Üí <strong>‚ÄúSX1262 Test‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone8.png" alt="Enable SX1262 Test App" /></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/ec97cff54064c9f9d7d1c700c035b777">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p><strong>For ESP32:</strong> Edit <a href="https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup.c</strong></a> to register our SPI Test Driver <a href="https://lupyuen.github.io/articles/spi2#register-device-driver">(See this)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
</ol>
<h2 id="run-the-firmware"><a class="doc-anchor" href="#run-the-firmware">¬ß</a>3.2 Run the Firmware</h2>
<p>Finally we run the NuttX Firmware and test our <strong>LoRa SX1262 Library</strong>‚Ä¶</p>
<ol>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev
</code></pre></div>
<p>Our SPI Test Driver should appear as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver10.png" alt="Our SPI Test Driver appears as ‚Äú/dev/spitest0‚Äù" /></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test
</code></pre></div></li>
<li>
<p>We should see these <strong>SX1262 Register Values</strong> (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Register 0x00 = 0x00
...
Register 0x08 = 0x80
Register 0x09 = 0x00
Register 0x0a = 0x01
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/1e732f5b1e0e4a80d1eb351ab3aadede">(See the Output Log)</a></p>
<p>Our LoRa SX1262 Library talks OK to the SX1262 Transceiver!</p>
<p>Note that the values above will change when we <strong>transmit and receive LoRa Messages</strong>. Let‚Äôs do that now.</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-read5.jpg" alt="Reading SX1262 Registers" /></p>
<h2 id="source-files"><a class="doc-anchor" href="#source-files">¬ß</a>3.3 Source Files</h2>
<p><em>We‚Äôre seeing layers of code, like an onion? (Or Shrek)</em></p>
<p>Yep our SX1262 Library is structured as <strong>layers of Source Files</strong> because we hope to support three platforms‚Ä¶</p>
<ol>
<li>
<p><strong>NuttX</strong> (Just Completed)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/usb"><strong>Linux</strong></a> (Completed: PineDio USB)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan"><strong>BL602 IoT SDK</strong></a> (Completed)</p>
</li>
</ol>
<p>The <strong>Platform-Independent</strong> Source Files shared by all platforms are‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c"><strong>src/sx126x.c</strong></a></p>
<p>(Semtech‚Äôs Driver for SX1262 Transceiver)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c"><strong>src/radio.c</strong></a></p>
<p>(Semtech‚Äôs Radio Interface for LoRa Transceivers)</p>
</li>
</ul>
<p>(We should minimise changes to the above files, because they will be called by Semtech‚Äôs LoRaWAN Driver)</p>
<p>The <strong>Platform-Specific</strong> Source Files for NuttX are‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c"><strong>src/sx126x-nuttx.c</strong></a></p>
<p>(NuttX Interface for SX1262)</p>
</li>
</ul>
<p>The Source Files are called like this‚Ä¶</p>
<p><strong>Test App</strong> ‚Üí <strong>radio.c</strong> ‚Üí <strong>sx126x.c</strong> ‚Üí <strong>sx126x-nuttx.c</strong></p>
<h1 id="lora-parameters"><a class="doc-anchor" href="#lora-parameters">¬ß</a>4 LoRa Parameters</h1>
<p>Before we transmit and receive LoRa Messages, let‚Äôs talk about the <strong>LoRa Parameters</strong>.</p>
<p>Check this doc to find out which <strong>LoRa Frequency</strong> we should use for our region‚Ä¶</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>We set the <strong>LoRa Frequency</strong> in our SX1262 Test App like so: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L45">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923
</code></pre></div>
<p>Change <strong>USE_BAND_923</strong> to <strong>USE_BAND_433</strong>, <strong>780</strong>, <strong>868</strong> or <strong>915</strong>.</p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L33-L45">(See the complete list)</a></p>
<p>Below are the other <strong>LoRa Parameters</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L47-L66">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// LoRa Parameters
#define LORAPING_TX_OUTPUT_POWER            14        /* dBm */

#define LORAPING_BANDWIDTH                  0         /* [0: 125 kHz, */
                                                      /*  1: 250 kHz, */
                                                      /*  2: 500 kHz, */
                                                      /*  3: Reserved] */
#define LORAPING_SPREADING_FACTOR           7         /* [SF7..SF12] */
#define LORAPING_CODINGRATE                 1         /* [1: 4/5, */
                                                      /*  2: 4/6, */
                                                      /*  3: 4/7, */
                                                      /*  4: 4/8] */
#define LORAPING_PREAMBLE_LENGTH            8         /* Same for Tx and Rx */
#define LORAPING_SYMBOL_TIMEOUT             5         /* Symbols */
#define LORAPING_FIX_LENGTH_PAYLOAD_ON      false
#define LORAPING_IQ_INVERSION_ON            false

#define LORAPING_TX_TIMEOUT_MS              3000    /* ms */
#define LORAPING_RX_TIMEOUT_MS              10000    /* ms */
#define LORAPING_BUFFER_SIZE                64      /* LoRa message size */
</code></pre></div>
<p><a href="https://www.thethingsnetwork.org/docs/lorawan/spreading-factors/">(More about LoRa Parameters)</a></p>
<p>During testing, these should <strong>match the LoRa Parameters</strong> used by the LoRa Transmitter / Receiver.</p>
<p>In a while we‚Äôll use <a href="https://lupyuen.github.io/articles/wisblock"><strong>RAKwireless WisBlock</strong></a> (pic below) to test our SX1262 Library. </p>
<p>Below are the <strong>LoRa Transmitter and Receiver</strong> programs (Arduino) that we‚Äôll run on WisBlock‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter"><strong>wisblock-lora-transmitter</strong></a></p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L38-L54">(LoRa Parameters for Transmitter)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver"><strong>wisblock-lora-receiver</strong></a></p>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver/blob/main/src/main.cpp#L37-L56">(LoRa Parameters for Receiver)</a></p>
</li>
</ul>
<p>The LoRa Parameters above should match the ones in our SX1262 Test App for NuttX.</p>
<p><em>Are there practical limits on the LoRa Parameters?</em></p>
<p>Yes we need to comply with the <strong>Local Regulations</strong> on the usage of <a href="https://en.wikipedia.org/wiki/ISM_radio_band"><strong>ISM Radio Bands</strong></a>: FCC, ETSI, ‚Ä¶</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/regional-parameters/"><strong>‚ÄúRegional Parameters‚Äù</strong></a></li>
</ul>
<p>(Blasting LoRa Messages non-stop is no-no!)</p>
<p><img src="https://lupyuen.github.io/images/wisblock-title.jpg" alt="RAKwireless WisBlock LPWAN Module mounted on WisBlock Base Board" /></p>
<h2 id="initialise-lora-sx1262"><a class="doc-anchor" href="#initialise-lora-sx1262">¬ß</a>4.1 Initialise LoRa SX1262</h2>
<p>Let‚Äôs watch how the LoRa Parameters are used to <strong>initialise the SX1262 Transceiver</strong>.</p>
<p>The <strong>init_driver</strong> function in our Test App takes the LoRa Parameters and initialises LoRa SX1262 like so: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L173-L227">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to initialise the LoRa Driver.
/// Assume that create_task has been called to init the Event Queue.
static void init_driver(char *buf, int len, int argc, char **argv) {
  //  Set the LoRa Callback Functions
  RadioEvents_t radio_events;
  memset(&amp;radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
  radio_events.TxDone    = on_tx_done;     //  Packet has been transmitted
  radio_events.RxDone    = on_rx_done;     //  Packet has been received
  radio_events.TxTimeout = on_tx_timeout;  //  Transmit Timeout
  radio_events.RxTimeout = on_rx_timeout;  //  Receive Timeout
  radio_events.RxError   = on_rx_error;    //  Receive Error
</code></pre></div>
<p>Here we set the <strong>Callback Functions</strong> that will be called when a LoRa Message has been transmitted or received, also when we encounter a transmit / receive timeout or error.</p>
<p>(We‚Äôll see the Callback Functions in a while)</p>
<p>Next we call our SX1262 Library to initialise the LoRa Transceiver and set the <strong>LoRa Frequency</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init the SPI Port and the LoRa Transceiver
  Radio.Init(&amp;radio_events);

  //  Set the LoRa Frequency
  Radio.SetChannel(RF_FREQUENCY);
</code></pre></div>
<p>Then we set the <strong>LoRa Transmit Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the LoRa Transceiver for transmitting messages
  Radio.SetTxConfig(
    MODEM_LORA,
    LORAPING_TX_OUTPUT_POWER,
    0,        //  Frequency deviation: Unused with LoRa
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    LORAPING_TX_TIMEOUT_MS
  );
</code></pre></div>
<p>Finally we set the <strong>LoRa Receive Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the LoRa Transceiver for receiving messages
  Radio.SetRxConfig(
    MODEM_LORA,
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    0,        //  AFC bandwidth: Unused with LoRa
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_SYMBOL_TIMEOUT,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    0,        //  Fixed payload length: N/A
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    true      //  Continuous receive mode
  );    
}
</code></pre></div>
<p>The <strong>Radio</strong> functions are Platform-Independent, defined in our SX1262 Library: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c">radio.c</a></p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module"><strong>RadioInit:</strong></a> Init LoRa SX1262</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module">(<strong>RadioInit</strong> is explained here)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetchannel-set-lora-frequency"><strong>RadioSetChannel:</strong></a> Set LoRa Frequency</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetchannel-set-lora-frequency">(<strong>RadioSetChannel</strong> is explained here)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosettxconfig-set-transmit-configuration"><strong>RadioSetTxConfig:</strong></a> Set LoRa Transmit Configuration</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosettxconfig-set-transmit-configuration">(<strong>RadioSetTxConfig</strong> is explained here)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetrxconfig-set-receive-configuration"><strong>RadioSetRxConfig:</strong></a> Set LoRa Receive Configuration</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetrxconfig-set-receive-configuration">(<strong>RadioSetRxConfig</strong> is explained here)</a></p>
</li>
</ul>
<p>(The <strong>Radio</strong> functions will also be called when we implement LoRaWAN)</p>
<p><img src="https://lupyuen.github.io/images/sx1262-send.jpg" alt="Transmitting a LoRa Message" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">(Source)</a></p>
<h1 id="transmit-lora-message"><a class="doc-anchor" href="#transmit-lora-message">¬ß</a>5 Transmit LoRa Message</h1>
<p>Now we‚Äôre ready to <strong>transmit a LoRa Message</strong> in our SX1262 Test App! Here‚Äôs how: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L110-L121">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main Function
int main(void) {
  //  Init SX1262 driver
  init_driver();

  //  TODO: Do we need to wait?
  sleep(1);

  //  Send a LoRa message
  send_message();
  return 0;
}
</code></pre></div>
<p>We begin by calling <strong>init_driver</strong> in our Test App to set the LoRa Parameters and the Callback Functions.</p>
<p>(We‚Äôve seen <strong>init_driver</strong> in the previous section)</p>
<p>To transmit a LoRa Message, <strong>send_message</strong> calls <strong>send_once</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L229-L235">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Send a LoRa message. Assume that SX1262 driver has been initialised.
static void send_message(void) {
  //  Send the &quot;PING&quot; message
  send_once(1);
}
</code></pre></div>
<p><strong>send_once</strong> prepares a 64-byte LoRa Message containing the string ‚Äú<code>PING</code>‚Äù: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// We send a &quot;PING&quot; message and expect a &quot;PONG&quot; response
const uint8_t loraping_ping_msg[] = &quot;PING&quot;;
const uint8_t loraping_pong_msg[] = &quot;PONG&quot;;

/// 64-byte buffer for our LoRa message
static uint8_t loraping_buffer[LORAPING_BUFFER_SIZE];

/// Send a LoRa message. If is_ping is 0, send &quot;PONG&quot;. Otherwise send &quot;PING&quot;.
static void send_once(int is_ping) {
  //  Copy the &quot;PING&quot; or &quot;PONG&quot; message 
  //  to the transmit buffer
  if (is_ping) {
    memcpy(loraping_buffer, loraping_ping_msg, 4);
  } else {
    memcpy(loraping_buffer, loraping_pong_msg, 4);
  }
</code></pre></div>
<p>Then we <strong>pad the 64-byte message</strong> with values 0, 1, 2, ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Fill up the remaining space in the 
  //  transmit buffer (64 bytes) with values 
  //  0, 1, 2, ...
  for (int i = 4; i &lt; sizeof loraping_buffer; i++) {
    loraping_buffer[i] = i - 4;
  }
</code></pre></div>
<p>And we call our SX1262 Library to <strong>transmit the LoRa Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  We send the transmit buffer (64 bytes)
  Radio.Send(loraping_buffer, sizeof loraping_buffer);
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message">(<strong>RadioSend</strong> is explained here)</a></p>
<p>When the LoRa Message has been transmitted, the SX1262 Library calls our Callback Function <strong>on_tx_done</strong> defined in <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L267-L280">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when our LoRa message has been transmitted
static void on_tx_done(void) {
  //  Log the success status
  loraping_stats.tx_success++;

  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosleep-switch-to-sleep-mode">(<strong>RadioSleep</strong> is explained here)</a></p>
<p>Here we log the number of packets transmitted, and put LoRa SX1262 into <strong>low power, sleep mode</strong>.</p>
<p>Note: <strong>on_tx_done</strong> won‚Äôt actually be called in our current driver, because we haven‚Äôt implemented Multithreading. (More about this later)</p>
<p>To handle Transmit Timeout Errors, we define the Callback Function <strong>on_tx_timeout</strong>: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L314-L326">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when our LoRa message couldn&#39;t be transmitted due to timeout
static void on_tx_timeout(void) {
  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.tx_timeout++;
}
</code></pre></div><h2 id="run-the-firmware-1"><a class="doc-anchor" href="#run-the-firmware-1">¬ß</a>5.1 Run the Firmware</h2>
<p>Let‚Äôs test our SX1262 Library and <strong>transmit a LoRa Message</strong>‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>Edit <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L116-L117"><strong>apps/examples/sx1262_test_main.c</strong></a> and uncomment‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define SEND_MESSAGE
</code></pre></div></li>
<li>
<p>Also edit <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L66"><strong>sx1262_test_main.c</strong></a> and set the <strong>LoRa Parameters</strong>. (As explained earlier)</p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>Switch over to <strong>RAKwireless WisBlock</strong> and run our <strong>LoRa Receiver</strong>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver"><strong>wisblock-lora-receiver</strong></a></p>
<p>Check that the <strong>LoRa Parameters</strong> are correct‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver/blob/main/src/main.cpp#L37-L56"><strong>LoRa Parameters for WisBlock Receiver</strong></a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test
</code></pre></div></li>
<li>
<p>We should see our SX1262 Library transmitting a 64-byte <strong>LoRa Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>send_message
RadioSend: size=64
50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">(‚Äú<code>PING</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
<p><a href="https://gist.github.com/lupyuen/5fdede131ad0e327478994872f190668">(See the Output Log)</a></p>
</li>
<li>
<p>On WisBlock we should see the same 64-byte <strong>LoRa Message</strong> received by WisBlock‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LoRaP2P Rx Test
Starting Radio.Rx
OnRxDone: Timestamp=18, RssiValue=-28 dBm, SnrValue=13, 
Data=50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b
</code></pre></div>
<p>Our SX1262 Library has successfully transmitted a 64-byte LoRa Message to RAKwireless WisBlock!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-send2.jpg" alt="Our SX1262 Library transmits a LoRa Message to RAKwireless WisBlock" /></p>
<p>In case of problems, try troubleshooting with a Software Defined Radio like Airspy R2‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sx1262-title.jpg" alt="PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)" /></p>
<h2 id="spectrum-analysis-with-sdr"><a class="doc-anchor" href="#spectrum-analysis-with-sdr">¬ß</a>5.2 Spectrum Analysis with SDR</h2>
<p><em>What if nothing appears in our LoRa Receiver?</em></p>
<p>Use a <strong>Spectrum Analyser</strong> (like a <strong>Software Defined Radio</strong>) to sniff the airwaves and check whether our LoRa Message is transmitted‚Ä¶</p>
<ol>
<li>
<p>At the right <strong>Radio Frequency</strong></p>
<p>(923 MHz below)</p>
</li>
<li>
<p>With <strong>sufficient power</strong></p>
<p>(Red stripe below)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-sdr.jpg" alt="Spectrum Analysis of LoRa Message with SDR" /></p>
<p>LoRa Messages have a characteristic criss-cross shape: <strong>LoRa Chirp</strong>. (Like above)</p>
<p>More about LoRa Chirps and Software Defined Radio‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora#visualise-lora-with-software-defined-radio"><strong>‚ÄúVisualise LoRa with Software Defined Radio‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/sx1262-receive.png" alt="Receiving a LoRa Message" /></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L123-L262">(Source)</a></p>
<h1 id="receive-lora-message"><a class="doc-anchor" href="#receive-lora-message">¬ß</a>6 Receive LoRa Message</h1>
<p>Watch the (turn)tables turn as we <strong>receive a LoRa Message</strong> with our SX1262 Library! This is how we do it: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L107-L137">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main Function
int main(void) {
  //  TODO: Create a Background Thread 
  //  to handle LoRa Events
  create_task();
</code></pre></div>
<p>We start by creating a <strong>Background Thread</strong> to handle LoRa Events in our Test App.</p>
<p>(<strong>create_task</strong> doesn‚Äôt do anything because we haven‚Äôt implemented Multithreading. More about this later)</p>
<p>Next we set the <strong>LoRa Parameters</strong> and the <strong>Callback Functions</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init SX1262 driver
  init_driver();

  //  TODO: Do we need to wait?
  sleep(1);
</code></pre></div>
<p>(Yep the same <strong>init_driver</strong> we‚Äôve seen earlier)</p>
<p>For the next <strong>10 seconds</strong> we poll and handle LoRa Events (like Message Received)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Handle LoRa events for the next 10 seconds
  for (int i = 0; i &lt; 10; i++) {
    //  Prepare to receive a LoRa message
    receive_message();

    //  Process the received LoRa message, if any
    RadioOnDioIrq(NULL);
    
    //  Sleep for 1 second
    usleep(1000 * 1000);
  }
  return 0;
}
</code></pre></div>
<p>(Polling isn‚Äôt efficient, we‚Äôll discuss the enhancements later)</p>
<p>We call <strong>receive_message</strong> to get SX1262 ready to receive a single LoRa Message.</p>
<p>Then we call <strong>RadioOnDioIrq</strong> (from our SX1262 Library) to handle the Message Received Event. (If any)</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioondioirq">(<strong>RadioOnDioIrq</strong> is explained here)</a></p>
<p><strong>receive_message</strong> is defined in our Test App: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L255-L262">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Receive a LoRa message. Assume that SX1262 driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(void) {
  //  Receive a LoRa message within the timeout period
  Radio.Rx(LORAPING_RX_TIMEOUT_MS);
}
</code></pre></div>
<p>This code calls <strong>RadioRx</strong> (from our SX1262 Library) to prep SX1262 to receive a single LoRa Message.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiorx-receive-message">(<strong>RadioRx</strong> is explained here)</a></p>
<p>When our SX1262 Library receives a LoRa Message, it calls our Callback Function <strong>on_rx_done</strong> defined in our Test App: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L282-L312">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
  uint8_t *payload,  //  Buffer containing received LoRa message
  uint16_t size,     //  Size of the LoRa message
  int16_t rssi,      //  Signal strength
  int8_t snr) {      //  Signal To Noise ratio

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the signal strength, signal to noise ratio
  loraping_rxinfo_rxed(rssi, snr);
</code></pre></div>
<p><strong>on_rx_done</strong> switches the LoRa Transceiver to low power, sleep mode and logs the received packet.</p>
<p>Next we <strong>copy the received packet</strong> into a buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Copy the received packet
  if (size &gt; sizeof loraping_buffer) {
    size = sizeof loraping_buffer;
  }
  loraping_rx_size = size;
  memcpy(loraping_buffer, payload, size);
</code></pre></div>
<p>Finally we <strong>dump the buffer</strong> containing the received packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Dump the contents of the received packet
  for (int i = 0; i &lt; loraping_rx_size; i++) {
    printf(&quot;%02x &quot;, loraping_buffer[i]);
  }
  puts(&quot;&quot;);
}
</code></pre></div>
<p><em>What happens when we don‚Äôt receive a packet in 10 seconds? (LORAPING_RX_TIMEOUT_MS)</em></p>
<p>Our SX1262 Library calls our Callback Function <strong>on_rx_timeout</strong> defined in our Test App: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L328-L341">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.rx_timeout++;
}
</code></pre></div>
<p>We switch the LoRa Transceiver into sleep mode and log the timeout.</p>
<p>Note: <strong>on_rx_timeout</strong> won‚Äôt actually be called in our current driver, because we haven‚Äôt implemented Multithreading. (More about this later)</p>
<p>To handle Receive Errors, we define the Callback Function <strong>on_rx_error</strong> in our Test App: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L343-L355">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when we couldn&#39;t receive a LoRa message due to error
static void on_rx_error(void) {
  //  Log the error
  loraping_stats.rx_error++;

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();
}
</code></pre></div><h2 id="run-the-firmware-2"><a class="doc-anchor" href="#run-the-firmware-2">¬ß</a>6.1 Run the Firmware</h2>
<p>Let‚Äôs test our SX1262 Library and <strong>receive a LoRa Message</strong>‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>Edit <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L123-L124"><strong>apps/examples/sx1262_test_main.c</strong></a> and uncomment‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define RECEIVE_MESSAGE
</code></pre></div></li>
<li>
<p>Also edit <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L66"><strong>sx1262_test_main.c</strong></a> and set the <strong>LoRa Parameters</strong>. (As explained earlier)</p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>Switch over to <strong>RAKwireless WisBlock</strong> and run our <strong>LoRa Transmitter</strong>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter"><strong>wisblock-lora-transmitter</strong></a></p>
<p>Check that the <strong>LoRa Parameters</strong> are correct‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L38-L54"><strong>LoRa Parameters for WisBlock Transmitter</strong></a></p>
</li>
<li>
<p>WisBlock transmits a 64-byte <strong>LoRa Message</strong> every 5 seconds‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LoRap2p Tx Test
send: 48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a
OnTxDone
</code></pre></div>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L120-L144">(‚Äú<code>Hello</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test
</code></pre></div></li>
<li>
<p>On NuttX we should see the same 64-byte <strong>LoRa Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>IRQ_RX_DONE
48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a
IRQ_PREAMBLE_DETECTED
IRQ_HEADER_VALID
receive_message
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b">(See the Output Log)</a></p>
<p>Congratulations our SX1262 Library has successfully received the 64-byte LoRa Message from RAKwireless WisBlock!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-receive2.jpg" alt="Our SX1262 Library receives a LoRa Message from RAKwireless WisBlock" /></p>
<h1 id="spi-interface"><a class="doc-anchor" href="#spi-interface">¬ß</a>7 SPI Interface</h1>
<p><em>Porting the SX1262 Library from Linux to NuttX‚Ä¶ Was it difficult?</em></p>
<p>Not at all! NuttX works much like Linux because of its <a href="https://lupyuen.github.io/articles/nuttx"><strong>POSIX Compliance</strong></a>.</p>
<p>Most of the porting effort <a href="https://lupyuen.github.io/images/sx1262-git.png">(14 minutes!)</a> was spent on‚Ä¶</p>
<ol>
<li>
<p><strong>SPI Interface</strong></p>
</li>
<li>
<p><strong>GPIO Interface</strong></p>
</li>
</ol>
<p>Because the interfaces work differently on NuttX vs Linux.</p>
<p>Let‚Äôs dive into the SPI Interface: How we initialise the interface and transfer data over SPI.</p>
<p><img src="https://lupyuen.github.io/images/spi2-plan2.jpg" alt="SPI Test Driver" /></p>
<h2 id="initialise-spi"><a class="doc-anchor" href="#initialise-spi">¬ß</a>7.1 Initialise SPI</h2>
<p>In the previous article we have created an <strong>SPI Test Driver ‚Äú/dev/spitest0‚Äù</strong> that exposes the SPI Interface to NuttX Apps (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2"><strong>‚ÄúSPI on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p>Our SX1262 Library opens the SPI Test Driver to <strong>initialise the SPI Bus</strong> like so: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L782-L804">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// SPI Bus
static int spi = 0;

/// Chip Select Pin (GPIO Output)
static int cs = 0;

/// Init the SPI Bus and Chip Select Pin. Return 0 on success.
static int init_spi(void) {
  //  Open the SPI Bus (SPI Test Driver).
  //  Defaults to &quot;/dev/spitest0&quot;
  spi = open(SPI_DEVPATH, O_RDWR);
  assert(spi &gt; 0);

  //  Open GPIO Output for SPI Chip Select.
  //  Defaults to &quot;/dev/gpio1&quot;
  cs = open(CS_DEVPATH, O_RDWR);
  assert(cs &gt; 0);

  //  Get SPI Chip Select Pin Type
  enum gpio_pintype_e pintype;
  int ret = ioctl(cs, GPIOC_PINTYPE, (unsigned long)((uintptr_t)&amp;pintype));
  assert(ret &gt;= 0);

  //  Verify that SPI Chip Select is GPIO Output (not GPIO Input or GPIO Interrupt)
  assert(pintype == GPIO_OUTPUT_PIN);

  //  TODO: Set SPI Chip Select to High for all SPI Devices
  return 0;
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths">(<strong>SPI_DEVPATH</strong> and <strong>CS_DEVPATH</strong> are explained in the Appendix)</a></p>
<p><strong>init_spi</strong> is called by <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L75-L94"><strong>SX126xIoInit</strong></a>, which is called by <a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module"><strong>RadioInit</strong></a> and <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L173-L227"><strong>init_driver</strong></a></p>
<p>(We‚Äôve seen <strong>init_driver</strong> earlier in our Test App)</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module">(<strong>RadioInit</strong> is explained here)</a></p>
<p><em>Where are SPI Mode and SPI Frequency defined?</em></p>
<p><strong>SPI Mode</strong> and <strong>SPI Frequency</strong> are defined in the SPI Test Driver‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#configure-spi"><strong>‚ÄúConfigure SPI‚Äù</strong></a></li>
</ul>
<p><em>Why did we use GPIO Output?</em></p>
<p>We‚Äôre controlling the <strong>SPI Chip Select Pin</strong> (/dev/gpio1) ourselves via GPIO Output, as explained below‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#control-chip-select-with-gpio"><strong>‚ÄúControl Chip Select with GPIO‚Äù</strong></a></li>
</ul>
<p>More about GPIO Output in the next section.</p>
<p><img src="https://lupyuen.github.io/images/sx1262-driver2a.png" alt="Initialise SPI" /></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L782-L804">(Source)</a></p>
<h2 id="transfer-spi"><a class="doc-anchor" href="#transfer-spi">¬ß</a>7.2 Transfer SPI</h2>
<p>To <strong>transfer SPI Data</strong> to SX1262 via our SPI Test Driver, we do this: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L806-L832">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Blocking call to transmit and receive buffers on SPI. Return 0 on success.
static int transfer_spi(const uint8_t *tx_buf, uint8_t *rx_buf, uint16_t len) {
  assert(spi &gt; 0);
  assert(cs  &gt; 0);
  assert(len &gt; 0);
  assert(len &lt;= SPI_BUFFER_SIZE);
  _info(&quot;spi tx: &quot;); for (int i = 0; i &lt; len; i++) { _info(&quot;%02x &quot;, tx_buf[i]); } _info(&quot;\n&quot;);

  //  Set SPI Chip Select to Low
  int ret = ioctl(cs, GPIOC_WRITE, 0);
  assert(ret &gt;= 0);

  //  Transmit data over SPI
  int bytes_written = write(spi, tx_buf, len);
  assert(bytes_written == len);

  //  Receive SPI response
  int bytes_read = read(spi, rx_buf, len);
  assert(bytes_read == len);

  //  Set SPI Chip Select to High
  ret = ioctl(cs, GPIOC_WRITE, 1);
  assert(ret &gt;= 0);

  _info(&quot;spi rx: &quot;); for (int i = 0; i &lt; len; i++) { _info(&quot;%02x &quot;, rx_buf[i]); } _info(&quot;\n&quot;);
  return 0;
}
</code></pre></div>
<p>Note that we control <strong>SPI Chip Select</strong> ourselves with GPIO Output. The code above is explained in‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#gpio-output-as-chip-select"><strong>‚ÄúGPIO Output as Chip Select‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs watch how <strong>transfer_spi</strong> is called by our SX1262 Library to transmit and receive LoRa Messages.</p>
<p><img src="https://lupyuen.github.io/images/sx1262-driver3.jpg" alt="Transfer SPI" /></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L806-L832">(Source)</a></p>
<h2 id="transmit-message"><a class="doc-anchor" href="#transmit-message">¬ß</a>7.3 Transmit Message</h2>
<p>Later as we walk through the <strong>sending of a LoRa Message</strong> <a href="https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message">(<strong>RadioSend</strong>)</a>, we‚Äôll learn that our SX1262 Driver calls this function to transfer the LoRa Message to SX1262: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L567-L573">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int sx126x_write_buffer(const void* context, const uint8_t offset, const uint8_t* buffer, const uint8_t size) {
  //  Prepare the Write Buffer Command (2 bytes)
  uint8_t buf[SX126X_SIZE_WRITE_BUFFER] = { 0 };
  buf[0] = RADIO_WRITE_BUFFER;  //  Write Buffer Command: 0x0E
  buf[1] = offset;              //  Write Buffer Offset

  //  Transfer the Write Buffer Command to SX1262 over SPI
  return sx126x_hal_write(
    context,  //  Context
    buf,      //  Command Buffer
    SX126X_SIZE_WRITE_BUFFER,  //  Command Buffer Size (2 bytes)
    buffer,   //  Write Data Buffer
    size      //  Write Data Buffer Size
  );
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message">(<strong>sx126x_write_buffer</strong> is called by <strong>RadioSend</strong>)</a></p>
<p>In code above we prepare a <strong>SX1262 Write Buffer Command</strong> (<code>0x0E 0x00</code>) and pass the Command Buffer (plus Data Buffer) to <strong>sx126x_hal_write</strong>.</p>
<p>(Data Buffer contains the 64-byte <strong>LoRa Message</strong> to be transmitted)</p>
<p>Note that <strong>Write Buffer Offset is always 0</strong>, because of <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L144-L147"><strong>SX126xSetPayload</strong></a> and <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L301-L307"><strong>SX126xWriteBuffer</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message">(<strong>SX126xSetPayload</strong> and <strong>SX126xWriteBuffer</strong> are explained here)</a></p>
<p><strong>sx126x_hal_write</strong> calls <strong>transfer_spi</strong> to transfer the Command Buffer and Data Buffer over SPI: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L606-L643">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/**
 * Radio data transfer - write
 *
 * @remark Shall be implemented by the user
 *
 * @param [in] context          Radio implementation parameters
 * @param [in] command          Pointer to the buffer to be transmitted
 * @param [in] command_length   Buffer size to be transmitted
 * @param [in] data             Pointer to the buffer to be transmitted
 * @param [in] data_length      Buffer size to be transmitted
 *
 * @returns Operation status
 */
static int sx126x_hal_write( 
  const void* context, const uint8_t* command, const uint16_t command_length,
  const uint8_t* data, const uint16_t data_length ) {
  printf(&quot;sx126x_hal_write: command_length=%d, data_length=%d\n&quot;, command_length, data_length);

  //  Total length is command + data length
  uint16_t len = command_length + data_length;
  assert(len &gt; 0);
  assert(len &lt;= SPI_BUFFER_SIZE);

  //  Clear the SPI Transmit and Receive buffers
  memset(&amp;spi_tx_buf, 0, len);
  memset(&amp;spi_rx_buf, 0, len);

  //  Copy command bytes to SPI Transmit Buffer
  memcpy(&amp;spi_tx_buf, command, command_length);

  //  Copy data bytes to SPI Transmit Buffer
  memcpy(&amp;spi_tx_buf[command_length], data, data_length);

  //  Transmit and receive the SPI buffers
  int rc = transfer_spi(spi_tx_buf, spi_rx_buf, len);
  assert(rc == 0);
  return 0;
}
</code></pre></div>
<p>(We‚Äôve seen <strong>transfer_spi</strong> in the previous section)</p>
<p><em>What are spi_tx_buf and spi_rx_buf?</em></p>
<p>They are the internal <strong>1024-byte buffers for SPI Transfers</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L588-L601">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Max size of SPI transfers
#define SPI_BUFFER_SIZE 1024

/// SPI Transmit Buffer
static uint8_t spi_tx_buf[SPI_BUFFER_SIZE];

/// SPI Receive Buffer
static uint8_t spi_rx_buf[SPI_BUFFER_SIZE];
</code></pre></div><h2 id="receive-message"><a class="doc-anchor" href="#receive-message">¬ß</a>7.4 Receive Message</h2>
<p>Later as we inspect the code that <strong>receives LoRa Messages</strong>, we‚Äôll see that our SX1262 Library calls this function when a <strong>Receive Done Event</strong> is triggered: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L575-L583">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int sx126x_read_buffer(const void* context, const uint8_t offset, uint8_t* buffer, const uint8_t size) {
  //  Prepare the Read Buffer Command (3 bytes)
  uint8_t buf[SX126X_SIZE_READ_BUFFER] = { 0 };
  buf[0] = RADIO_READ_BUFFER;  //  Read Buffer Command: 0x1E
  buf[1] = offset;             //  Read Buffer Offset
  buf[2] = 0;                  //  NOP

  //  Transfer the Read Buffer Command to SX1262 over SPI
  int status = sx126x_hal_read( 
    context,  //  Context
    buf,      //  Command Buffer
    SX126X_SIZE_READ_BUFFER,  //  Command Buffer Size (3 bytes)
    buffer,   //  Read Data Buffer
    size,     //  Read Data Buffer Size
    NULL      //  Ignore the status
  );
  return status;
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done">(<strong>sx126x_read_buffer</strong> is called by the <strong>Receive Done Event</strong>)</a></p>
<p>In this code we prepare a <strong>SX1262 Read Buffer Command</strong> (<code>0x1E 0x00 0x00</code>) and pass the Command Buffer (plus Data Buffer) to <strong>sx126x_hal_read</strong>.</p>
<p>(Data Buffer will contain the received 64-byte <strong>LoRa Message</strong>)</p>
<p>Note that <strong>Read Buffer Offset is always 0</strong>, because of <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L149-L160"><strong>SX126xGetPayload</strong></a> and <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L309-L315"><strong>SX126xReadBuffer</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done">(<strong>SX126xGetPayload</strong> and <strong>SX126xReadBuffer</strong> are explained here)</a></p>
<p><strong>sx126x_hal_read</strong> calls <strong>transfer_spi</strong> to transfer the Command Buffer over SPI: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L645-L689">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/**
 * Radio data transfer - read
 *
 * @remark Shall be implemented by the user
 *
 * @param [in] context          Radio implementation parameters
 * @param [in] command          Pointer to the buffer to be transmitted
 * @param [in] command_length   Buffer size to be transmitted
 * @param [in] data             Pointer to the buffer to be received
 * @param [in] data_length      Buffer size to be received
 * @param [out] status          If not null, return the second SPI byte received as status
 *
 * @returns Operation status
 */
static int sx126x_hal_read( 
  const void* context, const uint8_t* command, const uint16_t command_length,
  uint8_t* data, const uint16_t data_length, uint8_t *status ) {
  printf(&quot;sx126x_hal_read: command_length=%d, data_length=%d\n&quot;, command_length, data_length);

  //  Total length is command + data length
  uint16_t len = command_length + data_length;
  assert(len &gt; 0);
  assert(len &lt;= SPI_BUFFER_SIZE);

  //  Clear the SPI Transmit and Receive buffers
  memset(&amp;spi_tx_buf, 0, len);
  memset(&amp;spi_rx_buf, 0, len);

  //  Copy command bytes to SPI Transmit Buffer
  memcpy(&amp;spi_tx_buf, command, command_length);

  //  Transmit and receive the SPI buffers
  int rc = transfer_spi(spi_tx_buf, spi_rx_buf, len);
  assert(rc == 0);

  //  Copy SPI Receive buffer to data buffer
  memcpy(data, &amp;spi_rx_buf[command_length], data_length);

  //  Return the second SPI byte received as status
  if (status != NULL) {
    assert(len &gt;= 2);
    *status = spi_rx_buf[1];
  }
  return 0;
}
</code></pre></div>
<p>And returns the <strong>Data Buffer</strong> received from SX1262 over SPI.</p>
<h2 id="spi-in-action"><a class="doc-anchor" href="#spi-in-action">¬ß</a>7.5 SPI In Action</h2>
<p>We‚Äôve talked about <a href="https://lupyuen.github.io/articles/sx1262#transmit-message"><strong>sx126x_write_buffer</strong></a> and <a href="https://lupyuen.github.io/articles/sx1262#receive-message"><strong>sx126x_read_buffer</strong></a>, let‚Äôs watch them in action as we <strong>transmit and receive</strong> 64-byte LoRa Messages.</p>
<p>To transmit a LoRa Message, <a href="https://lupyuen.github.io/articles/sx1262#transmit-message"><strong>sx126x_write_buffer</strong></a> sends the <strong>WriteBuffer Command</strong> to SX1262 over SPI‚Ä¶</p>
<ol>
<li>
<p><strong>WriteBuffer Command:</strong> <code>0x0E</code></p>
</li>
<li>
<p><strong>WriteBuffer Offset:</strong> <code>0x00</code></p>
</li>
<li>
<p><strong>WriteBuffer Data:</strong> Transfer 64 bytes</p>
</li>
</ol>
<p>This copies the <strong>entire 64-byte LoRa Message</strong> into the SX1262 Transmit Buffer as a <strong>single (huge) chunk</strong>.</p>
<p>This appears in the <a href="https://gist.github.com/lupyuen/5fdede131ad0e327478994872f190668"><strong>Transmit Log</strong></a> as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>sx126x_hal_write: 
  command_length=2, 
  data_length=64
spi tx: 
  0e 00 
  50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b
spi rx: 
  a2 a2 
  a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2
</code></pre></div>
<p>The <strong>64-byte LoRa Message</strong> transmitted appears in the <strong>SPI Transmit Log</strong> above: <code>50 49 4e 47...</code></p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">(‚Äú<code>50 49 4e 47...</code>‚Äù is ‚Äú<code>PING</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
<p>To receive a LoRa Message, <a href="https://lupyuen.github.io/articles/sx1262#receive-message"><strong>sx126x_read_buffer</strong></a> sends this <strong>ReadBuffer Command</strong> to SX1262 over SPI‚Ä¶</p>
<ol>
<li>
<p><strong>ReadBuffer Command:</strong> <code>0x1E</code></p>
</li>
<li>
<p><strong>ReadBuffer Offset:</strong> <code>0x00</code></p>
</li>
<li>
<p><strong>ReadBuffer NOP:</strong> <code>0x00</code></p>
</li>
<li>
<p><strong>ReadBuffer Data:</strong> Transfer 64 bytes</p>
</li>
</ol>
<p>Which appears in the <a href="https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b"><strong>Receive Log</strong></a> as‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>sx126x_hal_read: 
  command_length=3, 
  data_length=64
spi tx: 
  1e 00 00 
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
spi rx: 
  d2 d2 d2 
  48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 
</code></pre></div>
<p>The <strong>64-byte LoRa Message</strong> received appears in the <strong>SPI Receive Log</strong> above: <code>48 65 6c 6c 6f...</code></p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L120-L144">(‚Äú<code>48 65 6c 6c 6f...</code>‚Äù is ‚Äú<code>Hello</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
<h1 id="gpio-interface"><a class="doc-anchor" href="#gpio-interface">¬ß</a>8 GPIO Interface</h1>
<p><em>Besides SPI, what Interfaces do we need to control the SX1262 Transceiver?</em></p>
<p>Our SX1262 Library needs a <strong>GPIO Interface</strong> to control these <strong>SX1262 Pins</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>BUSY</strong> at /dev/gpio0: GPIO Input that tells us whether SX1262 is busy</p>
<p>(BUSY is High when SX1262 is busy)</p>
</li>
<li>
<p><strong>Chip Select</strong> at /dev/gpio1: Select or deselect SX1262 on the SPI Bus</p>
<p>(Chip Select is Low when SX1262 is selected)</p>
</li>
<li>
<p><strong>DIO1</strong> at /dev/gpio2: GPIO Interrupt used by SX1262 to signal that a LoRa Packet has been transmitted or received</p>
<p>(DIO1 shifts from Low to High when that happens)</p>
</li>
<li>
<p><strong>NRESET</strong>: GPIO Output that is toggled to reset the SX1262 module</p>
<p>(NRESET is not implemented yet. To reset SX1262, we power cycle the board. <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L163-L183">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#gpio-expander">(We might implement NRESET with a GPIO Expander)</a></p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths">(<strong>PineDio Stack BL604</strong> uses different GPIO Names, see the Appendix)</a></p>
<p>Let‚Äôs look at the implementation of the GPIO Interface for the <strong>new SX1262 Library that will support LoRaWAN</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library">(See this for the old SX1262 Library)</a></p>
<h2 id="initialise-gpio"><a class="doc-anchor" href="#initialise-gpio">¬ß</a>8.1 Initialise GPIO</h2>
<p>This function is called to initialise the GPIO Pins when our app starts: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L75-L94"><strong>SX126xIoInit</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Initialise GPIO Pins and SPI Port. Called by SX126xIoIrqInit.
/// Note: This is different from the Reference Implementation,
/// which initialises the GPIO Pins and SPI Port at startup.
void SX126xIoInit( void ) {
  //  Init the Event Queue if not initialised. 
  //  TimerInit is called before SX126xIoInit, 
  //  so the Event Queue should already be initialised.
  init_event_queue();

  //  Init GPIO Pins. Event Queue must be initialised before this.
  int rc = init_gpio();
  assert(rc == 0);

  //  Init SPI Bus
  rc = init_spi();
  assert(rc == 0);
}
</code></pre></div>
<p>(We‚Äôll see <strong>init_event_queue</strong> in the next chapter)</p>
<p>(We‚Äôve seen <strong>init_spi</strong> earlier)</p>
<p><strong>init_gpio</strong> initialises the GPIO Pins like so: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L725-L780">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// SX1262 Busy Pin (GPIO Input)
static int busy = 0;

/// SX1262 DIO1 Pin (GPIO Interrupt)
static int dio1 = 0;

/// Init the GPIO Pins. Return 0 on success.
static int init_gpio(void) {
  //  Open GPIO Input for SX1262 Busy Pin.
  //  Defaults to &quot;/dev/gpio0&quot;
  busy = open(BUSY_DEVPATH, O_RDWR);
  assert(busy &gt; 0);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths">(<strong>BUSY_DEVPATH</strong> is explained in the Appendix)</a></p>
<p>We begin by opening the GPIO Input for the <strong>Busy Pin</strong> ‚Äú/dev/gpio0‚Äù.</p>
<p>We fetch the <strong>GPIO Pin Type</strong> and verify that it‚Äôs GPIO Input‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get SX1262 Busy Pin Type
  enum gpio_pintype_e pintype;
  int ret = ioctl(  //  Execute a GPIO Command...
    busy,           //  GPIO Descriptor
    GPIOC_PINTYPE,  //  Get GPIO Pin Type
    (unsigned long)((uintptr_t) &amp;pintype)  //  Returned Pin Type
  );
  assert(ret &gt;= 0);

  //  Verify that SX1262 Busy Pin is GPIO Input (not GPIO Output or GPIO Interrupt)
  assert(pintype == GPIO_INPUT_PIN);  //  No pullup / pulldown
</code></pre></div>
<p>Next we open the GPIO Interrupt for the <strong>DIO1 Pin</strong> ‚Äú/dev/gpio2‚Äù.</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Open GPIO Interrupt for SX1262 DIO1 Pin
  //  Defaults to &quot;/dev/gpio2&quot;
  dio1 = open(DIO1_DEVPATH, O_RDWR);
  assert(dio1 &gt; 0);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths">(<strong>DIO1_DEVPATH</strong> is explained in the Appendix)</a></p>
<p>We fetch the <strong>GPIO Pin Type</strong> and verify that it‚Äôs GPIO Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get SX1262 DIO1 Pin Type
  ret = ioctl(      //  Execute a GPIO Command...
    dio1,           //  GPIO Descriptor
    GPIOC_PINTYPE,  //  Get GPIO Pin Type
    (unsigned long)((uintptr_t) &amp;pintype)  //  Returned Pin Type
  );
  assert(ret &gt;= 0);
  printf(&quot;DIO1 pintype before=%d\n&quot;, pintype);

  //  Verify that SX1262 DIO1 Pin is GPIO Interrupt (not GPIO Input or GPIO Output)
  assert(pintype == GPIO_INTERRUPT_PIN);
</code></pre></div>
<p>Remember that <strong>DIO1 shifts from Low to High</strong> when a LoRa Packet has been transmitted or received.</p>
<p>Thus we configure NuttX to trigger a <strong>GPIO Interrupt on Rising Edge</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Change DIO1 Pin to Trigger GPIO Interrupt on Rising Edge
  //  TODO: Crashes at ioexpander/gpio.c (line 544) because change failed apparently
  puts(&quot;init_gpio: change DIO1 to Trigger GPIO Interrupt on Rising Edge&quot;);
  ret = ioctl(         //  Execute a GPIO Command...
    dio1,              //  GPIO Descriptor
    GPIOC_SETPINTYPE,  //  Set GPIO Pin Type
    (unsigned long) GPIO_INTERRUPT_RISING_PIN  //  Requested Pin Type
  );
  assert(ret &gt;= 0);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-gpio-pin-type-issue">(This crashes NuttX with an Assertion Failure, so we have <strong>disabled the assertion</strong>)</a></p>
<p>We fetch the <strong>GPIO Pin Type</strong> and verify that it‚Äôs GPIO Interrupt Triggered on Rising Edge‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get SX1262 DIO1 Pin Type again
  ret = ioctl(      //  Execute a GPIO Command...
    dio1,           //  GPIO Descriptor
    GPIOC_PINTYPE,  //  Get GPIO Pin Type
    (unsigned long)((uintptr_t) &amp;pintype)  //  Returned Pin Type
  );
  assert(ret &gt;= 0);
  printf(&quot;DIO1 pintype after=%d\n&quot;, pintype);

  //  Verify that SX1262 DIO1 Pin is GPIO Interrupt on Rising Edge
  //  TODO: This fails because the Pin Type remains as GPIO_INTERRUPT_PIN
  //  assert(pintype == GPIO_INTERRUPT_RISING_PIN);  //  Trigger interrupt on rising edge

  //  Omitted: Start the Background Thread to process DIO1 interrupts
  ...
</code></pre></div>
<p>(But there‚Äôs a quirk in NuttX so we have disabled the assertion)</p>
<p>In the next section we‚Äôll create a <strong>Background Thread</strong> to handle the GPIO Interrupt.</p>
<p><em>Why do we verify the GPIO Pin Types? (Input / Output / Interrupt)</em></p>
<p>The GPIO Pin Names look awfully similar: <strong>/dev/gpio0</strong>, <strong>gpio1</strong>, <strong>gpio2</strong>, ‚Ä¶</p>
<p>It‚Äôs easy to <strong>mix up the GPIO Pins.</strong> Hence we verify the GPIO Pin Types to be sure that we got the right pin.</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-gpio2.png" alt="Initialise GPIO" /></p>
<h2 id="start-dio1-thread"><a class="doc-anchor" href="#start-dio1-thread">¬ß</a>8.2 Start DIO1 Thread</h2>
<p>In the rest of <strong>init_gpio</strong> we create a <strong>Background Thread</strong> to handle GPIO Interrupts from DIO1: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L725-L780">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Init the GPIO Pins. Return 0 on success.
static int init_gpio(void) {
  //  Omitted: Open GPIO Input for SX1262 Busy Pin
  //  Omitted: Open GPIO Interrupt for SX1262 DIO1 Pin
  //  Omitted: Change DIO1 Pin to Trigger GPIO Interrupt on Rising Edge
  ...
  //  Init the Background Thread Attributes
  static pthread_attr_t attr;
  ret = pthread_attr_init(&amp;attr);
  assert(ret == 0);
</code></pre></div>
<p>After we have initialised the Thread Attributes, we <strong>create the Background Thread</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Start the Background Thread to process DIO1 interrupts
  static pthread_t thread;
  ret = pthread_create(  //  Create a Background Thread
    &amp;thread,             //  Returned Thread
    &amp;attr,               //  Thread Attributes
    process_dio1,        //  Function that will be executed by the thread
    0                    //  Argument to pass to the thread
  );
  assert(ret == 0);
</code></pre></div>
<p>Let‚Äôs look inside <strong>process_dio1</strong>, the function that will be executed by the thread.</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-gpio3.png" alt="Handle DIO1 Interrupt" /></p>
<h2 id="handle-dio1-interrupt"><a class="doc-anchor" href="#handle-dio1-interrupt">¬ß</a>8.3 Handle DIO1 Interrupt</h2>
<p>We have created a <strong>Background Thread</strong> that will handle <strong>GPIO Interrupts from DIO1</strong>.  (Whenever a LoRa Packet is transmitted or received)</p>
<p>The thread shall do this‚Ä¶</p>
<ol>
<li>
<p>Define a <strong>NuttX Signal</strong> that will be signalled on GPIO Interrupt</p>
</li>
<li>
<p><strong>Wait for the GPIO Interrupt (Signal)</strong> to be triggered by DIO1</p>
</li>
<li>
<p><strong>Add an Event</strong> to the Event Queue</p>
</li>
<li>
<p>Repeat forever</p>
</li>
</ol>
<p>(Event Queue comes from NimBLE Porting Layer, explained in the next chapter)</p>
<p>Below is the code for our <strong>Background Thread</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L834-L896">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Handle DIO1 Interrupt by adding to Event Queue
void *process_dio1(void *arg) {
  assert(dio1 &gt; 0);

  //  Define the DIO1 Interrupt Event
  static struct ble_npl_event ev;
  ble_npl_event_init(  //  Init the Event for...
    &amp;ev,               //  Event
    RadioOnDioIrq,     //  Event Handler Function
    NULL               //  Argument to be passed to Event Handler
  );
</code></pre></div>
<p>The thread begins by defining the <strong>DIO1 Interrupt Event</strong> that will be added to the Event Queue.</p>
<p>When the Event Loop receives this Event, it will call <a href="https://lupyuen.github.io/articles/sx1262#radioondioirq"><strong>RadioOnDioIrq</strong></a>
to process the received packet.</p>
<p>Next we define the <strong>NuttX Signal</strong> that will be signalled on GPIO Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Define the signal
  #define SIG_DIO1 1
  struct sigevent notify;
  notify.sigev_notify = SIGEV_SIGNAL;
  notify.sigev_signo  = SIG_DIO1;
</code></pre></div>
<p>We <strong>register the Signal</strong> that will be triggered on GPIO Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set up to receive signal from GPIO Interrupt (DIO1 rising edge)
  int ret = ioctl(   //  Execute a GPIO Command...
    dio1,            //  GPIO Descriptor
    GPIOC_REGISTER,  //  Register GPIO Interrupt
    (unsigned long) &amp;notify  //  Signal to be notified on GPIO Interrupt
  );
  assert(ret &gt;= 0);
</code></pre></div>
<p>Then we add the Signal to a <strong>Signal Set</strong> (which we shall await later)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Create an empty Signal Set
  sigset_t set;
  sigemptyset(&amp;set);

  //  Add the signal to the Signal Set
  sigaddset(
    &amp;set,     //  Signal Set
    SIG_DIO1  //  Signal to be added
  );
</code></pre></div>
<p>We loop forever. Inside the loop we <strong>await the Signal Set</strong> for up to 60 seconds‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Loop forever waiting for the signal (DIO1 rising edge)
  for (;;) {

    //  Wait up to 60 seconds for the Signal Set
    struct timespec ts;
    ts.tv_sec  = 60;
    ts.tv_nsec = 0;
    ret = sigtimedwait(&amp;set, NULL, &amp;ts);
</code></pre></div>
<p>(We should probably wait forever)</p>
<p>If we were signalled (due to GPIO Interrupt), we <strong>add our Event</strong> to the Event Queue‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Were we signalled?
    if (ret &gt;= 0) {
      //  We were signalled. Add the DIO1 Interrupt Event to the Event Queue.
      puts(&quot;DIO1 add event&quot;);
      ble_npl_eventq_put(&amp;event_queue, &amp;ev);
</code></pre></div>
<p>(Which gets handled by the Event Loop in the next chapter)</p>
<p>If we <strong>weren‚Äôt signalled in 60 seconds</strong>, everything is hunky dory, just try again‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    } else {
      //  We were not signalled
      int errcode = errno;
      if (errcode == EAGAIN) { puts(&quot;DIO1 timeout&quot;); }
      else { fprintf(stderr, &quot;ERROR: Failed to wait signal %d: %d\n&quot;, SIG_DIO1, errcode); return NULL; }
    }
  }
</code></pre></div>
<p>Finally this loops back perpetually, awaiting the next GPIO Interrupt (Signal) or timeout.</p>
<p>That‚Äôs it for the Background Thread! We don‚Äôt do much here, we do all the work in the Event Loop.</p>
<p>(Which is probably safer for Multithreading)</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-gpio4a.png" alt="Handle DIO1 Interrupt" /></p>
<h2 id="read-dio1-state"><a class="doc-anchor" href="#read-dio1-state">¬ß</a>8.4 Read DIO1 State</h2>
<p>Our SX1262 Library calls this function to read the <strong>DIO1 Pin State</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L349-L361">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>uint32_t SX126xGetDio1PinState( void ) {
  //  Return the value of DIO1 Pin
  assert(dio1 &gt; 0);

  //  Read the GPIO Input
  bool invalue;
  int ret = ioctl(  //  Execute a GPIO Command...
    dio1,           //  GPIO Descriptor
    GPIOC_READ,     //  Read GPIO Input
    (unsigned long)((uintptr_t) &amp;invalue)  //  Returned Value
  );
  assert(ret &gt;= 0);

  //  Return the value: 1 or 0
  return invalue ? 1 : 0;
}
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/lorawan3-gpio1.png" alt="Check Busy State" /></p>
<h2 id="check-busy-state"><a class="doc-anchor" href="#check-busy-state">¬ß</a>8.5 Check Busy State</h2>
<p>The Busy Pin goes High when SX1262 is busy. We wait for SX1262 by reading the GPIO Input for the Busy Pin: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L185-L200">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xWaitOnBusy( void ) {
  assert(busy &gt; 0);

  //  Loop until Busy Pin is Low
  for (;;) {
    //  Read Busy Pin
    bool invalue;
    int ret = ioctl(  //  Execute a GPIO Command...
      busy,           //  GPIO Descriptor
      GPIOC_READ,     //  Read GPIO Pin
      (unsigned long)((uintptr_t) &amp;invalue)  //  Returned value
    );
    assert(ret &gt;= 0);

    //  Exit if Busy Pin is Low
    if (invalue == 0) { break; }
  }
}
</code></pre></div>
<p>(<strong>SX126xWaitOnBusy</strong> is called by <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L133-L142"><strong>SX126xCheckDeviceReady</strong></a>, which wakes up SX1262 before checking if SX1262 is busy)</p>
<p>Earlier we talked about the Event Queue, let‚Äôs dive into the NimBLE Porting Layer.</p>
<p><img src="https://lupyuen.github.io/images/sx1262-handler.jpg" alt="Multithreading with NimBLE Porting Layer" /></p>
<h1 id="multithreading-with-nimble-porting-layer"><a class="doc-anchor" href="#multithreading-with-nimble-porting-layer">¬ß</a>9 Multithreading with NimBLE Porting Layer</h1>
<p>Our SX1262 Library was designed for <strong>Multithreading</strong> by calling the open-source <strong>NimBLE Porting Layer</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer"><strong>‚ÄúMultitask with NimBLE Porting Layer‚Äù</strong></a></li>
</ul>
<p>To transmit and receive LoRa Messages without polling we need <strong>Timers and Event Queues</strong>. Which are provided by NimBLE Porting Layer.</p>
<p><em>Have we used NimBLE Porting Layer on other platforms?</em></p>
<p>Yep we used NimBLE Porting Layer in the <strong>LoRa SX1262 and SX1276 Drivers</strong> for BL602 IoT SDK‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2"><strong>‚ÄúPineCone BL602 RISC-V Board Receives LoRa Packets‚Äù</strong></a></li>
</ul>
<p>NimBLE Porting Layer <a href="https://github.com/apache/mynewt-nimble/tree/master/porting/npl/nuttx"><strong>compiles on NuttX</strong></a> as well‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nimble-porting-nuttx"><strong>lupyuen/nimble-porting-nuttx</strong></a></li>
</ul>
<p>Note that NimBLE Porting Layer needs <strong>POSIX Timers and Message Queues</strong> (plus more) to work on NuttX‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3#appendix-posix-timers-and-message-queues"><strong>‚ÄúPOSIX Timers and Message Queues‚Äù</strong></a></li>
</ul>
<p><em>How will we receive LoRa Messages with GPIO Interrupts?</em></p>
<p>According to the pic above‚Ä¶</p>
<ol>
<li>
<p>When SX1262 receives a LoRa Message, it triggers a <strong>GPIO Interrupt</strong> on Pin DIO1</p>
</li>
<li>
<p>In the previous chapter we started a <strong>Background Thread</strong> that waits for GPIO Interrupts and <strong>adds a DIO1 Interrupt Event</strong> to our Event Queue</p>
</li>
<li>
<p>In our NuttX App, the <strong>Foreground Thread</strong> runs an <strong>Event Loop</strong> that handles every Event in our Event Queue</p>
</li>
<li>
<p>When the Event Loop receives the DIO1 Interrupt Event, it calls <a href="https://lupyuen.github.io/articles/sx1262#radioondioirq"><strong>RadioOnDioIrq</strong></a>
to process the received LoRa Message</p>
</li>
</ol>
<p>Let‚Äôs look at the implementation of NimBLE Porting Layer for the <strong>new SX1262 Library that will support LoRaWAN</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library">(See this for the old SX1262 Library)</a></p>
<h2 id="event-queue"><a class="doc-anchor" href="#event-queue">¬ß</a>9.1 Event Queue</h2>
<p><em>What Events will be added to our Event Queue?</em></p>
<p>Our Event Queue will have <strong>two types of Events</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>GPIO Interrupt</strong>: Triggered via DIO1 when SX1262 has transmitted or received a LoRa Message</p>
</li>
<li>
<p><strong>Timer Events</strong>: All Timers for LoRa and LoRaWAN will insert Events into our Event Queue upon timeout</p>
</li>
</ol>
<p>All Events are handled <strong>First In First Out</strong> by our Event Loop.</p>
<p><em>How do we create the Event Queue?</em></p>
<p>Our SX1262 Library <strong>creates the Event Queue</strong> by calling NimBLE Porting Layer: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L901-L916">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Event Queue containing Events to be processed. Exposed to NuttX App for Event Loop.
struct ble_npl_eventq event_queue;

/// True if Event Queue has been initialised
static bool is_event_queue_initialised = false;

/// Init the Event Queue
static void init_event_queue(void) {

  //  Init only once
  if (is_event_queue_initialised) { return; }
  is_event_queue_initialised = true;

  //  Init the Event Queue by calling NimBLE Porting Layer
  ble_npl_eventq_init(&amp;event_queue);
}
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/lorawan3-npl1.png" alt="Handling LoRaWAN Events with NimBLE Porting Layer" /></p>
<h2 id="event-loop"><a class="doc-anchor" href="#event-loop">¬ß</a>9.2 Event Loop</h2>
<p>Let‚Äôs look at the <strong>Event Loop</strong> that handles the LoRa and LoRaWAN Events in our Event Queue: <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c#L611-L655">lorawan_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Event Loop that dequeues Events from the Event Queue and processes the Events
static void handle_event_queue(void *arg) {

  //  Loop forever handling Events from the Event Queue
  for (;;) {

    //  Get the next Event from the Event Queue
    struct ble_npl_event *ev = ble_npl_eventq_get(
      &amp;event_queue,         //  Event Queue
      BLE_NPL_TIME_FOREVER  //  No Timeout (Wait forever for event)
    );
</code></pre></div>
<p>This code runs in the <strong>Foreground Thread</strong> of our NuttX App.</p>
<p>Here we loop forever, <strong>waiting for Events</strong> from the Event Queue.</p>
<p>When we receive an Event, we <strong>remove the Event</strong> from the Event Queue‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  If no Event due to timeout, wait for next Event.
    //  Should never happen since we wait forever for an Event.
    if (ev == NULL) { printf(&quot;.&quot;); continue; }

    //  Remove the Event from the Event Queue
    ble_npl_eventq_remove(&amp;event_queue, ev);
</code></pre></div>
<p>We call the <strong>Event Handler Function</strong> that was registered with the Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Trigger the Event Handler Function
    ble_npl_event_run(ev);
</code></pre></div>
<ul>
<li>
<p>For DIO1 Interrupts: We call <a href="https://lupyuen.github.io/articles/sx1262#radioondioirq"><strong>RadioOnDioIrq</strong></a> to handle the packet transmitted / received notification</p>
</li>
<li>
<p>For Timer Events: We call the <strong>Timeout Function</strong> defined in the Timer</p>
</li>
</ul>
<p>The rest of the Event Loop handles LoRaWAN Events. We‚Äôll cover this in the next article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<div class="example-wrap"><pre class="language-c"><code>    //  For LoRaWAN: Processes the LoRaMac events
    LmHandlerProcess( );

    //  For LoRaWAN: If we have joined the network, do the uplink
    if (!LmHandlerIsBusy( )) {
      UplinkProcess( );
    }

    //  For LoRaWAN: Handle Low Power Mode
    CRITICAL_SECTION_BEGIN( );
    if( IsMacProcessPending == 1 ) {
      //  Clear flag and prevent MCU to go into low power modes.
      IsMacProcessPending = 0;
    } else {
      //  The MCU wakes up through events
      //  TODO: BoardLowPowerHandler( );
    }
    CRITICAL_SECTION_END( );
  }
}
</code></pre></div>
<p>And we loop back perpetually, waiting for Events and handling them.</p>
<p>That‚Äôs how we handle LoRa and LoRaWAN Events with NimBLE Porting Layer!</p>
<p><img src="https://lupyuen.github.io/images/sx1262-library5.jpg" alt="Porting LoRaWAN to NuttX OS" /></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>10 What‚Äôs Next</h1>
<p>In our next article we‚Äôll move on to <strong>LoRaWAN!</strong> We‚Äôll port Semtech‚Äôs <strong>Reference LoRaWAN Stack</strong> to NuttX‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p><em>We‚Äôre porting plenty of code to NuttX: LoRa, LoRaWAN and NimBLE Porting Layer. Do we expect any problems?</em></p>
<p>Yep we might have issues keeping our LoRaWAN Stack in sync with Semtech‚Äôs version.  <a href="https://lupyuen.github.io/articles/sx1262#notes">(But we shall minimise the changes)</a></p>
<p>We have started porting the <a href="https://lupyuen.github.io/articles/nuttx#rust-on-nuttx"><strong>Rust Embedded HAL</strong></a> to NuttX. Here‚Äôs what we‚Äôve done‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rust2"><strong>‚ÄúRust on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rusti2c"><strong>‚ÄúRust talks I2C on Apache NuttX RTOS‚Äù</strong></a></p>
</li>
</ul>
<p>Now LoRa works on Rust too‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust2#transmit-lora-message"><strong>‚ÄúTransmit LoRa Message (in Rust)‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/embedded_oc/comments/rluiw0/lora_sx1262_on_apache_nuttx_os/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sx1262.md"><code>lupyuen.github.io/src/sx1262.md</code></a></p>
<h1 id="notes"><a class="doc-anchor" href="#notes">¬ß</a>11 Notes</h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1471179698268893188">this Twitter Thread</a></p>
</li>
<li>
<p>We‚Äôre <strong>porting plenty of code</strong> to NuttX: LoRa, LoRaWAN and NimBLE Porting Layer. Do we expect any problems?</p>
<ul>
<li>
<p>If we implement LoRa and LoRaWAN as <strong>NuttX Drivers</strong>, we‚Äôll have to scrub the code to comply with the <a href="https://nuttx.apache.org/docs/latest/contributing/coding_style.html"><strong>NuttX Coding Conventions</strong></a>.</p>
<p>This makes it <strong>harder to update</strong> the LoRaWAN Driver when there are changes in the LoRaWAN Spec. (Like for a new LoRaWAN Region)</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-lora-carrier-sensing">(Here‚Äôs an example)</a></p>
</li>
<li>
<p>Alternatively we may implement LoRa and LoRaWAN as <strong>External Libraries</strong>, similar to <a href="https://github.com/lupyuen/nuttx-apps/tree/master/wireless/bluetooth/nimble"><strong>NimBLE for NuttX</strong></a>.</p>
<p>(The <a href="https://github.com/lupyuen/nuttx-apps/blob/master/wireless/bluetooth/nimble/Makefile#L33"><strong>Makefile</strong></a> downloads the External Library during build)</p>
<p>But then we won‚Äôt get a proper NuttX Driver that exposes the ioctl() interface to NuttX Apps.</p>
</li>
</ul>
<p>Conundrum. Lemme know your thoughts!</p>
</li>
<li>
<p>How do other Embedded Operating Systems implement LoRaWAN?</p>
<ul>
<li>
<p><strong>Mynewt</strong> embeds a <a href="https://github.com/apache/mynewt-core/tree/master/net/lora/node"><strong>Partial Copy</strong></a> of Semtech‚Äôs LoRaWAN Stack into its source tree.</p>
</li>
<li>
<p><strong>Zephyr</strong> maintains a <a href="https://github.com/zephyrproject-rtos/loramac-node"><strong>Complete Fork</strong></a> of the entire LoRaWAN Repo by Semtech. Which gets embedded during the Zephyr build.</p>
</li>
</ul>
<p>We‚Äôre adopting the Zephyr approach to <strong>keep our LoRaWAN Stack in sync</strong> with Semtech‚Äôs.</p>
</li>
<li>
<p>We have already ported LoRaWAN to <strong>BL602 IoT SDK</strong> <a href="https://lupyuen.github.io/articles/lorawan">(see this)</a>, why are we porting again to NuttX?</p>
<p>Regrettably BL602 IoT SDK has been revamped (without warning) to the <strong>new ‚Äúhosal‚Äù HAL</strong> <a href="https://twitter.com/MisterTechBlog/status/1456259223323508748">(see this)</a>, and the LoRaWAN Stack will <strong>no longer work</strong> on the revamped BL602 IoT SDK.</p>
<p>For easier maintenance, we shall <strong>code our BL602 and BL604 projects with Apache NuttX OS</strong> instead.</p>
<p>(Which won‚Äôt get revamped overnight!)</p>
</li>
<li>
<p>Will NuttX become the official OS for PineDio Stack BL604 when it goes on sale?</p>
<p>It might! But first let‚Äôs get LoRaWAN (and ST7789) running on PineDio Stack.</p>
</li>
</ol>
<h1 id="appendix-spi-and-gpio-device-paths"><a class="doc-anchor" href="#appendix-spi-and-gpio-device-paths">¬ß</a>12 Appendix: SPI and GPIO Device Paths</h1>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> uses the <strong>GPIO Expander</strong>, which assigns meaningful names to GPIO Pins‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/expander"><strong>‚ÄúNuttX GPIO Expander for PineDio Stack BL604‚Äù</strong></a></li>
</ul>
<p>For PineDio Stack we changed the definition of <strong><code>DIO1_DEVPATH</code></strong> to ‚Äú<strong>/dev/gpio19</strong>‚Äù in Kconfig / menuconfig‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_LIBSX1262_SPI_DEVPATH=&quot;/dev/spitest0&quot;
CONFIG_LIBSX1262_CS_DEVPATH=&quot;/dev/gpio15&quot;
CONFIG_LIBSX1262_BUSY_DEVPATH=&quot;/dev/gpio10&quot;
CONFIG_LIBSX1262_DIO1_DEVPATH=&quot;/dev/gpio19&quot;
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/configs/pinedio/defconfig#L1141-L1144">(Source)</a></p>
<p>(Note also the changes to <strong>SPI_DEVPATH</strong>, <strong>CS_DEVPATH</strong> and <strong>BUSY_DEVPATH</strong>)</p>
<p>For backward compatibility with BL602 (which doesn‚Äôt use GPIO Expander), we default <strong><code>DIO1_DEVPATH</code></strong> to ‚Äú<strong>/dev/gpio2</strong>‚Äù if <strong><code>DIO1_DEVPATH</code></strong> isn‚Äôt configured‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Define the SPI Test Driver for SX1262. (Not the regular SPI Driver)

#ifdef CONFIG_LIBSX1262_SPI_DEVPATH
#define SPI_DEVPATH CONFIG_LIBSX1262_SPI_DEVPATH
#else
#define SPI_DEVPATH &quot;/dev/spitest0&quot;
#endif  //  CONFIG_LIBSX1262_SPI_DEVPATH

//  Define the GPIOs for SX1262 Chip Select (Output), Busy (Input) and DIO1 (Interrupt)

#ifdef CONFIG_LIBSX1262_CS_DEVPATH
#define CS_DEVPATH CONFIG_LIBSX1262_CS_DEVPATH
#else
#define CS_DEVPATH &quot;/dev/gpio1&quot;
#endif  //  CONFIG_LIBSX1262_CS_DEVPATH

#ifdef CONFIG_LIBSX1262_BUSY_DEVPATH
#define BUSY_DEVPATH CONFIG_LIBSX1262_BUSY_DEVPATH
#else
#define BUSY_DEVPATH &quot;/dev/gpio0&quot;
#endif  //  CONFIG_LIBSX1262_BUSY_DEVPATH

#ifdef CONFIG_LIBSX1262_DIO1_DEVPATH
#define DIO1_DEVPATH CONFIG_LIBSX1262_DIO1_DEVPATH
#else
#define DIO1_DEVPATH &quot;/dev/gpio2&quot;
#endif  //  CONFIG_LIBSX1262_DIO1_DEVPATH
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L18-L44">(Source)</a></p>
<p>(Note also the defaults for <strong>SPI_DEVPATH</strong>, <strong>CS_DEVPATH</strong> and <strong>BUSY_DEVPATH</strong>)</p>
<h1 id="appendix-create-a-nuttx-library"><a class="doc-anchor" href="#appendix-create-a-nuttx-library">¬ß</a>13 Appendix: Create a NuttX Library</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>This section explains the steps to create a <strong>NuttX Library</strong> named <strong>‚Äúlibsx1262‚Äù</strong>.</p>
<p>(Change ‚Äúlibsx1262‚Äù to the desired name of our library)</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/tree/newlibrary/libs"><strong>‚Äúnuttx/libs‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the <strong>‚Äúlibdsp‚Äù</strong> subfolder and paste it as <strong>‚Äúlibsx1262‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone1.png" alt="Copy the ‚Äúlibdsp‚Äù subfolder and paste it as ‚Äúlibsx1262‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/6596edd6eb47547f41f647e6da1e08d33faacf4f#diff-739a304e183a900711f6497e6544a814ef5367da89ccedad067fc1a3f0814b41">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúlibsx1262‚Äù</strong> folder, delete all source files except <strong>‚Äúlib_misc.c‚Äù</strong></p>
</li>
<li>
<p>Edit <strong>‚ÄúMakefile‚Äù</strong>. Remove all ‚ÄúCSRCS‚Äù lines except‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CSRCS += lib_misc.c
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/newlibrary/libs/libsx1262/Makefile">(See Makefile)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúlibsx1262‚Äù</strong> folder, search and replace all <strong>‚Äúlibdsp‚Äù</strong> by <strong>‚Äúlibsx1262‚Äù</strong></p>
<p>Be sure to <strong>Preserve Case!</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone2a.png" alt="Change all ‚Äúlibdsp‚Äù to ‚Äúlibsx1262‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/9fe76d3bca389642e71ac405c8343b280384276d#diff-a9d844356942ef04a0efe9eac47f95390756485e2aec9cd4018831af2e8e9409">(See changes)</a></p>
<p><a href="https://github.com/lupyuen/nuttx/tree/newlibrary/libs/libsx1262">(See libsx1262 folder)</a></p>
</li>
<li>
<p>Edit the file <strong>‚ÄúKconfig‚Äù</strong></p>
<p>Update the section <strong>‚Äúmenuconfig LIBSX1262‚Äù</strong> as follows‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>menuconfig LIBSX1262
    bool &quot;Semtech SX1262 Library&quot;
    default n
    ---help---
        Enable build for Semtech SX1262 functions    
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/sx1262-clone4.png" alt="Update Kconfig" /></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newlibrary/libs/libsx1262/Kconfig">(Source)</a></p>
</li>
<li>
<p>Edit the file <strong>‚Äúlib_misc.c‚Äù</strong>.  Remove all the code and add‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;stdio.h&gt;  /* TODO: Fix this for kernel mode */
#include &lt;sx1262.h&gt;

void test_libsx1262(void)
{
  puts(&quot;libsx1262 OK!&quot;);
}
</code></pre></div>
<p>We‚Äôll call this function in a while.</p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newlibrary/libs/libsx1262/lib_misc.c">(See lib_misc.c)</a></p>
</li>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/blob/newlibrary/include"><strong>‚Äúnuttx/include‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the file <strong>‚Äúdsp.h‚Äù</strong> and paste it as <strong>‚Äúsx1262.h‚Äù</strong></p>
</li>
<li>
<p>Inside the file <strong>‚Äúsx1262.h‚Äù</strong>, search and replace all <strong>‚Äúdsp‚Äù</strong> by <strong>‚Äúsx1262‚Äù</strong></p>
<p>Remember to <strong>Preserve Case!</strong></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/newlibrary/include/sx1262.h">(See sx1262.h)</a></p>
</li>
<li>
<p>Edit the file <strong>‚Äúsx1262.h‚Äù</strong>, remove all Public Functions Prototypes and add‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void test_libsx1262(void);
</code></pre></div>
<p>We‚Äôll test this function in a while.</p>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/include/sx1262.h">(See sx1262.h)</a></p>
</li>
</ol>
<h2 id="update-makefiles-and-kconfig"><a class="doc-anchor" href="#update-makefiles-and-kconfig">¬ß</a>13.1 Update Makefiles and Kconfig</h2>
<p>Next we update the Makefiles and Kconfig so that NuttX will build our library‚Ä¶</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/tree/newlibrary/tools"><strong>‚Äúnuttx/tools‚Äù</strong></a> folder</p>
</li>
<li>
<p>Edit the file <strong>‚ÄúDirectories.mk‚Äù</strong></p>
<p>After <strong>‚Äúlibdsp‚Äù</strong>, insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ifeq ($(CONFIG_LIBSX1262),y)
KERNDEPDIRS += libs$(DELIM)libsx1262
else
CLEANDIRS += libs$(DELIM)libsx1262
endif
</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone5.png" alt="Update ‚ÄúDirectories.mk‚Äù" /></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/8bd31da9abccbcfdd1b9b1ccfd22bd41803ac7f8#diff-f9d35d43770d39092a663e665e82ae1d84a9e0da3d0d10c407acada6a40cd281">(Source)</a></p>
</li>
<li>
<p>Edit the files <strong>‚ÄúFlatLibs.mk‚Äù</strong>, <strong>‚ÄúKernelLibs.mk‚Äù</strong> and <strong>‚ÄúProtectedLibs.mk‚Äù</strong></p>
<p>After <strong>‚Äúlibopenamp‚Äù</strong>, insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ifeq ($(CONFIG_LIBSX1262),y)
NUTTXLIBS += staging$(DELIM)libsx1262$(LIBEXT)
endif
</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone6.jpg" alt="Update Makefiles" /></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/b381a99e7512d09d74db4da982826b5e40b2606a#diff-f9d35d43770d39092a663e665e82ae1d84a9e0da3d0d10c407acada6a40cd281">(Source)</a></p>
</li>
<li>
<p>Edit the file <strong>‚ÄúLibTargets.mk‚Äù</strong></p>
<p>After <strong>‚Äúlibdsp‚Äù</strong>, insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>libs$(DELIM)libsx1262$(DELIM)libsx1262$(LIBEXT): pass2dep
    $(Q) $(MAKE) -C libs$(DELIM)libsx1262 libsx1262$(LIBEXT) EXTRAFLAGS=&quot;$(EXTRAFLAGS)&quot;

staging$(DELIM)libsx1262$(LIBEXT): libs$(DELIM)libsx1262$(DELIM)libsx1262$(LIBEXT)
    $(Q) $(call INSTALL_LIB,$&lt;,$@)
</code></pre></div>
<p>As shown in the pic above.</p>
</li>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/nuttx/tree/newlibrary"><strong>‚Äúnuttx‚Äù</strong></a> folder</p>
</li>
<li>
<p>Edit the file <strong>‚ÄúKconfig‚Äù</strong></p>
<p>Inside the section <strong>menu ‚ÄúLibrary Routines‚Äù</strong>, add this line‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>source &quot;libs/libsx1262/Kconfig&quot;
</code></pre></div>
<p><img src="https://lupyuen.github.io/images/sx1262-clone3a.png" alt="Update Root Kconfig" /></p>
<p><a href="https://github.com/lupyuen/nuttx/commit/6a18348842b5fcec6a9fe8672c0de380b889086c">(Source)</a></p>
</li>
<li>
<p>Run the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the path of our &quot;nuttx&quot; folder
cd nuttx/nuttx

## Preserve the Build Config
cp .config ../config

## Erase the Build Config
make distclean

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Restore the Build Config
cp ../config .config

## Edit the Build Config
make menuconfig 
</code></pre></div></li>
</ol>
<h2 id="enable-library"><a class="doc-anchor" href="#enable-library">¬ß</a>13.2 Enable Library</h2>
<p>We enable our library as follows‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúLibrary Routines‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúSemtech SX1262 Library‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone7.png" alt="Enable Library" /></p>
</li>
<li>
<p>Hit <strong>‚ÄúSave‚Äù</strong> then <strong>‚ÄúOK‚Äù</strong> to save the NuttX Configuration to <strong>‚Äú.config‚Äù</strong></p>
</li>
<li>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until <strong>menuconfig</strong> quits</p>
</li>
</ol>
<h2 id="verify-library"><a class="doc-anchor" href="#verify-library">¬ß</a>13.3 Verify Library</h2>
<p>To verify our library‚Ä¶</p>
<ol>
<li>
<p>We create a simple NuttX App: <a href="https://github.com/lupyuen/nuttx-apps/tree/newlibrary/examples/sx1262_test"><strong>apps/examples/sx1262_test</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;nuttx/config.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sx1262.h&gt;

int main(int argc, FAR char *argv[])
{
  printf(&quot;Sx1262_test, World!!\n&quot;);

  /* Call SX1262 Library */

  test_libsx1262();

  return 0;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/newlibrary/examples/sx1262_test/sx1262_test_main.c">(Source)</a></p>
</li>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32.</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test
</code></pre></div></li>
<li>
<p>We should see the message‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>libsx1262 OK!
</code></pre></div>
<p>Congratulations our library is now running on NuttX!</p>
<p><img src="https://lupyuen.github.io/images/sx1262-library4.jpg" alt="Our library runs OK" /></p>
</li>
</ol>
<h1 id="appendix-build-flash-and-run-nuttx"><a class="doc-anchor" href="#appendix-build-flash-and-run-nuttx">¬ß</a>14 Appendix: Build, Flash and Run NuttX</h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="build-nuttx"><a class="doc-anchor" href="#build-nuttx">¬ß</a>14.1 Build NuttX</h2>
<p>Follow these steps to build NuttX for BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>To build NuttX, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make
</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746">(See the complete log for BL602)</a></p>
</li>
<li>
<p><strong>For WSL:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>c:\blflash</strong> directory in the Windows File System‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  /mnt/c/blflash refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash
</code></pre></div>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx"><a class="doc-anchor" href="#flash-nuttx">¬ß</a>14.2 Flash NuttX</h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux: Change &quot;/dev/ttyUSB0&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change &quot;/dev/tty.usbserial-1410&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change &quot;COM5&quot; to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx"><a class="doc-anchor" href="#run-nuttx">¬ß</a>14.3 Run NuttX</h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0
</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;
</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p><strong>macOS Tip:</strong> Here‚Äôs the script I use to build, flash and run NuttX on macOS, all in a single step: <a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">run.sh</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="Script to build, flash and run NuttX on macOS" /></p>
<p><a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">(Source)</a></p>
<h1 id="appendix-radio-functions"><a class="doc-anchor" href="#appendix-radio-functions">¬ß</a>15 Appendix: Radio Functions</h1>
<p>In this section we explain the Platform-Independent <strong>Radio Functions</strong> for Semtech SX1262 Transceiver: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c">radio.c</a></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L522-L559"><strong>RadioInit:</strong></a> Initialise LoRa SX1262</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L599-L604"><strong>RadioSetChannel:</strong></a> Set LoRa Frequency</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L787-L908"><strong>RadioSetTxConfig:</strong></a> Set LoRa Transmit Configuration</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L660-L786"><strong>RadioSetRxConfig:</strong></a> Set LoRa Receive Configuration</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1068-L1098"><strong>RadioSend:</strong></a> Transmit a LoRa Message</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1116-L1138"><strong>RadioRx:</strong></a> Receive one LoRa Message</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1313-L1460"><strong>RadioIrqProcess:</strong></a> Process Transmit and Receive Interrupts</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1099-L1109"><strong>RadioSleep:</strong></a> Switch SX1262 to low-power sleep mode</p>
</li>
</ul>
<p>The code is nearly identical to <a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x"><strong><strong>Semtech‚Äôs Reference Implementation</strong></strong></a> of SX1262 Driver (29 Mar 2021).</p>
<p>(So it should work perfectly fine with Semtech‚Äôs LoRaWAN Stack, as explained in the next article)</p>
<p>The Radio Functions will trigger the following <strong>Callback Functions</strong> to handle <strong>Radio Events</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/include/radio.h#L54-L109">radio.h</a></p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit-done"><strong>TxDone:</strong></a> Transmit Done</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done"><strong>RxDone:</strong></a> Receive Done</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done"><strong>RxError:</strong></a> Receive Error</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout"><strong>TxTimeout:</strong></a> Transmit Timeout</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout"><strong>RxTimeout:</strong></a> Receive Timeout or Header Error</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#cad-done"><strong>CadDone:</strong></a> Channel Activity Detection Done</p>
</li>
</ul>
<p>The Callback Functions are defined in our LoRa Test App.</p>
<p>(Also in the LoRaWAN Library, as explained in the next article)</p>
<h2 id="radioinit-initialise-lora-module"><a class="doc-anchor" href="#radioinit-initialise-lora-module">¬ß</a>15.1 RadioInit: Initialise LoRa Module</h2>
<p><strong>RadioInit</strong> initialises the LoRa SX1262 Module: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L522-L559">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioInit( RadioEvents_t *events ) {
  //  We copy the Event Callbacks from &quot;events&quot;, because
  //  &quot;events&quot; may be stored on the stack
  assert(events != NULL);
  memcpy(&amp;RadioEvents, events, sizeof(RadioEvents));
  //  Previously: RadioEvents = events;
</code></pre></div>
<p>The function begins by copying the list of <strong>Radio Event Callbacks</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit-done"><strong>TxDone:</strong></a> Called when a LoRa Message has been transmitted</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done"><strong>RxDone:</strong></a> Called when a LoRa Message has been received</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout"><strong>TxTimeout:</strong></a> Called upon timeout when transmitting a LoRa Message</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout"><strong>RxTimeout:</strong></a>  Called upon timeout when receiving a LoRa Message</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done"><strong>RxError:</strong></a> Called when a LoRa Message has been received with CRC Error</p>
</li>
</ul>
<p>This differs from the Semtech Reference Implementation, which copies the pointer to <strong>RadioEvents_t</strong> instead of the entire <strong>RadioEvents_t</strong>.</p>
<p>(Which causes problems when <strong>RadioEvents_t</strong> lives on the stack)</p>
<p>Next we <strong>init the SPI and GPIO Ports</strong>, wake up the LoRa Module, and init the TCXO Control and RF Switch Control.</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init SPI and GPIO Ports, wake up the LoRa Module,
  //  init TCXO Control and RF Switch Control.
  SX126xInit( RadioOnDioIrq );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L112-L131">(<strong>SX126xInit</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioondioirq">(<strong>RadioOnDioIrq</strong> is explained here)</a></p>
<p>We set the LoRa Module to <strong>Standby Mode</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set LoRa Module to standby mode
  SX126xSetStandby( STDBY_RC );
</code></pre></div>
<p>We set the <strong>Power Regulation: LDO or DC-DC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  TODO: Declare the power regulation used to power the device
  //  This command allows the user to specify if DC-DC or LDO is used for power regulation.
  //  Using only LDO implies that the Rx or Tx current is doubled

  //  #warning SX126x is set to LDO power regulator mode (instead of DC-DC)
  //  SX126xSetRegulatorMode( USE_LDO );   //  Use LDO

  //  #warning SX126x is set to DC-DC power regulator mode (instead of LDO)
  SX126xSetRegulatorMode( USE_DCDC );  //  Use DC-DC
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L390-L393">(<strong>SX126xSetRegulatorMode</strong> is defined here)</a></p>
<p>This depends on how our LoRa Module is wired for power.</p>
<p>For now we‚Äôre using <strong>DC-DC</strong> Power Regulation. (To be verified)</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#dc-dc-vs-ldo">(More about LDO vs DC-DC Power Regulation)</a></p>
<p>We set the <strong>Base Addresses</strong> of the Read and Write Buffers to 0‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the base addresses of the Read and Write Buffers to 0
  SX126xSetBufferBaseAddress( 0x00, 0x00 );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L697-L704">(<strong>SX126xSetBufferBaseAddress</strong> is defined here)</a></p>
<p>The Read and Write Buffers are accessed by <a href="https://lupyuen.github.io/articles/sx1262#receive-message"><strong>sx126x_read_buffer</strong></a> and <a href="https://lupyuen.github.io/articles/sx1262#transmit-message"><strong>sx126x_write_buffer</strong></a>.</p>
<p>We set the <strong>Transmit Power</strong> and the <strong>Ramp Up Time</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  TODO: Set the correct transmit power and ramp up time
  SX126xSetTxParams( 22, RADIO_RAMP_3400_US );
  //  TODO: Previously: SX126xSetTxParams( 0, RADIO_RAMP_200_US );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L528-L576">(<strong>SX126xSetTxParams</strong> is defined here)</a></p>
<p><strong>Ramp Up Time</strong> is the duration (in microseconds) we need to wait for SX1262‚Äôs Power Amplifier to ramp up (charge up) to the configured Transmit Power.</p>
<p>For easier testing we have set the Transmit Power to <strong>22 dBm</strong> (highest power) and Ramp Up Time to <strong>3400 microseconds</strong> (longest duration).</p>
<p>(To give sufficient time for the Power Amplifier to ramp up to the highest Transmit Power)</p>
<p>After testing we should revert to the <strong>Default Transmit Power</strong> (0) and <strong>Ramp Up Time</strong> (200 microseconds).</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#transmit-power">(More about the Transmit Power)</a></p>
<p><a href="https://lupyuen.github.io/articles/lorawan#over-current-protection">(Over Current Protection in <strong>SX126xSetTxParams</strong>)</a></p>
<p>We configure which <strong>LoRa Events will trigger interrupts</strong> on each DIO Pin‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the DIO Interrupt Events:
  //  All LoRa Events will trigger interrupts on DIO1
  SX126xSetDioIrqParams(
    IRQ_RADIO_ALL,   //  Interrupt Mask
    IRQ_RADIO_ALL,   //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L457-L470">(<strong>SX126xSetDioIrqParams</strong> is defined here)</a></p>
<p>(All LoRa Events will trigger interrupts on DIO1)</p>
<p>We define the SX1262 Registers that will be restored from <strong>Retention Memory</strong> when waking up from Warm Start Mode‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Add registers to the retention list (4 is the maximum possible number)
  RadioAddRegisterToRetentionList( REG_RX_GAIN );
  RadioAddRegisterToRetentionList( REG_TX_MODULATION );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1167-L1195">(<strong>RadioAddRegisterToRetentionList</strong> is defined here)</a></p>
<p>Finally we init the Timeout Timers (from NimBLE Porting Layer) for <strong>Transmit Timeout</strong> and <strong>Receive Timeout</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Initialize driver timeout timers
  TimerInit( &amp;TxTimeoutTimer, RadioOnTxTimeoutIrq );
  TimerInit( &amp;RxTimeoutTimer, RadioOnRxTimeoutIrq );

  //  Interrupt not fired yet
  IrqFired = false;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L384-L405">(<strong>TimerInit</strong> is defined here)</a></p>
<h2 id="radiosetchannel-set-lora-frequency"><a class="doc-anchor" href="#radiosetchannel-set-lora-frequency">¬ß</a>15.2 RadioSetChannel: Set LoRa Frequency</h2>
<p><strong>RadioSetChannel</strong> sets the LoRa Frequency: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L599-L604">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSetChannel( uint32_t freq ) {
  SX126xSetRfFrequency( freq );
}
</code></pre></div>
<p><strong>RadioSetChannel</strong> passes the LoRa Frequency (like <code>923000000</code> for 923 MHz) to <strong>SX126xSetRfFrequency</strong>.</p>
<p><strong>SX126xSetRfFrequency</strong> is defined as follows: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L497-L514">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xSetRfFrequency( uint32_t frequency ) {
  uint8_t buf[4];
  if( ImageCalibrated == false ) {
    SX126xCalibrateImage( frequency );
    ImageCalibrated = true;
  }
  uint32_t freqInPllSteps = SX126xConvertFreqInHzToPllStep( frequency );
  buf[0] = ( uint8_t )( ( freqInPllSteps &gt;&gt; 24 ) &amp; 0xFF );
  buf[1] = ( uint8_t )( ( freqInPllSteps &gt;&gt; 16 ) &amp; 0xFF );
  buf[2] = ( uint8_t )( ( freqInPllSteps &gt;&gt; 8 ) &amp; 0xFF );
  buf[3] = ( uint8_t )( freqInPllSteps &amp; 0xFF );
  SX126xWriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L408-L438">(<strong>SX126xCalibrateImage</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L812-L826">(<strong>SX126xConvertFreqInHzToPllStep</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L222-L235">(<strong>SX126xWriteCommand</strong> is defined here)</a></p>
<h2 id="radiosettxconfig-set-transmit-configuration"><a class="doc-anchor" href="#radiosettxconfig-set-transmit-configuration">¬ß</a>15.3 RadioSetTxConfig: Set Transmit Configuration</h2>
<p><strong>RadioSetTxConfig</strong> sets the LoRa Transmit Configuration: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L787-L908">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSetTxConfig( RadioModems_t modem, int8_t power, uint32_t fdev,
  uint32_t bandwidth, uint32_t datarate,
  uint8_t coderate, uint16_t preambleLen,
  bool fixLen, bool crcOn, bool freqHopOn,
  uint8_t hopPeriod, bool iqInverted, uint32_t timeout ) {

  //  LoRa Modulation or FSK Modulation?
  switch( modem ) {
    case MODEM_FSK:
      //  Omitted: FSK Modulation
      ...
</code></pre></div>
<p>Since we‚Äôre using <strong>LoRa Modulation</strong> instead of FSK Modulation, we skip the section on FSK Modulation.</p>
<p>We begin by populating the <strong>Modulation Parameters</strong>: Spreading Factor, Bandwidth and Coding Rate‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    case MODEM_LORA:
      //  LoRa Modulation
      SX126x.ModulationParams.PacketType = 
        PACKET_TYPE_LORA;
      SX126x.ModulationParams.Params.LoRa.SpreadingFactor = 
        ( RadioLoRaSpreadingFactors_t ) datarate;
      SX126x.ModulationParams.Params.LoRa.Bandwidth =  
        Bandwidths[bandwidth];
      SX126x.ModulationParams.Params.LoRa.CodingRate = 
        ( RadioLoRaCodingRates_t )coderate;
</code></pre></div>
<p>Depending on the LoRa Parameters, we optimise for <strong>Low Data Rate</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Optimise for Low Data Rate
      if( ( ( bandwidth == 0 ) &amp;&amp; ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
      ( ( bandwidth == 1 ) &amp;&amp; ( datarate == 12 ) ) ) {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
      } else {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
      }
</code></pre></div>
<p>Next we populate the <strong>Packet Parameters</strong>: Preamble Length, Header Type, Payload Length, CRC Mode and Invert IQ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Populate Packet Type
      SX126x.PacketParams.PacketType = PACKET_TYPE_LORA;

      //  Populate Preamble Length
      if( ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
        ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF6 ) ) {
        if( preambleLen &lt; 12 ) {
          SX126x.PacketParams.Params.LoRa.PreambleLength = 12;
        } else {
          SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
        }
      } else {
        SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
      }

      //  Populate Header Type, Payload Length, CRC Mode and Invert IQ
      SX126x.PacketParams.Params.LoRa.HeaderType = 
        ( RadioLoRaPacketLengthsMode_t )fixLen;
      SX126x.PacketParams.Params.LoRa.PayloadLength = 
        MaxPayloadLength;
      SX126x.PacketParams.Params.LoRa.CrcMode = 
        ( RadioLoRaCrcModes_t )crcOn;
      SX126x.PacketParams.Params.LoRa.InvertIQ = 
        ( RadioLoRaIQModes_t )iqInverted;
</code></pre></div>
<p>We set the LoRa Module to <strong>Standby Mode</strong> and configure it for <strong>LoRa Modulation</strong> (or FSK Modulation)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Set LoRa Module to Standby Mode
      RadioStandby( );

      //  Configure LoRa Module for LoRa Modulation (or FSK Modulation)
      RadioSetModem( 
        ( SX126x.ModulationParams.PacketType == PACKET_TYPE_GFSK ) 
        ? MODEM_FSK 
        : MODEM_LORA
      );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1111-L1115">(<strong>RadioStandby</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L576-L598">(<strong>RadioSetModem</strong> is defined here)</a></p>
<p>We configure the LoRa Module with the <strong>Modulation Parameters</strong> and <strong>Packet Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Configure Modulation Parameters
      SX126xSetModulationParams( &amp;SX126x.ModulationParams );

      //  Configure Packet Parameters
      SX126xSetPacketParams( &amp;SX126x.PacketParams );
      break;
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L578-L621">(<strong>SX126xSetModulationParams</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L623-L680">(<strong>SX126xSetPacketParams</strong> is defined here)</a></p>
<p>This is a Workaround for <strong>Modulation Quality</strong> with <strong>500 kHz Bandwidth</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // WORKAROUND - Modulation Quality with 500 kHz LoRa Bandwidth, see DS_SX1261-2_V1.2 datasheet chapter 15.1
  if( ( modem == MODEM_LORA ) &amp;&amp; ( SX126x.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) ) {
    SX126xWriteRegister( 
      REG_TX_MODULATION, 
      SX126xReadRegister( REG_TX_MODULATION ) &amp; ~( 1 &lt;&lt; 2 ) 
    );
  } else {
    SX126xWriteRegister( 
      REG_TX_MODULATION, 
      SX126xReadRegister( REG_TX_MODULATION ) | ( 1 &lt;&lt; 2 ) 
    );
  }
  // WORKAROUND END
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L294-L299">(<strong>SX126xReadRegister</strong> is defined here)</a></p>
<p>We finish by setting the <strong>Transmit Power</strong> and <strong>Transmit Timeout</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set Transmit Power
  SX126xSetRfTxPower( power );

  //  Set Transmit Timeout
  TxTimeout = timeout;
}
</code></pre></div>
<p><strong>SX126xSetRfTxPower</strong> is defined in <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L317-L322">sx126x-nuttx.c</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xSetRfTxPower( int8_t power ) {
  //  TODO: Previously: SX126xSetTxParams( power, RADIO_RAMP_40_US );
  SX126xSetTxParams( power, RADIO_RAMP_3400_US );  //  TODO
}
</code></pre></div>
<p>For easier testing we have set the Ramp Up Time to <strong>3400 microseconds</strong> (longest duration).</p>
<p>After testing we should revert to the <strong>Default Ramp Up Time</strong> (40 microseconds).</p>
<h2 id="radiosetrxconfig-set-receive-configuration"><a class="doc-anchor" href="#radiosetrxconfig-set-receive-configuration">¬ß</a>15.4 RadioSetRxConfig: Set Receive Configuration</h2>
<p><strong>RadioSetRxConfig</strong> sets the LoRa Receive Configuration: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L660-L786">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSetRxConfig( RadioModems_t modem, uint32_t bandwidth,
  uint32_t datarate, uint8_t coderate,
  uint32_t bandwidthAfc, uint16_t preambleLen,
  uint16_t symbTimeout, bool fixLen,
  uint8_t payloadLen,
  bool crcOn, bool freqHopOn, uint8_t hopPeriod,
  bool iqInverted, bool rxContinuous ) {

  //  Set Symbol Timeout
  RxContinuous = rxContinuous;
  if( rxContinuous == true ) {
    symbTimeout = 0;
  }

  //  Set Max Payload Length
  if( fixLen == true ) {
    MaxPayloadLength = payloadLen;
  }
  else {
    MaxPayloadLength = 0xFF;
  }
</code></pre></div>
<p>We begin by setting the <strong>Symbol Timeout</strong> and <strong>Max Payload Length</strong>.</p>
<p>Since we‚Äôre using <strong>LoRa Modulation</strong> instead of FSK Modulation, we skip the section on FSK Modulation‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  LoRa Modulation or FSK Modulation?
  switch( modem )
  {
    case MODEM_FSK:
      //  Omitted: FSK Modulation
      ...
</code></pre></div>
<p>We populate the <strong>Modulation Parameters</strong>: Spreading Factor, Bandwidth and Coding Rate‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    case MODEM_LORA:
      //  LoRa Modulation
      SX126xSetStopRxTimerOnPreambleDetect( false );
      SX126x.ModulationParams.PacketType = 
        PACKET_TYPE_LORA;
      SX126x.ModulationParams.Params.LoRa.SpreadingFactor = 
        ( RadioLoRaSpreadingFactors_t )datarate;
      SX126x.ModulationParams.Params.LoRa.Bandwidth = 
        Bandwidths[bandwidth];
      SX126x.ModulationParams.Params.LoRa.CodingRate = 
        ( RadioLoRaCodingRates_t )coderate;
</code></pre></div>
<p>Depending on the LoRa Parameters, we optimise for <strong>Low Data Rate</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Optimise for Low Data Rate
      if( ( ( bandwidth == 0 ) &amp;&amp; ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
      ( ( bandwidth == 1 ) &amp;&amp; ( datarate == 12 ) ) ) {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
      } else {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
      }
</code></pre></div>
<p>We populate the <strong>Packet Parameters</strong>: Preamble Length, Header Type, Payload Length, CRC Mode and Invert IQ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Populate Packet Type
      SX126x.PacketParams.PacketType = PACKET_TYPE_LORA;

      //  Populate Preamble Length
      if( ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
          ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF6 ) ){
        if( preambleLen &lt; 12 ) {
          SX126x.PacketParams.Params.LoRa.PreambleLength = 12;
        } else {
          SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
        }
      } else {
        SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
      }

      //  Populate Header Type, Payload Length, CRC Mode and Invert IQ
      SX126x.PacketParams.Params.LoRa.HeaderType = 
        ( RadioLoRaPacketLengthsMode_t )fixLen;
      SX126x.PacketParams.Params.LoRa.PayloadLength = 
        MaxPayloadLength;
      SX126x.PacketParams.Params.LoRa.CrcMode = 
        ( RadioLoRaCrcModes_t )crcOn;
      SX126x.PacketParams.Params.LoRa.InvertIQ = 
        ( RadioLoRaIQModes_t )iqInverted;
</code></pre></div>
<p>We set the LoRa Module to <strong>Standby Mode</strong> and configure it for <strong>LoRa Modulation</strong> (or FSK Modulation)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Set LoRa Module to Standby Mode
      RadioStandby( );

      //  Configure LoRa Module for LoRa Modulation (or FSK Modulation)
      RadioSetModem( 
          ( SX126x.ModulationParams.PacketType == PACKET_TYPE_GFSK ) 
          ? MODEM_FSK 
          : MODEM_LORA 
      );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1111-L1115">(<strong>RadioStandby</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L576-L598">(<strong>RadioSetModem</strong> is defined here)</a></p>
<p>We configure the LoRa Module with the <strong>Modulation Parameters</strong>, <strong>Packet Parameters</strong> and Symbol Timeout‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Configure Modulation Parameters
      SX126xSetModulationParams( &amp;SX126x.ModulationParams );

      //  Configure Packet Parameters
      SX126xSetPacketParams( &amp;SX126x.PacketParams );

      //  Configure Symbol Timeout
      SX126xSetLoRaSymbNumTimeout( symbTimeout );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L578-L621">(<strong>SX126xSetModulationParams</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L623-L680">(<strong>SX126xSetPacketParams</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L366-L388">(<strong>SX126xSetLoRaSymbNumTimeout</strong> is defined here)</a></p>
<p>This is a Workaround that <strong>optimises the Inverted IQ Operation</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      // WORKAROUND - Optimizing the Inverted IQ Operation, see DS_SX1261-2_V1.2 datasheet chapter 15.4
      if( SX126x.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED ) {
        SX126xWriteRegister( 
          REG_IQ_POLARITY, 
          SX126xReadRegister( REG_IQ_POLARITY ) &amp; ~( 1 &lt;&lt; 2 ) 
        );
      } else {
        SX126xWriteRegister( 
          REG_IQ_POLARITY, 
          SX126xReadRegister( REG_IQ_POLARITY ) | ( 1 &lt;&lt; 2 ) 
        );
      }
      // WORKAROUND END
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L294-L299">(<strong>SX126xReadRegister</strong> is defined here)</a></p>
<p>We finish by setting the <strong>Receive Timeout</strong> to No Timeout (always receiving)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      // Timeout Max, Timeout handled directly in SetRx function
      RxTimeout = 0xFFFF;
      break;
  }
}
</code></pre></div><h2 id="radiosend-transmit-message"><a class="doc-anchor" href="#radiosend-transmit-message">¬ß</a>15.5 RadioSend: Transmit Message</h2>
<p><strong>RadioSend</strong> transmits a LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1068-L1098">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSend( uint8_t *buffer, uint8_t size ) {

  //  Set the DIO Interrupt Events:
  //  Transmit Done and Transmit Timeout
  //  will trigger interrupts on DIO1
  SX126xSetDioIrqParams( 
    IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT,  //  Interrupt Mask
    IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT,  //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L457-L470">(<strong>SX126xSetDioIrqParams</strong> is defined here)</a></p>
<p>We begin by configuring which <strong>LoRa Events will trigger interrupts</strong> on each DIO Pin.</p>
<p>(Transmit Done and Transmit Timeout will trigger interrupts on DIO1)</p>
<p>Next we configure the <strong>Packet Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Populate the payload length
  if( SX126xGetPacketType( ) == PACKET_TYPE_LORA ) {
    SX126x.PacketParams.Params.LoRa.PayloadLength = size;
  } else {
    SX126x.PacketParams.Params.Gfsk.PayloadLength = size;
  }
  //  Configure the packet parameters
  SX126xSetPacketParams( &amp;SX126x.PacketParams );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L523-L526">(<strong>SX126xGetPacketType</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L623-L680">(<strong>SX126xSetPacketParams</strong> is defined here)</a></p>
<p>We finish by sending the <strong>Message Payload</strong> and starting the <strong>Transmit Timer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Send message payload
  SX126xSendPayload( buffer, size, 0 );

  //  Start Transmit Timer
  TimerStart2( &amp;TxTimeoutTimer, TxTimeout );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L466-L491">(<strong>TimerStart2</strong> is defined here)</a></p>
<p><strong>SX126xSendPayload</strong> is defined below: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L162-L166">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>///  Send message payload
void SX126xSendPayload( uint8_t *payload, uint8_t size, uint32_t timeout ) {
  //  Copy message payload to Transmit Buffer
  SX126xSetPayload( payload, size );

  //  Transmit the buffer
  SX126xSetTx( timeout );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L289-L299">(<strong>SX126xSetTx</strong> is defined here)</a></p>
<p>This code copies the Message Payload to the SX1262 <strong>Transmit Buffer</strong> and transmits the message.</p>
<p><strong>SX126xSetPayload</strong> copies to the Transmit Buffer by calling <strong>SX126xWriteBuffer</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L144-L147">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload to Transmit Buffer
void SX126xSetPayload( uint8_t *payload, uint8_t size ) {
  //  Copy message payload to Transmit Buffer
  SX126xWriteBuffer( 0x00, payload, size );
}
</code></pre></div>
<p><strong>SX126xWriteBuffer</strong> wakes up the LoRa Module, writes to the Transmit Buffer and waits for the operation to be completed: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L283-L289">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload to Transmit Buffer
void SX126xWriteBuffer( uint8_t offset, uint8_t *buffer, uint8_t size ) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady( );

  //  Copy message payload to Transmit Buffer
  int rc = sx126x_write_buffer(NULL, offset, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy( );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L133-L142">(<strong>SX126xCheckDeviceReady</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit-message">(<strong>sx126x_write_buffer</strong> is explained here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L185-L200">(<strong>SX126xWaitOnBusy</strong> is defined here)</a></p>
<p>When the LoRa Message is transmitted (successfully or unsuccessfully), the LoRa Module triggers a <strong>DIO1 Interrupt</strong>.</p>
<p>Our driver calls <strong>RadioIrqProcess</strong> to process the interrupt. <a href="https://lupyuen.github.io/articles/sx1262#radioirqprocess-process-transmit-and-receive-interrupts">(See this)</a></p>
<h2 id="radiorx-receive-message"><a class="doc-anchor" href="#radiorx-receive-message">¬ß</a>15.6 RadioRx: Receive Message</h2>
<p><strong>RadioRx</strong> preps SX1262 to receive a single LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1116-L1138">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioRx( uint32_t timeout ) {

  //  Set the DIO Interrupt Events:
  //  All LoRa Events will trigger interrupts on DIO1
  SX126xSetDioIrqParams(
    IRQ_RADIO_ALL,   //  Interrupt Mask
    IRQ_RADIO_ALL,   //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L457-L470">(<strong>SX126xSetDioIrqParams</strong> is defined here)</a></p>
<p>We begin by configuring which <strong>LoRa Events will trigger interrupts</strong> on each DIO Pin.</p>
<p>(All LoRa Events will trigger interrupts on DIO1)</p>
<p>We start the <strong>Receive Timer</strong> to catch Receive Timeouts‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Start the Receive Timer
  if( timeout != 0 ) {
    TimerStart2( &amp;RxTimeoutTimer, timeout );
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L466-L491">(<strong>TimerStart2</strong> is defined here)</a></p>
<p>Now we begin to <strong>receive a LoRa Message</strong> continuously, or until a timeout occurs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if( RxContinuous == true ) {
    //  Receive continuously
    SX126xSetRx( 0xFFFFFF ); // Rx Continuous
  } else {
    //  Receive with timeout
    SX126xSetRx( RxTimeout &lt;&lt; 6 );
  }
}
</code></pre></div>
<p><strong>SX126xSetRx</strong> enters Receive Mode like so: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L301-L313">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xSetRx( uint32_t timeout ) {
  uint8_t buf[3];

  //  Remember we&#39;re in Receive Mode
  SX126xSetOperatingMode( MODE_RX );

  //  Configure Receive Gain
  SX126xWriteRegister( REG_RX_GAIN, 0x94 ); // default gain

  //  Enter Receive Mode
  buf[0] = ( uint8_t )( ( timeout &gt;&gt; 16 ) &amp; 0xFF );
  buf[1] = ( uint8_t )( ( timeout &gt;&gt; 8 ) &amp; 0xFF );
  buf[2] = ( uint8_t )( timeout &amp; 0xFF );
  SX126xWriteCommand( RADIO_SET_RX, buf, 3 );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L140-L161">(<strong>SX126xSetOperatingMode</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L222-L235">(<strong>SX126xWriteCommand</strong> is defined here)</a></p>
<p>When a LoRa Message is received (successfully or unsuccessfully), the LoRa Module triggers a <strong>DIO1 Interrupt</strong>.</p>
<p>Our driver calls <strong>RadioIrqProcess</strong> to process the interrupt, which is explained next‚Ä¶</p>
<h2 id="radioirqprocess-process-transmit-and-receive-interrupts"><a class="doc-anchor" href="#radioirqprocess-process-transmit-and-receive-interrupts">¬ß</a>15.7 RadioIrqProcess: Process Transmit and Receive Interrupts</h2>
<p><strong>RadioIrqProcess</strong> processes the interrupts that are triggered when a LoRa Message is transmitted and received: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1313-L1460">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Process Transmit and Receive Interrupts.
/// For BL602: Must be run in the Application
/// Task Context, not Interrupt Context because 
/// we will call printf and SPI Functions here.
void RadioIrqProcess( void ) {

  //  Remember and clear Interrupt Flag
  CRITICAL_SECTION_BEGIN( );
  const bool isIrqFired = IrqFired;
  IrqFired = false;
  CRITICAL_SECTION_END( );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/include/sx126x-board.h#L58-L60">(Note: Critical Sections are not yet implemented)</a></p>
<p>The function begins by copying the <strong>Interrupt Flag</strong> and clearing the flag.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioondioirq">(The Interrupt Flag is set by <strong>RadioOnDioIrq</strong>)</a></p>
<p>The rest of the function will run only if the <strong>Interrupt Flag was originally set</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  IrqFired must be true to process interrupts
  if( isIrqFired == true ) {
    //  Get the Interrupt Status
    uint16_t irqRegs = SX126xGetIrqStatus( );

    //  Clear the Interrupt Status
    SX126xClearIrqStatus( irqRegs );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L472-L478">(<strong>SX126xGetIrqStatus</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L803-L810">(<strong>SX126xClearIrqStatus</strong> is defined here)</a></p>
<p>This code fetches the <strong>Interrupt Status</strong> from the LoRa Module and clears the Interrupt Status.</p>
<p>If DIO1 is still High, we set the <strong>Interrupt Flag</strong> for future processing‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Check if DIO1 pin is High. If it is the case revert IrqFired to true
    CRITICAL_SECTION_BEGIN( );
    if( SX126xGetDio1PinState( ) == 1 ) {
      IrqFired = true;
    }
    CRITICAL_SECTION_END( );
</code></pre></div>
<p><strong>Interrupt Status</strong> tells us which LoRa Events have just occurred. We handle the LoRa Events accordingly‚Ä¶</p>
<ul>
<li>
<p>Transmit Done</p>
</li>
<li>
<p>Receive Done</p>
</li>
<li>
<p>CAD Done</p>
</li>
<li>
<p>Transmit / Receive Timeout</p>
</li>
<li>
<p>Preamble Detected</p>
</li>
<li>
<p>Sync Word Valid</p>
</li>
<li>
<p>Header Valid</p>
</li>
<li>
<p>Header Error</p>
</li>
</ul>
<h3 id="transmit-done"><a class="doc-anchor" href="#transmit-done">¬ß</a>15.7.1 Transmit Done</h3>
<p>When the LoRa Module has transmitted a LoRa Message successfully, we stop the Transmit Timer and call the <strong>Callback Function for Transmit Done</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1339-L1349">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a LoRa Message was transmitted successfully...
    if( ( irqRegs &amp; IRQ_TX_DONE ) == IRQ_TX_DONE ) {

      //  Stop the Transmit Timer
      TimerStop( &amp;TxTimeoutTimer );

      //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
      SX126xSetOperatingMode( MODE_STDBY_RC );

      //  Call the Callback Function for Transmit Done
      if( ( RadioEvents.TxDone != NULL ) ) {
        RadioEvents.TxDone( );
      }
    }
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L407-L419">(<strong>TimerStop</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L140-L161">(<strong>SX126xSetOperatingMode</strong> is defined here)</a></p>
<p><strong>TxDone</strong> points to the <strong>on_tx_done</strong> Callback Function that we‚Äôve seen earlier.</p>
<h3 id="receive-done"><a class="doc-anchor" href="#receive-done">¬ß</a>15.7.2 Receive Done</h3>
<p>When the LoRa Module receives a LoRa Message, we stop the Receive Timer: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1351-L1389">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a LoRa Message was received...
    if( ( irqRegs &amp; IRQ_RX_DONE ) == IRQ_RX_DONE ) {

      //  Stop the Receive Timer
      TimerStop( &amp;RxTimeoutTimer );
</code></pre></div>
<p>In case of CRC Error, we call the <strong>Callback Function for Receive Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      if( ( irqRegs &amp; IRQ_CRC_ERROR ) == IRQ_CRC_ERROR ) {

        //  If the received message has CRC Error...
        if( RxContinuous == false ) {
          //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
          SX126xSetOperatingMode( MODE_STDBY_RC );
        }

        //  Call the Callback Function for Receive Error
        if( ( RadioEvents.RxError ) ) {
          RadioEvents.RxError( );
        }
</code></pre></div>
<p><strong>RxError</strong> points to the <strong>on_rx_error</strong> Callback Function that we‚Äôve seen earlier.</p>
<p>If the received message has no CRC Error, we do this Workaround for <strong>Implicit Header Mode Timeout Behavior</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      } else {
        //  If the received message has no CRC Error...
        uint8_t size;

        //  If we are receiving continously...
        if( RxContinuous == false ) {
          //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
          SX126xSetOperatingMode( MODE_STDBY_RC );

          // WORKAROUND - Implicit Header Mode Timeout Behavior, see DS_SX1261-2_V1.2 datasheet chapter 15.3
          SX126xWriteRegister( REG_RTC_CTRL, 0x00 );
          SX126xWriteRegister( 
            REG_EVT_CLR, 
            SX126xReadRegister( REG_EVT_CLR ) | ( 1 &lt;&lt; 1 ) 
          );
          // WORKAROUND END
        }
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L294-L299">(<strong>SX126xReadRegister</strong> is defined here)</a></p>
<p>Then we copy the <strong>Received Message Payload</strong> and get the <strong>Packet Status</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>        //  Copy the Received Message Payload (max 255 bytes)
        SX126xGetPayload( RadioRxPayload, &amp;size , 255 );
        
        //  Get the Packet Status:
        //  Packet Signal Strength (RSSI), Signal-to-Noise Ratio (SNR),
        //  Signal RSSI, Frequency Error
        SX126xGetPacketStatus( &amp;RadioPktStatus );
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L746-L778">(<strong>SX126xGetPacketStatus</strong> is defined here)</a></p>
<p>And we call the <strong>Callback Function for Receive Done</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>        //  Call the Callback Function for Receive Done
        if( ( RadioEvents.RxDone != NULL ) ) {
          RadioEvents.RxDone( 
            RadioRxPayload, 
            size, 
            RadioPktStatus.Params.LoRa.RssiPkt, 
            RadioPktStatus.Params.LoRa.SnrPkt 
          );
        }
      }
    }
</code></pre></div>
<p><strong>RxDone</strong> points to the <strong>on_rx_done</strong> Callback Function that we‚Äôve seen earlier.</p>
<p><strong>SX126xGetPayload</strong> copies the received message payload from the SX1262 <strong>Receive Buffer</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L149-L160">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload from Receive Buffer
uint8_t SX126xGetPayload( uint8_t *buffer, uint8_t *size,  uint8_t maxSize ) {
  uint8_t offset = 0;

  //  Get the size and offset of the received message
  //  in the Receive Buffer
  SX126xGetRxBufferStatus( size, &amp;offset );
  if( *size &gt; maxSize ) {
    return 1;
  }

  //  Copy message payload from Receive Buffer
  SX126xReadBuffer( offset, buffer, *size );
  return 0;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L727-L744">(<strong>SX126xGetRxBufferStatus</strong> is defined here)</a></p>
<p><strong>SX126xReadBuffer</strong> wakes up the LoRa Module, reads from the Receive Buffer and waits for the operation to be completed: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L309-L315">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload from Receive Buffer
void SX126xReadBuffer( uint8_t offset, uint8_t *buffer, uint8_t size ) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady( );

  //  Copy message payload from Receive Buffer
  int rc = sx126x_read_buffer(NULL, offset, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy( );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L133-L142">(<strong>SX126xCheckDeviceReady</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-message">(<strong>sx126x_read_buffer</strong> is explained here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L185-L200">(<strong>SX126xWaitOnBusy</strong> is defined here)</a></p>
<h3 id="cad-done"><a class="doc-anchor" href="#cad-done">¬ß</a>15.7.3 CAD Done</h3>
<p><strong>Channel Activity Detection</strong> lets us <strong>detect whether there‚Äôs any ongoing transmission</strong> in a LoRa Radio Channel, in a power-efficient way.</p>
<p>We won‚Äôt be doing Channel Activity Detection in our driver: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1391-L1400">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If Channel Activity Detection is complete...
    if( ( irqRegs &amp; IRQ_CAD_DONE ) == IRQ_CAD_DONE ) {

      //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
      SX126xSetOperatingMode( MODE_STDBY_RC );

      //  Call Callback Function for CAD Done
      if( ( RadioEvents.CadDone != NULL ) ) {
        RadioEvents.CadDone( ( 
            ( irqRegs &amp; IRQ_CAD_ACTIVITY_DETECTED ) 
            == IRQ_CAD_ACTIVITY_DETECTED 
        ) );
      }
    }
</code></pre></div><h3 id="transmit--receive-timeout"><a class="doc-anchor" href="#transmit--receive-timeout">¬ß</a>15.7.4 Transmit / Receive Timeout</h3>
<p>When the LoRa Module <strong>fails to transmit</strong> a LoRa Message due to Timeout, we stop the Transmit Timer and call the <strong>Callback Function for Transmit Timeout</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1402-L1425">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a LoRa Message failed to Transmit or Receive due to Timeout...
    if( ( irqRegs &amp; IRQ_RX_TX_TIMEOUT ) == IRQ_RX_TX_TIMEOUT ) {

      //  If the message failed to Transmit due to Timeout...
      if( SX126xGetOperatingMode( ) == MODE_TX ) {

        //  Stop the Transmit Timer
        TimerStop( &amp;TxTimeoutTimer );

        //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );

        //  Call the Callback Function for Transmit Timeout
        if( ( RadioEvents.TxTimeout != NULL ) ) {
          RadioEvents.TxTimeout( );
        }
      }
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L135-L138">(<strong>SX126xGetOperatingMode</strong> is defined here)</a></p>
<p><strong>TxTimeout</strong> points to the <strong>on_tx_timeout</strong> Callback Function that we‚Äôve seen earlier.</p>
<p>When the LoRa Module <strong>fails to receive</strong> a LoRa Message due to Timeout, we stop the Receive Timer and call the <strong>Callback Function for Receive Timeout</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  If the message failed to Receive due to Timeout...
      else if( SX126xGetOperatingMode( ) == MODE_RX ) {

        //  Stop the Receive Timer
        TimerStop( &amp;RxTimeoutTimer );

        //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );

        //  Call the Callback Function for Receive Timeout
        if( ( RadioEvents.RxTimeout != NULL ) ) {
          RadioEvents.RxTimeout( );
        }
      }
    }
</code></pre></div>
<p><strong>RxTimeout</strong> points to the <strong>on_rx_timeout</strong> Callback Function that we‚Äôve seen earlier.</p>
<h3 id="preamble-detected"><a class="doc-anchor" href="#preamble-detected">¬ß</a>15.7.5 Preamble Detected</h3>
<p>Preamble is the Radio Signal that <strong>precedes the LoRa Message</strong>. When the LoRa Module detects the Preamble Signal, it knows that it‚Äôs about to receive a LoRa Message.</p>
<p>We don‚Äôt need to handle the Preamble Signal, the LoRa Module does it for us: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1427-L1431">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If LoRa Preamble was detected...
    if( ( irqRegs &amp; IRQ_PREAMBLE_DETECTED ) == IRQ_PREAMBLE_DETECTED ) {
      //__NOP( );
    }
</code></pre></div>
<p>Our <a href="https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b"><strong>Receive Message Log</strong></a> shows that the Preamble Signal (<strong>IRQ_PREAMBLE_DETECTED</strong>) is always detected before receiving a LoRa Message.</p>
<p>(<strong>IRQ_PREAMBLE_DETECTED</strong> appears just before the LoRa Header: <strong>IRQ_HEADER_VALID</strong>)</p>
<p><a href="https://www.link-labs.com/blog/what-is-lora">(More about LoRa Preamble)</a></p>
<h3 id="sync-word-valid"><a class="doc-anchor" href="#sync-word-valid">¬ß</a>15.7.6 Sync Word Valid</h3>
<p><strong>Sync Words</strong> are 16-bit values that differentiate the types of LoRa Networks.</p>
<p>The LoRa Module detects the Sync Words when it receive a LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1433-L1437">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a valid Sync Word was detected...
    if( ( irqRegs &amp; IRQ_SYNCWORD_VALID ) == IRQ_SYNCWORD_VALID ) {
      //__NOP( );
    }
</code></pre></div>
<p>Note that the <strong>Sync Word differs for LoRaWAN</strong> vs Private LoRa Networks‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Syncword for Private LoRa networks
#define LORA_MAC_PRIVATE_SYNCWORD                   0x1424

//  Syncword for Public LoRa networks (LoRaWAN)
#define LORA_MAC_PUBLIC_SYNCWORD                    0x3444
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-lora-sync-word">(More about Sync Words)</a></p>
<h3 id="header-valid"><a class="doc-anchor" href="#header-valid">¬ß</a>15.7.7 Header Valid</h3>
<p>The LoRa Module checks for a <strong>valid LoRa Header</strong> when receiving a LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1439-L1443">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a valid Header was received...
    if( ( irqRegs &amp; IRQ_HEADER_VALID ) == IRQ_HEADER_VALID ) {
      //__NOP( );
    }
</code></pre></div>
<p>Our <a href="https://github.com/lupyuen/lora-sx1262#receive-message"><strong>Receive Message Log</strong></a> shows that the LoRa Header (<strong>IRQ_HEADER_VALID</strong>) is always detected before receiving a LoRa Message.</p>
<p>(<strong>IRQ_HEADER_VALID</strong> appears right after the Preamble Signal: <strong>IRQ_PREAMBLE_DETECTED</strong>)</p>
<h3 id="header-error"><a class="doc-anchor" href="#header-error">¬ß</a>15.7.8 Header Error</h3>
<p>When the LoRa Module detects a <strong>LoRa Header with CRC Error</strong>, we stop the Receive Timer and call the Callback Function for Receive Timeout: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1445-L1458">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a Header with CRC Error was received...
    if( ( irqRegs &amp; IRQ_HEADER_ERROR ) == IRQ_HEADER_ERROR ) {

      //  Stop the Receive Timer
      TimerStop( &amp;RxTimeoutTimer );

      if( RxContinuous == false ) {
        //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );
      }

      //  Call the Callback Function for Receive Timeout
      if( ( RadioEvents.RxTimeout != NULL ) ) {
        RadioEvents.RxTimeout( );
      }
    }
  }
}
</code></pre></div>
<p><strong>RxTimeout</strong> points to the <strong>on_rx_timeout</strong> Callback Function that we‚Äôve seen earlier.</p>
<h3 id="radioondioirq"><a class="doc-anchor" href="#radioondioirq">¬ß</a>15.7.9 RadioOnDioIrq</h3>
<p><strong>RadioIrqProcess</strong> (as defined above) is called by <strong>RadioOnDioIrq</strong> to handle LoRa Transmit and Receive Events: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1300-L1312">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function for Transmit and Receive Interrupts.
/// For BL602: This function runs in the context of the 
/// Background Application Task. So we are safe to call 
/// printf and SPI Functions now.
void RadioOnDioIrq( struct ble_npl_event *ev ) {
  //  Set the Interrupt Flag
  IrqFired = true;

  //  BL602 Note: It&#39;s OK to process the interrupt here because we are in
  //  Application Task Context, not Interrupt Context.
  //  The Reference Implementation processes the interrupt in the main loop.
  RadioIrqProcess();
}
</code></pre></div><h2 id="radiosleep-switch-to-sleep-mode"><a class="doc-anchor" href="#radiosleep-switch-to-sleep-mode">¬ß</a>15.8 RadioSleep: Switch to Sleep Mode</h2>
<p><strong>RadioSleep</strong> switches SX1262 to low-power sleep mode: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1099-L1109">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Switch to Sleep Mode
void RadioSleep( void ) {
  SleepParams_t params = { 0 };
  params.Fields.WarmStart = 1;

  //  Switch to Sleep Mode and wait 2 milliseconds
  SX126xSetSleep( params );
  DelayMs( 2 );
}
</code></pre></div>
<p><strong>SX126xSetSleep</strong> executes the Sleep Command on the LoRa Module: <a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L253-L268">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Switch to Sleep Mode
void SX126xSetSleep( SleepParams_t sleepConfig ) {
  //  Switch off antenna (not used)
  SX126xAntSwOff( );

  //  Compute Sleep Parameter
  uint8_t value = ( 
      ( ( uint8_t )sleepConfig.Fields.WarmStart &lt;&lt; 2 ) |
      ( ( uint8_t )sleepConfig.Fields.Reset &lt;&lt; 1 ) |
      ( ( uint8_t )sleepConfig.Fields.WakeUpRTC ) 
  );

  if( sleepConfig.Fields.WarmStart == 0 ) {
    // Force image calibration
    ImageCalibrated = false;
  }

  //  Run Sleep Command
  SX126xWriteCommand( RADIO_SET_SLEEP, &amp;value, 1 );
  SX126xSetOperatingMode( MODE_SLEEP );
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L342-L347">(<strong>SX126xAntSwOff</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L222-L235">(<strong>SX126xWriteCommand</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L140-L161">(<strong>SX126xSetOperatingMode</strong> is defined here)</a></p>
<h1 id="appendix-gpio-pin-type-issue"><a class="doc-anchor" href="#appendix-gpio-pin-type-issue">¬ß</a>16 Appendix: GPIO Pin Type Issue</h1>
<p>When we switch a GPIO Interrupt Pin Type to Trigger On Rising Edge, it crashes with an Assertion Failure‚Ä¶ </p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>nsh&gt; gpio -t <span class="number">8 </span>-w <span class="number">1 </span>/dev/gpio2

Driver: /dev/gpio2
up_assert: Assertion failed at file:ioexpander/gpio.c line: <span class="number">544 </span>task: gpio</code></pre></div>
<p>(For PineDio Stack BL604: Use ‚Äú/dev/gpio19‚Äù)</p>
<p>I‚Äôll submit a NuttX Issue, meanwhile I have disabled the assertion‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx/blob/lorawan/drivers/ioexpander/gpio.c#L544-L547">drivers/ioexpander/gpio.c (line 544)</a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/lorawan3-int.png" alt="GPIO Pin Type Issue" /></p>
<h1 id="appendix-nimble-callout-issue"><a class="doc-anchor" href="#appendix-nimble-callout-issue">¬ß</a>17 Appendix: NimBLE Callout Issue</h1>
<p>NimBLE Porting Layer doesn‚Äôt work for multiple Callout Timers unless we loop the thread‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-callout.png" alt="NimBLE Callout Issue" /></p>
<p><a href="https://github.com/lupyuen/nimble-porting-nuttx/blob/master/porting/npl/nuttx/src/os_callout.c#L35-L70">(Source)</a></p>
<p>I will submit a Pull Request to Apache NimBLE.</p>
<p>UPDATE: Unfortunately the thread never terminates, so any NuttX App that calls NimBLE Callouts won‚Äôt terminate either. (Even when we call exit()). We need to terminate the thread in our code.</p>
<h1 id="appendix-previous-sx1262-library"><a class="doc-anchor" href="#appendix-previous-sx1262-library">¬ß</a>18 Appendix: Previous SX1262 Library</h1>
<p>This section describes the <strong>previous (obsolete) version</strong> of the SX1262 Library‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262/tree/nuttx"><strong>lupyuen/lora-sx1262 (nuttx branch)</strong></a></li>
</ul>
<p>Which has been superseded by the <strong>new version</strong> of the SX1262 Library‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262/tree/lorawan"><strong>lupyuen/lora-sx1262 (lorawan branch)</strong></a></li>
</ul>
<p>The previous version <strong>does NOT support LoRaWAN, GPIO Interface and NimBLE Porting Layer.</strong></p>
<p><em>Huh? SX1262 works without GPIO control?</em></p>
<p>We found some sneaky workarounds to <strong>control LoRa SX1262 without GPIO</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>DIO1</strong>: Because we don‚Äôt support GPIO Interrupts (yet), we <strong>poll the SX1262 Status every second</strong> to check if a LoRa Packet has been received.</p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L126-L136">(See this)</a></p>
</li>
<li>
<p><strong>BUSY</strong>: Instead of reading this pin to check if SX1262 is busy, we <strong>sleep 10 milliseconds</strong>.</p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182">(See this)</a></p>
</li>
<li>
<p><strong>NRESET</strong>: To reset the SX1262 module, we <strong>manually restart our NuttX gadget</strong>.</p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L149-L169">(See this)</a></p>
</li>
</ul>
<p>These sneaky hacks will need to be fixed by calling the GPIO Interface.</p>
<p><em>What needs to be fixed for GPIO?</em></p>
<p>We need to mod these functions to call the <strong>NuttX GPIO Interface</strong>‚Ä¶</p>
<ol>
<li>
<p>Initialise the GPIO Pins: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L65-L77"><strong>SX126xIoInit</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-spi-functions">(Similar to BL602 IoT SDK)</a></p>
</li>
<li>
<p>Register GPIO Interrupt Handler for DIO1: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L79-L91"><strong>SX126xIoIrqInit</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts">(Similar to BL602 IoT SDK)</a></p>
</li>
<li>
<p>Reset SX1262 via GPIO: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L149-L169"><strong>SX126xReset</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xReset(void) {
    //  TODO: Set Reset pin to Low
    //  rc = bl_gpio_output_set(SX126X_NRESET, 1);
    //  assert(rc == 0);

    //  Wait 1 ms
    DelayMs(1);

    //  TODO: Configure Reset pin as a GPIO Input Pin, no pullup, no pulldown
    //  rc = bl_gpio_enable_input(SX126X_NRESET, 0, 0);
    //  assert(rc == 0);

    //  Wait 6 ms
    DelayMs(6);
}
</code></pre></div></li>
<li>
<p>Check SX1262 Busy State via GPIO: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182"><strong>SX126xWaitOnBusy</strong></a></p>
<p>(<strong>SX126xWaitOnBusy</strong> is called by <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L133-L142"><strong>SX126xCheckDeviceReady</strong></a>, which wakes up SX1262 before checking if SX1262 is busy)</p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xWaitOnBusy(void) {
  //  TODO: Fix the GPIO check for busy state.
  //  while( bl_gpio_input_get_value( SX126X_BUSY_PIN ) == 1 );

  //  Meanwhile we sleep 10 milliseconds
  usleep(10 * 1000);
}
</code></pre></div></li>
<li>
<p>Get DIO1 Pin State: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L337-L344"><strong>SX126xGetDio1PinState</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>uint32_t SX126xGetDio1PinState(void) {    
  //  TODO: Read and return DIO1 Pin State
  //  return bl_gpio_input_get_value( SX126X_DIO1 );

  //  Meanwhile we always return 0
  return 0;
}
</code></pre></div></li>
</ol>
<p>When we have implemented <strong>GPIO Interrupts</strong> in our driver, we can remove the <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L126-L136"><strong>Event Polling</strong></a>. And we run a <strong>Background Thread</strong> to handle LoRa Events.</p>
<p><em>How will we receive LoRa Messages with GPIO Interrupts?</em></p>
<p>After we have implemented <strong>GPIO Interrupts</strong> in our SX1262 Library, this is how we‚Äôll <strong>receive LoRa Messages</strong> without polling (see pic above)‚Ä¶</p>
<ol>
<li>
<p>When SX1262 receives a LoRa Message, it triggers a <strong>GPIO Interrupt</strong> on Pin DIO1</p>
</li>
<li>
<p>GPIO Driver forwards the GPIO Interrupt to our Interrupt Handler Function <a href="https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler"><strong>handle_gpio_interrupt</strong></a></p>
</li>
<li>
<p><strong>handle_gpio_interrupt</strong> enqueues an Event into our <strong>Event Queue</strong></p>
</li>
<li>
<p>Our <strong>Background Thread</strong> removes the Event from the Event Queue and calls <a href="https://lupyuen.github.io/articles/sx1262#radioondioirq"><strong>RadioOnDioIrq</strong></a> to process the received LoRa Message</p>
</li>
</ol>
<p>We handle GPIO Interrupts the same way in our <strong>LoRa SX1262 Driver for BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts"><strong>‚ÄúBL602 GPIO Interrupts‚Äù</strong></a></li>
</ul>
<p><em>Why do we need a Background Thread?</em></p>
<p>This will allow our LoRa Application to <strong>run without blocking</strong> (waiting) on incoming LoRa Messages.</p>
<p>This is especially useful when we implement <strong>LoRaWAN with our SX1262 Library</strong>, because LoRaWAN needs to handle <strong>asynchronous messages</strong> in the background.</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#join-network-request">(Like when we join a LoRaWAN Network)</a></p>
<p><em>How will we implement the Background Thread and Event Queue?</em></p>
<p>The code below shall be updated to <strong>start the Background Thread</strong> by calling NimBLE Porting Layer: <a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L369-L388">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// TODO: Create a Background Thread to handle LoRa Events
static void create_task(void) {
  //  Init the Event Queue
  ble_npl_eventq_init(&amp;event_queue);

  //  Init the Event
  ble_npl_event_init(
    &amp;event,        //  Event
    handle_event,  //  Event Handler Function
    NULL           //  Argument to be passed to Event Handler
  );

  //  TODO: Create a Background Thread to process the Event Queue
  //  nimble_port_freertos_init(task_callback);
}
</code></pre></div>
<p>And we shall implement the GPIO Interrupt Handler Function <a href="https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler"><strong>handle_gpio_interrupt</strong></a> for NuttX.</p>
<p><a href="https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L357-L432">(We don‚Äôt need to code the Event Queue, it has been done here)</a></p>
<p><em>When will we begin the implementation?</em></p>
<p>Very soon! We shall implement the Background Thread and Event Queue as we <strong>port the LoRaWAN Stack to NuttX</strong>.</p>
<p>(Because LoRaWAN needs multithreading to work)</p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>