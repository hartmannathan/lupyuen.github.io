<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Simpler USB with EHCI (Enhanced Host Controller Interface)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Simpler USB with EHCI (Enhanced Host Controller Interface)" 
    data-rh="true">
<meta property="og:description" 
    content="Porting the Enhanced Host Controller Interface (EHCI) USB Driver... From Apache NuttX RTOS to Pine64 PinePhone"
    data-rh="true">
<meta name="description" 
    content="Porting the Enhanced Host Controller Interface (EHCI) USB Driver... From Apache NuttX RTOS to Pine64 PinePhone">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/usb3-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Simpler USB with EHCI (Enhanced Host Controller Interface)</h1>
    <nav id="TOC"><ul>
<li><a href="#usb-enhanced-host-controller-interface">1 USB Enhanced Host Controller Interface</a><ul></ul></li>
<li><a href="#ehci-is-simpler-than-usb-on-the-go">2 EHCI is simpler than USB On-The-Go</a><ul></ul></li>
<li><a href="#pinephone-usb-controller">3 PinePhone USB Controller</a><ul></ul></li>
<li><a href="#pinephone-usb-driver-for-apache-nuttx-rtos">4 PinePhone USB Driver for Apache NuttX RTOS</a><ul></ul></li>
<li><a href="#64-bit-update-for-ehci-driver">5 64-Bit Update for EHCI Driver</a><ul></ul></li>
<li><a href="#halt-timeout-for-usb-controller">6 Halt Timeout for USB Controller</a><ul></ul></li>
<li><a href="#pinephone-usb-drivers-in-u-boot-bootloader">7 PinePhone USB Drivers in U-Boot Bootloader</a><ul></ul></li>
<li><a href="#power-on-the-usb-controller">8 Power On the USB Controller</a><ul></ul></li>
<li><a href="#usb-controller-clocks">9 USB Controller Clocks</a><ul></ul></li>
<li><a href="#usb-controller-reset">10 USB Controller Reset</a><ul></ul></li>
<li><a href="#enable-usb-controller-clocks">11 Enable USB Controller Clocks</a><ul></ul></li>
<li><a href="#reset-usb-controller">12 Reset USB Controller</a><ul></ul></li>
<li><a href="#nuttx-ehci-driver-starts-ok-on-pinephone">13 NuttX EHCI Driver Starts OK on PinePhone</a><ul></ul></li>
<li><a href="#set-usb-magnitude--rate--threshold">14 Set USB Magnitude / Rate / Threshold</a><ul></ul></li>
<li><a href="#usb-controller-configuration">15 USB Controller Configuration</a><ul></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>28 Mar 2023</em></p>
<p><img src="https://lupyuen.github.io/images/usb3-title.jpg" alt="USB Controller Block Diagram from Allwinner A64 User Manual" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><em>USB Controller Block Diagram from Allwinner A64 User Manual</em></a></p>
<p>Weeks ago we talked about porting <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) to <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a>. And how we might turn it into a <strong>Feature Phone</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/usb2#pinephone--nuttx--feature-phone"><strong>‚ÄúPinePhone + NuttX = Feature Phone‚Äù</strong></a></li>
</ul>
<p>But to make phone calls and send text messages, we need to control the <strong>LTE Modem over USB</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/usb2#lte-modem-talks-usb"><strong>‚ÄúLTE Modem talks USB‚Äù</strong></a></li>
</ul>
<p>Thus today we‚Äôll build a <strong>USB Driver</strong> for NuttX on PinePhone. As we find out‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs <strong>USB Enhanced Host Controller Interface</strong> (EHCI)</p>
</li>
<li>
<p>Why it‚Äôs simpler than <strong>USB On-The-Go</strong> (OTG)</p>
</li>
<li>
<p>How we‚Äôre porting the <strong>USB EHCI Driver</strong> from NuttX to PinePhone</p>
</li>
<li>
<p>Handling <strong>USB Clocks</strong> and <strong>USB Resets</strong> on PinePhone</p>
</li>
<li>
<p>Why <strong>U-Boot Bootloader</strong> is a terrific resource for PinePhone USB</p>
</li>
</ul>
<p>Let‚Äôs dive into the fascinating world of USB EHCI!</p>
<p><a href="https://lupyuen.github.io/articles/usb2#appendix-enhanced-host-controller-interface-for-usb">(Thanks to <strong>Lwazi Dube</strong> for teaching me about EHCI üôÇ)</a></p>
<p><img src="https://lupyuen.github.io/images/usb2-ehci3.jpg" alt="USB EHCI Registers in Allwinner A64 User Manual (Page 585)" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><em>USB EHCI Registers in Allwinner A64 User Manual (Page 585)</em></a></p>
<h1 id="usb-enhanced-host-controller-interface"><a href="#usb-enhanced-host-controller-interface">1 USB Enhanced Host Controller Interface</a></h1>
<p><em>What‚Äôs USB EHCI?</em></p>
<p>According to the <a href="https://www.intel.sg/content/www/xa/en/products/docs/io/universal-serial-bus/ehci-specification.html"><strong>Official Spec</strong></a>‚Ä¶</p>
<blockquote>
<p>‚ÄúThe <strong>Enhanced Host Controller Interface (EHCI)</strong> specification describes the <strong>Register-Level Interface</strong> for a Host Controller for the Universal Serial Bus (USB) Revision 2.0‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúThe specification includes a description of the Hardware and Software Interface between System Software and the Host Controller Hardware‚Äù</p>
</blockquote>
<p><em>So EHCI is a standard, unified way to program the USB Controller on any Hardware Platform?</em></p>
<p>Yep and USB EHCI is <strong>supported on PinePhone</strong>!</p>
<p>Which means we can build the USB Driver for PinePhone‚Ä¶ By simply reading and writing the (Memory-Mapped) <strong>EHCI Registers</strong> on Allwinner A64‚Äôs USB Controller! (Pic above)</p>
<p><em>What are the USB EHCI Registers?</em></p>
<p>The <strong>Standard EHCI Registers</strong> are documented here‚Ä¶</p>
<ul>
<li>
<p><a href="https://www.intel.sg/content/www/xa/en/products/docs/io/universal-serial-bus/ehci-specification.html"><strong>‚ÄúEnhanced Host Controller Interface Specification‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://www.intel.sg/content/www/xa/en/products/docs/io/universal-serial-bus/ehci-specification-for-usb.html"><strong>‚ÄúEnhanced Host Controller Interface for USB 2.0: Specification‚Äù</strong></a></p>
<p>(Skip the ‚ÄúVersion 1.1 Addendum‚Äù, Allwinner A64 only implements Version 1.0 of the spec)</p>
</li>
</ul>
<p>Allwinner A64 implements the EHCI Registers for <strong>Port USB1</strong> at Base Address <strong><code>0x01C1</code> <code>B000</code></strong> (USB_HCI1, pic above)</p>
<p>More about this in the <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a>‚Ä¶</p>
<ul>
<li>
<p><strong>Section 7.5.3.3:</strong> USB Host Register List (Page 585, pic above)</p>
</li>
<li>
<p><strong>Section 7.5.3.4:</strong> EHCI Register Description (Page 587)</p>
</li>
<li>
<p><strong>Section 7.5.3.5:</strong> OHCI Register Description (Page 601)</p>
</li>
<li>
<p><strong>Section 7.5.3.6:</strong> HCI Interface Control and Status Register Description (Page 619)</p>
</li>
<li>
<p><strong>Section 7.5.3.7:</strong> USB Host Clock Requirement (Page 620)</p>
</li>
</ul>
<p>This looks messy, but the <strong>NuttX EHCI Driver</strong> will probably run OK on PinePhone.</p>
<p><em>USB EHCI sounds like a lifesaver?</em></p>
<p>Yep USB Programming on PinePhone would be super complicated without EHCI!</p>
<p>Let‚Äôs take a peek at life without EHCI‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-uart2.jpg" alt="PinePhone Jumpdrive appears as a USB Drive when connected to a computer" /></p>
<p><a href="https://github.com/dreemurrs-embedded/Jumpdrive"><em>PinePhone Jumpdrive appears as a USB Drive when connected to a computer</em></a></p>
<h1 id="ehci-is-simpler-than-usb-on-the-go"><a href="#ehci-is-simpler-than-usb-on-the-go">2 EHCI is simpler than USB On-The-Go</a></h1>
<p><em>What‚Äôs USB On-The-Go?</em></p>
<p>PinePhone supports <a href="https://en.wikipedia.org/wiki/USB_On-The-Go"><strong>USB On-The-Go (OTG)</strong></a>, which works as 2 modes‚Ä¶</p>
<ul>
<li>
<p><strong>USB Host</strong>: PinePhone controls other USB Devices</p>
</li>
<li>
<p><strong>USB Device</strong>: PinePhone is controlled by a USB Host</p>
</li>
</ul>
<p>This means if we connect PinePhone to a computer, it will appear as a USB Drive.</p>
<p>(Assuming the right drivers are started)</p>
<p><em>USB OTG isn‚Äôt compatible with USB EHCI?</em></p>
<p>EHCI supports <strong>only USB Host</strong>, not USB Device.</p>
<p>(Hence the name ‚ÄúEnhanced <strong>Host Controller</strong> Interface‚Äù)</p>
<p>PinePhone supports both USB OTG and USB EHCI. The USB Physical Layer can switch between OTG and EHCI modes. (As we‚Äôll soon see)</p>
<p><em>How would we program USB OTG?</em></p>
<p>To do USB OTG, we would need to create a driver for the <strong>Mentor Graphics OTG Controller</strong> inside PinePhone‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/usb2#document-the-usb-controller"><strong>‚ÄúDocument the USB Controller (Mentor Graphics)‚Äù</strong></a></li>
</ul>
<p>Which gets really low-level and complex.</p>
<p>Thankfully we won‚Äôt need USB OTG and the Mentor Graphics Driver. Here‚Äôs why‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/usb3-title.jpg" alt="USB Controller Block Diagram from Allwinner A64 User Manual" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><em>USB Controller Block Diagram from Allwinner A64 User Manual</em></a></p>
<h1 id="pinephone-usb-controller"><a href="#pinephone-usb-controller">3 PinePhone USB Controller</a></h1>
<p><em>Phew! We‚Äôre doing USB EHCI, not USB OTG?</em></p>
<p>According to the <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a> (Page 583), there are two USB Ports in Allwinner A64: <strong>USB0 and USB1</strong> (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>Port USB0</strong> is exposed as the <strong>External USB Port</strong> on PinePhone</p>
</li>
<li>
<p><strong>Port USB1</strong> is connected to the <strong>Internal LTE Modem</strong></p>
</li>
</ul>
<div><table><thead><tr><th style="text-align: center">USB Port</th><th>Alternate Name</th><th>Base Address</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Port USB0</strong></td><td>USB-OTG-EHCI / OHCI</td><td><strong><code>0x01C1</code> <code>A000</code></strong> (USB_HCI0)</td></tr>
<tr><td style="text-align: center"><strong>Port USB1</strong></td><td>USB-EHCI0 / OHCI0</td><td><strong><code>0x01C1</code> <code>B000</code></strong> (USB_HCI1)</td></tr>
</tbody></table>
</div>
<p>Port USB0 isn‚Äôt documented, but it appears in the <strong>Memory Mapping</strong> of <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a>. (Page 73)</p>
<p><em>They work differently?</em></p>
<ul>
<li>
<p>Only <strong>Port USB0</strong> supports <a href="https://lupyuen.github.io/articles/usb3#ehci-is-simpler-than-usb-on-the-go"><strong>USB On-The-Go (OTG)</strong></a>.</p>
<p>Which means if we connect PinePhone to a computer, it will appear as a USB Drive. (Assuming the right drivers are started)</p>
<p>(That‚Äôs why Port USB0 is exposed as the External USB Port on PinePhone)</p>
</li>
<li>
<p>Both <strong>USB0 and USB1</strong> support <a href="https://lupyuen.github.io/articles/usb3#usb-enhanced-host-controller-interface"><strong>USB Enhanced Host Controller Interface (EHCI)</strong></a>.</p>
<p>Which will work only as a USB Host (not USB Device)</p>
</li>
</ul>
<p>TODO</p>
<p>Today we‚Äôll talk only about <strong>Port USB1</strong> (EHCI / Non-OTG), since it‚Äôs connected to the LTE Modem.</p>
<p>TODO</p>
<h1 id="pinephone-usb-driver-for-apache-nuttx-rtos"><a href="#pinephone-usb-driver-for-apache-nuttx-rtos">4 PinePhone USB Driver for Apache NuttX RTOS</a></h1>
<p>TODO</p>
<p>We‚Äôre porting the <a href="https://github.com/apache/nuttx/blob/master/arch/arm/src/imxrt/imxrt_ehci.c#L4970">NXP i.MX RT EHCI USB Driver</a> from Apache NuttX RTOS to PinePhone and Allwinner A64‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/usb2#appendix-enhanced-host-controller-interface-for-usb">‚ÄúEnhanced Host Controller Interface for USB‚Äù</a></li>
</ul>
<p>To add the PinePhone USB Driver to our NuttX Project‚Ä¶</p>
<p>TODO</p>
<p>Let‚Äôs boot the NuttX USB EHCI Driver on PinePhone‚Ä¶</p>
<h1 id="64-bit-update-for-ehci-driver"><a href="#64-bit-update-for-ehci-driver">5 64-Bit Update for EHCI Driver</a></h1>
<p>TODO</p>
<p>When PinePhone boots the NuttX USB EHCI Driver, it halts with an Assertion Failure‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>_assert: Current Version: NuttX  12.0.3 4d922be-dirty Mar  7 2023 15:54:47 arm64
_assert: Assertion failed : at file: chip/a64_ehci.c:4996 task: nsh_main 0x4008b0d0
</code></pre></div>
<p>Here‚Äôs the assertion, which says that the <code>a64_qh_s</code> struct must be aligned to 32 bytes: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/b80499b3b8ec837fe2110e9476e8a6ad0f194cde/a64_ehci.c#L4996">a64_ehci.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  DEBUGASSERT((sizeof(struct a64_qh_s) &amp; 0x1f) == 0);
</code></pre></div>
<p>Size of the <code>a64_qh_s</code> struct is 72 bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>sizeof(struct a64_qh_s)=72
</code></pre></div>
<p>Which isn‚Äôt aligned to 32 bytes: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/b80499b3b8ec837fe2110e9476e8a6ad0f194cde/a64_ehci.c#L186-L200">a64_ehci.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Internal representation of the EHCI Queue Head (QH) */

struct a64_epinfo_s;
struct a64_qh_s
{
  /* Fields visible to hardware */

  struct ehci_qh_s hw;           /* Hardware representation of the queue head */

  /* Internal fields used by the EHCI driver */

  struct a64_epinfo_s *epinfo; /* Endpoint used for the transfer */
  uint32_t fqp;                  /* First qTD in the list (physical address) */
  uint8_t pad[8];                /* Padding to assure 32-byte alignment */
};
</code></pre></div>
<p>Because it contains a 64-bit pointer <code>epinfo</code>: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/b80499b3b8ec837fe2110e9476e8a6ad0f194cde/a64_ehci.c#L197">a64_ehci.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  struct a64_epinfo_s *epinfo; /* Endpoint used for the transfer */
</code></pre></div>
<p><em>How has <code>a64_qh_s</code> changed for 32-bit platforms vs 64-bit platforms?</em></p>
<p>On 32-bit platforms: <code>a64_qh_s</code> was previously 64 bytes. (48 + 4 + 4 + 8)</p>
<p>On 64-bit platforms: <code>a64_qh_s</code> is now 72 bytes. (48 + 8 + 4 + 8, round up for 4-byte alignment)</p>
<p>In the EHCI Driver we need to align <code>a64_qh_s</code> to 32 bytes. So we pad <code>a64_qh_s</code> from 72 bytes to 96 bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>uint8_t pad2[96 - 72]; // TODO: Pad from 72 to 96 bytes for 64-bit platform
</code></pre></div>
<p>Like this: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/2e1f9ab090b14f88afb8c3a36ec40a0dbbb23d49/a64_ehci.c#L190-L202">a64_ehci.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>struct a64_qh_s
{
  /* Fields visible to hardware */

  struct ehci_qh_s hw;           /* Hardware representation of the queue head */

  /* Internal fields used by the EHCI driver */

  struct a64_epinfo_s *epinfo; /* Endpoint used for the transfer */
  uint32_t fqp;                  /* First qTD in the list (physical address) */
  uint8_t pad[8];                /* Padding to assure 32-byte alignment */
  uint8_t pad2[96 - 72]; // TODO: Pad from 72 to 96 bytes for 64-bit platform
};
</code></pre></div>
<p>Which fixes the Assertion Failure.</p>
<p><em>What about other structs?</em></p>
<p>To be safe, we verified that the other Struct Sizes are still valid for 64-bit platforms: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/2e1f9ab090b14f88afb8c3a36ec40a0dbbb23d49/a64_ehci.c#L4999-L5004">a64_ehci.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  DEBUGASSERT(sizeof(struct ehci_itd_s) == SIZEOF_EHCI_ITD_S);////
  DEBUGASSERT(sizeof(struct ehci_sitd_s) == SIZEOF_EHCI_SITD_S);////
  DEBUGASSERT(sizeof(struct ehci_qtd_s) == SIZEOF_EHCI_QTD_S);////
  DEBUGASSERT(sizeof(struct ehci_overlay_s) == 32);////
  DEBUGASSERT(sizeof(struct ehci_qh_s) == 48);////
  DEBUGASSERT(sizeof(struct ehci_fstn_s) == SIZEOF_EHCI_FSTN_S);////
</code></pre></div>
<p>Here are the Struct Sizes‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a64_ehci_initialize: sizeof(struct a64_qh_s)=72
a64_ehci_initialize: sizeof(struct a64_qtd_s)=32
a64_ehci_initialize: sizeof(struct ehci_itd_s)=64
a64_ehci_initialize: sizeof(struct ehci_sitd_s)=28
a64_ehci_initialize: sizeof(struct ehci_qtd_s)=32
a64_ehci_initialize: sizeof(struct ehci_overlay_s)=32
a64_ehci_initialize: sizeof(struct ehci_qh_s)=48
a64_ehci_initialize: sizeof(struct ehci_fstn_s)=8
</code></pre></div>
<p>We need to fix this typo in NuttX: <code>SIZEOF_EHCI_OVERLAY</code> is defined twice: <a href="https://github.com/apache/nuttx/blob/master/include/nuttx/usb/ehci.h#L955-L974">ehci.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>struct ehci_overlay_s
{
  uint32_t nqp;                              /* 0x00-0x03: Next qTD Pointer (NOTE 1) */
  uint32_t alt;                              /* 0x04-0x07: Alternate Next qTD Pointer (NOTE 2) */
  uint32_t token;                            /* 0x08-0x0b: qTD Token (NOTE 1) */
  uint32_t bpl[5];                           /* 0x0c-0x1c: Buffer Page Pointer List (NOTE 2) */
};

#define SIZEOF_EHCI_OVERLAY (32)             /* 8*sizeof(uint32_t) */

struct ehci_qh_s
{
  uint32_t hlp;                              /* 0x00-0x03: Queue Head Horizontal Link Pointer */
  uint32_t epchar;                           /* 0x04-0x07: Endpoint Characteristics */
  uint32_t epcaps;                           /* 0x08-0x0b: Endpoint Capabilities */
  uint32_t cqp;                              /* 0x0c-0x0f: Current qTD Pointer */
  struct ehci_overlay_s overlay;             /* 0x10-0x2c: Transfer overlay */
};

#define SIZEOF_EHCI_OVERLAY (48)             /* 4*sizeof(uint32_t) + SIZEOF_EHCI_OVERLAY */
</code></pre></div><h1 id="halt-timeout-for-usb-controller"><a href="#halt-timeout-for-usb-controller">6 Halt Timeout for USB Controller</a></h1>
<p>TODO</p>
<p>The NuttX USB EHCI Driver fails with a timeout when booting on PinePhone‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a64_usbhost_initialize: TODO: a64_clockall_usboh3
a64_usbhost_initialize: TODO: switch off USB bus power
a64_usbhost_initialize: TODO: Setup pins, with power initially off
usbhost_registerclass: Registering class:0x40124838 nids:2
EHCI Initializing EHCI Stack
a64_ehci_initialize: TODO: a64_clockall_usboh3
a64_ehci_initialize: TODO: Reset the controller from the OTG peripheral
a64_ehci_initialize: TODO: Program the controller to be the USB host controller
a64_printreg: 01c1b010&lt;-00000000
a64_printreg: 01c1b014-&gt;00000000
EHCI ERROR: Timed out waiting for HCHalted. USBSTS: 000000
EHCI ERROR: a64_reset failed: 110
a64_usbhost_initialize: ERROR: a64_ehci_initialize failed
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/b921aa5259ef94ece41610ebf806ebd0fa19dee5/README.md#output-log">(Source)</a></p>
<p>The timeout happens while waiting for the USB Controller to Halt: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/2e1f9ab090b14f88afb8c3a36ec40a0dbbb23d49/a64_ehci.c#L4831-L4917">a64_ehci.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int a64_reset(void)
{
  uint32_t regval;
  unsigned int timeout;

  /* Make sure that the EHCI is halted:  &quot;When [the Run/Stop] bit is set to
   * 0, the Host Controller completes the current transaction on the USB and
   * then halts. The HC Halted bit in the status register indicates when the
   * Host Controller has finished the transaction and has entered the
   * stopped state...&quot;
   */

  a64_putreg(0, &amp;HCOR-&gt;usbcmd);

  /* &quot;... Software should not set [HCRESET] to a one when the HCHalted bit in
   *  the USBSTS register is a zero. Attempting to reset an actively running
   *  host controller will result in undefined behavior.&quot;
   */

  timeout = 0;
  do
    {
      /* Wait one microsecond and update the timeout counter */

      up_udelay(1);
      timeout++;

      /* Get the current value of the USBSTS register.  This loop will
       * terminate when either the timeout exceeds one millisecond or when
       * the HCHalted bit is no longer set in the USBSTS register.
       */

      regval = a64_getreg(&amp;HCOR-&gt;usbsts);
    }
  while (((regval &amp; EHCI_USBSTS_HALTED) == 0) &amp;&amp; (timeout &lt; 1000));

  /* Is the EHCI still running?  Did we timeout? */

  if ((regval &amp; EHCI_USBSTS_HALTED) == 0)
    {
      usbhost_trace1(EHCI_TRACE1_HCHALTED_TIMEOUT, regval);
      return -ETIMEDOUT;
    }
</code></pre></div>
<p><em>What are 01c1 b010 and 01c1 b014?</em></p>
<p><code>01c1</code> <code>b000</code> is the Base Address of the USB EHCI Controller on Allwinner A64. <a href="https://lupyuen.github.io/articles/usb2#appendix-enhanced-host-controller-interface-for-usb">(See this)</a></p>
<p><code>01c1</code> <code>b010</code> is the USB Command Register USBCMD. <a href="https://www.intel.sg/content/www/xa/en/products/docs/io/universal-serial-bus/ehci-specification-for-usb.html">(Page 18)</a></p>
<p><code>01c1</code> <code>b014</code> is the USB Status Register USBSTS. <a href="https://www.intel.sg/content/www/xa/en/products/docs/io/universal-serial-bus/ehci-specification-for-usb.html">(Page 21)</a></p>
<div class="example-wrap"><pre class="language-text"><code>a64_printreg: 01c1b010&lt;-00000000
a64_printreg: 01c1b014-&gt;00000000
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/b921aa5259ef94ece41610ebf806ebd0fa19dee5/README.md#output-log">(Source)</a></p>
<p>According the log, the driver wrote Command 0 (Stop) to USB Command Register USBCMD. Which will Halt the USB Controller.</p>
<p>Then we read USB Status Register USBSTS. This returns 0, which means that the USB Controller has NOT been halted. (HCHalted = 0)</p>
<p>That‚Äôs why the USB Driver failed: It couldn‚Äôt Halt the USB Controller at startup.</p>
<p><em>Why?</em></p>
<p>Probably because we haven‚Äôt powered on the USB Controller? According to the log‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a64_usbhost_initialize: TODO: a64_clockall_usboh3
a64_usbhost_initialize: TODO: switch off USB bus power
a64_usbhost_initialize: TODO: Setup pins, with power initially off
a64_ehci_initialize: TODO: a64_clockall_usboh3
a64_ehci_initialize: TODO: Reset the controller from the OTG peripheral
a64_ehci_initialize: TODO: Program the controller to be the USB host controller
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/b921aa5259ef94ece41610ebf806ebd0fa19dee5/README.md#output-log">(Source)</a></p>
<p>And maybe we need to init the USB PHY (Physical Layer)?</p>
<p><em>How do we power on the USB Controller?</em></p>
<p>Let‚Äôs check the U-Boot source code‚Ä¶</p>
<h1 id="pinephone-usb-drivers-in-u-boot-bootloader"><a href="#pinephone-usb-drivers-in-u-boot-bootloader">7 PinePhone USB Drivers in U-Boot Bootloader</a></h1>
<p>TODO</p>
<p>Let‚Äôs find the PinePhone USB Driver in the U-Boot Bootloader, to understand how it powers on the USB Controller.</p>
<p>When we search for PinePhone in the Source Code of the <a href="https://github.com/u-boot/u-boot">U-Boot Bootloader</a>, we find this Build Configuration: <a href="https://github.com/u-boot/u-boot/blob/master/configs/pinephone_defconfig#L3">pinephone_defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_DEFAULT_DEVICE_TREE=&quot;sun50i-a64-pinephone-1.2&quot;
</code></pre></div>
<p>Which refers to this PinePhone Device Tree: <a href="https://github.com/u-boot/u-boot/blob/master/arch/arm/dts/sun50i-a64-pinephone-1.2.dts#L6">sun50i-a64-pinephone-1.2.dts</a></p>
<div class="example-wrap"><pre class="language-text"><code>#include &quot;sun50i-a64-pinephone.dtsi&quot;
</code></pre></div>
<p>Which includes another PinePhone Device Tree: <a href="https://github.com/u-boot/u-boot/blob/master/arch/arm/dts/sun50i-a64-pinephone.dtsi#L153-L516">sun50i-a64-pinephone.dtsi</a></p>
<div class="example-wrap"><pre class="language-text"><code>#include &quot;sun50i-a64.dtsi&quot;
#include &quot;sun50i-a64-cpu-opp.dtsi&quot;
...
&amp;ehci0 { status = &quot;okay&quot;; };
&amp;ehci1 { status = &quot;okay&quot;; };

&amp;usb_otg {
  dr_mode = &quot;peripheral&quot;;
  status = &quot;okay&quot;;
};

&amp;usb_power_supply { status = &quot;okay&quot;; };
&amp;usbphy { status = &quot;okay&quot;; };
</code></pre></div>
<p>Which includes this Allwinner A64 Device Tree: <a href="https://github.com/u-boot/u-boot/blob/master/arch/arm/dts/sun50i-a64.dtsi#L575-L659">sun50i-a64.dtsi</a></p>
<div class="example-wrap"><pre class="language-text"><code>usb_otg: usb@1c19000 {
  compatible = &quot;allwinner,sun8i-a33-musb&quot;;
  reg = &lt;0x01c19000 0x0400&gt;;
  clocks = &lt;&amp;ccu CLK_BUS_OTG&gt;;
  resets = &lt;&amp;ccu RST_BUS_OTG&gt;;
  interrupts = &lt;GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH&gt;;
  interrupt-names = &quot;mc&quot;;
  phys = &lt;&amp;usbphy 0&gt;;
  phy-names = &quot;usb&quot;;
  extcon = &lt;&amp;usbphy 0&gt;;
  dr_mode = &quot;otg&quot;;
  status = &quot;disabled&quot;;
};

usbphy: phy@1c19400 {
  compatible = &quot;allwinner,sun50i-a64-usb-phy&quot;;
  reg = 
    &lt;0x01c19400 0x14&gt;,
    &lt;0x01c1a800 0x4&gt;,
    &lt;0x01c1b800 0x4&gt;;
  reg-names = 
    &quot;phy_ctrl&quot;,
    &quot;pmu0&quot;,
    &quot;pmu1&quot;;
  clocks = 
    &lt;&amp;ccu CLK_USB_PHY0&gt;,
    &lt;&amp;ccu CLK_USB_PHY1&gt;;
  clock-names = 
    &quot;usb0_phy&quot;,
    &quot;usb1_phy&quot;;
  resets = 
    &lt;&amp;ccu RST_USB_PHY0&gt;,
    &lt;&amp;ccu RST_USB_PHY1&gt;;
  reset-names = 
    &quot;usb0_reset&quot;,
    &quot;usb1_reset&quot;;
  status = &quot;disabled&quot;;
  #phy-cells = &lt;1&gt;;
};

ehci0: usb@1c1a000 {
  compatible = &quot;allwinner,sun50i-a64-ehci&quot;, &quot;generic-ehci&quot;;
  reg = &lt;0x01c1a000 0x100&gt;;
  interrupts = &lt;GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH&gt;;
  clocks = 
    &lt;&amp;ccu CLK_BUS_OHCI0&gt;,
    &lt;&amp;ccu CLK_BUS_EHCI0&gt;,
    &lt;&amp;ccu CLK_USB_OHCI0&gt;;
  resets = 
    &lt;&amp;ccu RST_BUS_OHCI0&gt;,
    &lt;&amp;ccu RST_BUS_EHCI0&gt;;
  phys = &lt;&amp;usbphy 0&gt;;
  phy-names = &quot;usb&quot;;
  status = &quot;disabled&quot;;
};

ehci1: usb@1c1b000 {
  compatible = &quot;allwinner,sun50i-a64-ehci&quot;, &quot;generic-ehci&quot;;
  reg = &lt;0x01c1b000 0x100&gt;;
  interrupts = &lt;GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH&gt;;
  clocks = 
    &lt;&amp;ccu CLK_BUS_OHCI1&gt;,
    &lt;&amp;ccu CLK_BUS_EHCI1&gt;,
    &lt;&amp;ccu CLK_USB_OHCI1&gt;;
  resets = 
    &lt;&amp;ccu RST_BUS_OHCI1&gt;,
    &lt;&amp;ccu RST_BUS_EHCI1&gt;;
  phys = &lt;&amp;usbphy 1&gt;;
  phy-names = &quot;usb&quot;;
  status = &quot;disabled&quot;;
};
</code></pre></div>
<p>Which says that the USB Drivers are‚Ä¶</p>
<ul>
<li>
<p><strong>EHCI0 and EHCI1 (Enhanced Host Controller Interface):</strong> ‚Äúallwinner,sun50i-a64-ehci‚Äù, ‚Äúgeneric-ehci‚Äù</p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/usb/host/ehci-generic.c#L160">usb/host/ehci-generic.c</a></p>
</li>
<li>
<p><strong>USB OTG (On-The-Go):</strong> ‚Äúallwinner,sun8i-a33-musb‚Äù</p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/usb/musb-new/sunxi.c#L527">usb/musb-new/sunxi.c</a></p>
</li>
<li>
<p><strong>USB PHY (Physical Layer):</strong> ‚Äúallwinner,sun50i-a64-usb-phy‚Äù</p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L654">phy/allwinner/phy-sun4i-usb.c</a></p>
</li>
</ul>
<p>Why so many USB drivers? Let‚Äôs talk about it‚Ä¶</p>
<h1 id="power-on-the-usb-controller"><a href="#power-on-the-usb-controller">8 Power On the USB Controller</a></h1>
<p>TODO</p>
<p>Earlier we <a href="https://github.com/lupyuen/pinephone-nuttx-usb#pinephone-usb-drivers-in-u-boot-bootloader">searched for the USB Drivers</a> for PinePhone and found these‚Ä¶</p>
<ul>
<li>
<p><strong>EHCI0 and EHCI1 (Enhanced Host Controller Interface):</strong> </p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/usb/host/ehci-generic.c#L160">usb/host/ehci-generic.c</a></p>
</li>
<li>
<p><strong>USB PHY (Physical Layer):</strong></p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L654">phy/allwinner/phy-sun4i-usb.c</a></p>
</li>
</ul>
<p>We disregard the USB OTG Driver because we‚Äôre only interested in the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-enhanced-host-controller-interface-vs-on-the-go">EHCI Driver (Non-OTG)</a> for PinePhone.</p>
<p>The USB PHY Driver handles the Physical Layer (physical wires) that connect to the USB Controller.</p>
<p>To power on the USB Controller ourselves, let‚Äôs look inside the USB PHY Driver: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L259-L327">sun4i_usb_phy_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int sun4i_usb_phy_init(struct phy *phy)
{
  struct sun4i_usb_phy_data *data = dev_get_priv(phy-&gt;dev);
  struct sun4i_usb_phy_plat *usb_phy = &amp;data-&gt;usb_phy[phy-&gt;id];
  u32 val;
  int ret;

  ret = clk_enable(&amp;usb_phy-&gt;clocks);
  if (ret) {
    dev_err(phy-&gt;dev, &quot;failed to enable usb_%ldphy clock\n&quot;,
      phy-&gt;id);
    return ret;
  }
</code></pre></div>
<p>In the code above we enable the USB Clocks. We‚Äôll explain here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-clocks">‚ÄúUSB Controller Clocks‚Äù</a></li>
</ul>
<p>Then we deassert the USB Reset‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  ret = reset_deassert(&amp;usb_phy-&gt;resets);
  if (ret) {
    dev_err(phy-&gt;dev, &quot;failed to deassert usb_%ldreset reset\n&quot;,
      phy-&gt;id);
    return ret;
  }
</code></pre></div>
<p>We‚Äôll explain the USB Reset here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-reset">‚ÄúUSB Controller Reset‚Äù</a></li>
</ul>
<p>TODO: Is PMU is needed for PinePhone Port USB1? If PMU is not needed, we skip this part‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // `hci_phy_ctl_clear` is `PHY_CTL_H3_SIDDQ`, which is `1 &lt;&lt; 1`
  // https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-configuration
  if (usb_phy-&gt;pmu &amp;&amp; data-&gt;cfg-&gt;hci_phy_ctl_clear) {
    val = readl(usb_phy-&gt;pmu + REG_HCI_PHY_CTL);
    val &amp;= ~data-&gt;cfg-&gt;hci_phy_ctl_clear;
    writel(val, usb_phy-&gt;pmu + REG_HCI_PHY_CTL);
  }
</code></pre></div>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf">(FYI: PinePhone Port USB0 is connected to the PMIC, according to PinePhone Schematic Page 6)</a></p>
<p>PinePhone is <code>sun50i_a64_phy</code>, so we skip this part‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // Skip this part because PinePhone is `sun50i_a64_phy`
  if (data-&gt;cfg-&gt;type == sun8i_a83t_phy ||
      data-&gt;cfg-&gt;type == sun50i_h6_phy) {
    if (phy-&gt;id == 0) {
      val = readl(data-&gt;base + data-&gt;cfg-&gt;phyctl_offset);
      val |= PHY_CTL_VBUSVLDEXT;
      val &amp;= ~PHY_CTL_SIDDQ;
      writel(val, data-&gt;base + data-&gt;cfg-&gt;phyctl_offset);
    }
</code></pre></div>
<p>PinePhone is <code>sun50i_a64_phy</code>, so we run this instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  } else {
    if (usb_phy-&gt;id == 0)
      sun4i_usb_phy_write(phy, PHY_RES45_CAL_EN,
              PHY_RES45_CAL_DATA,
              PHY_RES45_CAL_LEN);

    /* Adjust PHY&#39;s magnitude and rate */
    sun4i_usb_phy_write(phy, PHY_TX_AMPLITUDE_TUNE,
            PHY_TX_MAGNITUDE | PHY_TX_RATE,
            PHY_TX_AMPLITUDE_LEN);

    /* Disconnect threshold adjustment */
    sun4i_usb_phy_write(phy, PHY_DISCON_TH_SEL,
            data-&gt;cfg-&gt;disc_thresh, PHY_DISCON_TH_LEN);
  }
</code></pre></div>
<p>Which will‚Ä¶</p>
<ul>
<li>
<p>Set PHY_RES45_CAL (TODO: What‚Äôs this?)</p>
</li>
<li>
<p>Set USB PHY Magnitude and Rate</p>
</li>
<li>
<p>Disconnect USB PHY Threshold Adjustment</p>
</li>
</ul>
<p>As explained here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#set-usb-magnitude--rate--threshold">‚ÄúSet USB Magnitude / Rate / Threshold‚Äù</a></li>
</ul>
<p>TODO: Is <code>usb_phy-&gt;id</code> set to 1 for USB Port 1?</p>
<p>Assume <code>CONFIG_USB_MUSB_SUNXI</code> is undefined. So we skip this part‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_USB_MUSB_SUNXI
  // Skip this part because `CONFIG_USB_MUSB_SUNXI` is undefined
  /* Needed for HCI and conflicts with MUSB, keep PHY0 on MUSB */
  if (usb_phy-&gt;id != 0)
    sun4i_usb_phy_passby(phy, true);

  /* Route PHY0 to MUSB to allow USB gadget */
  if (data-&gt;cfg-&gt;phy0_dual_route)
    sun4i_usb_phy0_reroute(data, true);
</code></pre></div>
<p><code>CONFIG_USB_MUSB_SUNXI</code> is undefined, so we run this instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#else
  sun4i_usb_phy_passby(phy, true);

  /* Route PHY0 to HCI to allow USB host */
  if (data-&gt;cfg-&gt;phy0_dual_route)
    sun4i_usb_phy0_reroute(data, false);
#endif

  return 0;
}
</code></pre></div>
<p>Which will‚Ä¶</p>
<ul>
<li>
<p>Enable USB PHY Bypass</p>
</li>
<li>
<p>Route USB PHY0 to EHCI (instead of Mentor Graphics OTG MUSB)</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-configuration">(<code>phy0_dual_route</code> is true for PinePhone)</a></p>
</li>
</ul>
<p><code>sun4i_usb_phy_passby</code> and <code>sun4i_usb_phy0_reroute</code> are defined here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L190-L215">sun4i_usb_phy_passby</a></p>
</li>
<li>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L244-L257">sun4i_usb_phy0_reroute</a></p>
</li>
</ul>
<p><em>What‚Äôs <code>CONFIG_USB_MUSB_SUNXI</code>?</em></p>
<p><code>CONFIG_USB_MUSB_SUNXI</code> enables support for the Mentor Graphics OTG / DRC USB Controller‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config USB_MUSB_SUNXI
  bool &quot;Enable sunxi OTG / DRC USB controller&quot;
  depends on ARCH_SUNXI
  select USB_MUSB_PIO_ONLY
  default y
  ---help---
  Say y here to enable support for the sunxi OTG / DRC USB controller
  used on almost all sunxi boards.
</code></pre></div>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/usb/musb-new/Kconfig#L68-L75">(Source)</a></p>
<p>We assume <code>CONFIG_USB_MUSB_SUNXI</code> is disabled because we won‚Äôt be using USB OTG for NuttX (yet).</p>
<h1 id="usb-controller-clocks"><a href="#usb-controller-clocks">9 USB Controller Clocks</a></h1>
<p>TODO</p>
<p>Earlier we looked at the Source Code for the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#power-on-the-usb-controller">USB PHY Driver for PinePhone</a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#power-on-the-usb-controller">‚ÄúPower On the USB Controller‚Äù</a></li>
</ul>
<p>And we saw this code that will enable the USB Clocks: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L266-L271">sun4i_usb_phy_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>  ret = clk_enable(&amp;usb_phy-&gt;clocks);
</code></pre></div>
<p><code>clk_enable</code> is explained here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#enable-usb-controller-clocks">‚ÄúEnable USB Controller Clocks‚Äù</a></li>
</ul>
<p><em>What‚Äôs <code>usb_phy-&gt;clocks</code>?</em></p>
<p>According to the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#pinephone-usb-drivers-in-u-boot-bootloader">PinePhone Device Tree</a>, the USB Clocks are‚Ä¶</p>
<ul>
<li>
<p><strong>usb0_phy:</strong> CLK_USB_PHY0</p>
</li>
<li>
<p><strong>usb1_phy:</strong> CLK_USB_PHY1</p>
</li>
<li>
<p><strong>EHCI0:</strong> CLK_BUS_OHCI0, CLK_BUS_EHCI0, CLK_USB_OHCI0</p>
</li>
<li>
<p><strong>EHCI1:</strong> CLK_BUS_OHCI1, CLK_BUS_EHCI1, CLK_USB_OHCI1</p>
</li>
</ul>
<p><em>What are the values of the above USB Clocks?</em></p>
<p>The USB Clocks are defined in <a href="https://github.com/u-boot/u-boot/blob/master/include/dt-bindings/clock/sun50i-a64-ccu.h">clock/sun50i-a64-ccu.h</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define CLK_BUS_EHCI0		42
#define CLK_BUS_EHCI1		43
#define CLK_BUS_OHCI0		44
#define CLK_BUS_OHCI1		45
#define CLK_USB_PHY0		86
#define CLK_USB_PHY1		87
#define CLK_USB_OHCI0		91
#define CLK_USB_OHCI1		93
</code></pre></div>
<p>Which are consistent with the values in the PinePhone JumpDrive Device Tree: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/sun50i-a64-pinephone-1.2.dts#L661-L721">sun50i-a64-pinephone-1.2.dts</a></p>
<p>The Allwinner A64 Register Addresses for USB Clocks are defined here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#enable-usb-controller-clocks">‚ÄúEnable USB Controller Clocks‚Äù</a></li>
</ul>
<p>Here‚Äôs the definition of USB Clocks in our U-Boot Device Tree: <a href="https://github.com/u-boot/u-boot/blob/master/arch/arm/dts/sun50i-a64.dtsi#L575-L659">sun50i-a64.dtsi</a></p>
<div class="example-wrap"><pre class="language-text"><code>usbphy: phy@1c19400 {
  reg = 
    &lt;0x01c19400 0x14&gt;,
    &lt;0x01c1a800 0x4&gt;,
    &lt;0x01c1b800 0x4&gt;;
  reg-names = 
    &quot;phy_ctrl&quot;,
    &quot;pmu0&quot;,
    &quot;pmu1&quot;;
  clocks = 
    &lt;&amp;ccu CLK_USB_PHY0&gt;,
    &lt;&amp;ccu CLK_USB_PHY1&gt;;
  clock-names = 
    &quot;usb0_phy&quot;,
    &quot;usb1_phy&quot;;
    ...

ehci0: usb@1c1a000 {
  reg = &lt;0x01c1a000 0x100&gt;;
  clocks = 
    &lt;&amp;ccu CLK_BUS_OHCI0&gt;,
    &lt;&amp;ccu CLK_BUS_EHCI0&gt;,
    &lt;&amp;ccu CLK_USB_OHCI0&gt;;
    ...

ehci1: usb@1c1b000 {
  reg = &lt;0x01c1b000 0x100&gt;;
  clocks = 
    &lt;&amp;ccu CLK_BUS_OHCI1&gt;,
    &lt;&amp;ccu CLK_BUS_EHCI1&gt;,
    &lt;&amp;ccu CLK_USB_OHCI1&gt;;
  resets = 
    &lt;&amp;ccu RST_BUS_OHCI1&gt;,
    &lt;&amp;ccu RST_BUS_EHCI1&gt;;
</code></pre></div>
<p>(CCU means Clock Control Unit)</p>
<p><em>What are the USB PHY Reg Values from above?</em></p>
<div class="example-wrap"><pre class="language-text"><code>usbphy: phy@1c19400 {
  reg = 
    &lt;0x01c19400 0x14&gt;,
    &lt;0x01c1a800 0x4&gt;,
    &lt;0x01c1b800 0x4&gt;;
  reg-names = 
    &quot;phy_ctrl&quot;,
    &quot;pmu0&quot;,
    &quot;pmu1&quot;;
</code></pre></div>
<p>According to the Allwinner A64 User Manual (Memory Mapping, Page 73)‚Ä¶</p>
<ul>
<li>
<p><strong>phy_ctrl:</strong> <code>0x01c1</code> <code>9400</code> (Offset <code>0x14</code>)</p>
<p>Belongs to USB-OTG-Device (USB Port 0)</p>
</li>
<li>
<p><strong>pmu0:</strong> <code>0x01c1</code> <code>a800</code> (Offset <code>0x4</code>)</p>
<p>Belongs to USB-OTG-EHCI (USB Port 0)</p>
</li>
<li>
<p><strong>pmu1:</strong> <code>0x01c1</code> <code>b800</code> (Offset <code>0x4</code>)</p>
<p>Belongs to USB-EHCI0 (USB Port 1)</p>
</li>
</ul>
<h1 id="usb-controller-reset"><a href="#usb-controller-reset">10 USB Controller Reset</a></h1>
<p>TODO</p>
<p>Earlier we looked at the Source Code for the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#power-on-the-usb-controller">USB PHY Driver for PinePhone</a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#power-on-the-usb-controller">‚ÄúPower On the USB Controller‚Äù</a></li>
</ul>
<p>And we saw this code that will deassert the USB Reset: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L273-L278">sun4i_usb_phy_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>  ret = reset_deassert(&amp;usb_phy-&gt;resets);
</code></pre></div>
<p><code>reset_deassert</code> is explained here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#reset-usb-controller">‚ÄúReset USB Controller‚Äù</a></li>
</ul>
<p><em>What‚Äôs <code>usb_phy-&gt;resets</code>?</em></p>
<p>According to the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#pinephone-usb-drivers-in-u-boot-bootloader">PinePhone Device Tree</a>, the USB Resets are‚Ä¶</p>
<ul>
<li>
<p><strong>usb0_reset:</strong> RST_USB_PHY0</p>
</li>
<li>
<p><strong>usb1_reset:</strong> RST_USB_PHY1</p>
</li>
<li>
<p><strong>EHCI0:</strong> RST_BUS_OHCI0, RST_BUS_EHCI0</p>
</li>
<li>
<p><strong>EHCI1:</strong> RST_BUS_OHCI1, RST_BUS_EHCI1</p>
</li>
</ul>
<p><em>What are the values of the USB Resets?</em></p>
<p>The USB Resets are defined in <a href="https://github.com/u-boot/u-boot/blob/master/include/dt-bindings/reset/sun50i-a64-ccu.h">reset/sun50i-a64-ccu.h</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define RST_USB_PHY0		0
#define RST_USB_PHY1		1
#define RST_BUS_EHCI0		19
#define RST_BUS_EHCI1		20
#define RST_BUS_OHCI0		21
#define RST_BUS_OHCI1		22
</code></pre></div>
<p>Which are consistent with the values in the PinePhone JumpDrive Device Tree: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/sun50i-a64-pinephone-1.2.dts#L661-L721">sun50i-a64-pinephone-1.2.dts</a></p>
<p>The Allwinner A64 Register Addresses for USB Resets are defined here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#reset-usb-controller">‚ÄúReset USB Controller‚Äù</a></li>
</ul>
<p>Here‚Äôs the definition of USB Resets in our U-Boot Device Tree: <a href="https://github.com/u-boot/u-boot/blob/master/arch/arm/dts/sun50i-a64.dtsi#L575-L659">sun50i-a64.dtsi</a></p>
<div class="example-wrap"><pre class="language-text"><code>usbphy: phy@1c19400 {
  resets = 
    &lt;&amp;ccu RST_USB_PHY0&gt;,
    &lt;&amp;ccu RST_USB_PHY1&gt;;
  reset-names = 
    &quot;usb0_reset&quot;,
    &quot;usb1_reset&quot;;
    ...

ehci0: usb@1c1a000 {
  resets = 
    &lt;&amp;ccu RST_BUS_OHCI0&gt;,
    &lt;&amp;ccu RST_BUS_EHCI0&gt;;
    ...

ehci1: usb@1c1b000 {
  resets = 
    &lt;&amp;ccu RST_BUS_OHCI1&gt;,
    &lt;&amp;ccu RST_BUS_EHCI1&gt;;
</code></pre></div><h1 id="enable-usb-controller-clocks"><a href="#enable-usb-controller-clocks">11 Enable USB Controller Clocks</a></h1>
<p>TODO</p>
<p>Earlier we saw this code that will enable the USB Clocks: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L266-L271">sun4i_usb_phy_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>  ret = clk_enable(&amp;usb_phy-&gt;clocks);
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-clocks">(USB Clocks <code>usb_phy-&gt;clocks</code> are defined here)</a></p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/clk/sunxi/clk_sunxi.c#L58-L61"><code>clk_enable</code></a> calls <a href="https://github.com/u-boot/u-boot/blob/master/drivers/clk/sunxi/clk_sunxi.c#L30-L56"><code>sunxi_set_gate</code></a></p>
<p><em>Which A64 Registers will our NuttX USB Driver set?</em></p>
<p>Our NuttX USB Driver will set the CCU Registers, defined in Allwinner A64 User Manual, Page 81.</p>
<p>(CCU Base Address is <code>0x01C2</code> <code>0000</code>)</p>
<p>Based on the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-clocks">USB Clocks <code>usb_phy-&gt;clocks</code></a>, our NuttX USB Driver will set the following CCU Registers: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/clk/sunxi/clk_a64.c#L16-L66">clk_a64.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct ccu_clk_gate a64_gates[] = {
  [CLK_BUS_EHCI0]		= GATE(0x060, BIT(24)),
  [CLK_BUS_EHCI1]		= GATE(0x060, BIT(25)),
  [CLK_BUS_OHCI0]		= GATE(0x060, BIT(28)),
  [CLK_BUS_OHCI1]		= GATE(0x060, BIT(29)),
  [CLK_USB_PHY0]		= GATE(0x0cc, BIT(8)),
  [CLK_USB_PHY1]		= GATE(0x0cc, BIT(9)),
  [CLK_USB_OHCI0]		= GATE(0x0cc, BIT(16)),
  [CLK_USB_OHCI1]		= GATE(0x0cc, BIT(17)),
</code></pre></div>
<p>So to enable the USB Clock CLK_BUS_EHCI0, we‚Äôll set Bit 24 of the CCU Register at <code>0x060</code> + <code>0x01C2</code> <code>0000</code>.</p>
<p>This will be similar to setting SCLK_GATING of DE_CLK_REG as described here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine">‚ÄúInitialising the Allwinner A64 Display Engine‚Äù</a></li>
</ul>
<p>TODO: What about OHCI1_12M_SRC_SEL, OHCI0_12M_SRC_SEL? (Allwinner A64 User Manual Page 113)</p>
<h1 id="reset-usb-controller"><a href="#reset-usb-controller">12 Reset USB Controller</a></h1>
<p>TODO</p>
<p>Earlier we saw this code that will deassert the USB Reset: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L273-L278">sun4i_usb_phy_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>  ret = reset_deassert(&amp;usb_phy-&gt;resets);
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-reset">(USB Resets <code>usb_phy-&gt;resets</code> are defined here)</a></p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/reset/reset-uclass.c#L207-L214"><code>reset_deassert</code></a> calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/reset/reset-sunxi.c#L71-L75"><code>rst_deassert</code></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/reset/reset-sunxi.c#L66-L69"><code>sunxi_reset_deassert</code></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/reset/reset-sunxi.c#L36-L59"><code>sunxi_set_reset</code></a></p>
</li>
</ul>
<p><em>Which A64 Registers will our NuttX USB Driver set?</em></p>
<p>Our NuttX USB Driver will set the CCU Registers, defined in Allwinner A64 User Manual, Page 81.</p>
<p>(CCU Base Address is <code>0x01C2</code> <code>0000</code>)</p>
<p>Based on the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-reset">USB Resets <code>usb_phy-&gt;resets</code></a>, our NuttX USB Driver will set the following CCU Registers: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/clk/sunxi/clk_a64.c#L68-L100">clk_a64.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct ccu_reset a64_resets[] = {
  [RST_USB_PHY0]          = RESET(0x0cc, BIT(0)),
  [RST_USB_PHY1]          = RESET(0x0cc, BIT(1)),
  [RST_BUS_EHCI0]         = RESET(0x2c0, BIT(24)),
  [RST_BUS_EHCI1]         = RESET(0x2c0, BIT(25)),
  [RST_BUS_OHCI0]         = RESET(0x2c0, BIT(28)),
  [RST_BUS_OHCI1]         = RESET(0x2c0, BIT(29)),
</code></pre></div>
<p>So to deassert the USB Reset RST_USB_PHY0, we‚Äôll set Bit 0 of the CCU Register at <code>0x0cc</code> + <code>0x01C2</code> <code>0000</code>.</p>
<p>This will be similar to setting DE_RST of BUS_SOFT_RST_REG1 as described here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine">‚ÄúInitialising the Allwinner A64 Display Engine‚Äù</a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/usb3-run.png" alt="NuttX EHCI Driver Starts OK on PinePhone" /></p>
<h1 id="nuttx-ehci-driver-starts-ok-on-pinephone"><a href="#nuttx-ehci-driver-starts-ok-on-pinephone">13 NuttX EHCI Driver Starts OK on PinePhone</a></h1>
<p>TODO</p>
<p>Earlier the NuttX USB EHCI Driver fails during PinePhone startup‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx-usb#halt-timeout-for-usb-controller">‚ÄúHalt Timeout for USB Controller‚Äù</a></li>
</ul>
<p>Then we discovered how the U-Boot Bootloader enables the USB Clocks and deasserts the USB Resets‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-clocks">‚ÄúUSB Controller Clocks‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#enable-usb-controller-clocks">‚ÄúEnable USB Controller Clocks‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-reset">‚ÄúUSB Controller Reset‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#reset-usb-controller">‚ÄúReset USB Controller‚Äù</a></p>
</li>
</ul>
<p>So we do the same for NuttX. And now the NuttX EHCI Driver starts OK on PinePhone yay! üéâ</p>
<p>This is how we enable the USB Clocks and deassert the USB Resets on PinePhone: <a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/0e1632ed351975a6432b7e4fde1857d6bcc0940a/a64_usbhost.c#L118-L279">a64_usbhost.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define A64_CCU_ADDR        0x01c20000 /* CCU             0x01c2:0000-0x01c2:03ff 1K */

/* Display Engine Clock Register (A64 Page 117) */
// #define DE_CLK_REG       (A64_CCU_ADDR + 0x0104)
// #define CLK_SRC_SEL(n)   ((n) &lt;&lt; 24)
// #define CLK_SRC_SEL_MASK (0b111 &lt;&lt; 24)
// #define SCLK_GATING      (1 &lt;&lt; 31)
// #define SCLK_GATING_MASK (0b1 &lt;&lt; 31)

/* Bus Software Reset Register 1 (A64 Page 140) */
// #define BUS_SOFT_RST_REG1 (A64_CCU_ADDR + 0x02c4)
// #define DE_RST            (1 &lt;&lt; 12)

// Set the bit
static void set_bit(unsigned long addr, uint8_t bit)
{
  _info(&quot;0x%lx Bit %d\n&quot;, addr, bit);
  modreg32(1 &lt;&lt; bit, 1 &lt;&lt; bit, addr);
}

// Enable USB Clocks
// https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-clocks
// https://github.com/lupyuen/pinephone-nuttx-usb#enable-usb-controller-clocks
static void a64_usbhost_clk_enable(void)
{
  // usb0_phy: CLK_USB_PHY0
  // 0x0cc BIT(8)
  _info(&quot;CLK_USB_PHY0\n&quot;);
  #define CLK_USB_PHY0 (A64_CCU_ADDR + 0x0cc)
  #define CLK_USB_PHY0_BIT 8
  set_bit(CLK_USB_PHY0, CLK_USB_PHY0_BIT);

  // usb1_phy: CLK_USB_PHY1
  // 0x0cc BIT(9)
  _info(&quot;CLK_USB_PHY1\n&quot;);
  #define CLK_USB_PHY1 (A64_CCU_ADDR + 0x0cc)
  #define CLK_USB_PHY1_BIT 9
  set_bit(CLK_USB_PHY1, CLK_USB_PHY1_BIT);

  // EHCI0: CLK_BUS_OHCI0, CLK_BUS_EHCI0, CLK_USB_OHCI0
  // 0x060 BIT(28)
  _info(&quot;CLK_BUS_OHCI0\n&quot;);
  #define CLK_BUS_OHCI0 (A64_CCU_ADDR + 0x060)
  #define CLK_BUS_OHCI0_BIT 28
  set_bit(CLK_BUS_OHCI0, CLK_BUS_OHCI0_BIT);

  // 0x060 BIT(24)
  _info(&quot;CLK_BUS_EHCI0\n&quot;);
  #define CLK_BUS_EHCI0 (A64_CCU_ADDR + 0x060)
  #define CLK_BUS_EHCI0_BIT 24
  set_bit(CLK_BUS_EHCI0, CLK_BUS_EHCI0_BIT);

  // 0x0cc BIT(16)
  _info(&quot;CLK_USB_OHCI0\n&quot;);
  #define CLK_USB_OHCI0 (A64_CCU_ADDR + 0x0cc)
  #define CLK_USB_OHCI0_BIT 16
  set_bit(CLK_USB_OHCI0, CLK_USB_OHCI0_BIT);

  // EHCI1: CLK_BUS_OHCI1, CLK_BUS_EHCI1, CLK_USB_OHCI1
  // 0x060 BIT(29)
  _info(&quot;CLK_BUS_OHCI1\n&quot;);
  #define CLK_BUS_OHCI1 (A64_CCU_ADDR + 0x060)
  #define CLK_BUS_OHCI1_BIT 29
  set_bit(CLK_BUS_OHCI1, CLK_BUS_OHCI1_BIT);

  // 0x060 BIT(25)
  _info(&quot;CLK_BUS_EHCI1\n&quot;);
  #define CLK_BUS_EHCI1 (A64_CCU_ADDR + 0x060)
  #define CLK_BUS_EHCI1_BIT 25
  set_bit(CLK_BUS_EHCI1, CLK_BUS_EHCI1_BIT);

  // 0x0cc BIT(17)
  _info(&quot;CLK_USB_OHCI1\n&quot;);
  #define CLK_USB_OHCI1 (A64_CCU_ADDR + 0x0cc)
  #define CLK_USB_OHCI1_BIT 17
  set_bit(CLK_USB_OHCI1, CLK_USB_OHCI1_BIT);

  /* Display Engine Clock Register (A64 Page 117)
   * Set SCLK_GATING (Bit 31) to 1
   *   (Enable Special Clock)
   * Set CLK_SRC_SEL (Bits 24 to 26) to 1
   *   (Clock Source is Display Engine PLL)
   */
  // clk = SCLK_GATING | CLK_SRC_SEL(1);
  // clk_mask = SCLK_GATING_MASK | CLK_SRC_SEL_MASK;
  // modreg32(clk, clk_mask, DE_CLK_REG);
}

// Deassert USB Resets
// https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-reset
// https://github.com/lupyuen/pinephone-nuttx-usb#reset-usb-controller
static void a64_usbhost_reset_deassert(void)
{
  // usb0_reset: RST_USB_PHY0
  // 0x0cc BIT(0)
  _info(&quot;RST_USB_PHY0\n&quot;);
  #define RST_USB_PHY0 (A64_CCU_ADDR + 0x0cc)
  #define RST_USB_PHY0_BIT 0
  set_bit(RST_USB_PHY0, RST_USB_PHY0_BIT);

  // usb1_reset: RST_USB_PHY1
  // 0x0cc BIT(1)
  _info(&quot;RST_USB_PHY1\n&quot;);
  #define RST_USB_PHY1 (A64_CCU_ADDR + 0x0cc)
  #define RST_USB_PHY1_BIT 1
  set_bit(RST_USB_PHY1, RST_USB_PHY1_BIT);

  // EHCI0: RST_BUS_OHCI0, RST_BUS_EHCI0
  // 0x2c0 BIT(28)
  _info(&quot;RST_BUS_OHCI0\n&quot;);
  #define RST_BUS_OHCI0 (A64_CCU_ADDR + 0x2c0)
  #define RST_BUS_OHCI0_BIT 28
  set_bit(RST_BUS_OHCI0, RST_BUS_OHCI0_BIT);

  // 0x2c0 BIT(24)
  _info(&quot;RST_BUS_EHCI0\n&quot;);
  #define RST_BUS_EHCI0 (A64_CCU_ADDR + 0x2c0)
  #define RST_BUS_EHCI0_BIT 24
  set_bit(RST_BUS_EHCI0, RST_BUS_EHCI0_BIT);

  // EHCI1: RST_BUS_OHCI1, RST_BUS_EHCI1
  // 0x2c0 BIT(29)
  _info(&quot;RST_BUS_OHCI1\n&quot;);
  #define RST_BUS_OHCI1 (A64_CCU_ADDR + 0x2c0)
  #define RST_BUS_OHCI1_BIT 29
  set_bit(RST_BUS_OHCI1, RST_BUS_OHCI1_BIT);

  // 0x2c0 BIT(25)
  _info(&quot;RST_BUS_EHCI1\n&quot;);
  #define RST_BUS_EHCI1 (A64_CCU_ADDR + 0x2c0)
  #define RST_BUS_EHCI1_BIT 25
  set_bit(RST_BUS_EHCI1, RST_BUS_EHCI1_BIT);

  /* Bus Software Reset Register 1 (A64 Page 140)
   * Set DE_RST (Bit 12) to 1 (De-Assert Display Engine)
   */
  // modreg32(DE_RST, DE_RST, BUS_SOFT_RST_REG1);
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/

/****************************************************************************
 * Name: a64_usbhost_initialize
 *
 * Description:
 *   Called at application startup time to initialize the USB host
 *   functionality.
 *   This function will start a thread that will monitor for device
 *   connection/disconnection events.
 *
 ****************************************************************************/

int a64_usbhost_initialize(void)
{
  int ret;

  a64_usbhost_clk_enable();

  a64_usbhost_reset_deassert();
</code></pre></div>
<p>Here‚Äôs the log‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a64_usbhost_clk_enable: CLK_USB_PHY0
set_bit: 0x1c200cc Bit 8
a64_usbhost_clk_enable: CLK_USB_PHY1
set_bit: 0x1c200cc Bit 9
a64_usbhost_clk_enable: CLK_BUS_OHCI0
set_bit: 0x1c20060 Bit 28
a64_usbhost_clk_enable: CLK_BUS_EHCI0
set_bit: 0x1c20060 Bit 24
a64_usbhost_clk_enable: CLK_USB_OHCI0
set_bit: 0x1c200cc Bit 16
a64_usbhost_clk_enable: CLK_BUS_OHCI1
set_bit: 0x1c20060 Bit 29
a64_usbhost_clk_enable: CLK_BUS_EHCI1
set_bit: 0x1c20060 Bit 25
a64_usbhost_clk_enable: CLK_USB_OHCI1
set_bit: 0x1c200cc Bit 17
a64_usbhost_reset_deassert: RST_USB_PHY0
set_bit: 0x1c200cc Bit 0
a64_usbhost_reset_deassert: RST_USB_PHY1
set_bit: 0x1c200cc Bit 1
a64_usbhost_reset_deassert: RST_BUS_OHCI0
set_bit: 0x1c202c0 Bit 28
a64_usbhost_reset_deassert: RST_BUS_EHCI0
set_bit: 0x1c202c0 Bit 24
a64_usbhost_reset_deassert: RST_BUS_OHCI1
set_bit: 0x1c202c0 Bit 29
a64_usbhost_reset_deassert: RST_BUS_EHCI1
set_bit: 0x1c202c0 Bit 25
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/5238bc5246bcae896883f056d24691ebaa050f83/README.md#output-log">(Source)</a></p>
<p>This log above shows NuttX enabling the USB Clocks and deasserting the USB Resets for‚Ä¶</p>
<ul>
<li>
<p>USB PHY0 and USB PHY1</p>
</li>
<li>
<p>EHCI0 and OHCI0</p>
</li>
<li>
<p>EHCI1 and OHCI1</p>
</li>
</ul>
<p>(Yeah this looks excessive. We probably need only USB PHY1, EHCI1 and OHCI1)</p>
<p>Then the NuttX EHCI Driver starts‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a64_usbhost_initialize: TODO: a64_clockall_usboh3
a64_usbhost_initialize: TODO: switch off USB bus power
a64_usbhost_initialize: TODO: Setup pins, with power initially off
usbhost_registerclass: Registering class:0x40124838 nids:2
a64_ehci_initialize: sizeof(struct a64_qh_s)=96
a64_ehci_initialize: sizeof(struct a64_qtd_s)=32
a64_ehci_initialize: sizeof(struct ehci_itd_s)=64
a64_ehci_initialize: sizeof(struct ehci_sitd_s)=28
a64_ehci_initialize: sizeof(struct ehci_qtd_s)=32
a64_ehci_initialize: sizeof(struct ehci_overlay_s)=32
a64_ehci_initialize: sizeof(struct ehci_qh_s)=48
a64_ehci_initialize: sizeof(struct ehci_fstn_s)=8
EHCI Initializing EHCI Stack
a64_ehci_initialize: TODO: a64_clockall_usboh3
a64_ehci_initialize: TODO: Reset the controller from the OTG peripheral
a64_ehci_initialize: TODO: Program the controller to be the USB host controller
a64_printreg: 01c1b010&lt;-00000000
a64_printreg: 01c1b014-&gt;00001000
a64_printreg: 01c1b010-&gt;00000000
a64_printreg: 01c1b010&lt;-00000002
a64_printreg: 01c1b010-&gt;00080b00
a64_ehci_initialize: TODO: Re-program the USB host controller
a64_printreg: 01c1b018&lt;-00000000
a64_printreg: 01c1b014&lt;-0000003f
EHCI HCIVERSION 1.00
a64_printreg: 01c1b004-&gt;00001101
EHCI nports=1, HCSPARAMS=1101
a64_printreg: 01c1b008-&gt;0000a026
EHCI HCCPARAMS=00a026
a64_printreg: 01c1b028&lt;-40a87fa0
a64_printreg: 01c1b024&lt;-40a95000
a64_printreg: 01c1b010-&gt;00080b00
a64_printreg: 01c1b010&lt;-00080b30
a64_printreg: 01c1b010-&gt;00080b30
a64_printreg: 01c1b010&lt;-00080b31
a64_printreg: 01c1b050-&gt;00000000
a64_printreg: 01c1b050&lt;-00000001
a64_printreg: 01c1b014-&gt;00000000
a64_ehci_initialize: TODO: irq_attach
a64_printreg: 01c1b018&lt;-00000037
a64_ehci_initialize: TODO: up_enable_irq
a64_ehci_initialize: TODO: a64_usbhost_vbusdrive
a64_printreg: 01c1b054-&gt;00001000
EHCI USB EHCI Initialized
NuttShell (NSH) NuttX-12.0.3
nsh&gt; 
</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb/blob/5238bc5246bcae896883f056d24691ebaa050f83/README.md#output-log">(Source)</a></p>
<p>The log above says that NuttX has successfully started the EHCI Controller. Yay!</p>
<div class="example-wrap"><pre class="language-text"><code>EHCI HCIVERSION 1.00
EHCI nports=1, HCSPARAMS=1101
EHCI HCCPARAMS=00a026
EHCI USB EHCI Initialized
</code></pre></div>
<p>TODO: What next?</p>
<h1 id="set-usb-magnitude--rate--threshold"><a href="#set-usb-magnitude--rate--threshold">14 Set USB Magnitude / Rate / Threshold</a></h1>
<p>TODO</p>
<p>Earlier we saw this code for setting the <a href="https://github.com/lupyuen/pinephone-nuttx-usb#power-on-the-usb-controller">USB Magnitude, Rate and Threshold</a> in the USB PHY Driver: <a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L259-L327">sun4i_usb_phy_init</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int sun4i_usb_phy_init(struct phy *phy) {
  ...
  // Assume ID is 1 for Port USB 1
  if (usb_phy-&gt;id == 0)
    sun4i_usb_phy_write(phy, PHY_RES45_CAL_EN,
      PHY_RES45_CAL_DATA,
      PHY_RES45_CAL_LEN);

  /* Adjust PHY&#39;s magnitude and rate */
  sun4i_usb_phy_write(phy, PHY_TX_AMPLITUDE_TUNE,
    PHY_TX_MAGNITUDE | PHY_TX_RATE,
    PHY_TX_AMPLITUDE_LEN);

  /* Disconnect threshold adjustment */
  sun4i_usb_phy_write(phy, PHY_DISCON_TH_SEL,
    data-&gt;cfg-&gt;disc_thresh, PHY_DISCON_TH_LEN);
</code></pre></div>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L145-L188">(<code>sun4i_usb_phy_write</code> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx-usb#usb-controller-configuration">(<code>disc_thresh</code> is 3)</a></p>
<p>TODO</p>
<h1 id="usb-controller-configuration"><a href="#usb-controller-configuration">15 USB Controller Configuration</a></h1>
<p>TODO</p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/drivers/phy/allwinner/phy-sun4i-usb.c#L622-L630">phy-sun4i-usb.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct sun4i_usb_phy_cfg sun50i_a64_cfg = {
  .num_phys = 2,
  .type = sun50i_a64_phy,
  .disc_thresh = 3,
  .phyctl_offset = REG_PHYCTL_A33,
  .dedicated_clocks = true,
  .hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,
  .phy0_dual_route = true,
};
</code></pre></div>
<p>(<code>PHY_CTL_H3_SIDDQ</code> is <code>1 &lt;&lt; 1</code>)</p>
<h1 id="whats-next"><a href="#whats-next">16 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>(I promised to reward myself with a Bread Machine when the NuttX EHCI Driver boots OK on PinePhone‚Ä¶ Time to go shopping! üòÄ)</p>
<p>TODO</p>
<p>But stay tuned for updates! Meanwhile please check out the other articles on NuttX for PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=34843712"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/PINE64official/comments/11566h0/nuttx_rtos_for_pinephone_exploring_usb/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/usb3.md"><strong>lupyuen.github.io/src/usb3.md</strong></a></p>

    
</body>
</html>