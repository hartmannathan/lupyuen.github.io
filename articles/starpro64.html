<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/starpro64-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/starpro64.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?</h1>
    <nav id="rustdoc"><ul>
<li><a href="#eswin-eic7700x-risc-v-soc" title="ESWIN EIC7700X RISC-V SoC">1 ESWIN EIC7700X RISC-V SoC</a><ul></ul></li>
<li><a href="#boot-without-microsd" title="Boot Without MicroSD">2 Boot Without MicroSD</a><ul></ul></li>
<li><a href="#download-the-linux-image" title="Download the Linux Image">3 Download the Linux Image</a><ul></ul></li>
<li><a href="#prepare-the-linux-image" title="Prepare the Linux Image">4 Prepare the Linux Image</a><ul></ul></li>
<li><a href="#starpro64-gets-smokin-hot" title="StarPro64 Gets Smokin‚Äô Hot!">5 StarPro64 Gets Smokin‚Äô Hot!</a><ul></ul></li>
<li><a href="#boot-the-linux-image" title="Boot the Linux Image">6 Boot the Linux Image</a><ul></ul></li>
<li><a href="#settings-for-u-boot-bootloader" title="Settings for U-Boot Bootloader">7 Settings for U-Boot Bootloader</a><ul></ul></li>
<li><a href="#boot-nuttx-over-tftp" title="Boot NuttX over TFTP">8 Boot NuttX over TFTP</a><ul></ul></li>
<li><a href="#smart-power-plug" title="Smart Power Plug">9 Smart Power Plug</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-starpro64" title="Appendix: Build NuttX for StarPro64">10 Appendix: Build NuttX for StarPro64</a><ul></ul></li>
<li><a href="#appendix-port-nuttx-to-starpro64" title="Appendix: Port NuttX to StarPro64">11 Appendix: Port NuttX to StarPro64</a><ul></ul></li>
<li><a href="#appendix-multiple-harts-on-starpro64" title="Appendix: Multiple Harts on StarPro64">12 Appendix: Multiple Harts on StarPro64</a><ul></ul></li>
<li><a href="#eswin-ai-sample-user-guide" title="ESWIN AI Sample User Guide">13 ESWIN AI Sample User Guide</a><ul></ul></li>
<li><a href="#uart" title="UART">14 UART</a><ul></ul></li>
<li><a href="#build-loop" title="Build Loop">15 Build Loop</a><ul></ul></li>
<li><a href="#multiple-cpu" title="Multiple CPU">16 Multiple CPU</a><ul></ul></li>
<li><a href="#disable-smp" title="Disable SMP">17 Disable SMP</a><ul></ul></li>
<li><a href="#todo" title="TODO">18 TODO</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">19 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>16 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/starpro64-title.jpg" alt="StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?" /></p>
<p>TODO</p>
<p>StarPro64 EIC7700X is the (literally) Hot New RISC-V SBC by PINE64.</p>
<p>Star64 power</p>
<p>IKEA Smart Power Plug</p>
<p>iTerm: Edit &gt; Paste Special &gt; Paste Slowly</p>
<p>Settings &gt; Advanced &gt; Pasteboard</p>
<p>Delay in seconds between chunks when Pasting Slowly: 1 second</p>
<p>Number of bytes to paste in each chunk when Pasting Slowly: 16</p>
<p>Well documented</p>
<p>NuttX: Power efficient AI</p>
<p><em>StarPro64 is just an upgraded Star64?</em></p>
<p>Nope it‚Äôs a totally different beast!</p>
<p>Docs are so much better! (??? pages)</p>
<p><em>(Thanks to PINE64 for providing the Prototype StarPro64)</em></p>
<h1 id="eswin-eic7700x-risc-v-soc"><a class="doc-anchor" href="#eswin-eic7700x-risc-v-soc">¬ß</a>1 ESWIN EIC7700X RISC-V SoC</h1>
<p>TODO: NPU</p>
<p><img src="https://lupyuen.org/images/starpro64-fan2.jpg" alt="TODO" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.org/images/starpro64-uart.jpg" alt="TODO" /></p>
<h1 id="boot-without-microsd"><a class="doc-anchor" href="#boot-without-microsd">¬ß</a>2 Boot Without MicroSD</h1>
<p><em>What happens if we boot StarPro64? Fresh from the box?</em></p>
<p>We monitor the <strong>UART0 Port</strong> for Debug Messages. Connect our <strong>USB UART Dongle</strong> (CH340 or CP2102) to these pins (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">StarPro64</th><th style="text-align: center">USB UART</th><th style="text-align: center">Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>GND</strong> (Pin 6)</td><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center"><em>Yellow</em></td></tr>
<tr><td style="text-align: center"><strong>TX</strong> (Pin 8)</td><td style="text-align: center"><strong>RX</strong></td><td style="text-align: center"><em>Blue</em></td></tr>
<tr><td style="text-align: center"><strong>RX</strong> (Pin 10)</td><td style="text-align: center"><strong>TX</strong></td><td style="text-align: center"><em>Green</em></td></tr>
</tbody></table>
</div>
<p>(Same Pins as the <strong>GPIO Header</strong> on Oz64 SG2000 and Star64 JH7110)</p>
<p>Connect to the USB UART at <strong>115.2 kbps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 115200</code></pre></div>
<p>Power up the board with a <strong>Power Adapter</strong>. <a href="TODO">(Same one as <strong>Star64 JH7110</strong>)</a></p>
<p>We‚Äôll see <a href="TODO"><strong>OpenSBI</strong></a>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>OpenSBI v1.5
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|
Platform Name             : ESWIN EIC7700 EVB
Platform Features         : medeleg
Platform HART Count       : 4
Platform Console Device   : uart8250
Firmware Base             : 0x80000000

Domain0 Boot HART         : 2
Domain0 HARTs             : 0*,1*,2*,3*
Domain0 Next Address      : 0x0000000080200000

Boot HART ID              : 2
Boot HART Base ISA        : rv64imafdchx
Boot HART ISA Extensions  : sscofpmf,zihpm,sdtrig
Boot HART MIDELEG         : 0x0000000000002666
Boot HART MEDELEG         : 0x0000000000f0b509</code></pre></div></span>
<p>Then <a href="TODO"><strong>U-Boot Bootloader</strong></a>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2024.01-gaa36f0b4 (Jan 23 2025 - 02:49:59 +0000)
CPU:     rv64imafdc_zba_zbb
Model:   ESWIN EIC7700 EVB
DRAM:    32 GiB (effective 16 GiB)
llCore:  143 devices, 31 uclasses, devicetree: separate
Warning: Device tree includes old &#39;u-boot,dm-&#39; tags: please fix by 2023.07!
MMC:    sdhci@50450000: 0, sd@50460000: 1

Loading Environment from SPIFlash...
SF: Detected w25q128fw with page size 256 Bytes, erase size 4 KiB, total 16 MiB
*** Warning - bad CRC, using default environment
No SATA device found!
Hit any key to stop autoboot:  0
=&gt;</code></pre></div></span>
<p>And it stops at U-Boot, waiting to boot from MicroSD or eMMC. Let‚Äôs init our eMMC‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/9db7b36f3cdf26f7b7f75c0d35177ee7">(See the <strong>Boot Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-hdmi.jpg" alt="TODO" /></p>
<p><em>HDMI Output will show U-Boot, but not OpenSBI</em></p>
<h1 id="download-the-linux-image"><a class="doc-anchor" href="#download-the-linux-image">¬ß</a>3 Download the Linux Image</h1>
<p><em>Is there a Linux Image for StarPro64?</em></p>
<p>The fine folks at <a href="https://github.com/rockos-riscv"><strong>PLCT Lab RockOS</strong></a> are busy preparing the <strong>Linux Image</strong> for StarPro64. Thanks to <a href="https://nightcord.de/@icenowy/114027871300585376"><strong>@icenowy</strong></a>, we have a <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/"><strong>Preview Version</strong></a> of the Linux Image‚Ä¶</p>
<ol>
<li>
<p><strong>Bootloader (OpenSBI + U-Boot)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/bootloader_secboot_ddr5_pine64-starpro64.bin"><em>bootloader_secboot_ddr5_pine64-starpro64.bin</em></a></p>
</li>
<li>
<p><strong>Linux Boot Image (Linux Kernel)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/boot-rockos-20250123-210346.ext4.zst"><em>boot-rockos-20250123-210346.ext4.zst</em></a></p>
</li>
<li>
<p><strong>Linux Root Image (Linux Filesystem)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/root-rockos-20250123-210346.ext4.zst"><em>root-rockos-20250123-210346.ext4.zst</em></a></p>
</li>
</ol>
<p>Uncompress the files and rename them. Copy them to a <a href="TODO"><strong>USB Drive</strong></a> (not MicroSD)</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -lh *.bin *.zst
4.2M  bootloader_secboot_ddr5_pine64-starpro64.bin
154M  boot-rockos-20250123-210346.ext4.zst
2.3G  root-rockos-20250123-210346.ext4.zst

$ unzstd boot-rockos-20250123-210346.ext4.zst
boot-rockos-20250123-210346.ext4.zst: 524288000 bytes

$ unzstd root-rockos-20250123-210346.ext4.zst
root-rockos-20250123-210346.ext4.zst: 7516192768 bytes

$ mv boot-rockos-20250123-210346.ext4 boot.ext4
$ mv root-rockos-20250123-210346.ext4 root.ext4

$ ls -lh *.bin *.ext4
4.2M  bootloader_secboot_ddr5_pine64-starpro64.bin
500M  boot.ext4
7.0G  root.ext4

$ cp *.bin *.ext4 /media/$USER/YOUR_USB_DRIVE</code></pre></div>
<p>We‚Äôll skip the <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/sdcard-rockos-20250123-210346.img.zst"><strong>MicroSD Image</strong></a>, because <a href="TODO"><strong>MicroSD Interface</strong></a> wasn‚Äôt working reliably on our Prototype StarPro64.</p>
<p><img src="https://lupyuen.org/images/starpro64-emmc.jpg" alt="TODO" /></p>
<h1 id="prepare-the-linux-image"><a class="doc-anchor" href="#prepare-the-linux-image">¬ß</a>4 Prepare the Linux Image</h1>
<p><em>How to load the Linux Image into eMMC?</em></p>
<p>Based on the <a href="TODO"><strong>Official Doc</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Connect our <strong>eMMC to StarPro64</strong> (pic above)</p>
</li>
<li>
<p>Connect our <strong>USB Drive</strong> from previous section</p>
</li>
<li>
<p><strong>At U-Boot:</strong> Press <strong>Ctrl-C</strong> to stop Autoboot</p>
</li>
<li>
<p>Verify that the <strong>eMMC is OK</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls mmc 0
[ Nothing ]

$ mmc part
[ Nothing ]</code></pre></div></li>
<li>
<p>First Time Only: <strong>GPT Partition</strong> our eMMC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ echo $partitions
partitions=
  name=boot,start=1MiB,size=2048MiB,type=${typeid_filesystem},uuid=${uuid_boot};
  name=swap,size=4096MiB,type=${typeid_swap},uuid=${uuid_swap};
  name=root,size=-,type=${typeid_filesystem},uuid=${uuid_root}

$ run gpt_partition
$ mmc part
1 0x00000800 0x001007ff &quot;boot&quot;
2 0x00100800 0x009007ff &quot;swap&quot;
3 0x00900800 0x0e677fde &quot;root&quot;</code></pre></div></li>
<li>
<p>Verify that our <strong>USB Drive</strong> works‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls usb 0
 524288000 boot.ext4
7516192768 root.ext4
   4380760 bootloader_secboot_ddr5_pine64-starpro64.bin   </code></pre></div></li>
<li>
<p>Install the <strong>Bootloader, Boot Image and Root Image</strong>, from USB Drive to eMMC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ es_fs update usb 0 boot.ext4 mmc 0:1
mmc has been successfully writen in mmc 0:1

$ es_fs update usb 0 root.ext4 mmc 0:3
mmc has been successfully writen in mmc 0:3

$ ext4load usb 0 0x100000000 bootloader_secboot_ddr5_pine64-starpro64.bin
4380760 bytes read in 162 ms (25.8 MiB/s)

$ es_burn write 0x100000000 flash
bootloader write OK</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/a07e8dcd56d3fb306dce8983f4924702">(See the <strong>eMMC Log</strong>)</a></p>
</li>
<li>
<p><strong>Beware of Overheating!</strong> Keep StarPro64 cool, or the previous step might corrupt the <strong>SPI Boot Flash</strong> and cause unspeakable agony‚Ä¶</p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/starpro64-fan.jpg" alt="TODO" /></p>
<h1 id="starpro64-gets-smokin-hot"><a class="doc-anchor" href="#starpro64-gets-smokin-hot">¬ß</a>5 StarPro64 Gets Smokin‚Äô Hot!</h1>
<p><em>Something is smelling like barbecue?</em></p>
<p>Whoa StarPro64 is on fire: Drop it, stop it and <strong>power off</strong>! StarPro64 will show <a href="https://gist.github.com/lupyuen/47170b4c4d7117ac495c5faede48280b#file-gistfile1-txt-L796-L894"><strong>PLL Errors</strong></a> when it overheats‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>pll failed.
pll failed.
pll failed.</code></pre></div>
<p>Also watch for <a href="https://gist.github.com/lupyuen/89e1e87e7f213b6f52f31987f254b32f#file-gistfile1-txt-L1940-L1947"><strong>Thermal Errors</strong></a> when booting Linux‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>thermal thermal_zone0: thermal0:
critical temperature reached, shutting down
reboot: HARDWARE PROTECTION shutdown (Temperature too high)</code></pre></div>
<p>Install a <a href="https://www.lazada.sg/products/i2932991583-s20178422377.html"><strong>USB Fan</strong></a>, preferably something stronger. <em>(Pic above, boxed up with IKEA 365+)</em></p>
<p>But don‚Äôt power it with the USB Port on StarPro64! Instead, connect it to our <a href="TODO"><strong>Smart Power Plug</strong></a>.</p>
<p><em>Anything else we should worry about?</em></p>
<p>The <a href="TODO"><strong>MicroSD Interface</strong></a> wasn‚Äôt working well on our Prototype StarPro64. The MicroSD Card deactivated itself after a bit of U-Boot Access.</p>
<p>Hence the <strong>Headless Ironman</strong>: USB Drive on StarPro64‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-ironman.jpg" alt="TODO" /></p>
<h1 id="boot-the-linux-image"><a class="doc-anchor" href="#boot-the-linux-image">¬ß</a>6 Boot the Linux Image</h1>
<p><em>Earlier we flashed Linux to eMMC. Can we boot Linux now?</em></p>
<p>Yep just power up StarPro64. eMMC will <strong>Boot Linux</strong>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>U-Boot menu
1:      RockOS GNU/Linux 6.6.73-win2030
2:      RockOS GNU/Linux 6.6.73-win2030 (rescue target)
Enter choice: 1:        RockOS GNU/Linux 6.6.73-win2030
Retrieving file: /vmlinuz-6.6.73-win2030
Retrieving file: /initrd.img-6.6.73-win2030
append: root=PARTUUID=b0f77ad6-36cd-4a99-a8c0-31d73649aa08 console=ttyS0,115200 root=PARTUUID=b0f77ad6-36cd-4a99-a8c0-31d73649aa08 rootfstype=ext4 rootwait rw earlycon selinux=0 LANG=en_US.UTF-8

Retrieving file: /dtbs/linux-image-6.6.73-win2030/eswin/eic7700-pine64-starpro64.dtb
   Uncompressing Kernel Image
Moving Image from 0x84000000 to 0x80200000, end=81e63000
## Flattened Device Tree blob at 88000000
   Booting using the fdt blob at 0x88000000
Working FDT set to 88000000
ERROR: reserving fdt memory region failed (addr=fffff000 size=1000 flags=4)
   Using Device Tree in place at 0000000088000000, end 0000000088027af4
Working FDT set to 88000000

Starting kernel ...
Linux version 6.6.73-win2030 (riscv@riscv-builder) (riscv64-unknown-linux-gnu-gcc () 13.2.0, GNU ld (GNU Binutils) 2.42) #2025.01.23.02.46+aeb0f375c SMP Thu Jan 23 03:08:39 UTC 2025
Machine model: Pine64 StarPro64
...
mmc0: Timeout waiting for hardware interrupt.
mmc0: sdhci: ============ SDHCI REGISTER DUMP ===========
mmc0: sdhci: Sys addr:  0x00000008 | Version:  0x00000005
mmc0: sdhci: Blk size:  0x00007200 | Blk cnt:  0x00000000</code></pre></div></span>
<p>Sadly the <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/"><strong>Preview Version</strong></a> of RockOS won‚Äôt boot correctly on our Prototype StarPro64. Hopefully we‚Äôll sort this out real soon! (Pic below)</p>
<p><a href="https://gist.github.com/lupyuen/89e1e87e7f213b6f52f31987f254b32f">(See the <strong>Boot Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-linux.jpg" alt="TODO" /></p>
<h1 id="settings-for-u-boot-bootloader"><a class="doc-anchor" href="#settings-for-u-boot-bootloader">¬ß</a>7 Settings for U-Boot Bootloader</h1>
<p><em>Bummer. What else can we boot on StarPro64?</em></p>
<p>Let‚Äôs snoop around <a href="TODO"><strong>U-Boot Bootloader</strong></a>. And figure out how to boot <a href="TODO"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>Power up StarPro64 and press <strong>Ctrl-C</strong>. At the <strong>U-Boot Prompt</strong>: We enter these commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ help
printenv  - print environment variables
saveenv   - save environment variables to persistent storage
net       - NET sub-system
dhcp      - boot image via network using DHCP/TFTP protocol
tftpboot  - load file via network using TFTP protocol
fdt       - flattened device tree utility commands
booti     - boot Linux kernel &#39;Image&#39; format from memory

$ printenv
fdt_addr_r=0x88000000
kernel_addr_r=0x84000000
loadaddr=0x80200000</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9db7b36f3cdf26f7b7f75c0d35177ee7">(See the <strong>U-Boot Log</strong>)</a></p>
<p>A-ha! This says‚Ä¶</p>
<ul>
<li>
<p>U-Boot supports booting over TFTP: <a href="TODO"><strong>Trivial File Transfer Protocol</strong></a></p>
</li>
<li>
<p>It will load the <strong>Kernel Image</strong> <em>(Linux / NuttX)</em> into RAM at <strong><code>0x8400</code> <code>0000</code></strong></p>
</li>
<li>
<p>Then it will move the Kernel Image to <strong><code>0x8020</code> <code>0000</code></strong> and boot there</p>
</li>
<li>
<p>Also it loads the <strong>Device Tree</strong> into <strong><code>0x8800</code> <code>0000</code></strong></p>
</li>
</ul>
<p>Thanks U-Boot! You told us everything we need to Boot NuttX‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.org/images/starpro64-nuttx.png" alt="TODO" /></p>
</blockquote>
<h1 id="boot-nuttx-over-tftp"><a class="doc-anchor" href="#boot-nuttx-over-tftp">¬ß</a>8 Boot NuttX over TFTP</h1>
<p><em>How to boot NuttX over TFTP?</em></p>
<ol>
<li>
<p>Install our <strong>TFTP Server</strong>: Follow the <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>instructions here</strong></a></p>
</li>
<li>
<p>Copy these files to our TFTP Server‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/TODO"><strong>NuttX Image: Image-starpro64</strong></a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/TODO"><strong>Device Tree: jh7110-star64-pine64.dtb</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p><a href="TODO">(How to <strong>Build NuttX</strong> ourselves)</a></p>
</li>
<li>
<p>Power up StarPro64 and press <strong>Ctrl-C</strong></p>
</li>
<li>
<p>At the <strong>U-Boot Prompt</strong>: Enter these commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Check if the Network Adapter is alive
## &quot;eth0 : ethernet@50400000 f6:70:f9:6e:73:ae active&quot;
net list

## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## Save the U-Boot Config for future reboots
saveenv

## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=TODO
dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64

## Load the Device Tree from TFTP Server
## fdt_addr_r=TODO
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=TODO
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
fdt addr ${fdt_addr_r}

## Boot the NuttX Image with the Device Tree
## kernel_addr_r=TODO
## fdt_addr_r=TODO
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}</code></pre></div>
<p><a href="TODO"><em>(U-Boot dropping chars? Try <strong>iTerm &gt; Edit &gt; Paste Special &gt; Paste Slowly</strong>)</em></a></p>
</li>
<li>
<p>NuttX boots OK on StarPro64 yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>TODO</code></pre></div></li>
<li>
<p>How did we port NuttX to StarPro64? Check the details here‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúTODO‚Äù</strong></a></p>
</li>
</ol>
<p><em>We type these commands EVERY TIME we boot?</em></p>
<p>We can automate: Just do this once, and NuttX will <strong>Auto-Boot</strong> whenever we power up‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Add the Boot Command for TFTP
setenv bootcmd_tftp &#39;dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}&#39;

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Command: `bootflow scan -lb`
setenv orig_bootcmd &quot;$bootcmd&quot;

## Prepend TFTP to the Boot Command: `run bootcmd_tftp ; bootflow scan -lb`
setenv bootcmd &quot;run bootcmd_tftp ; $bootcmd&quot;

## Save it for future reboots
saveenv</code></pre></div>
<p><a href="TODO"><em>(U-Boot dropping chars? Try <strong>iTerm &gt; Edit &gt; Paste Special &gt; Paste Slowly</strong>)</em></a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-sg2000/issues/1">(What about <strong>Static IP</strong>?)</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-sg2000/issues/1#issuecomment-2114415245">(How to <strong>Undo Auto-Boot</strong>)</a></p>
<p>TODO: Press Ctrl-C to stop</p>
<p>TODO: Pic of Smart Plug, Fan, Ubuntu PC, StarPro64, USB Serial, TFTP Server</p>
<h1 id="smart-power-plug"><a class="doc-anchor" href="#smart-power-plug">¬ß</a>9 Smart Power Plug</h1>
<p><em>Powering StarPro64 on and off: Gets so tiresome ain‚Äôt it?</em></p>
<p>Try a <strong>Smart Power Plug</strong>, integrated with our Build Script‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-power1.jpg" alt="TODO" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.org/images/starpro64-power2.jpg" alt="TODO" /></p>
<p>https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac#file-run-sh-L118-L163</p>
<div class="example-wrap"><pre class="language-bash"><code>## Get the Home Assistant Token, copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC&quot;
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait for SBC Testing to complete
echo Press Enter to Power Off
read

## Power Off the SBC&quot;
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p>Remember the <a href="TODO"><strong>USB Fan</strong></a>? It goes into our Smart Power Plug as a Power Jenga like so‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.org/images/starpro64-power3.jpg" alt="TODO" /></p>
</blockquote>
<h1 id="appendix-build-nuttx-for-starpro64"><a class="doc-anchor" href="#appendix-build-nuttx-for-starpro64">¬ß</a>10 Appendix: Build NuttX for StarPro64</h1>
<p><em>Earlier we booted Image-starpro64 over TFTP. How to get the file?</em></p>
<p>We may download the NuttX Image File <strong><code>Image-starpro64</code></strong> from here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-sg2000/tags"><strong>Daily Build: NuttX for SG2000</strong></a></li>
</ul>
<p>If we prefer to build NuttX ourselves‚Ä¶</p>
<ol>
<li>
<p>Install the Build Prerequisites, skip the RISC-V Toolchain‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the RISC-V Toolchain for <strong>riscv-none-elf</strong> (xPack)‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-xpack-gnu-risc-v-embedded-gcc-toolchain-for-64-bit-risc-v"><strong>‚ÄúxPack GNU RISC-V Embedded GCC Toolchain for 64-bit RISC-V‚Äù</strong></a></p>
</li>
<li>
<p>Download and Build <strong>NuttX for StarPro64</strong> (work-in-progress)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch starpro64
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch starpro64
cd nuttx
tools/configure.sh milkv_duos:nsh

## Build the NuttX Kernel and Apps
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Copy NuttX Image to TFTP Server
scp Image tftpserver:/tftpboot/Image-starpro64
ssh tftpserver ls -l /tftpboot/Image-starpro64

## In U-Boot: Boot NuttX over TFTP
## setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}</code></pre></div>
<p><a href="TODO">(See the <strong>Build Script</strong>)</a></p>
<p><a href="TODO">(See the <strong>Build Log</strong>)</a></p>
<p><a href="TODO">(See the <strong>Build Outputs</strong>)</a></p>
</li>
<li>
<p>The steps above assume that we‚Äôve installed our TFTP Server, according to the <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>instructions here</strong></a></p>
</li>
<li>
<p>Then follow these steps to boot NuttX on StarPro64‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúBoot NuttX over TFTP‚Äù</strong></a></p>
</li>
<li>
<p>Powering StarPro64 on and off can get tiresome. Try a Smart Power Plug, integrated with our Build Script‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúTODO‚Äù</strong></a></p>
</li>
<li>
<p>How did we port NuttX to StarPro64? Check the details here‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúTODO‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/mmu-l3user.jpg" alt="Virtual Memory for NuttX Apps" /></p>
<p><em>Why the RAM Disk? Isn‚Äôt NuttX an RTOS?</em></p>
<p>StarPro64 uses a RAM Disk because it runs in <strong>NuttX Kernel Mode</strong> (instead of the typical Flat Mode). This means we can do <strong>Memory Protection</strong> and <strong>Virtual Memory</strong> for Apps. (Pic above)</p>
<p>But it also means we need to bundle the <strong>NuttX Apps as ELF Files</strong>, hence the RAM Disk‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/app"><strong>‚ÄúNuttX Apps and Initial RAM Disk‚Äù</strong></a></li>
</ul>
<p>Most of the NuttX Platforms run on <strong>NuttX Flat Mode</strong>, which has NuttX Apps Statically-Linked into the NuttX Kernel.</p>
<p>NuttX Flat Mode works well for Small Microcontrollers. But StarPro64 and other SoCs will need the more sophisticated <strong>NuttX Kernel Mode</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode"><strong>‚ÄúNuttX Flat Mode vs Kernel Mode‚Äù</strong></a></li>
</ul>
<h1 id="appendix-port-nuttx-to-starpro64"><a class="doc-anchor" href="#appendix-port-nuttx-to-starpro64">¬ß</a>11 Appendix: Port NuttX to StarPro64</h1>
<p><em>How did we port NuttX to StarPro64? In under One Week?</em></p>
<p>We took the NuttX Port of <strong>Milk-V Duo S (Oz64 SG2000)</strong> and tweaked it for <strong>StarPro64 EIC7700X</strong>, with these minor modifications‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files"><strong>Modified Files: NuttX for StarPro64</strong></a></li>
</ul>
<p>Here‚Äôs what we changed‚Ä¶</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-9c348f27c59e1ed0d1d9c24e172d233747ee09835ab0aa7f156da1b7caa6a5fb">arch/risc-v/Kconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>config ARCH_CHIP_SG2000
	select ARCH_RV_CPUID_MAP</code></pre></div>
<p>TODO
disable thead mmu flags
app addr env
nuttx/arch/risc-v/Kconfig
remove ARCH_MMU_EXT_THEAD</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-523f77920746a4b6cb3e02ef9dfb71223593ae328aa8019e8d8fd730b828ab9f">arch/risc-v/include/sg2000/irq.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define NR_IRQS (RISCV_IRQ_SEXT + 458)</code></pre></div>
<p>EIC7700X supports <strong>458 External Interrupts</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 374</th></tr></thead><tbody>
<tr><td style="text-align: left">Max Interrupts</td><td style="text-align: left">458</td></tr>
</tbody></table>
</div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-14db47e674d6ddcbffc6f855a536a173b5833e3bd96a3490a45f1ef94e3b2767">arch/risc-v/src/sg2000/hardware/sg2000_memorymap.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define SG2000_PLIC_BASE 0x0C000000ul</code></pre></div>
<p><strong>PLIC Base Address</strong> is specified here‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 239</th></tr></thead><tbody>
<tr><td style="text-align: left">PLIC Memory Map</td><td style="text-align: left">0x0C00_0000</td></tr>
</tbody></table>
</div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-64c2a42d4a59409becf86f2967d2a27ff48635231437f56620d3e86a28002a28">arch/risc-v/src/sg2000/hardware/sg2000_plic.h</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Interrupt Priority */

#define SG2000_PLIC_PRIORITY (SG2000_PLIC_BASE + 0x000000)

/* Hart 0 S-Mode Interrupt Enable */

#define SG2000_PLIC_ENABLE0     (SG2000_PLIC_BASE + 0x002080)
#define SG2000_PLIC_ENABLE_HART (0x100)

/* Hart 0 S-Mode Priority Threshold */

#define SG2000_PLIC_THRESHOLD0     (SG2000_PLIC_BASE + 0x201000)
#define SG2000_PLIC_THRESHOLD_HART (0x2000)

/* Hart 0 S-Mode Claim / Complete */

#define SG2000_PLIC_CLAIM0     (SG2000_PLIC_BASE + 0x201004)
#define SG2000_PLIC_CLAIM_HART (0x2000)</code></pre></div>
<p><strong>Interrupt Enable: PLIC_ENABLE_HART</strong> is 0x100 because we skip 0x100 bytes per Hart‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 240</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(Skip the M-Modes)</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">0x0C00_2080</td><td style="text-align: left">Start Hart 0 S-Mode interrupt enables</td></tr>
<tr><td style="text-align: left">0x0C00_2180</td><td style="text-align: left">Start Hart 1 S-Mode interrupt enables</td></tr>
<tr><td style="text-align: left">0x0C00_2280</td><td style="text-align: left">Start Hart 2 S-Mode interrupt enables</td></tr>
</tbody></table>
</div>
<p><strong>Priority Threshold: PLIC_THRESHOLD_HART</strong> is 0x2000 because we skip 0x2000 bytes per Hart</p>
<p><strong>Claim / Complete: PLIC_CLAIM_HART</strong> is 0x2000 because we skip 0x2000 per Hart</p>
<p>Which comes from this‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 241</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(Skip the M-Modes)</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">0x0C20_1000</td><td style="text-align: left">Hart 0 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left">0x0C20_1004</td><td style="text-align: left">Hart 0 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: left">0x0C20_3000</td><td style="text-align: left">Hart 1 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left">0x0C20_3004</td><td style="text-align: left">Hart 1 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: left">0x0C20_5000</td><td style="text-align: left">Hart 2 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left">0x0C20_5004</td><td style="text-align: left">Hart 2 S-Mode Claim / Complete</td></tr>
</tbody></table>
</div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-d8bd71e8ea93fc23ec348eeaca3d45f89dc896eff80311583d758d42e6e8fc58">arch/risc-v/src/sg2000/sg2000_head.S</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>  .quad   0x4000000            /* Kernel size (fdt_addr_r-kernel_addr_r) */</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x50900000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* If a0 (hartid) &gt;= t1 (the number of CPUs), stop here */

  /* TODO: Enable this for SMP
  blt  a0, t1, 3f
  csrw CSR_SIE, zero
  wfi
  */

3:
  /* Set stack pointer to the idle thread stack */
  li a2, 0
  riscv_set_inital_sp SG2000_IDLESTACK_BASE, SMP_STACK_SIZE, a2

  /* TODO: Enable this for SMP
  riscv_set_inital_sp SG2000_IDLESTACK_BASE, SMP_STACK_SIZE, a0
  */</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-0c39d310c3819d6b7bfecb05f6a203019d0f937b171abe539f299fa37805b366">arch/risc-v/src/sg2000/sg2000_irq.c</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>  /* Disable all global interrupts */

  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++)
    {
      addr = SG2000_PLIC_ENABLE0 + (hart * SG2000_PLIC_ENABLE_HART);
      for (offset = 0; offset &lt; (NR_IRQS - RISCV_IRQ_EXT) &gt;&gt; 3; offset += 4)
        {
          putreg32(0x0, addr + offset);          
        }
    }

  /* Clear pendings in PLIC */

  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++)
    {
      addr = SG2000_PLIC_CLAIM0 + (hart * SG2000_PLIC_CLAIM_HART);
      claim = getreg32(addr);
      putreg32(claim, addr);
    }

  /* Set irq threshold to 0 (permits all global interrupts) */

  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++)
    {
      addr = SG2000_PLIC_THRESHOLD0 +
             (hart * SG2000_PLIC_THRESHOLD_HART);
      putreg32(0, addr);
    }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>void up_disable_irq(int irq) {
      ...
      /* Clear enable bit for the irq */

      if (0 &lt;= extirq &amp;&amp; extirq &lt;= NR_IRQS - RISCV_IRQ_EXT)
        {
          addr = SG2000_PLIC_ENABLE0 + 
                 (boot_hartid * SG2000_PLIC_ENABLE_HART);
          modifyreg32(addr + (4 * (extirq / 32)),
                      1 &lt;&lt; (extirq % 32), 0);
        }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>void up_enable_irq(int irq) {
      ...
      /* Set enable bit for the irq */

      if (0 &lt;= extirq &amp;&amp; extirq &lt;= NR_IRQS - RISCV_IRQ_EXT)
        {
          addr = SG2000_PLIC_ENABLE0 + 
                 (boot_hartid * SG2000_PLIC_ENABLE_HART);
          modifyreg32(addr + (4 * (extirq / 32)),
                      0, 1 &lt;&lt; (extirq % 32));
        }</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-75ceaf9a0a70840fc2e15cea303fff5e9d2339d4f524574df94b5d0ec46e37ea">arch/risc-v/src/sg2000/sg2000_irq_dispatch.c</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs)
{
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);
  uintptr_t claim = SG2000_PLIC_CLAIM0 + 
                    (boot_hartid * SG2000_PLIC_CLAIM_HART);
      ...
      uintptr_t val = getreg32(claim);
      ...
      /* Then write PLIC_CLAIM to clear pending in PLIC */

      putreg32(irq - RISCV_IRQ_EXT, claim);</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-cacefdc3058a54e86027d411b0a6711d8a322b1750150521d5c640e72daa8b5f">arch/risc-v/src/sg2000/sg2000_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MMU_IO_BASE      (0x00000000ul)
#define MMU_IO_SIZE      (0x80000000ul)</code></pre></div>
<p>We derived the above from the <strong>EIC7700X Memory Map</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 380</th></tr></thead><tbody>
<tr><td style="text-align: left">System Memory Map</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">System Space (Low)</td><td style="text-align: left">0000_0000 to 8000_0000</td></tr>
<tr><td style="text-align: left">Memory Space</td><td style="text-align: left">8000_0000 to 10_0000_0000</td></tr>
</tbody></table>
</div>
<p>We removed all <strong>T-Head MMU Extensions</strong>, including <strong>mmu_flush_cache</strong>.</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-84111f6f800efef513a2420c571ea39fe2068d19cff6c1eab015da0f9755b9c7">arch/risc-v/src/sg2000/sg2000_start.c</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>//// TODO
struct sbiret_s
{
  intreg_t    error;
  uintreg_t   value;
};
typedef struct sbiret_s sbiret_t;
static void sg2000_boot_secondary(void);
static int riscv_sbi_boot_secondary(uintreg_t hartid, uintreg_t addr);
static sbiret_t sbi_ecall(unsigned int extid, unsigned int fid,
                          uintreg_t parm0, uintreg_t parm1,
                          uintreg_t parm2, uintreg_t parm3,
                          uintreg_t parm4, uintreg_t parm5);

#define SBI_EXT_HSM (0x0048534D)
#define SBI_EXT_HSM_HART_START (0x0)

int boot_hartid = -1;

void sg2000_start_s(int mhartid)
{
  /* Configure FPU */

  riscv_fpuconfig();

  if (mhartid != boot_hartid)
    {
      goto cpux;
    }
    ...

cpux:

  /* Non-Boot Hart starts here */

  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;a&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;0&#39; + mhartid;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;

  ...

void sg2000_start(int mhartid)
{
  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;e&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;l&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;l&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;o&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39; &#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;N&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;u&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;X&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;!&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;

  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;a&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;0&#39; + mhartid;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;
  up_mdelay(1000);  // Wait a while for UART Queue to flush

  /* If Boot Hart is not 0, restart with Hart 0 */

  if (mhartid != 0)
    {
      /* Clear the BSS */

      sg2000_clear_bss();

      /* Restart with Hart 0 */

      riscv_sbi_boot_secondary(0, (uintptr_t)&amp;__start);

      /* Let this Hart idle forever */

      while (true)
        {
          asm(&quot;WFI&quot;);
        }  
      PANIC(); /* Should not come here */
    }

  /* Init the globals once only. Remember the Boot Hart. */

  if (boot_hartid &lt; 0)
    {
      boot_hartid = mhartid;

      /* Clear the BSS */

      sg2000_clear_bss();

      /* Boot the other cores */

      // TODO: sg2000_boot_secondary();

      /* Copy the RAM Disk */

      sg2000_copy_ramdisk();
      /* Initialize the per CPU areas */
      riscv_percpu_add_hart(mhartid);
    }

/****************************************************************************
 * Name: riscv_hartid_to_cpuid
 *
 * Description:
 *   Convert physical core number to logical core number.
 *
 ****************************************************************************/

int weak_function riscv_hartid_to_cpuid(int hart)
{
  /* Boot Hart is CPU 0. Renumber the Other Harts. */

  if (hart == boot_hartid)
    {
      return 0;
    }
  else if (hart &lt; boot_hartid)
    {
      return hart + 1;
    }
  else
    {
      return hart;
    }
}

/****************************************************************************
 * Name: riscv_cpuid_to_hartid
 *
 * Description:
 *   Convert logical core number to physical core number.
 *
 ****************************************************************************/

int weak_function riscv_cpuid_to_hartid(int cpu)
{
  /* Boot Hart is CPU 0. Renumber the Other Harts. */

  if (cpu == 0)
    {
      return boot_hartid;
    }
  else if (cpu &lt; boot_hartid + 1)
    {
      return cpu - 1;
    }
  else
    {
      return cpu;
    }
}

static void sg2000_boot_secondary(void)
{
  int i;

  for (i = 0; i &lt; CONFIG_SMP_NCPUS; i++)
    {
      if (i == boot_hartid)
        {
          continue;
        }

      riscv_sbi_boot_secondary(i, (uintptr_t)&amp;__start);
    }
}

static int riscv_sbi_boot_secondary(uintreg_t hartid, uintreg_t addr)
{
  sbiret_t ret = sbi_ecall(SBI_EXT_HSM, SBI_EXT_HSM_HART_START,
                           hartid, addr, 0, 0, 0, 0);

  if (ret.error &lt; 0)
    {
      _err(&quot;Boot Hart %d failed\n&quot;, hartid);
      PANIC();
    }

  return 0;
}

static sbiret_t sbi_ecall(unsigned int extid, unsigned int fid,
                          uintreg_t parm0, uintreg_t parm1,
                          uintreg_t parm2, uintreg_t parm3,
                          uintreg_t parm4, uintreg_t parm5)
{
  register long r0 asm(&quot;a0&quot;) = (long)(parm0);
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);
  register long r4 asm(&quot;a4&quot;) = (long)(parm4);
  register long r5 asm(&quot;a5&quot;) = (long)(parm5);
  register long r6 asm(&quot;a6&quot;) = (long)(fid);
  register long r7 asm(&quot;a7&quot;) = (long)(extid);
  sbiret_t ret;

  asm volatile
    (
     &quot;ecall&quot;
     : &quot;+r&quot;(r0), &quot;+r&quot;(r1)
     : &quot;r&quot;(r2), &quot;r&quot;(r3), &quot;r&quot;(r4), &quot;r&quot;(r5), &quot;r&quot;(r6), &quot;r&quot;(r7)
     : &quot;memory&quot;
     );

  ret.error = r0;
  ret.value = (uintreg_t)r1;

  return ret;
}</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-1c190e766d71f3e5a43109b975405c9e43b2d01e50f748b0f0c19a8d942caffe">arch/risc-v/src/sg2000/sg2000_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 1000000ul</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-82b3bf6ae151a2f4e1fb9b23de18af9fd683accc70aff2c88e0b5d6d0e26904b">boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_REGINCR=4
CONFIG_16550_UART0_BASE=0x50900000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_IRQ=125

CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y</code></pre></div>
<p><strong>16550_REGINCR</strong> is 4 because the UART Registers are spaced 4 bytes apart‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf">EIC7700X Tech Ref #4</a></th><th style="text-align: left">Page 524</th></tr></thead><tbody>
<tr><td style="text-align: left">UART Register Offset</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">0x0</td><td style="text-align: left">Receive Buffer Register (RBR)</td></tr>
<tr><td style="text-align: left">0x4</td><td style="text-align: left">Interrupt Enable Register (IER)</td></tr>
<tr><td style="text-align: left">0x8</td><td style="text-align: left">Interrupt Identification Register (IIR)</td></tr>
</tbody></table>
</div>
<p><strong>UART0 Base Address</strong> is here‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf">EIC7700X Tech Ref #4</a></th><th style="text-align: left">Page 353</th></tr></thead><tbody>
<tr><td style="text-align: left">Peripheral Address Space</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">UART0</td><td style="text-align: left">0x5090_0000</td></tr>
</tbody></table>
</div>
<p><strong>Why IRQ 125?</strong> UART0 Interrupt Number is 100, we add 25 because of TODO‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 366</th></tr></thead><tbody>
<tr><td style="text-align: left">UART0 Interrupt Number</td><td style="text-align: left">100 <em>(lsp_uart0_intr)</em></td></tr>
</tbody></table>
</div>
<p>TODO: <strong>16550_UART0_CLOCK</strong></p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-f208234edbfb636de240a0fef1c85f9cecb37876d5bc91ffb759f70a1e96b1d1">drivers/serial/uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef TODO  //  Compute CONFIG_16550_UART0_CLOCK
  /* Enter DLAB=1 */

  u16550_serialout(priv, UART_LCR_OFFSET, (lcr | UART_LCR_DLAB));
  ...
  /* Clear DLAB */

  u16550_serialout(priv, UART_LCR_OFFSET, lcr);
#endif  // TODO</code></pre></div>
<p><img src="https://lupyuen.org/images/starpro64-hartid0.png" alt="TODO" /></p>
<h1 id="appendix-multiple-harts-on-starpro64"><a class="doc-anchor" href="#appendix-multiple-harts-on-starpro64">¬ß</a>12 Appendix: Multiple Harts on StarPro64</h1>
<p><em>Multiple Harts are problematic. Why?</em></p>
<p>Inside EIC7700X SoC: We have <strong>Four Harts</strong> (RISC-V CPU Cores) numbered 0 to 3.</p>
<p>This SoC will boot OpenSBI on <strong>Any Random Hart</strong>, 0 to 3! Which means U-Boot and NuttX will subsequently boot on the <strong>Same Random Hart</strong>.</p>
<p><em>What‚Äôs the problem?</em></p>
<p>NuttX assumes that it always <strong>Boots on Hart 0</strong>. (Pic above)</p>
<p>This code <strong>will fail</strong> when NuttX boots on Harts 1 to 3: <a href="https://github.com/lupyuen2/wip-nuttx/blob/starpro64c/arch/risc-v/src/common/riscv_macros.S#L383-L423"><strong>riscv_set_inital_sp</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Set inital sp for riscv core. This function should be only called when initing.
## TODO: Support Non-Zero Boot Hart.
.macro riscv_set_inital_sp base, size, hartid
  la      t0, \base
  li      t1, \size
  mul     t1, \hartid, t1
  add     t0, t0, t1

  ## Ensure the last XCPTCONTEXT_SIZE is reserved for non boot CPU
  bnez \hartid, 998f
  li   t1, STACK_ALIGN_DOWN(\size)
  j    999f
998:
  li   t1, STACK_ALIGN_DOWN(\size - XCPTCONTEXT_SIZE)
999:
  add  t0, t0, t1
  mv   sp, t0
.endm</code></pre></div>
<p><em>How to fix this?</em></p>
<p>Our workaround is to <strong>Always Reboot NuttX on Hart 0</strong>.</p>
<p>TODO</p>
<p><em>Harts vs CPUs: What‚Äôs the difference?</em></p>
<p>NuttX insists on booting with CPU 0. Otherwise it fails with this <a href="https://gist.github.com/lupyuen/7278c35c3d556a5d4574668b54272fef"><strong>nx_start Error</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>[CPU2] dump_assert_info:
Assertion failed up_cpu_index() == 0: 
at file: init/nx_start.c:745 task(CPU2):
CPU2 IDLE process: Kernel 0x802019a6</code></pre></div>
<p>That‚Äôs why we <strong>Renumber the CPUs</strong>: Boot Hart is always <strong>CPU 0</strong>. Other Harts become <strong>CPUs 1 to 3</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>TODO</code></pre></div>
<p><em>Can‚Äôt we start One Hart and ignore the Other Harts?</em></p>
<p>We tried <a href="https://github.com/lupyuen2/wip-nuttx/commits/starpro64c"><strong>Enabling One Hart Only (CPU 0)</strong></a>. But OSTest <a href="https://gist.github.com/lupyuen/901365650d8f908a7caa431de4e84ff6"><strong>hangs at sem_test</strong></a>..</p>
<div class="example-wrap"><pre class="language-bash"><code>## OSTest hangs for StarPro64 when we enable One Hart only...
user_main: semaphore test
sem_test: Initializing semaphore to 0
sem_test: Starting waiter thread 1
sem_test: Set thread 1 priority to 191
## Oops: Thread 1 is NOT started!

sem_test: Starting waiter thread 2
sem_test: Set thread 2 priority to 128
waiter_func: Thread 2 Started

## Oops: Semaphore Value should be -1!
waiter_func: Thread 2 initial semaphore value = 0
waiter_func: Thread 2 waiting on semaphore
## Hangs here</code></pre></div>
<p>Compare the above with <a href="https://github.com/lupyuen/nuttx-sg2000/releases/tag/nuttx-sg2000-2025-02-23"><strong>SG2000 sem_test</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>## OSTest runs OK for SG2000...
user_main: semaphore test
sem_test: Initializing semaphore to 0
sem_test: Starting waiter thread 1
sem_test: Set thread 1 priority to 191
## Yep Thread 1 is started
waiter_func: Thread 1 Started

sem_test: Starting waiter thread 2
waiter_func: Thread 1 initial semaphore value = 0
sem_test: Set thread 2 priority to 128
waiter_func: Thread 1 waiting on semaphore
waiter_func: Thread 2 Started

## Yep Semaphore Value is -1
waiter_func: Thread 2 initial semaphore value = -1
waiter_func: Thread 2 waiting on semaphore
sem_test: Starting poster thread 3
## Completes successfully</code></pre></div>
<p>Here‚Äôs the problem: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/master/testing/ostest/sem.c#L159-L253"><strong>sem_test</strong></a> calls <a href="https://github.com/lupyuen2/wip-nuttx/blob/starpro64b/sched/pthread/pthread_create.c#L179-L412"><strong>nx_pthread_create</strong></a> to create a PThread for Thread #1‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int nx_pthread_create(...) { ...
#ifdef CONFIG_SMP
  // pthread_setup_scheduler() will set the affinity mask by inheriting the
  // setting from the parent task.  We need to override this setting
  // with the value from the pthread attributes unless that value is
  // zero:  Zero is the default value and simply means to inherit the
  // parent thread&#39;s affinity mask.
  if (attr-&gt;affinity != 0) {
    ptcb-&gt;cmn.affinity = attr-&gt;affinity;
  }
#endif</code></pre></div>
<p>But the New Thread defaults to <strong>No CPU Affinity</strong>, it <strong>Lacks Affinity for CPU 0</strong>.</p>
<p>So it gets allocated to <strong>Another CPU</strong>. Which never runs!</p>
<p>Hence <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/master/testing/ostest/sem.c#L244-L253"><strong>sem_test loops forever</strong></a> waiting for the Semaphore Value to change.</p>
<p><a href="https://youtu.be/70DQ4YlQMMw">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/901365650d8f908a7caa431de4e84ff6">(See the <strong>NuttX Log</strong></a></p>
<p><em>How to enable Multple Harts?</em></p>
<p>TODO</p>
<h1 id="eswin-ai-sample-user-guide"><a class="doc-anchor" href="#eswin-ai-sample-user-guide">¬ß</a>13 ESWIN AI Sample User Guide</h1>
<p>https://github.com/eswincomputing/eic7x-images/releases/tag/Debian-v1.0.0-p550-20241230</p>
<p>https://github.com/eswincomputing/eic7x-images/releases/download/Debian-v1.0.0-p550-20241230/ESWIN_AI_Sample_User_Guide.pdf</p>
<div class="example-wrap"><pre class="language-text"><code>ESWIN provides users with the desktop version of the Debian image files. the default username and
password for the system are both &quot;eswin / eswin&quot;.
Download the Debian-v1.0.0-p550-20241230 version system image via the link
https://github.com/eswincomputing/eic7x-images/releases. The image file is as follows:
EIC7x_Release_Images_p550_20241230
‚îî‚îÄ‚îÄ hifive-premier-p550
 ‚îú‚îÄ‚îÄ bootloader_P550.bin
 ‚îú‚îÄ‚îÄ boot-P550-20250126-011559.ext4
‚îî‚îÄ‚îÄ root-P550-20250126-011559.ext4</code></pre></div><h1 id="uart"><a class="doc-anchor" href="#uart">¬ß</a>14 UART</h1><div class="example-wrap"><pre class="language-text"><code>## First Time Only
echo &quot;defscrollback 1000000&quot; &gt;&gt; ~/.screenrc

set -x
for (( ; ; )) do 
  screen /dev/ttyUSB* 115200
  sleep 5
done</code></pre></div>
<p>Same pins as Star64 and Oz64 SG2000</p>
<p>Garbage: Compute CONFIG_16550_UART0_CLOCK</p>
<p>CONFIG_16550_UART0_IRQ=125</p>
<p>100 + 25</p>
<h1 id="build-loop"><a class="doc-anchor" href="#build-loop">¬ß</a>15 Build Loop</h1>
<p>make</p>
<p>make app</p>
<p>power off</p>
<p>power on</p>
<p>read</p>
<p>power off</p>
<h1 id="multiple-cpu"><a class="doc-anchor" href="#multiple-cpu">¬ß</a>16 Multiple CPU</h1>
<p>boot_hartid=2
hart=0, cpu=1
hart=1, cpu=2
hart=2, cpu=0
hart=3, cpu=3</p>
<p>cpu=0, hart=2
cpu=1, hart=0
cpu=2, hart=1
cpu=3, hart=3</p>
<h1 id="disable-smp"><a class="doc-anchor" href="#disable-smp">¬ß</a>17 Disable SMP</h1>
<p>https://github.com/lupyuen2/wip-nuttx/commit/6b321e1cd56bf74b0529711bfad62780291f841b</p>
<p>Remove these from defconfig:</p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_SMP=y
CONFIG_SMP_NCPUS=4</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/2823528f7b53375f080256bc798b2bf5">Apache NuttX RTOS on StarPro64: OSTest runs OK yay! (ESWIN EIC7700X)</a></p>
<p><a href="https://youtu.be/Yr7aYNIMUsw"><strong>Watch the Demo on YouTube</strong></a></p>
<p>Apache NuttX RTOS on StarPro64: Build Script</p>
<p>https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac</p>
<p>We could actually allow a Remote Developer to boot and test NuttX on StarPro64 ‚Ä¶ From anywhere in the world!</p>
<p><img src="https://lupyuen.org/images/starpro64-ostest.png" alt="TODO" /></p>
<h1 id="todo"><a class="doc-anchor" href="#todo">¬ß</a>18 TODO</h1>
<p>https://github.com/rockos-riscv</p>
<p>ü§î Booting #StarPro64 @ThePine64 (#RISCV #ESWIN EIC7700X)</p>
<p>Source: https://pine64.org/2024/10/02/september_2024/#starpro64</p>
<p>#RISCV ESWIN EIC7700X Technical Reference Manual (#StarPro64)</p>
<p>https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual</p>
<p>#RISCV #ESWIN EIC7700X: Qwen #LLM on NPU (#StarPro64)</p>
<p>Source: https://github.com/eswincomputing/eic7x-images/releases/download/Debian-v1.0.0-p550-20241230/ESWIN_AI_Sample_User_Guide.pdf</p>
<p>#RISCV #ESWIN EIC7700X: NPU Driver (#StarPro64)</p>
<p>https://github.com/eswincomputing/linux-stable/tree/linux-6.6.18-EIC7X/drivers/soc/eswin/ai_driver/npu</p>
<p><strong>llama.cpp</strong> <em>(C++)</em></p>
<p>https://github.com/ggml-org/llama.cpp</p>
<p>or <strong>ollama</strong> <em>(GoLang)</em></p>
<p>https://github.com/ollama/ollama/blob/main/model/models/llama/model.go</p>
<p><em>Qwen is an odd name innit?</em></p>
<p>Qwen will sound confusing to Bilingual Folks‚Ä¶</p>
<ul>
<li>
<p>It‚Äôs NOT supposed to rhyme with Gwen Stefani / Gwen Stacy</p>
</li>
<li>
<p>Instead it‚Äôs pronounced <strong>‚ÄúQ Wen‚Äù</strong></p>
</li>
<li>
<p>And it confuses me: <em>‚ÄúQ = Question‚Äù</em> and <em>‚ÄúWen = ÈóÆ = Question‚Äù</em>, thus contracting to <em>‚ÄúQQ‚Äù</em>, which means <em>‚ÄúBouncy‚Äù</em></p>
</li>
<li>
<p>Thankfully <em>‚ÄúQ Wen‚Äù</em> actually means something: <strong>‚ÄúÂçÉÈóÆ‚Äù</strong> <em>(Ask a Thousand Questions, ‚ÄúQian1 Wen4‚Äù)</em></p>
</li>
<li>
<p>Which is short for <strong>‚ÄúÈÄö‰πâÂçÉÈóÆ‚Äù</strong> <em>(Tong1 Yi4 Qian1 Wen4)</em>, meaning <a href="https://baike.baidu.com/item/%E9%80%9A%E4%B9%89/64394178"><strong>‚ÄúÈÄöÊÉÖÔºåËææ‰πâ‚Äù</strong></a></p>
</li>
</ul>
<span style="font-size:80%">
<p><em>(Here‚Äôs an idea for Sci-Fi Horror: We installed an LLM Sensor in a Remote Uninhabited Island. One day our LLM Sensor sends us sinister words: ‚ÄúEVIL‚Äù, ‚ÄúDEATH‚Äù, ‚ÄúDOOM‚Äù‚Ä¶)</em></p>
</span>
<p>southern islands of singapore
identify pic of creatures or sea life
rainforest critters or underwater creatures
in one word
‚ÄúDUCK‚Äù, ‚ÄúOCTOPUS‚Äù</p>
<p>strings
ghidra
npu driver
ollama</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>19 What‚Äôs Next</h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/starpro64.md"><strong>lupyuen.org/src/starpro64.md</strong></a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>