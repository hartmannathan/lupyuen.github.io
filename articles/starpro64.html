<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/starpro64-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/starpro64.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?</h1>
    <nav id="rustdoc"><ul>
<li><a href="#eswin-eic7700x-risc-v-soc" title="ESWIN EIC7700X RISC-V SoC">1 ESWIN EIC7700X RISC-V SoC</a><ul></ul></li>
<li><a href="#boot-without-microsd" title="Boot Without MicroSD">2 Boot Without MicroSD</a><ul></ul></li>
<li><a href="#download-the-linux-image" title="Download the Linux Image">3 Download the Linux Image</a><ul></ul></li>
<li><a href="#prepare-the-linux-image" title="Prepare the Linux Image">4 Prepare the Linux Image</a><ul></ul></li>
<li><a href="#starpro64-gets-smokin-hot" title="StarPro64 Gets Smokin‚Äô Hot!">5 StarPro64 Gets Smokin‚Äô Hot!</a><ul></ul></li>
<li><a href="#boot-the-linux-image" title="Boot the Linux Image">6 Boot the Linux Image</a><ul></ul></li>
<li><a href="#settings-for-u-boot-bootloader" title="Settings for U-Boot Bootloader">7 Settings for U-Boot Bootloader</a><ul></ul></li>
<li><a href="#boot-nuttx-over-tftp" title="Boot NuttX over TFTP">8 Boot NuttX over TFTP</a><ul></ul></li>
<li><a href="#smart-power-plug" title="Smart Power Plug">9 Smart Power Plug</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-starpro64" title="Appendix: Build NuttX for StarPro64">10 Appendix: Build NuttX for StarPro64</a><ul></ul></li>
<li><a href="#appendix-port-nuttx-to-starpro64" title="Appendix: Port NuttX to StarPro64">11 Appendix: Port NuttX to StarPro64</a><ul></ul></li>
<li><a href="#appendix-multiple-harts-on-starpro64" title="Appendix: Multiple Harts on StarPro64">12 Appendix: Multiple Harts on StarPro64</a><ul></ul></li>
<li><a href="#eswin-ai-sample-user-guide" title="ESWIN AI Sample User Guide">13 ESWIN AI Sample User Guide</a><ul></ul></li>
<li><a href="#uart" title="UART">14 UART</a><ul></ul></li>
<li><a href="#multiple-cpu" title="Multiple CPU">15 Multiple CPU</a><ul></ul></li>
<li><a href="#plic-multiple-harts" title="PLIC Multiple Harts">16 PLIC Multiple Harts</a><ul></ul></li>
<li><a href="#build-loop" title="Build Loop">17 Build Loop</a><ul></ul></li>
<li><a href="#semaphore-fail" title="Semaphore Fail">18 Semaphore Fail</a><ul></ul></li>
<li><a href="#thread-1-isnt-started" title="Thread 1 isn‚Äôt started!">19 Thread 1 isn‚Äôt started!</a><ul></ul></li>
<li><a href="#multiple-cpu-1" title="Multiple CPU">20 Multiple CPU</a><ul></ul></li>
<li><a href="#disable-smp" title="Disable SMP">21 Disable SMP</a><ul></ul></li>
<li><a href="#todo" title="TODO">22 TODO</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">23 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>16 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/starpro64-title.jpg" alt="StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?" /></p>
<p>TODO</p>
<p>StarPro64 EIC7700X is the (literally) Hot New RISC-V SBC by PINE64.</p>
<p>Star64 power</p>
<p>IKEA Smart Power Plug</p>
<p>iTerm: Edit &gt; Paste Special &gt; Paste Slowly</p>
<p>Settings &gt; Advanced &gt; Pasteboard</p>
<p>Delay in seconds between chunks when Pasting Slowly: 1 second</p>
<p>Number of bytes to paste in each chunk when Pasting Slowly: 16</p>
<p>Well documented</p>
<p>NuttX: Power efficient AI</p>
<p><em>StarPro64 is just an upgraded Star64?</em></p>
<p>Nope it‚Äôs a totally different beast!</p>
<p>Docs are so much better! (??? pages)</p>
<p><em>(Thanks to PINE64 for providing the Prototype StarPro64)</em></p>
<h1 id="eswin-eic7700x-risc-v-soc"><a class="doc-anchor" href="#eswin-eic7700x-risc-v-soc">¬ß</a>1 ESWIN EIC7700X RISC-V SoC</h1>
<p>TODO: NPU</p>
<p><img src="https://lupyuen.org/images/starpro64-fan2.jpg" alt="TODO" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.org/images/starpro64-uart.jpg" alt="TODO" /></p>
<h1 id="boot-without-microsd"><a class="doc-anchor" href="#boot-without-microsd">¬ß</a>2 Boot Without MicroSD</h1>
<p><em>What happens if we boot StarPro64? Fresh from the box?</em></p>
<p>We monitor the <strong>UART0 Port</strong> for Debug Messages. Connect our <strong>USB UART Dongle</strong> (CH340 or CP2102) to these pins (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">StarPro64</th><th style="text-align: center">USB UART</th><th style="text-align: center">Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>GND</strong> (Pin 6)</td><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center"><em>Yellow</em></td></tr>
<tr><td style="text-align: center"><strong>TX</strong> (Pin 8)</td><td style="text-align: center"><strong>RX</strong></td><td style="text-align: center"><em>Blue</em></td></tr>
<tr><td style="text-align: center"><strong>RX</strong> (Pin 10)</td><td style="text-align: center"><strong>TX</strong></td><td style="text-align: center"><em>Green</em></td></tr>
</tbody></table>
</div>
<p>(Same Pins as the <strong>GPIO Header</strong> on Oz64 SG2000 and Star64 JH7110)</p>
<p>Connect to the USB UART at <strong>115.2 kbps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 115200</code></pre></div>
<p>Power up the board with a <strong>Power Adapter</strong>. <a href="TODO">(Same one as <strong>Star64 JH7110</strong>)</a></p>
<p>We‚Äôll see <a href="TODO"><strong>OpenSBI</strong></a>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>OpenSBI v1.5
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|
Platform Name             : ESWIN EIC7700 EVB
Platform Features         : medeleg
Platform HART Count       : 4
Platform Console Device   : uart8250
Firmware Base             : 0x80000000

Domain0 Boot HART         : 2
Domain0 HARTs             : 0*,1*,2*,3*
Domain0 Next Address      : 0x0000000080200000

Boot HART ID              : 2
Boot HART Base ISA        : rv64imafdchx
Boot HART ISA Extensions  : sscofpmf,zihpm,sdtrig
Boot HART MIDELEG         : 0x0000000000002666
Boot HART MEDELEG         : 0x0000000000f0b509</code></pre></div></span>
<p>Then <a href="TODO"><strong>U-Boot Bootloader</strong></a>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2024.01-gaa36f0b4 (Jan 23 2025 - 02:49:59 +0000)
CPU:     rv64imafdc_zba_zbb
Model:   ESWIN EIC7700 EVB
DRAM:    32 GiB (effective 16 GiB)
llCore:  143 devices, 31 uclasses, devicetree: separate
Warning: Device tree includes old &#39;u-boot,dm-&#39; tags: please fix by 2023.07!
MMC:    sdhci@50450000: 0, sd@50460000: 1

Loading Environment from SPIFlash...
SF: Detected w25q128fw with page size 256 Bytes, erase size 4 KiB, total 16 MiB
*** Warning - bad CRC, using default environment
No SATA device found!
Hit any key to stop autoboot:  0
=&gt;</code></pre></div></span>
<p>And it stops at U-Boot, waiting to boot from MicroSD or eMMC. Let‚Äôs init our eMMC‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/9db7b36f3cdf26f7b7f75c0d35177ee7">(See the <strong>Boot Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-hdmi.jpg" alt="TODO" /></p>
<p><em>HDMI Output will show U-Boot, but not OpenSBI</em></p>
<h1 id="download-the-linux-image"><a class="doc-anchor" href="#download-the-linux-image">¬ß</a>3 Download the Linux Image</h1>
<p><em>Is there a Linux Image for StarPro64?</em></p>
<p>The fine folks at <a href="https://github.com/rockos-riscv"><strong>PLCT Lab RockOS</strong></a> are busy preparing the <strong>Linux Image</strong> for StarPro64. Thanks to <a href="https://nightcord.de/@icenowy/114027871300585376"><strong>@icenowy</strong></a>, we have a <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/"><strong>Preview Version</strong></a> of the Linux Image‚Ä¶</p>
<ol>
<li>
<p><strong>Bootloader (OpenSBI + U-Boot)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/bootloader_secboot_ddr5_pine64-starpro64.bin"><em>bootloader_secboot_ddr5_pine64-starpro64.bin</em></a></p>
</li>
<li>
<p><strong>Linux Boot Image (Linux Kernel)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/boot-rockos-20250123-210346.ext4.zst"><em>boot-rockos-20250123-210346.ext4.zst</em></a></p>
</li>
<li>
<p><strong>Linux Root Image (Linux Filesystem)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/root-rockos-20250123-210346.ext4.zst"><em>root-rockos-20250123-210346.ext4.zst</em></a></p>
</li>
</ol>
<p>Uncompress the files and rename them. Copy them to a <a href="TODO"><strong>USB Drive</strong></a> (not MicroSD)</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -lh *.bin *.zst
4.2M  bootloader_secboot_ddr5_pine64-starpro64.bin
154M  boot-rockos-20250123-210346.ext4.zst
2.3G  root-rockos-20250123-210346.ext4.zst

$ unzstd boot-rockos-20250123-210346.ext4.zst
boot-rockos-20250123-210346.ext4.zst: 524288000 bytes

$ unzstd root-rockos-20250123-210346.ext4.zst
root-rockos-20250123-210346.ext4.zst: 7516192768 bytes

$ mv boot-rockos-20250123-210346.ext4 boot.ext4
$ mv root-rockos-20250123-210346.ext4 root.ext4

$ ls -lh *.bin *.ext4
4.2M  bootloader_secboot_ddr5_pine64-starpro64.bin
500M  boot.ext4
7.0G  root.ext4

$ cp *.bin *.ext4 /media/$USER/YOUR_USB_DRIVE</code></pre></div>
<p>We‚Äôll skip the <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/sdcard-rockos-20250123-210346.img.zst"><strong>MicroSD Image</strong></a>, because <a href="TODO"><strong>MicroSD Interface</strong></a> wasn‚Äôt working reliably on our Prototype StarPro64.</p>
<p><img src="https://lupyuen.org/images/starpro64-emmc.jpg" alt="TODO" /></p>
<h1 id="prepare-the-linux-image"><a class="doc-anchor" href="#prepare-the-linux-image">¬ß</a>4 Prepare the Linux Image</h1>
<p><em>How to load the Linux Image into eMMC?</em></p>
<p>Based on the <a href="TODO"><strong>Official Doc</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Connect our <strong>eMMC to StarPro64</strong> (pic above)</p>
</li>
<li>
<p>Connect our <strong>USB Drive</strong> from previous section</p>
</li>
<li>
<p><strong>At U-Boot:</strong> Press <strong>Ctrl-C</strong> to stop Autoboot</p>
</li>
<li>
<p>Verify that the <strong>eMMC is OK</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls mmc 0
[ Nothing ]

$ mmc part
[ Nothing ]</code></pre></div></li>
<li>
<p>First Time Only: <strong>GPT Partition</strong> our eMMC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ echo $partitions
partitions=
  name=boot,start=1MiB,size=2048MiB,type=${typeid_filesystem},uuid=${uuid_boot};
  name=swap,size=4096MiB,type=${typeid_swap},uuid=${uuid_swap};
  name=root,size=-,type=${typeid_filesystem},uuid=${uuid_root}

$ run gpt_partition
$ mmc part
1 0x00000800 0x001007ff &quot;boot&quot;
2 0x00100800 0x009007ff &quot;swap&quot;
3 0x00900800 0x0e677fde &quot;root&quot;</code></pre></div></li>
<li>
<p>Verify that our <strong>USB Drive</strong> works‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls usb 0
 524288000 boot.ext4
7516192768 root.ext4
   4380760 bootloader_secboot_ddr5_pine64-starpro64.bin   </code></pre></div></li>
<li>
<p>Install the <strong>Bootloader, Boot Image and Root Image</strong>, from USB Drive to eMMC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ es_fs update usb 0 boot.ext4 mmc 0:1
mmc has been successfully writen in mmc 0:1

$ es_fs update usb 0 root.ext4 mmc 0:3
mmc has been successfully writen in mmc 0:3

$ ext4load usb 0 0x100000000 bootloader_secboot_ddr5_pine64-starpro64.bin
4380760 bytes read in 162 ms (25.8 MiB/s)

$ es_burn write 0x100000000 flash
bootloader write OK</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/a07e8dcd56d3fb306dce8983f4924702">(See the <strong>eMMC Log</strong>)</a></p>
</li>
<li>
<p><strong>Beware of Overheating!</strong> Keep StarPro64 cool, or the previous step might corrupt the <strong>SPI Boot Flash</strong> and cause unspeakable agony‚Ä¶</p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/starpro64-fan.jpg" alt="TODO" /></p>
<h1 id="starpro64-gets-smokin-hot"><a class="doc-anchor" href="#starpro64-gets-smokin-hot">¬ß</a>5 StarPro64 Gets Smokin‚Äô Hot!</h1>
<p><em>Something is smelling like barbecue?</em></p>
<p>Whoa StarPro64 is on fire: Drop it, stop it and <strong>power off</strong>! StarPro64 will show <a href="https://gist.github.com/lupyuen/47170b4c4d7117ac495c5faede48280b#file-gistfile1-txt-L796-L894"><strong>PLL Errors</strong></a> when it overheats‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>pll failed.
pll failed.
pll failed.</code></pre></div>
<p>Also watch for <a href="https://gist.github.com/lupyuen/89e1e87e7f213b6f52f31987f254b32f#file-gistfile1-txt-L1940-L1947"><strong>Thermal Errors</strong></a> when booting Linux‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>thermal thermal_zone0: thermal0:
critical temperature reached, shutting down
reboot: HARDWARE PROTECTION shutdown (Temperature too high)</code></pre></div>
<p>Install a <a href="https://www.lazada.sg/products/i2932991583-s20178422377.html"><strong>USB Fan</strong></a>, preferably something stronger. <em>(Pic above, boxed up with IKEA 365+)</em></p>
<p>But don‚Äôt power it with the USB Port on StarPro64! Instead, connect it to our <a href="TODO"><strong>Smart Power Plug</strong></a>.</p>
<p><em>Anything else we should worry about?</em></p>
<p>The <a href="TODO"><strong>MicroSD Interface</strong></a> wasn‚Äôt working well on our Prototype StarPro64. The MicroSD Card deactivated itself after a bit of U-Boot Access.</p>
<p>Hence the <strong>Headless Ironman</strong>: USB Drive on StarPro64‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-ironman.jpg" alt="TODO" /></p>
<h1 id="boot-the-linux-image"><a class="doc-anchor" href="#boot-the-linux-image">¬ß</a>6 Boot the Linux Image</h1>
<p><em>Earlier we flashed Linux to eMMC. Can we boot Linux now?</em></p>
<p>Yep just power up StarPro64. eMMC will <strong>Boot Linux</strong>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>U-Boot menu
1:      RockOS GNU/Linux 6.6.73-win2030
2:      RockOS GNU/Linux 6.6.73-win2030 (rescue target)
Enter choice: 1:        RockOS GNU/Linux 6.6.73-win2030
Retrieving file: /vmlinuz-6.6.73-win2030
Retrieving file: /initrd.img-6.6.73-win2030
append: root=PARTUUID=b0f77ad6-36cd-4a99-a8c0-31d73649aa08 console=ttyS0,115200 root=PARTUUID=b0f77ad6-36cd-4a99-a8c0-31d73649aa08 rootfstype=ext4 rootwait rw earlycon selinux=0 LANG=en_US.UTF-8

Retrieving file: /dtbs/linux-image-6.6.73-win2030/eswin/eic7700-pine64-starpro64.dtb
   Uncompressing Kernel Image
Moving Image from 0x84000000 to 0x80200000, end=81e63000
## Flattened Device Tree blob at 88000000
   Booting using the fdt blob at 0x88000000
Working FDT set to 88000000
ERROR: reserving fdt memory region failed (addr=fffff000 size=1000 flags=4)
   Using Device Tree in place at 0000000088000000, end 0000000088027af4
Working FDT set to 88000000

Starting kernel ...
Linux version 6.6.73-win2030 (riscv@riscv-builder) (riscv64-unknown-linux-gnu-gcc () 13.2.0, GNU ld (GNU Binutils) 2.42) #2025.01.23.02.46+aeb0f375c SMP Thu Jan 23 03:08:39 UTC 2025
Machine model: Pine64 StarPro64
...
mmc0: Timeout waiting for hardware interrupt.
mmc0: sdhci: ============ SDHCI REGISTER DUMP ===========
mmc0: sdhci: Sys addr:  0x00000008 | Version:  0x00000005
mmc0: sdhci: Blk size:  0x00007200 | Blk cnt:  0x00000000</code></pre></div></span>
<p>Sadly the <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/"><strong>Preview Version</strong></a> of RockOS won‚Äôt boot correctly on our Prototype StarPro64. Hopefully we‚Äôll sort this out real soon! (Pic below)</p>
<p><a href="https://gist.github.com/lupyuen/89e1e87e7f213b6f52f31987f254b32f">(See the <strong>Boot Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-linux.jpg" alt="TODO" /></p>
<h1 id="settings-for-u-boot-bootloader"><a class="doc-anchor" href="#settings-for-u-boot-bootloader">¬ß</a>7 Settings for U-Boot Bootloader</h1>
<p><em>Bummer. What else can we boot on StarPro64?</em></p>
<p>Let‚Äôs snoop around <a href="TODO"><strong>U-Boot Bootloader</strong></a>. And figure out how to boot <a href="TODO"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>Power up StarPro64 and press <strong>Ctrl-C</strong>. At the <strong>U-Boot Prompt</strong>: We enter these commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ help
printenv  - print environment variables
saveenv   - save environment variables to persistent storage
net       - NET sub-system
dhcp      - boot image via network using DHCP/TFTP protocol
tftpboot  - load file via network using TFTP protocol
fdt       - flattened device tree utility commands
booti     - boot Linux kernel &#39;Image&#39; format from memory

$ printenv
fdt_addr_r=0x88000000
kernel_addr_r=0x84000000
loadaddr=0x80200000</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9db7b36f3cdf26f7b7f75c0d35177ee7">(See the <strong>U-Boot Log</strong>)</a></p>
<p>A-ha! This says‚Ä¶</p>
<ul>
<li>
<p>U-Boot supports booting over TFTP: <a href="TODO"><strong>Trivial File Transfer Protocol</strong></a></p>
</li>
<li>
<p>It will load the <strong>Kernel Image</strong> <em>(Linux / NuttX)</em> into RAM at <strong><code>0x8400</code> <code>0000</code></strong></p>
</li>
<li>
<p>Then it will move the Kernel Image to <strong><code>0x8020</code> <code>0000</code></strong> and boot there</p>
</li>
<li>
<p>Also it loads the <strong>Device Tree</strong> into <strong><code>0x8800</code> <code>0000</code></strong></p>
</li>
</ul>
<p>Thanks U-Boot! You told us everything we need to Boot NuttX‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.org/images/starpro64-nuttx.png" alt="TODO" /></p>
</blockquote>
<h1 id="boot-nuttx-over-tftp"><a class="doc-anchor" href="#boot-nuttx-over-tftp">¬ß</a>8 Boot NuttX over TFTP</h1>
<p><em>How to boot NuttX over TFTP?</em></p>
<ol>
<li>
<p>Install our <strong>TFTP Server</strong>: Follow the <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>instructions here</strong></a></p>
</li>
<li>
<p>Copy these files to our TFTP Server‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/TODO"><strong>NuttX Image: Image-starpro64</strong></a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/TODO"><strong>Device Tree: jh7110-star64-pine64.dtb</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p><a href="TODO">(How to <strong>Build NuttX</strong> ourselves)</a></p>
</li>
<li>
<p>Power up StarPro64 and press <strong>Ctrl-C</strong></p>
</li>
<li>
<p>At the <strong>U-Boot Prompt</strong>: Enter these commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Check if the Network Adapter is alive
## &quot;eth0 : ethernet@50400000 f6:70:f9:6e:73:ae active&quot;
net list

## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## Save the U-Boot Config for future reboots
saveenv

## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=TODO
dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64

## Load the Device Tree from TFTP Server
## fdt_addr_r=TODO
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=TODO
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
fdt addr ${fdt_addr_r}

## Boot the NuttX Image with the Device Tree
## kernel_addr_r=TODO
## fdt_addr_r=TODO
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}</code></pre></div>
<p><a href="TODO"><em>(U-Boot dropping chars? Try <strong>iTerm &gt; Edit &gt; Paste Special &gt; Paste Slowly</strong>)</em></a></p>
</li>
<li>
<p>NuttX boots OK on StarPro64 yay! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>TODO</code></pre></div></li>
<li>
<p>How did we port NuttX to StarPro64? Check the details here‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúTODO‚Äù</strong></a></p>
</li>
</ol>
<p><em>We type these commands EVERY TIME we boot?</em></p>
<p>We can automate: Just do this once, and NuttX will <strong>Auto-Boot</strong> whenever we power up‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Add the Boot Command for TFTP
setenv bootcmd_tftp &#39;dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}&#39;

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Command: `bootflow scan -lb`
setenv orig_bootcmd &quot;$bootcmd&quot;

## Prepend TFTP to the Boot Command: `run bootcmd_tftp ; bootflow scan -lb`
setenv bootcmd &quot;run bootcmd_tftp ; $bootcmd&quot;

## Save it for future reboots
saveenv</code></pre></div>
<p><a href="TODO"><em>(U-Boot dropping chars? Try <strong>iTerm &gt; Edit &gt; Paste Special &gt; Paste Slowly</strong>)</em></a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-sg2000/issues/1">(What about <strong>Static IP</strong>?)</a></p>
<p>TODO: <a href="https://github.com/lupyuen/nuttx-sg2000/issues/1#issuecomment-2114415245">(How to <strong>Undo Auto-Boot</strong>)</a></p>
<p>TODO: Press Ctrl-C to stop</p>
<p>TODO: Pic of Smart Plug, Fan, Ubuntu PC, StarPro64, USB Serial, TFTP Server</p>
<h1 id="smart-power-plug"><a class="doc-anchor" href="#smart-power-plug">¬ß</a>9 Smart Power Plug</h1>
<p><em>Powering StarPro64 on and off: Gets so tiresome ain‚Äôt it?</em></p>
<p>Try a <strong>Smart Power Plug</strong>, integrated with our Build Script‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-power1.jpg" alt="TODO" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.org/images/starpro64-power2.jpg" alt="TODO" /></p>
<p>https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac#file-run-sh-L118-L163</p>
<div class="example-wrap"><pre class="language-bash"><code>## Get the Home Assistant Token, copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC&quot;
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait for SBC Testing to complete
echo Press Enter to Power Off
read

## Power Off the SBC&quot;
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p>Remember the <a href="TODO"><strong>USB Fan</strong></a>? It goes into our Smart Power Plug as a Power Jenga like so‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.org/images/starpro64-power3.jpg" alt="TODO" /></p>
</blockquote>
<h1 id="appendix-build-nuttx-for-starpro64"><a class="doc-anchor" href="#appendix-build-nuttx-for-starpro64">¬ß</a>10 Appendix: Build NuttX for StarPro64</h1>
<p><em>Earlier we booted Image-starpro64 over TFTP. How to get the file?</em></p>
<p>We may download the NuttX Image File <strong><code>Image-starpro64</code></strong> from here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-sg2000/tags"><strong>Daily Build: NuttX for SG2000</strong></a></li>
</ul>
<p>If we prefer to build NuttX ourselves‚Ä¶</p>
<ol>
<li>
<p>Install the Build Prerequisites, skip the RISC-V Toolchain‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the RISC-V Toolchain for <strong>riscv-none-elf</strong> (xPack)‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-xpack-gnu-risc-v-embedded-gcc-toolchain-for-64-bit-risc-v"><strong>‚ÄúxPack GNU RISC-V Embedded GCC Toolchain for 64-bit RISC-V‚Äù</strong></a></p>
</li>
<li>
<p>Download and Build <strong>NuttX for StarPro64</strong> (work-in-progress)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch starpro64
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch starpro64
cd nuttx
tools/configure.sh milkv_duos:nsh

## Build the NuttX Kernel and Apps
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Copy NuttX Image to TFTP Server
scp Image tftpserver:/tftpboot/Image-starpro64
ssh tftpserver ls -l /tftpboot/Image-starpro64

## In U-Boot: Boot NuttX over TFTP
## setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}</code></pre></div>
<p><a href="TODO">(See the <strong>Build Script</strong>)</a></p>
<p><a href="TODO">(See the <strong>Build Log</strong>)</a></p>
<p><a href="TODO">(See the <strong>Build Outputs</strong>)</a></p>
</li>
<li>
<p>The steps above assume that we‚Äôve installed our TFTP Server, according to the <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>instructions here</strong></a></p>
</li>
<li>
<p>Then follow these steps to boot NuttX on StarPro64‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúBoot NuttX over TFTP‚Äù</strong></a></p>
</li>
<li>
<p>Powering StarPro64 on and off can get tiresome. Try a Smart Power Plug, integrated with our Build Script‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúTODO‚Äù</strong></a></p>
</li>
<li>
<p>How did we port NuttX to StarPro64? Check the details here‚Ä¶</p>
<p><a href="TODO"><strong>‚ÄúTODO‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/mmu-l3user.jpg" alt="Virtual Memory for NuttX Apps" /></p>
<p><em>Why the RAM Disk? Isn‚Äôt NuttX an RTOS?</em></p>
<p>StarPro64 uses a RAM Disk because it runs in <strong>NuttX Kernel Mode</strong> (instead of the typical Flat Mode). This means we can do <strong>Memory Protection</strong> and <strong>Virtual Memory</strong> for Apps. (Pic above)</p>
<p>But it also means we need to bundle the <strong>NuttX Apps as ELF Files</strong>, hence the RAM Disk‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/app"><strong>‚ÄúNuttX Apps and Initial RAM Disk‚Äù</strong></a></li>
</ul>
<p>Most of the NuttX Platforms run on <strong>NuttX Flat Mode</strong>, which has NuttX Apps Statically-Linked into the NuttX Kernel.</p>
<p>NuttX Flat Mode works well for Small Microcontrollers. But StarPro64 and other SoCs will need the more sophisticated <strong>NuttX Kernel Mode</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode"><strong>‚ÄúNuttX Flat Mode vs Kernel Mode‚Äù</strong></a></li>
</ul>
<h1 id="appendix-port-nuttx-to-starpro64"><a class="doc-anchor" href="#appendix-port-nuttx-to-starpro64">¬ß</a>11 Appendix: Port NuttX to StarPro64</h1>
<p><em>How did we port NuttX to StarPro64? In under One Week?</em></p>
<p>We took the NuttX Port of <strong>Milk-V Duo S (Oz64 SG2000)</strong> and tweaked it for <strong>StarPro64 EIC7700X</strong>, with these minor modifications‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files"><strong>Modified Files: NuttX for StarPro64</strong></a></li>
</ul>
<p>Here‚Äôs what we changed‚Ä¶</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-9c348f27c59e1ed0d1d9c24e172d233747ee09835ab0aa7f156da1b7caa6a5fb">arch/risc-v/Kconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>config ARCH_CHIP_SG2000
	select ARCH_RV_CPUID_MAP</code></pre></div>
<p>TODO
disable thead mmu flags
app addr env
nuttx/arch/risc-v/Kconfig
remove ARCH_MMU_EXT_THEAD</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-523f77920746a4b6cb3e02ef9dfb71223593ae328aa8019e8d8fd730b828ab9f">arch/risc-v/include/sg2000/irq.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define NR_IRQS (RISCV_IRQ_SEXT + 458)</code></pre></div>
<p>EIC7700X supports <strong>458 External Interrupts</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 374</th></tr></thead><tbody>
<tr><td style="text-align: left">Max Interrupts</td><td style="text-align: left">458</td></tr>
</tbody></table>
</div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-14db47e674d6ddcbffc6f855a536a173b5833e3bd96a3490a45f1ef94e3b2767">arch/risc-v/src/sg2000/hardware/sg2000_memorymap.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define SG2000_PLIC_BASE 0x0C000000ul</code></pre></div>
<p><strong>PLIC Base Address</strong> is specified here‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 239</th></tr></thead><tbody>
<tr><td style="text-align: left">PLIC Memory Map</td><td style="text-align: left">0x0C00_0000</td></tr>
</tbody></table>
</div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-64c2a42d4a59409becf86f2967d2a27ff48635231437f56620d3e86a28002a28">arch/risc-v/src/sg2000/hardware/sg2000_plic.h</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Interrupt Priority */

#define SG2000_PLIC_PRIORITY (SG2000_PLIC_BASE + 0x000000)

/* Hart 0 S-Mode Interrupt Enable */

#define SG2000_PLIC_ENABLE0     (SG2000_PLIC_BASE + 0x002080)
#define SG2000_PLIC_ENABLE_HART (0x100)

/* Hart 0 S-Mode Priority Threshold */

#define SG2000_PLIC_THRESHOLD0     (SG2000_PLIC_BASE + 0x201000)
#define SG2000_PLIC_THRESHOLD_HART (0x2000)

/* Hart 0 S-Mode Claim / Complete */

#define SG2000_PLIC_CLAIM0     (SG2000_PLIC_BASE + 0x201004)
#define SG2000_PLIC_CLAIM_HART (0x2000)</code></pre></div>
<p><strong>Interrupt Enable: PLIC_ENABLE_HART</strong> is 0x100 because we skip 0x100 bytes per Hart‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 240</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(Skip the M-Modes)</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">0x0C00_2080</td><td style="text-align: left">Start Hart 0 S-Mode interrupt enables</td></tr>
<tr><td style="text-align: left">0x0C00_2180</td><td style="text-align: left">Start Hart 1 S-Mode interrupt enables</td></tr>
<tr><td style="text-align: left">0x0C00_2280</td><td style="text-align: left">Start Hart 2 S-Mode interrupt enables</td></tr>
</tbody></table>
</div>
<p><strong>Priority Threshold: PLIC_THRESHOLD_HART</strong> is 0x2000 because we skip 0x2000 bytes per Hart</p>
<p><strong>Claim / Complete: PLIC_CLAIM_HART</strong> is 0x2000 because we skip 0x2000 per Hart</p>
<p>Which comes from this‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 241</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(Skip the M-Modes)</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">0x0C20_1000</td><td style="text-align: left">Hart 0 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left">0x0C20_1004</td><td style="text-align: left">Hart 0 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: left">0x0C20_3000</td><td style="text-align: left">Hart 1 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left">0x0C20_3004</td><td style="text-align: left">Hart 1 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: left">0x0C20_5000</td><td style="text-align: left">Hart 2 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left">0x0C20_5004</td><td style="text-align: left">Hart 2 S-Mode Claim / Complete</td></tr>
</tbody></table>
</div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-d8bd71e8ea93fc23ec348eeaca3d45f89dc896eff80311583d758d42e6e8fc58">arch/risc-v/src/sg2000/sg2000_head.S</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>  .quad   0x4000000            /* Kernel size (fdt_addr_r-kernel_addr_r) */</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x50900000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* If a0 (hartid) &gt;= t1 (the number of CPUs), stop here */

  /* TODO: Enable this for SMP
  blt  a0, t1, 3f
  csrw CSR_SIE, zero
  wfi
  */

3:
  /* Set stack pointer to the idle thread stack */
  li a2, 0
  riscv_set_inital_sp SG2000_IDLESTACK_BASE, SMP_STACK_SIZE, a2

  /* TODO: Enable this for SMP
  riscv_set_inital_sp SG2000_IDLESTACK_BASE, SMP_STACK_SIZE, a0
  */</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-0c39d310c3819d6b7bfecb05f6a203019d0f937b171abe539f299fa37805b366">arch/risc-v/src/sg2000/sg2000_irq.c</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>  /* Disable all global interrupts */

  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++)
    {
      addr = SG2000_PLIC_ENABLE0 + (hart * SG2000_PLIC_ENABLE_HART);
      for (offset = 0; offset &lt; (NR_IRQS - RISCV_IRQ_EXT) &gt;&gt; 3; offset += 4)
        {
          putreg32(0x0, addr + offset);          
        }
    }

  /* Clear pendings in PLIC */

  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++)
    {
      addr = SG2000_PLIC_CLAIM0 + (hart * SG2000_PLIC_CLAIM_HART);
      claim = getreg32(addr);
      putreg32(claim, addr);
    }

  /* Set irq threshold to 0 (permits all global interrupts) */

  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++)
    {
      addr = SG2000_PLIC_THRESHOLD0 +
             (hart * SG2000_PLIC_THRESHOLD_HART);
      putreg32(0, addr);
    }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>void up_disable_irq(int irq) {
      ...
      /* Clear enable bit for the irq */

      if (0 &lt;= extirq &amp;&amp; extirq &lt;= NR_IRQS - RISCV_IRQ_EXT)
        {
          addr = SG2000_PLIC_ENABLE0 + 
                 (boot_hartid * SG2000_PLIC_ENABLE_HART);
          modifyreg32(addr + (4 * (extirq / 32)),
                      1 &lt;&lt; (extirq % 32), 0);
        }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>void up_enable_irq(int irq) {
      ...
      /* Set enable bit for the irq */

      if (0 &lt;= extirq &amp;&amp; extirq &lt;= NR_IRQS - RISCV_IRQ_EXT)
        {
          addr = SG2000_PLIC_ENABLE0 + 
                 (boot_hartid * SG2000_PLIC_ENABLE_HART);
          modifyreg32(addr + (4 * (extirq / 32)),
                      0, 1 &lt;&lt; (extirq % 32));
        }</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-75ceaf9a0a70840fc2e15cea303fff5e9d2339d4f524574df94b5d0ec46e37ea">arch/risc-v/src/sg2000/sg2000_irq_dispatch.c</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs)
{
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);
  uintptr_t claim = SG2000_PLIC_CLAIM0 + 
                    (boot_hartid * SG2000_PLIC_CLAIM_HART);
      ...
      uintptr_t val = getreg32(claim);
      ...
      /* Then write PLIC_CLAIM to clear pending in PLIC */

      putreg32(irq - RISCV_IRQ_EXT, claim);</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-cacefdc3058a54e86027d411b0a6711d8a322b1750150521d5c640e72daa8b5f">arch/risc-v/src/sg2000/sg2000_mm_init.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MMU_IO_BASE      (0x00000000ul)
#define MMU_IO_SIZE      (0x80000000ul)</code></pre></div>
<p>We derived the above from the <strong>EIC7700X Memory Map</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 380</th></tr></thead><tbody>
<tr><td style="text-align: left">System Memory Map</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">System Space (Low)</td><td style="text-align: left">0000_0000 to 8000_0000</td></tr>
<tr><td style="text-align: left">Memory Space</td><td style="text-align: left">8000_0000 to 10_0000_0000</td></tr>
</tbody></table>
</div>
<p>We removed all <strong>T-Head MMU Extensions</strong>, including <strong>mmu_flush_cache</strong>.</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-84111f6f800efef513a2420c571ea39fe2068d19cff6c1eab015da0f9755b9c7">arch/risc-v/src/sg2000/sg2000_start.c</a></p>
<p><a href="TODO">(<strong>Multiple Harts</strong> explained)</a></p>
<div class="example-wrap"><pre class="language-c"><code>//// TODO
struct sbiret_s
{
  intreg_t    error;
  uintreg_t   value;
};
typedef struct sbiret_s sbiret_t;
static void sg2000_boot_secondary(void);
static int riscv_sbi_boot_secondary(uintreg_t hartid, uintreg_t addr);
static sbiret_t sbi_ecall(unsigned int extid, unsigned int fid,
                          uintreg_t parm0, uintreg_t parm1,
                          uintreg_t parm2, uintreg_t parm3,
                          uintreg_t parm4, uintreg_t parm5);

#define SBI_EXT_HSM (0x0048534D)
#define SBI_EXT_HSM_HART_START (0x0)

int boot_hartid = -1;

void sg2000_start_s(int mhartid)
{
  /* Configure FPU */

  riscv_fpuconfig();

  if (mhartid != boot_hartid)
    {
      goto cpux;
    }
    ...

cpux:

  /* Non-Boot Hart starts here */

  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;a&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;0&#39; + mhartid;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;

  ...

void sg2000_start(int mhartid)
{
  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;e&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;l&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;l&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;o&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39; &#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;N&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;u&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;X&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;!&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;

  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;a&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;0&#39; + mhartid;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;
  up_mdelay(1000);  // Wait a while for UART Queue to flush

  /* If Boot Hart is not 0, restart with Hart 0 */

  if (mhartid != 0)
    {
      /* Clear the BSS */

      sg2000_clear_bss();

      /* Restart with Hart 0 */

      riscv_sbi_boot_secondary(0, (uintptr_t)&amp;__start);

      /* Let this Hart idle forever */

      while (true)
        {
          asm(&quot;WFI&quot;);
        }  
      PANIC(); /* Should not come here */
    }

  /* Init the globals once only. Remember the Boot Hart. */

  if (boot_hartid &lt; 0)
    {
      boot_hartid = mhartid;

      /* Clear the BSS */

      sg2000_clear_bss();

      /* Boot the other cores */

      // TODO: sg2000_boot_secondary();

      /* Copy the RAM Disk */

      sg2000_copy_ramdisk();
      /* Initialize the per CPU areas */
      riscv_percpu_add_hart(mhartid);
    }

/****************************************************************************
 * Name: riscv_hartid_to_cpuid
 *
 * Description:
 *   Convert physical core number to logical core number.
 *
 ****************************************************************************/

int weak_function riscv_hartid_to_cpuid(int hart)
{
  /* Boot Hart is CPU 0. Renumber the Other Harts. */

  if (hart == boot_hartid)
    {
      return 0;
    }
  else if (hart &lt; boot_hartid)
    {
      return hart + 1;
    }
  else
    {
      return hart;
    }
}

/****************************************************************************
 * Name: riscv_cpuid_to_hartid
 *
 * Description:
 *   Convert logical core number to physical core number.
 *
 ****************************************************************************/

int weak_function riscv_cpuid_to_hartid(int cpu)
{
  /* Boot Hart is CPU 0. Renumber the Other Harts. */

  if (cpu == 0)
    {
      return boot_hartid;
    }
  else if (cpu &lt; boot_hartid + 1)
    {
      return cpu - 1;
    }
  else
    {
      return cpu;
    }
}

static void sg2000_boot_secondary(void)
{
  int i;

  for (i = 0; i &lt; CONFIG_SMP_NCPUS; i++)
    {
      if (i == boot_hartid)
        {
          continue;
        }

      riscv_sbi_boot_secondary(i, (uintptr_t)&amp;__start);
    }
}

static int riscv_sbi_boot_secondary(uintreg_t hartid, uintreg_t addr)
{
  sbiret_t ret = sbi_ecall(SBI_EXT_HSM, SBI_EXT_HSM_HART_START,
                           hartid, addr, 0, 0, 0, 0);

  if (ret.error &lt; 0)
    {
      _err(&quot;Boot Hart %d failed\n&quot;, hartid);
      PANIC();
    }

  return 0;
}

static sbiret_t sbi_ecall(unsigned int extid, unsigned int fid,
                          uintreg_t parm0, uintreg_t parm1,
                          uintreg_t parm2, uintreg_t parm3,
                          uintreg_t parm4, uintreg_t parm5)
{
  register long r0 asm(&quot;a0&quot;) = (long)(parm0);
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);
  register long r4 asm(&quot;a4&quot;) = (long)(parm4);
  register long r5 asm(&quot;a5&quot;) = (long)(parm5);
  register long r6 asm(&quot;a6&quot;) = (long)(fid);
  register long r7 asm(&quot;a7&quot;) = (long)(extid);
  sbiret_t ret;

  asm volatile
    (
     &quot;ecall&quot;
     : &quot;+r&quot;(r0), &quot;+r&quot;(r1)
     : &quot;r&quot;(r2), &quot;r&quot;(r3), &quot;r&quot;(r4), &quot;r&quot;(r5), &quot;r&quot;(r6), &quot;r&quot;(r7)
     : &quot;memory&quot;
     );

  ret.error = r0;
  ret.value = (uintreg_t)r1;

  return ret;
}</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-1c190e766d71f3e5a43109b975405c9e43b2d01e50f748b0f0c19a8d942caffe">arch/risc-v/src/sg2000/sg2000_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 1000000ul</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-82b3bf6ae151a2f4e1fb9b23de18af9fd683accc70aff2c88e0b5d6d0e26904b">boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_REGINCR=4
CONFIG_16550_UART0_BASE=0x50900000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_IRQ=125

CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y</code></pre></div>
<p><strong>16550_REGINCR</strong> is 4 because the UART Registers are spaced 4 bytes apart‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf">EIC7700X Tech Ref #4</a></th><th style="text-align: left">Page 524</th></tr></thead><tbody>
<tr><td style="text-align: left">UART Register Offset</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">0x0</td><td style="text-align: left">Receive Buffer Register (RBR)</td></tr>
<tr><td style="text-align: left">0x4</td><td style="text-align: left">Interrupt Enable Register (IER)</td></tr>
<tr><td style="text-align: left">0x8</td><td style="text-align: left">Interrupt Identification Register (IIR)</td></tr>
</tbody></table>
</div>
<p><strong>UART0 Base Address</strong> is here‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf">EIC7700X Tech Ref #4</a></th><th style="text-align: left">Page 353</th></tr></thead><tbody>
<tr><td style="text-align: left">Peripheral Address Space</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">UART0</td><td style="text-align: left">0x5090_0000</td></tr>
</tbody></table>
</div>
<p><strong>Why IRQ 125?</strong> UART0 Interrupt Number is 100, we add 25 because of TODO‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 366</th></tr></thead><tbody>
<tr><td style="text-align: left">UART0 Interrupt Number</td><td style="text-align: left">100 <em>(lsp_uart0_intr)</em></td></tr>
</tbody></table>
</div>
<p>TODO: <strong>16550_UART0_CLOCK</strong></p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-f208234edbfb636de240a0fef1c85f9cecb37876d5bc91ffb759f70a1e96b1d1">drivers/serial/uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef TODO  //  Compute CONFIG_16550_UART0_CLOCK
  /* Enter DLAB=1 */

  u16550_serialout(priv, UART_LCR_OFFSET, (lcr | UART_LCR_DLAB));
  ...
  /* Clear DLAB */

  u16550_serialout(priv, UART_LCR_OFFSET, lcr);
#endif  // TODO</code></pre></div><h1 id="appendix-multiple-harts-on-starpro64"><a class="doc-anchor" href="#appendix-multiple-harts-on-starpro64">¬ß</a>12 Appendix: Multiple Harts on StarPro64</h1>
<p><em>Multiple Harts are problematic. Why?</em></p>
<p>Inside EIC7700X SoC: We have <strong>Four Harts</strong> (RISC-V CPU Cores) numbered 0 to 3.</p>
<p>This SoC will boot OpenSBI on <strong>Any Random Hart</strong>, 0 to 3! Which means U-Boot and NuttX will subsequently boot on the <strong>Same Random Hart</strong>.</p>
<p><em>What‚Äôs the problem?</em></p>
<p>NuttX assumes that it always <strong>Boots on Hart 0</strong>. This code <strong>will fail</strong> when it boots on Harts 1 to 3: <a href="TODO"><strong>TODO</strong></a></p>
<p><em>How to fix this?</em></p>
<p>Our workaround is to <strong>Always Reboot NuttX on Hart 0</strong>.</p>
<p>TODO</p>
<p><em>Harts vs CPUs: What‚Äôs the difference?</em></p>
<p>NuttX insists on booting with CPU 0. Otherwise it fails with this <a href="https://gist.github.com/lupyuen/7278c35c3d556a5d4574668b54272fef"><strong>nx_start Error</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>[CPU2] dump_assert_info:
Assertion failed up_cpu_index() == 0: 
at file: init/nx_start.c:745 task(CPU2):
CPU2 IDLE process: Kernel 0x802019a6</code></pre></div>
<p>That‚Äôs why we <strong>Renumber the CPUs</strong>: Boot Hart is always <strong>CPU 0</strong>. Other Harts become <strong>CPUs 1 to 3</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>TODO</code></pre></div>
<p><em>Can‚Äôt we start One Hart and ignore the Other Harts?</em></p>
<p>We tried here.</p>
<p>TODO: Affinity</p>
<p><em>How to enable Multple Harts?</em></p>
<p>TODO</p>
<h1 id="eswin-ai-sample-user-guide"><a class="doc-anchor" href="#eswin-ai-sample-user-guide">¬ß</a>13 ESWIN AI Sample User Guide</h1>
<p>https://github.com/eswincomputing/eic7x-images/releases/tag/Debian-v1.0.0-p550-20241230</p>
<p>https://github.com/eswincomputing/eic7x-images/releases/download/Debian-v1.0.0-p550-20241230/ESWIN_AI_Sample_User_Guide.pdf</p>
<div class="example-wrap"><pre class="language-text"><code>ESWIN provides users with the desktop version of the Debian image files. the default username and
password for the system are both &quot;eswin / eswin&quot;.
Download the Debian-v1.0.0-p550-20241230 version system image via the link
https://github.com/eswincomputing/eic7x-images/releases. The image file is as follows:
EIC7x_Release_Images_p550_20241230
‚îî‚îÄ‚îÄ hifive-premier-p550
 ‚îú‚îÄ‚îÄ bootloader_P550.bin
 ‚îú‚îÄ‚îÄ boot-P550-20250126-011559.ext4
‚îî‚îÄ‚îÄ root-P550-20250126-011559.ext4</code></pre></div><h1 id="uart"><a class="doc-anchor" href="#uart">¬ß</a>14 UART</h1><div class="example-wrap"><pre class="language-text"><code>## First Time Only
echo &quot;defscrollback 1000000&quot; &gt;&gt; ~/.screenrc

set -x
for (( ; ; )) do 
  screen /dev/ttyUSB* 115200
  sleep 5
done</code></pre></div>
<p>Same pins as Star64 and Oz64 SG2000</p>
<p>Garbage: Compute CONFIG_16550_UART0_CLOCK</p>
<p>CONFIG_16550_UART0_IRQ=125</p>
<p>100 + 25</p>
<h1 id="multiple-cpu"><a class="doc-anchor" href="#multiple-cpu">¬ß</a>15 Multiple CPU</h1>
<p>https://gist.github.com/lupyuen/7278c35c3d556a5d4574668b54272fef</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...

123Hello NuttX!
2ABC[CPU2] nx_start: Entry
[CPU2] uart_register: Registering /dev/console
[CPU2] uart_register: Registering /dev/ttyS0
[CPU2] dump_assert_info: Current Version: NuttX  12.4.0 01cbd0ca38-dirty Feb 20 2025 19:56:29 risc-v
[CPU2] dump_assert_info: Assertion failed up_cpu_index() == 0: at file: init/nx_start.c:745 task(CPU2): CPU2 IDLE process: Kernel 0x802019a6
[CPU2] up_dump_register: EPC: 0000000080216ffc</code></pre></div>
<p>Boot HART ID = 0. OSTest OK yay!</p>
<p>https://gist.github.com/lupyuen/47170b4c4d7117ac495c5faede48280b</p>
<p>Boot HART ID = 2. Boot fail :-(</p>
<p>https://gist.github.com/lupyuen/66f93f69b29ba77f9b0c9eb7f78f1f95</p>
<p><img src="https://lupyuen.org/images/starpro64-hartid0.png" alt="TODO" /></p>
<p>StarPro64 will boot on a Random Hart: 0 to 3. But NuttX only boots on Hart 0!</p>
<p>We need to fix the PLIC Driver in NuttX, which only works on Hart 0‚Ä¶</p>
<ul>
<li>
<p><a href="https://gist.github.com/lupyuen/47170b4c4d7117ac495c5faede48280b">NuttX boots OK on Hart 0</a></p>
<div class="example-wrap"><pre class="language-text"><code>Boot HART ID              : 0
...
[CPU0] nx_start: Entry
[CPU0] nx_start: CPU0: Beginning Idle Loop

NuttShell (NSH) NuttX-12.4.0
nsh&gt; hello
Hello, World!!   </code></pre></div></li>
<li>
<p><a href="https://gist.github.com/lupyuen/66f93f69b29ba77f9b0c9eb7f78f1f95">NuttX won‚Äôt boot on other Harts</a></p>
<div class="example-wrap"><pre class="language-text"><code>Boot HART ID              : 2
...
[CPU0] nx_start: Entry
[CPU0] nx_start: CPU0: Beginning Idle Loop
[ Stuck here ]</code></pre></div></li>
</ul>
<h1 id="plic-multiple-harts"><a class="doc-anchor" href="#plic-multiple-harts">¬ß</a>16 PLIC Multiple Harts</h1>
<p><a href="https://gist.github.com/lupyuen/0f5d4ad0697bef7839cb92875abba1b0">Hart ID 2. OK yay!</a></p>
<p><a href="https://gist.github.com/lupyuen/9bdfad6d283945effc994923ae99117a">Hart ID 1. OK yay!</a></p>
<p>Fix the sleep. too slow. factor of 25</p>
<p><a href="https://gist.github.com/lupyuen/5553ee833440ceb3e2a85cdb5515ed65">waiter_func: Thread 2 waiting on semaphore</a></p>
<p><a href="https://youtu.be/70DQ4YlQMMw"><strong>Watch the Demo on YouTube</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/901365650d8f908a7caa431de4e84ff6"><strong>See the NuttX Log</strong></a></p>
<h1 id="build-loop"><a class="doc-anchor" href="#build-loop">¬ß</a>17 Build Loop</h1>
<p>make</p>
<p>make app</p>
<p>power off</p>
<p>power on</p>
<p>read</p>
<p>power off</p>
<h1 id="semaphore-fail"><a class="doc-anchor" href="#semaphore-fail">¬ß</a>18 Semaphore Fail</h1>
<p>https://gist.github.com/lupyuen/901365650d8f908a7caa431de4e84ff6</p>
<div class="example-wrap"><pre class="language-text"><code>user_main: semaphore test
sem_test: Initializing semaphore to 0
sem_test: Starting waiter thread 1
sem_test: Set thread 1 priority to 191

&lt;&lt;
???
&gt;&gt;

sem_test: Starting waiter thread 2
sem_test: Set thread 2 priority to 128
waiter_func: Thread 2 Started
&lt;&lt;&lt;
waiter_func: Thread 2 initial semaphore value = 0
&gt;&gt;&gt;
waiter_func: Thread 2 waiting on semaphore</code></pre></div>
<p>Compare with SG2000: https://github.com/lupyuen/nuttx-sg2000/releases/tag/nuttx-sg2000-2025-02-23</p>
<div class="example-wrap"><pre class="language-text"><code>user_main: semaphore test
sem_test: Initializing semaphore to 0
sem_test: Starting waiter thread 1
sem_test: Set thread 1 priority to 191

&lt;&lt;
waiter_func: Thread 1 Started
&gt;&gt;

sem_test: Starting waiter thread 2
waiter_func: Thread 1 initial semaphore value = 0
sem_test: Set thread 2 priority to 128
waiter_func: Thread 1 waiting on semaphore
waiter_func: Thread 2 Started
&lt;&lt;&lt;
waiter_func: Thread 2 initial semaphore value = -1
&gt;&gt;&gt;
waiter_func: Thread 2 waiting on semaphore
sem_test: Starting poster thread 3</code></pre></div>
<p>Thread 1 isn‚Äôt started!</p>
<p>https://github.com/lupyuen2/wip-nuttx-apps/blob/starpro64/testing/ostest/ostest_main.c#L435-L439</p>
<div class="example-wrap"><pre class="language-c"><code>      /* Verify pthreads and semaphores */

      printf(&quot;\nuser_main: semaphore test\n&quot;);
      sem_test();
      check_test_memory_usage();</code></pre></div>
<p>https://github.com/lupyuen2/wip-nuttx-apps/blob/starpro64/testing/ostest/sem.c#L49-L73</p>
<div class="example-wrap"><pre class="language-c"><code>static void *waiter_func(void *parameter)
{
  int id  = (int)((intptr_t)parameter);
  int status;
  int value;

  printf(&quot;waiter_func: Thread %d Started\n&quot;,  id);

  /* Take the semaphore */

  status = sem_getvalue(&amp;sem, &amp;value);
  if (status &lt; 0)
    {
      printf(&quot;waiter_func: &quot;
             &quot;ERROR thread %d could not get semaphore value\n&quot;,  id);
      ASSERT(false);
    }
  else
    {
      printf(&quot;waiter_func: &quot;
             &quot;Thread %d initial semaphore value = %d\n&quot;,  id, value);
    }

  printf(&quot;waiter_func: Thread %d waiting on semaphore\n&quot;,  id);
  status = sem_wait(&amp;sem);</code></pre></div>
<p>sem_wait:</p>
<p>https://github.com/apache/nuttx/blob/824dd706177444d020ebb20acdc08c294ab0db37/libs/libc/semaphore/sem_wait.c#L59</p>
<div class="example-wrap"><pre class="language-c"><code>int sem_wait(FAR sem_t *sem)
{
  int errcode;
  int ret;

  if (sem == NULL)
    {
      set_errno(EINVAL);
      return ERROR;
    }

  /* sem_wait() is a cancellation point */

  if (enter_cancellation_point())
    {
#ifdef CONFIG_CANCELLATION_POINTS
      /* If there is a pending cancellation, then do not perform
       * the wait.  Exit now with ECANCELED.
       */

      errcode = ECANCELED;
      goto errout_with_cancelpt;
#endif
    }

  /* Let nxsem_wait() do the real work */

  ret = nxsem_wait(sem);
  if (ret &lt; 0)
    {
      errcode = -ret;
      goto errout_with_cancelpt;
    }

  leave_cancellation_point();
  return OK;

errout_with_cancelpt:
  set_errno(errcode);
  leave_cancellation_point();
  return ERROR;
}</code></pre></div>
<p>nxsem_wait: https://github.com/lupyuen2/wip-nuttx/blob/starpro64/sched/semaphore/sem_wait.c#L248-L271</p>
<div class="example-wrap"><pre class="language-c"><code>int nxsem_wait(FAR sem_t *sem)
{
  /* This API should not be called from interrupt handlers &amp; idleloop */

  DEBUGASSERT(sem != NULL &amp;&amp; up_interrupt_context() == false);
  DEBUGASSERT(!OSINIT_IDLELOOP() || !sched_idletask());

  /* If this is a mutex, we can try to get the mutex in fast mode,
   * else try to get it in slow mode.
   */

#if !defined(CONFIG_PRIORITY_INHERITANCE) &amp;&amp; !defined(CONFIG_PRIORITY_PROTECT)
  if (sem-&gt;flags &amp; SEM_TYPE_MUTEX)
    {
      int32_t old = 1;
      if (atomic_try_cmpxchg_acquire(NXSEM_COUNT(sem), &amp;old, 0))
        {
          return OK;
        }
    }
#endif

  return nxsem_wait_slow(sem);
}</code></pre></div>
<p>nxsem_wait in disassembly: nuttx.S</p>
<div class="example-wrap"><pre class="language-text"><code>/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:260
  /* If this is a mutex, we can try to get the mutex in fast mode,
   * else try to get it in slow mode.
   */

#if !defined(CONFIG_PRIORITY_INHERITANCE) &amp;&amp; !defined(CONFIG_PRIORITY_PROTECT)
  if (sem-&gt;flags &amp; SEM_TYPE_MUTEX)
    80204f96:	0044c783          	lbu	a5,4(s1)
    80204f9a:	8b91                	and	a5,a5,4
    80204f9c:	e7a1                	bnez	a5,80204fe4 &lt;nxsem_wait+0xbc&gt;
nxsem_wait_slow():
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:82
  flags = enter_critical_section();
    80204f9e:	b5bfc0ef          	jal	80201af8 &lt;enter_critical_section_wo_note&gt;
    80204fa2:	89aa                	mv	s3,a0
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:88
  if (atomic_fetch_sub(NXSEM_COUNT(sem), 1) &gt; 0)
    80204fa4:	577d                	li	a4,-1
    80204fa6:	0f50000f          	fence	iorw,ow
    80204faa:	04e4a7af          	amoadd.w.aq	a5,a4,(s1)
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:88 (discriminator 1)
    80204fae:	2781                	sext.w	a5,a5
    80204fb0:	04f04e63          	bgtz	a5,8020500c &lt;nxsem_wait+0xe4&gt;
up_irq_save():
/Users/luppy/starpro64/nuttx/include/arch/irq.h:766
  __asm__ __volatile__
    80204fb4:	4a09                	li	s4,2
    80204fb6:	100a3a73          	csrrc	s4,sstatus,s4
this_task():
/Users/luppy/starpro64/nuttx/sched/sched/sched.h:381
    80204fba:	80efc0ef          	jal	80200fc8 &lt;up_this_cpu&gt;
/Users/luppy/starpro64/nuttx/sched/sched/sched.h:381 (discriminator 1)
    80204fbe:	001fe917          	auipc	s2,0x1fe
    80204fc2:	ef290913          	add	s2,s2,-270 # 80402eb0 &lt;g_assignedtasks&gt;
    80204fc6:	00451793          	sll	a5,a0,0x4
    80204fca:	97ca                	add	a5,a5,s2
    80204fcc:	6380                	ld	s0,0(a5)
up_irq_restore():
/Users/luppy/starpro64/nuttx/include/arch/irq.h:792
  __asm__ __volatile__
    80204fce:	100a1073          	csrw	sstatus,s4
nxsem_wait_slow():
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:118 (discriminator 1)
      DEBUGASSERT(rtcb-&gt;waitobj == NULL);
    80204fd2:	6c7c                	ld	a5,216(s0)
    80204fd4:	c3a9                	beqz	a5,80205016 &lt;nxsem_wait+0xee&gt;
    80204fd6:	0001b617          	auipc	a2,0x1b
    80204fda:	1a260613          	add	a2,a2,418 # 80220178 &lt;_srodata+0x1200&gt;
    80204fde:	07600593          	li	a1,118
    80204fe2:	b78d                	j	80204f44 &lt;nxsem_wait+0x1c&gt;
nxsem_wait():
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:263
    {
      int32_t old = 1;
      if (atomic_try_cmpxchg_acquire(NXSEM_COUNT(sem), &amp;old, 0))
    80204fe4:	4705                	li	a4,1
    80204fe6:	1004a7af          	lr.w	a5,(s1)
    80204fea:	00e79563          	bne	a5,a4,80204ff4 &lt;nxsem_wait+0xcc&gt;
    80204fee:	1c04a6af          	sc.w.aq	a3,zero,(s1)
    80204ff2:	faf5                	bnez	a3,80204fe6 &lt;nxsem_wait+0xbe&gt;
    80204ff4:	37fd                	addw	a5,a5,-1
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:265
        {
          return OK;
    80204ff6:	4401                	li	s0,0
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:263
      if (atomic_try_cmpxchg_acquire(NXSEM_COUNT(sem), &amp;old, 0))
    80204ff8:	f3dd                	bnez	a5,80204f9e &lt;nxsem_wait+0x76&gt;
/Users/luppy/starpro64/nuttx/sched/semaphore/sem_wait.c:271
        }
    }
#endif

  return nxsem_wait_slow(sem);
}</code></pre></div>
<p>Log sem_wait</p>
<p>https://github.com/lupyuen2/wip-nuttx/blob/starpro64b/sched/semaphore/sem_wait.c#L170-L172</p>
<div class="example-wrap"><pre class="language-c"><code>      *(volatile uint8_t *) 0x50900000ul = &#39;3&#39;; ////
      up_switch_context(this_task(), rtcb);
      *(volatile uint8_t *) 0x50900000ul = &#39;4&#39;; ////</code></pre></div>
<p>Output log:</p>
<div class="example-wrap"><pre class="language-text"><code>430101010101010101010101010101010100
4343E43n43d43 43o43f43 43t43e43s43t43 43m43e43m43o43r43y43 43u43s43a43g43e43:43
4343V43A43R43I43A43B43L401013E43 43 43B43E43F43O43R43E43 43 43 43A43F43T43E43R43
4343=43=43=43=43=43=43=43=43 43=43=43=43=43=43=43=43=401013 43=43=43=43=43=43=43=43=43
4343a43r43e43n43a43 43 43 43 43 43 43 43843143043043043 43 43 43 43843143043043043
  43o40101010101010101[CPU0] nxtask_activate: ostest pid=21,TCB=0x80413028
430133r43d43b43l43k43s43 43 43 43 43 43 43 43 43 43343 43 43 43 43 43 43 43 43343
4343m43x43o43r43d43b43l43k43 401013 43 43 43743843f43f43843 43 43 43 43743843f43f43843
  43u43o43r43d43b43l43k43s43 43 43 43 43 43443543843843 43 43 43 40101010101[CPU0] nxtask_activate: ostest pid=25,TCB=0x80413e08
43013 43443543843843
4343f43o43r43d43b43l43k43s43 43 43 43 43743c43a43743843 43 43 43 43743c43a401013743843
4343
4343u43s43e43r43_43m43a43i43n43:43 43s43e43m43a43p43h43o43r43e43 43t43e43s43t43
  43s43e43m43_43t43e43s43t43:43 43I43n43i43t43i43a43l43i401013z43i43n43g43 43s43e43m43a43p43h43o43r43e43 43t43o43 43043
  43s43e43m43_43t43e43s43t43:43 43S43t43a43r43t43i43n43g43 43w43a43i43t43er thread 1
sem_test: Set thread 1 priority to 191
sem_test: Starting waiter thread 2
sem_test: Set thread 2 priority to 128
waiter_func: Thread 2 Started
waiter_func: Thread 2 initial semaphore value = 0
waiter_func: Thread 2 waiting on semaphore</code></pre></div>
<p>https://github.com/lupyuen2/wip-nuttx/blob/starpro64b/sched/semaphore/sem_wait.c#L76-L84</p>
<div class="example-wrap"><pre class="language-c"><code>
  /* The following operations must be performed with interrupts
   * disabled because nxsem_post() may be called from an interrupt
   * handler.
   */

   *(volatile uint8_t *) 0x50900000ul = &#39;5&#39;; ////
   flags = enter_critical_section();
   *(volatile uint8_t *) 0x50900000ul = &#39;6&#39;; ////</code></pre></div>
<p>Output log:</p>
<div class="example-wrap"><pre class="language-text"><code>84565631456563045656304565630456563 456563 456563 456563 456563845656314565630456563045656304565456563
      456563o40101010101010101[CPU0] nxtask_activate: ostest pid=21,TCB=0x80413028
010156563563r456563d456563b456563l456563k456563s456563 456563 456563 456563 456563 456563 4565634565633 456563 4565633456563 456563 456563 456563 456563 456563 456563 456563 4565633456563
      456563m456563x456563o456563r456563d456563b456563l456563k456563 4010156563 456563 456563 45656374565638456563f456563f4565638456563 456563 456563 456563 45656374565638456563f456563f4565638456563
      456563u456563o456563r456563d456563b456563l456563k456563s456563 456563 456563 456563 456563 4565634456563545656384565638456563 456563 456563 456563 40101010101[CPU0] nxtask_activate: ostest pid=25,TCB=0x80413e08
456563563 4565634456563545656384565638456563
      456563f456563o456563r456563d456563b456563l456563k456563s456563 456563 456563 456563 4565637456563c456563a45656374565638456563 456563 456563 456563 4565637456563c456563a401015656374565638456563
456563456563
      456563u456563s456563e456563r456563_456563m456563a456563i456563n456563:456563 456563s4565634565633m456563a456563p456563h456563o456563r456563e456563 456563t456563e456563s456563t456563
      456563s456563e456563m456563_456563t456563e456563s456563t456563:456563 456563I456563n456563i456563t456563i456563a456563l456563i4010156563z456563i456563n456563g456563 456563s456563e456563m456563a456563p456563h456563o456563r456563e456563 456563t456563o456563 4565630456563
      456563s456563e456563m456563_456563t456563e456563s456563t456563:456563 456563S456563t456563a456563r456563t456563i456563n456563g456563 456563w456563a456563i456563t4563er thread 1
sem_test: Set thread 1 priority to 191
sem_test: Starting waiter thread 2
sem_test: Set thread 2 priority to 128
waiter_func: Thread 2 Started
waiter_func: Thread 2 initial semaphore value = 0
waiter_func: Thread 2 waiting on semaphore</code></pre></div>
<p>Hang in up_switch_context:</p>
<p>up_switch_context:</p>
<div class="example-wrap"><pre class="language-text"><code>000000008020d362 &lt;up_switch_context&gt;:
up_switch_context():
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_switchcontext.c:61
 *   rtcb: Refers to the running task which will be blocked.
 *
 ****************************************************************************/

void up_switch_context(struct tcb_s *tcb, struct tcb_s *rtcb)
{
    8020d362:	1101                	add	sp,sp,-32
    8020d364:	e822                	sd	s0,16(sp)
    8020d366:	e426                	sd	s1,8(sp)
    8020d368:	e04a                	sd	s2,0(sp)
    8020d36a:	ec06                	sd	ra,24(sp)
    8020d36c:	842a                	mv	s0,a0
    8020d36e:	84ae                	mv	s1,a1
up_irq_save():
/Users/luppy/starpro64/nuttx/include/arch/irq.h:766
    8020d370:	4909                	li	s2,2
    8020d372:	10093973          	csrrc	s2,sstatus,s2
up_interrupt_context():
/Users/luppy/starpro64/nuttx/include/arch/irq.h:832
  bool ret = g_interrupt_context[up_this_cpu()];
    8020d376:	c53f30ef          	jal	80200fc8 &lt;up_this_cpu&gt;
/Users/luppy/starpro64/nuttx/include/arch/irq.h:832 (discriminator 1)
    8020d37a:	001f9797          	auipc	a5,0x1f9
    8020d37e:	5de78793          	add	a5,a5,1502 # 80406958 &lt;g_interrupt_context&gt;
    8020d382:	97aa                	add	a5,a5,a0
    8020d384:	0007c783          	lbu	a5,0(a5)
    8020d388:	0ff7f793          	zext.b	a5,a5
up_irq_restore():
/Users/luppy/starpro64/nuttx/include/arch/irq.h:792
  __asm__ __volatile__
    8020d38c:	10091073          	csrw	sstatus,s2
up_switch_context():
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_switchcontext.c:64 (discriminator 1)
  /* Are we in an interrupt handler? */

  if (up_interrupt_context())
    8020d390:	c785                	beqz	a5,8020d3b8 &lt;up_switch_context+0x56&gt;
riscv_savecontext():
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_internal.h:262
  riscv_savefpu(tcb-&gt;xcp.regs, riscv_fpuregs(tcb));
    8020d392:	1504b503          	ld	a0,336(s1)
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_internal.h:262 (discriminator 1)
    8020d396:	10850593          	add	a1,a0,264
    8020d39a:	868f30ef          	jal	80200402 &lt;riscv_savefpu&gt;
riscv_restorecontext():
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_internal.h:277
  riscv_restorefpu(tcb-&gt;xcp.regs, riscv_fpuregs(tcb));
    8020d39e:	15043503          	ld	a0,336(s0)
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_internal.h:277 (discriminator 1)
    8020d3a2:	10850593          	add	a1,a0,264
    8020d3a6:	8f8f30ef          	jal	8020049e &lt;riscv_restorefpu&gt;
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_internal.h:289
  __asm__ __volatile__(&quot;mv tp, %0&quot; : : &quot;r&quot;(tcb));
    8020d3aa:	8222                	mv	tp,s0
up_switch_context():
/Users/luppy/starpro64/nuttx/arch/risc-v/src/common/riscv_switchcontext.c:93
       * head of the ready-to-run list.  It does not &#39;return&#39; in the
       * normal sense.  When it does return, it is because the blocked
       * task is again ready to run and has execution priority.
       */
    }
}</code></pre></div><h1 id="thread-1-isnt-started"><a class="doc-anchor" href="#thread-1-isnt-started">¬ß</a>19 Thread 1 isn‚Äôt started!</h1>
<p>pthread_create: https://github.com/lupyuen2/wip-nuttx/blob/starpro64b/libs/libc/pthread/pthread_create.c#L88-L93</p>
<div class="example-wrap"><pre class="language-c"><code>int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
                   pthread_startroutine_t pthread_entry, pthread_addr_t arg)
{
  return nx_pthread_create(pthread_startup, thread, attr, pthread_entry,
                           arg);
}</code></pre></div>
<p>nx_pthread_create: https://github.com/lupyuen2/wip-nuttx/blob/starpro64b/sched/pthread/pthread_create.c#L179-L412</p>
<div class="example-wrap"><pre class="language-c"><code>int nx_pthread_create(pthread_trampoline_t trampoline, FAR pthread_t *thread,
                      FAR const pthread_attr_t *attr,
                      pthread_startroutine_t entry, pthread_addr_t arg)
{
  pthread_attr_t default_attr = g_default_pthread_attr;
  FAR struct pthread_tcb_s *ptcb;
  struct sched_param param;
  FAR struct tcb_s *parent;
  int policy;
  int errcode;
  int ret;

  DEBUGASSERT(trampoline != NULL);

  parent = this_task();
  DEBUGASSERT(parent != NULL);

  /* If attributes were not supplied, use the default attributes */

  if (!attr)
    {
      /* Inherit parent priority by default. except idle */

      if (!is_idle_task(parent))
        {
          default_attr.priority = parent-&gt;sched_priority;
        }

      attr = &amp;default_attr;
    }

  /* Allocate a TCB for the new task. */

  ptcb = kmm_zalloc(sizeof(struct pthread_tcb_s));
  if (!ptcb)
    {
      serr(&quot;ERROR: Failed to allocate TCB\n&quot;);
      return ENOMEM;
    }

  ptcb-&gt;cmn.flags |= TCB_FLAG_FREE_TCB;

  /* Initialize the task join */

  nxtask_joininit(&amp;ptcb-&gt;cmn);

#ifndef CONFIG_PTHREAD_MUTEX_UNSAFE
  spin_lock_init(&amp;ptcb-&gt;cmn.mutex_lock);
#endif

  /* Bind the parent&#39;s group to the new TCB (we have not yet joined the
   * group).
   */

  group_bind(ptcb);

#ifdef CONFIG_ARCH_ADDRENV
  /* Share the address environment of the parent task group. */

  ret = addrenv_join(this_task(), (FAR struct tcb_s *)ptcb);
  if (ret &lt; 0)
    {
      errcode = -ret;
      goto errout_with_tcb;
    }
#endif

  if (attr-&gt;detachstate == PTHREAD_CREATE_DETACHED)
    {
      ptcb-&gt;cmn.flags |= TCB_FLAG_DETACHED;
    }

  if (attr-&gt;stackaddr)
    {
      /* Use pre-allocated stack */

      ret = up_use_stack((FAR struct tcb_s *)ptcb, attr-&gt;stackaddr,
                         attr-&gt;stacksize);
    }
  else
    {
      /* Allocate the stack for the TCB */

      ret = up_create_stack((FAR struct tcb_s *)ptcb, attr-&gt;stacksize,
                            TCB_FLAG_TTYPE_PTHREAD);
    }

  if (ret != OK)
    {
      errcode = ENOMEM;
      goto errout_with_tcb;
    }

#if defined(CONFIG_ARCH_ADDRENV) &amp;&amp; \
    defined(CONFIG_BUILD_KERNEL) &amp;&amp; defined(CONFIG_ARCH_KERNEL_STACK)
  /* Allocate the kernel stack */

  ret = up_addrenv_kstackalloc(&amp;ptcb-&gt;cmn);
  if (ret &lt; 0)
    {
      errcode = ENOMEM;
      goto errout_with_tcb;
    }
#endif

  /* Initialize thread local storage */

  ret = tls_init_info(&amp;ptcb-&gt;cmn);
  if (ret != OK)
    {
      errcode = -ret;
      goto errout_with_tcb;
    }

  /* Should we use the priority and scheduler specified in the pthread
   * attributes?  Or should we use the current thread&#39;s priority and
   * scheduler?
   */

  if (attr-&gt;inheritsched == PTHREAD_INHERIT_SCHED)
    {
      /* Get the priority (and any other scheduling parameters) for this
       * thread.
       */

      ret = nxsched_get_param(0, &amp;param);
      if (ret &lt; 0)
        {
          errcode = -ret;
          goto errout_with_tcb;
        }

      /* Get the scheduler policy for this thread */

      policy = nxsched_get_scheduler(0);
      if (policy &lt; 0)
        {
          errcode = -policy;
          goto errout_with_tcb;
        }
    }
  else
    {
      /* Use the scheduler policy and policy the attributes */

      policy                             = attr-&gt;policy;
      param.sched_priority               = attr-&gt;priority;

#ifdef CONFIG_SCHED_SPORADIC
      param.sched_ss_low_priority        = attr-&gt;low_priority;
      param.sched_ss_max_repl            = attr-&gt;max_repl;
      param.sched_ss_repl_period.tv_sec  = attr-&gt;repl_period.tv_sec;
      param.sched_ss_repl_period.tv_nsec = attr-&gt;repl_period.tv_nsec;
      param.sched_ss_init_budget.tv_sec  = attr-&gt;budget.tv_sec;
      param.sched_ss_init_budget.tv_nsec = attr-&gt;budget.tv_nsec;
#endif
    }

#ifdef CONFIG_SCHED_SPORADIC
  if (policy == SCHED_SPORADIC)
    {
      FAR struct sporadic_s *sporadic;
      sclock_t repl_ticks;
      sclock_t budget_ticks;

      /* Convert timespec values to system clock ticks */

      repl_ticks = clock_time2ticks(&amp;param.sched_ss_repl_period);
      budget_ticks = clock_time2ticks(&amp;param.sched_ss_init_budget);

      /* The replenishment period must be greater than or equal to the
       * budget period.
       */

      if (repl_ticks &lt; budget_ticks)
        {
          errcode = EINVAL;
          goto errout_with_tcb;
        }

      /* Initialize the sporadic policy */

      ret = nxsched_initialize_sporadic(&amp;ptcb-&gt;cmn);
      if (ret &gt;= 0)
        {
          sporadic               = ptcb-&gt;cmn.sporadic;
          DEBUGASSERT(sporadic != NULL);

          /* Save the sporadic scheduling parameters */

          sporadic-&gt;hi_priority  = param.sched_priority;
          sporadic-&gt;low_priority = param.sched_ss_low_priority;
          sporadic-&gt;max_repl     = param.sched_ss_max_repl;
          sporadic-&gt;repl_period  = repl_ticks;
          sporadic-&gt;budget       = budget_ticks;

          /* And start the first replenishment interval */

          ret = nxsched_start_sporadic(&amp;ptcb-&gt;cmn);
        }

      /* Handle any failures */

      if (ret &lt; 0)
        {
          errcode = -ret;
          goto errout_with_tcb;
        }
    }
#endif

  /* Initialize the task control block */

  ret = pthread_setup_scheduler(ptcb, param.sched_priority, pthread_start,
                                entry);
  if (ret != OK)
    {
      errcode = EBUSY;
      goto errout_with_tcb;
    }

#ifdef CONFIG_SMP
  /* pthread_setup_scheduler() will set the affinity mask by inheriting the
   * setting from the parent task.  We need to override this setting
   * with the value from the pthread attributes unless that value is
   * zero:  Zero is the default value and simply means to inherit the
   * parent thread&#39;s affinity mask.
   */

  if (attr-&gt;affinity != 0)
    {
      ptcb-&gt;cmn.affinity = attr-&gt;affinity;
    }
#endif</code></pre></div>
<p>How to set affinity?</p>
<h1 id="multiple-cpu-1"><a class="doc-anchor" href="#multiple-cpu-1">¬ß</a>20 Multiple CPU</h1>
<p>boot_hartid=2
hart=0, cpu=1
hart=1, cpu=2
hart=2, cpu=0
hart=3, cpu=3</p>
<p>cpu=0, hart=2
cpu=1, hart=0
cpu=2, hart=1
cpu=3, hart=3</p>
<div class="example-wrap"><pre class="language-text"><code>123Hello NuttX!
Hart1
ABC[123Hello NuttX!
Hart0
Hart0
CPU0] nx_start: Entry
[CPU0] uart_register: Registering /dev/console
[CPU0] uart_register: Registering /dev/ttyS0
[CPU0] up_cpu_start: CPU=1
V[CCP[UC0P]U 0]r idsucvm_pc_pauss_ebroto_t:in CfPo:U0  CSurtarretnetd
2er[sCPioU0n]:  nNxu_titdX l e1_2t.r4am.p0o 0l2i6n5e:46 C7P5Ucb0-: diBregtiyn nFeibn g 23I dl20e 2L5o o20p:
 9:44 risc-v
[CPU0] dump_assert_info: Assertion failed (g_cpu_irqset &amp; (1 &lt;&lt; cpu)) == 0: at file: irq/irq_csection.c:232 task(CPU0): CPU0 IDLE process: Kernel 0x80201dfa
[CPU0] up_dump_register: EPC: 0000000080202d1a</code></pre></div>
<p>TODO: Support non-zero boot hart.</p>
<p>https://github.com/lupyuen2/wip-nuttx/blob/starpro64c/arch/risc-v/src/common/riscv_macros.S#L383-L423</p>
<div class="example-wrap"><pre class="language-text"><code>/****************************************************************************
 * Name: riscv_set_inital_sp
 *
 * Description:
 *   Set inital sp for riscv core. This function should be only called
 *   when initing.
 *
 *   sp (stack top) = sp base + idle stack size * hart id
 *   sp (stack base) = sp (stack top) + idle stack size * - XCPTCONTEXT_SIZE
 *
 *   Note: The XCPTCONTEXT_SIZE byte after stack base is reserved for
 *         up_initial_state since we are already running and using
 *         the per CPU idle stack.
 *
 *   TODO: Support non-zero boot hart.
 *
 * Parameter:
 *   base - Pointer to where the stack is allocated (e.g. _ebss)
 *   size - Stack size for pre cpu to allocate
 *   hartid - Hart id register of this hart (Usually a0)
 *
 ****************************************************************************/
.macro riscv_set_inital_sp base, size, hartid
  la      t0, \base
  li      t1, \size
  mul     t1, \hartid, t1
  add     t0, t0, t1

  /* ensure the last XCPTCONTEXT_SIZE is reserved for non boot CPU */

  bnez \hartid, 998f
  li   t1, STACK_ALIGN_DOWN(\size)
  j    999f

998:
  li   t1, STACK_ALIGN_DOWN(\size - XCPTCONTEXT_SIZE)

999:
  add  t0, t0, t1
  mv   sp, t0
.endm</code></pre></div>
<p>Stack is full:</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...

123Hello NuttX!
Hart2
123123123ABC[CPU0] nx_start: Entry
[CPU0] uart_register: Registering /dev/console
[CPU0] uart_register: Registering /dev/ttyS0
[CPU0] up_cpu_start: CPU=1
VeCCP[UC0P]U 0]r isdcuvm_p_capsus_ebroto_t:i nfCPoU: 0C uStrraertnte d
: [rCsPioU0n:]  Nnuxt_tiXd l e_1t2r.a4m.p0o 9l8ian4e:d 65CPaU601:-d iBretgiy nFnienbg  23I d2le02 5Lo 2op1
 13:42 risc-v
[CPU0] dump_assert_info: Assertion failed (g_cpu_irqset &amp; (1 &lt;&lt; cpu)) == 0: at file: irq/irq_csection.c:232 task(CPU0): CPU0 IDLE process: Kernel 0x80201dfa
[CPU0] up_dump_register: EPC: 0000000080202d1a
[CPU0] up_dump_register: A0: 0000000080404d30 A1: 00000000000000e8 A2: 000000008021fc28 A3: 0000000000000000
[CPU0] up_dump_register: A4: 0000000080402740 A5: 0000000000000002 A6: 0000000000000000 A7: 0000000000735049
[CPU0] up_dump_register: T0: 00000000802000c0 T1: 0000000000000007 T2: 0000000000000000 T3: 000000008040d090
[CPU0] up_dump_register: T4: 000000008040d088 T5: 0000000080200000 T6: 00000000ed4ec178
[CPU0] up_dump_register: S0: 0000000000000210 S1: 0000000080402760 S2: 0000000000000000 S3: 000000008021fc28
[CPU0] up_dump_register: S4: 000000008021fb50 S5: 0000000080406968 S6: 00000000000000e8 S7: 0000000000000004
[CPU0] up_dump_register: S8: 0000000080404d30 S9: 8000000200046020 S10: 0000000080201dfa S11: 00000000802022da
[CPU0] up_dump_register: SP: 000000008040cd00 FP: 0000000000000210 TP: 0000000080402760 RA: 0000000080202d1a
[CPU0] dump_stacks: ERROR: Stack pointer is not within the stack
[CPU0] dump_stackinfo: IRQ Stack:
[CPU0] dump_stackinfo:   base: 0x80401e60
[CPU0] dump_stackinfo:   size: 00002048
[CPU0] stack_dump: 0x80402660: 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000
[CPU0] dump_stackinfo: Kernel Stack:
[CPU0] dump_stackinfo:   base: 0
[CPU0] dump_stackinfo:   size: 00003072
[CPU0] stack_dump: 0xc00: 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000
[CPU0] dump_stackinfo: User Stack:
[CPU0] dump_stackinfo:   base: 0x8040b010
[CPU0] dump_stackinfo:   size: 00003056
[CPU0] stack_dump: 0x8040b938: 000000008040b9d0 0000000000000020 0000000080209e02 deadbeefdeadbeef 000000008040b9d0 000000008040b9d0 000000008021f0ea deadbeefdeadbeef
[CPU0] stack_dump: 0x8040b978: 0000000080228928 0000000000000001 000000008040ba20 000000000000000a 0000000080209e02 fffffffffffffffc 000000008040ba20 000000008040ba20
[CPU0] stack_dump: 0x8040b9b8: 000000008021f0ea deadbeefdeadbeef 000000008021fabf 0000000000000001 0000000000000000 000000008040bb80 0000000000000000 fffffffffffffffc
[CPU0] stack_dump: 0x8040b9f8: 000000000000000a 000000008040bae8 000000008021dacc deadbeefdeadbeef 0a0000008022a320 0000000000000000 000000000000002e 000000008040bae8
[CPU0] stack_dump: 0x8040ba38: 000000008020b02a 0000000000002000 0000000000000004 8000000a00006800 0000000000000030 fffffffffffffff3 0000000000000000 000000008040bb38
[CPU0] stack_dump: 0x8040ba78: 0000000000000000 0000000000000000 0000000080043710 0000000000002000 0000000000000004 8000000a00006800 0000000000000000 fffffffffffffff3
[CPU0] stack_dump: 0x8040bab8: 0000000000000000 000000008040bb38 000000008021faa0 0000000000000007 000000008021beb0 deadbeefdeadbeef deadbeef00000035 000000008021da8c
[CPU0] stack_dump: 0x8040baf8: 000000008021da2a 000000008020bdc6 deadbeef0000000a 0000000080200000 0000000000000000 deadbeefdeadbeef 000000008020c052 deadbeefdeadbeef
[CPU0] stack_dump: 0x8040bb38: 000000008040bb70 deadbeefdeadbeef 000000008020c072 0000000000000002 000000008040bb70 0000000080402760 0000000080202310 000000008022a320
[CPU0] stack_dump: 0x8040bb78: 0000000000000000 0000000080402740 0000000000000002 0000000000000009 000000000000000f deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef
[CPU0] stack_dump: 0x8040bbb8: deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef deadbeefdeadbeef
[CPU0] stack_dump: 0x8040bbf8: deadbeefdeadbeef 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000 0000000000000000
[CPU0] dump_fatal_info: Dump CPU1: RUNNING
[CPU0] dump_fatal_info: Dump CPU2: RUNNING
[CPU0] dump_fatal_info: Dump CPU3: RUNNING
[CPU0] dump_tasks:    PID GROUP   CPU PRI POLICY   TYPE    NPX STATE   EVENT      SIGMASK          STACKBASE  STACKSIZE      USED   FILLED    COMMAND
[CPU0] dump_tasks:   ----   ---     0 --- -------- ------- --- ------- ---------- ---------------- 0x80401e60      2048         0     0.0%    irq
[CPU0] dump_tasks:   ----   ---     1 --- -------- ------- --- ------- ---------- ---------------- 0x80401660      2048         0     0.0%    irq
[CPU0] dump_tasks:   ----   ---     2 --- -------- ------- --- ------- ---------- ---------------- 0x80400e60      2048         0     0.0%    irq
[CPU0] dump_tasks:   ----   ---     3 --- -------- ------- --- ------- ---------- ---------------- 0x80400660      2048         0     0.0%    irq
[CPU0] dump_task:       0     0     0   0 FIFO     Kthread -   Running            0000000000000000 0x8040b010      3056       712    23.2%    CPU0 IDLE
[CPU0] dump_task:       1     0     1   0 FIFO     Kthread -   Running            0000000000000000 0x8040bc10      3056       528    17.2%    CPU1 IDLE
[CPU0] dump_task:       2     0     2   0 FIFO     Kthread -   Running            0000000000000000 0x8040c810      3056      2824    92.4%!   CPU2 IDLE
[CPU0] dump_task:       3     0     3   0 FIFO     Kthread -   Running            0000000000000000 0x8040d410      3056      3056   100.0%!   CPU3 IDLE</code></pre></div><h1 id="disable-smp"><a class="doc-anchor" href="#disable-smp">¬ß</a>21 Disable SMP</h1>
<p>https://github.com/lupyuen2/wip-nuttx/commit/6b321e1cd56bf74b0529711bfad62780291f841b</p>
<p>Remove these from defconfig:</p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_SMP=y
CONFIG_SMP_NCPUS=4</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/2823528f7b53375f080256bc798b2bf5">Apache NuttX RTOS on StarPro64: OSTest runs OK yay! (ESWIN EIC7700X)</a></p>
<p><a href="https://youtu.be/Yr7aYNIMUsw"><strong>Watch the Demo on YouTube</strong></a></p>
<p>Apache NuttX RTOS on StarPro64: Build Script</p>
<p>https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac</p>
<p>We could actually allow a Remote Developer to boot and test NuttX on StarPro64 ‚Ä¶ From anywhere in the world!</p>
<p><img src="https://lupyuen.org/images/starpro64-ostest.png" alt="TODO" /></p>
<h1 id="todo"><a class="doc-anchor" href="#todo">¬ß</a>22 TODO</h1>
<p>https://github.com/rockos-riscv</p>
<p>ü§î Booting #StarPro64 @ThePine64 (#RISCV #ESWIN EIC7700X)</p>
<p>Source: https://pine64.org/2024/10/02/september_2024/#starpro64</p>
<p>#RISCV ESWIN EIC7700X Technical Reference Manual (#StarPro64)</p>
<p>https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual</p>
<p>#RISCV #ESWIN EIC7700X: Qwen #LLM on NPU (#StarPro64)</p>
<p>Source: https://github.com/eswincomputing/eic7x-images/releases/download/Debian-v1.0.0-p550-20241230/ESWIN_AI_Sample_User_Guide.pdf</p>
<p>#RISCV #ESWIN EIC7700X: NPU Driver (#StarPro64)</p>
<p>https://github.com/eswincomputing/linux-stable/tree/linux-6.6.18-EIC7X/drivers/soc/eswin/ai_driver/npu</p>
<p><strong>llama.cpp</strong> <em>(C++)</em></p>
<p>https://github.com/ggml-org/llama.cpp</p>
<p>or <strong>ollama</strong> <em>(GoLang)</em></p>
<p>https://github.com/ollama/ollama/blob/main/model/models/llama/model.go</p>
<p><em>Qwen is an odd name innit?</em></p>
<p>Qwen will sound confusing to Bilingual Folks‚Ä¶</p>
<ul>
<li>
<p>It‚Äôs NOT supposed to rhyme with Gwen Stefani / Gwen Stacy</p>
</li>
<li>
<p>Instead it‚Äôs pronounced <strong>‚ÄúQ Wen‚Äù</strong></p>
</li>
<li>
<p>And it confuses me: <em>‚ÄúQ = Question‚Äù</em> and <em>‚ÄúWen = ÈóÆ = Question‚Äù</em>, thus contracting to <em>‚ÄúQQ‚Äù</em>, which means <em>‚ÄúBouncy‚Äù</em></p>
</li>
<li>
<p>Thankfully <em>‚ÄúQ Wen‚Äù</em> actually means something: <strong>‚ÄúÂçÉÈóÆ‚Äù</strong> <em>(Ask a Thousand Questions, ‚ÄúQian1 Wen4‚Äù)</em></p>
</li>
<li>
<p>Which is short for <strong>‚ÄúÈÄö‰πâÂçÉÈóÆ‚Äù</strong> <em>(Tong1 Yi4 Qian1 Wen4)</em>, meaning <a href="https://baike.baidu.com/item/%E9%80%9A%E4%B9%89/64394178"><strong>‚ÄúÈÄöÊÉÖÔºåËææ‰πâ‚Äù</strong></a></p>
</li>
</ul>
<span style="font-size:80%">
<p><em>(Here‚Äôs an idea for Sci-Fi Horror: We installed an LLM Sensor in a Remote Uninhabited Island. One day our LLM Sensor sends us sinister words: ‚ÄúEVIL‚Äù, ‚ÄúDEATH‚Äù, ‚ÄúDOOM‚Äù‚Ä¶)</em></p>
</span>
<p>southern islands of singapore
identify pic of creatures or sea life
rainforest critters or underwater creatures
in one word
‚ÄúDUCK‚Äù, ‚ÄúOCTOPUS‚Äù</p>
<p>strings
ghidra
npu driver
ollama</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>23 What‚Äôs Next</h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/starpro64.md"><strong>lupyuen.org/src/starpro64.md</strong></a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>