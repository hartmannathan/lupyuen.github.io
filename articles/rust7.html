<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust Standard Library on Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust Standard Library on Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust7-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/rust7.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust Standard Library on Apache NuttX RTOS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#compile-our-rust-hello-app" title="Compile our Rust Hello App">1 Compile our Rust Hello App</a><ul></ul></li>
<li><a href="#json-with-serde" title="JSON with Serde">2 JSON with Serde</a><ul></ul></li>
<li><a href="#async-functions-with-tokio" title="Async Functions with Tokio">3 Async Functions with Tokio</a><ul></ul></li>
<li><a href="#led-blinky-with-nix" title="LED Blinky with Nix">4 LED Blinky with Nix</a><ul></ul></li>
<li><a href="#owned-file-descriptors" title="Owned File Descriptors">5 Owned File Descriptors</a><ul></ul></li>
<li><a href="#nix-vs-rustix" title="Nix vs Rustix">6 Nix vs Rustix</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-rust-standard-library" title="Appendix: Build NuttX for Rust Standard Library">8 Appendix: Build NuttX for Rust Standard Library</a><ul></ul></li>
<li><a href="#appendix-tokio-async-threading" title="Appendix: Tokio Async Threading">9 Appendix: Tokio Async Threading</a><ul></ul></li>
<li><a href="#appendix-porting-nix-to-nuttx" title="Appendix: Porting Nix to NuttX">10 Appendix: Porting Nix to NuttX</a><ul></ul></li>
<li><a href="#appendix-snooping-tokio-on-nuttx" title="Appendix: Snooping Tokio on NuttX">11 Appendix: Snooping Tokio on NuttX</a><ul></ul></li></ul></nav><p>üìù <em>30 Jan 2025</em></p>
<p><img src="https://lupyuen.github.io/images/rust7-title.jpg" alt="TODO" /></p>
<p><strong>Freshly Baked:</strong> Here‚Äôs how we <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>Blink the LED</strong></a> with <strong>Rust Standard Library</strong> on <a href="TODO"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Open the LED Device for NuttX
</span><span class="kw">let </span>fd = open(      <span class="comment">// Equivalent to NuttX open()
  </span><span class="string">"/dev/userleds"</span>,  <span class="comment">// LED Device
  </span>OFlag::O_WRONLY,  <span class="comment">// Write Only
  </span>Mode::empty()     <span class="comment">// No Modes
</span>).unwrap();         <span class="comment">// Halt on Error

// Define the ioctl() function for Flipping LEDs
</span><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;  <span class="comment">// ioctl() Command
</span><span class="macro">ioctl_write_int_bad!</span>(  <span class="comment">// ioctl() will write One Int Value (LED Bit State)
  </span>led_set_all,         <span class="comment">// Name of our New Function
  </span>ULEDIOC_SETALL       <span class="comment">// ioctl() Command to send
</span>);

<span class="comment">// Flip LED 1 to On
</span><span class="kw">unsafe </span>{             <span class="comment">// Be careful of ioctl()
  </span>led_set_all(       <span class="comment">// Set the LEDs for...
    </span>fd.as_raw_fd(),  <span class="comment">// LED Device
    </span><span class="number">1                </span><span class="comment">// LED 1 (Bit 0) turns On
  </span>).unwrap();        <span class="comment">// Halt on Error
</span>}  <span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 1)

// Flip LED 1 to Off: ioctl(fd, ULEDIOC_SETALL, 0)
</span><span class="kw">unsafe </span>{ led_set_all(fd.as_raw_fd(), <span class="number">0</span>).unwrap(); }</code></pre></div>
<p>Which requires the <strong><code>nix</code> Rust Crate</strong> / Library‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Add the `nix` Rust Crate
## To our NuttX Rust App
$ cd apps/examples/rust/hello
$ cargo add nix --features fs,ioctl

Updating crates.io index
Adding nix v0.29.0 to dependencies
Features: + fs + ioctl</code></pre></div>
<p><em>(OK it‚Äôs more complicated. Stay tuned)</em></p>
<p>All this is now possible thanks to the awesome work by <a href="https://github.com/apache/nuttx-apps/pull/2487"><strong>Huang Qi</strong></a>! üéâ</p>
<h1 id="compile-our-rust-hello-app"><a class="doc-anchor" href="#compile-our-rust-hello-app">¬ß</a>1 Compile our Rust Hello App</h1>
<p>TODO: Instructions</p>
<p>TODO: Run our Rust Hello App</p>
<p>Some bits are a little wonky</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx-apps/pull/2487">examples: New app to build Rust with Cargo</a></p>
</li>
<li>
<p><a href="https://github.com/rust-lang/rust/pull/127755">Add NuttX based targets for RISC-V and ARM</a></p>
</li>
</ul>
<h1 id="json-with-serde"><a class="doc-anchor" href="#json-with-serde">¬ß</a>2 JSON with Serde</h1>
<p><em>What‚Äôs this Serde?</em></p>
<p>Think <em>‚ÄúSerialize-Deserialize‚Äù</em>. <a href="https://crates.io/crates/serde"><strong>Serde</strong></a> is a Rust Crate / Library for Serializing and Deserializing our Data Structures. Works with <a href="https://serde.rs/#data-formats"><strong>JSON, CBOR, MessagePack, ‚Ä¶</strong></a></p>
<p>This is how we <strong>Serialize to JSON</strong> in our NuttX App: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs">nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Allow Serde to Serialize and Deserialize a Person Struct
</span><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Person {
  name: String,  <span class="comment">// Containing a Name (string)
  </span>age:  u8,      <span class="comment">// And Age (uint8_t)
</span>}  <span class="comment">// Note: Rust Strings live in Heap Memory!

// Main Function of our Hello Rust App
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>hello_rust_cargo_main() {

  <span class="comment">// Create a Person Struct
  </span><span class="kw">let </span>john = Person {
    name: <span class="string">"John"</span>.to_string(),
    age:  <span class="number">30</span>,
  };

  <span class="comment">// Serialize our Person Struct
  </span><span class="kw">let </span>json_str = serde_json  <span class="comment">// Rust Struct
    </span>::to_string(<span class="kw-2">&amp;</span>john)  <span class="comment">// Becomes a String
    </span>.unwrap();          <span class="comment">// Halt on Error
  </span><span class="macro">println!</span>(<span class="string">"{}"</span>, json_str);</code></pre></div>
<p>This prints‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30}</code></pre></div>
<p>Now we <strong>Deserialize from JSON</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs">nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Declare a String with JSON inside
  </span><span class="kw">let </span>json_data = <span class="string">r#"
    {
      "name": "Alice",
      "age": 28
    }"#</span>;

  <span class="comment">// Deserialize our JSON String
  // Into a Person Struct
  </span><span class="kw">let </span>alice: Person = serde_json
    ::from_str(json_data)
    .unwrap();
  <span class="macro">println!</span>(<span class="string">"Deserialized: {} is {} years old"</span>,
    alice.name, alice.age);</code></pre></div>
<p>Which prints‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Deserialized: Alice is 28 years old</code></pre></div>
<p>Serde will also handle <strong>JSON Formatting</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs">nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// Serialize our Person Struct
  // But neatly please
  </span><span class="kw">let </span>pretty_json_str = serde_json
    ::to_string_pretty(<span class="kw-2">&amp;</span>alice)
    .unwrap();
  <span class="macro">println!</span>(<span class="string">"Pretty JSON:\n{}"</span>, pretty_json_str);</code></pre></div>
<p>Looks much neater!</p>
<div class="example-wrap"><pre class="language-bash"><code>Pretty JSON:
{
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;age&quot;: 28
}</code></pre></div>
<p><a href="https://bitboom.github.io/2020-10-22/serde-no-std">(Serde also runs on <strong>Rust Core Library</strong>, but super messy)</a></p>
<h1 id="async-functions-with-tokio"><a class="doc-anchor" href="#async-functions-with-tokio">¬ß</a>3 Async Functions with Tokio</h1>
<p><em>What‚Äôs this Tokio? Sounds like a city?</em></p>
<p>Indeed! ‚ÄúTokio‚Äù is inspired by Tokyo (and <a href="https://crates.io/crates/mio"><strong>Metal I/O</strong></a>)</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Tokio_(software)"><strong>Tokio</strong></a> ‚Ä¶ provides a runtime and functions that enable the use of Asynchronous I/O, allowing for Concurrency in regards to Task Completion</p>
</blockquote>
<p>Inside our <strong>Rust Hello App</strong>, this is how we we run <strong>Async Functions</strong> with Tokio: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs">nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Use One Single Thread (Current NuttX Thread)
// To schedule Async Functions
</span>tokio::runtime::Builder
  ::new_current_thread()  <span class="comment">// Current Thread is the Single-Threaded Scheduler
  </span>.enable_all()  <span class="comment">// Enable the I/O and Time Functions
  </span>.build()   <span class="comment">// Create the Single-Threaded Scheduler
  </span>.unwrap()  <span class="comment">// Halt on Error
  </span>.block_on( <span class="comment">// Start the Scheduler
    </span><span class="kw">async </span>{  <span class="comment">// With this Async Function
      </span><span class="macro">println!</span>(<span class="string">"Hello world from tokio!"</span>);
  });

<span class="comment">// Is it really async? Let's block and find out!
</span><span class="macro">println!</span>(<span class="string">"Looping Forever..."</span>);
<span class="kw">loop </span>{}</code></pre></div>
<p><a href="https://tokio.rs/tokio/topics/bridging">(Derived from <strong><code>#[tokio::main]</code></strong>)</a></p>
<p>Which prints‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
Hello world from tokio!
Looping Forever...</code></pre></div>
<p><em>Yawn. Tokio looks underwhelming?</em></p>
<p>Ah we haven‚Äôt seen the full power of <strong>Tokio Multi-Threaded Async Functions</strong> on NuttX!</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create
Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms
Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p>Check the Appendix for the <strong>Tokio Async Demo</strong>. That works beautifully on NuttX!</p>
<ul>
<li>TODO: test_async</li>
</ul>
<p><em>But NuttX has POSIX Threads. Why use Async Functions?</em></p>
<p>TODO: Threads vs Tasks vs Processes</p>
<p>TODO: NodeJS</p>
<p>(We‚Äôre not calling it <em>‚ÄúAsync Task‚Äù</em>. Because a Task in NuttX is more like a NuttX Process)</p>
<p><em>How would we use Tokio?</em></p>
<blockquote>
<p><a href="https://tokio.rs/tokio/tutorial"><strong>Tokio</strong></a> is designed for <strong>I/O-Bound Applications</strong> where each individual task spends most of its time waiting for I/O.</p>
</blockquote>
<p>Which means it‚Äôs great for <a href="https://tokio.rs/tokio/tutorial/io"><strong>Network Servers</strong></a>. Instead of spawning many many <strong>NuttX Threads</strong>‚Ä¶ We spawn a few threads and call <strong>Async Functions</strong>.</p>
<h1 id="led-blinky-with-nix"><a class="doc-anchor" href="#led-blinky-with-nix">¬ß</a>4 LED Blinky with Nix</h1>
<p><em>We‚Äôre running nix on NuttX?</em></p>
<p>Oh that‚Äôs <a href="https://crates.io/crates/nix"><strong><code>nix</code> Crate</strong></a> that provides <strong>Safer Rust Bindings</strong> for POSIX / Unix / Linux. (Nope, not NixOS)</p>
<p>This is how we add the library to our <strong>Rust Hello App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cd ../apps/examples/rust/hello
$ cargo add nix \
  --features fs,ioctl \
  --git https://github.com/lupyuen/nix.git \
  --branch nuttx

Updating git repository `https://github.com/lupyuen/nix.git`
Adding nix (git) to dependencies
Features: + fs + ioctl
34 deactivated features</code></pre></div>
<p><em>The URL looks a little sus?</em></p>
<p>Yep it‚Äôs our Bespoke <code>nix</code> Crate. That‚Äôs because the Official <code>nix</code> Crate doesn‚Äôt support NuttX yet. We made <a href="https://github.com/lupyuen/nix/pull/1/files"><strong>a few tweaks</strong></a> to compile on NuttX. <a href="TODO">(Details in the <strong>Appendix</strong>)</a></p>
<p><em>Why are we calling nix?</em></p>
<p>We‚Äôre <strong>Blinking the LED</strong> on NuttX. We could call the <a href="https://crates.io/crates/libc"><strong>POSIX API</strong></a> direcly from Rust‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fd = <span class="kw">unsafe </span>{ libc::open(<span class="string">"/dev/userleds"</span>, ...) };
<span class="kw">unsafe </span>{ libc::ioctl(fd, ULEDIOC_SETALL, <span class="number">1</span>); }
<span class="kw">unsafe </span>{ close(fd); }</code></pre></div>
<p>But it doesn‚Äôt look very‚Ä¶ Safe. That‚Äôs why we call the <strong>Safer POSIX Bindings</strong> provided by <code>nix</code> (tweaked for NuttX). Like so: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs">wip-nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Open the LED Device for NuttX
</span><span class="kw">let </span>fd = open(      <span class="comment">// Equivalent to NuttX open()
  </span><span class="string">"/dev/userleds"</span>,  <span class="comment">// LED Device
  </span>OFlag::O_WRONLY,  <span class="comment">// Write Only
  </span>Mode::empty()     <span class="comment">// No Modes
</span>).unwrap();         <span class="comment">// Halt on Error

// Define the ioctl() function for Flipping LEDs
</span><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;  <span class="comment">// ioctl() Command
</span><span class="macro">ioctl_write_int_bad!</span>(  <span class="comment">// ioctl() will write One Int Value (LED Bit State)
  </span>led_set_all,         <span class="comment">// Name of our New Function
  </span>ULEDIOC_SETALL       <span class="comment">// ioctl() Command to send
</span>);

<span class="comment">// Flip LED 1 to On
</span><span class="kw">unsafe </span>{             <span class="comment">// Be careful of ioctl()
  </span>led_set_all(       <span class="comment">// Set the LEDs for...
    </span>fd.as_raw_fd(),  <span class="comment">// LED Device
    </span><span class="number">1                </span><span class="comment">// LED 1 (Bit 0) turns On
  </span>).unwrap();        <span class="comment">// Halt on Error
</span>}  <span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 1)

// Flip LED 1 to Off: ioctl(fd, ULEDIOC_SETALL, 0)
</span><span class="kw">unsafe </span>{ led_set_all(fd.as_raw_fd(), <span class="number">0</span>).unwrap(); }</code></pre></div>
<p><em>ULEDIOC_SETALL looks familiar?</em></p>
<p>We spoke about <em>ULEDIOC_SETALL</em> in <a href="https://lupyuen.github.io/articles/rust6#blink-the-led"><strong>an earlier article</strong></a>. And the Rust Code above mirrors the <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85"><strong>C Version</strong></a> of our Blinky App.</p>
<p><em>How to run the Rust Blinky App?</em></p>
<ol>
<li>
<p>Copy the files from TODO‚Ä¶</p>
</li>
<li>
<p>Overwrite our <strong>Rust Hello App</strong>: <em>apps/examples/rust/hello</em></p>
</li>
<li>
<p><a href="TODO">Rebuild our <strong>NuttX Project</strong></a></p>
</li>
<li>
<p>Then run it with <strong>QEMU RISC-V Emulator</strong></p>
</li>
</ol>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p>QEMU Emulator shows the <strong>Emulated LED</strong> on NuttX.</p>
<p><a href="TODO">(What about <strong>Rust Embedded HAL</strong>?)</a></p>
<h1 id="owned-file-descriptors"><a class="doc-anchor" href="#owned-file-descriptors">¬ß</a>5 Owned File Descriptors</h1>
<p><strong>Safety Quiz:</strong> Why will this run OK‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Copied from above: Open the LED Device
</span><span class="kw">let </span>owned_fd = open(<span class="string">"/dev/userleds"</span>, OFlag::O_WRONLY, Mode::empty())
  .unwrap();  <span class="comment">// Returns an Owned File Descriptor
</span>...
<span class="comment">// Copied from above: Set the LEDs via ioctl()
</span>led_set_all(
  owned_fd.as_raw_fd(),  <span class="comment">// Borrow the Raw File Descriptor
  </span><span class="number">1                      </span><span class="comment">// Flip LED 1 to On
</span>).unwrap();              <span class="comment">// Yep runs OK</span></code></pre></div>
<p>But not this?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Fetch earlier the Raw File Descriptor (from the LED Device)
</span><span class="kw">let </span>raw_fd = open(<span class="string">"/dev/userleds"</span>, OFlag::O_WRONLY, Mode::empty())
  .unwrap()      <span class="comment">// Returns an Owned File Descriptor
  </span>.as_raw_fd();  <span class="comment">// Which becomes a Raw File Descriptor
</span>...
<span class="comment">// Set the LEDs via ioctl()
</span>led_set_all(
  raw_fd,    <span class="comment">// Use the earlier Raw File Descriptor
  </span><span class="number">1          </span><span class="comment">// Flip LED 1 to On
</span>).unwrap();  <span class="comment">// Oops will fail!</span></code></pre></div>
<p>The second snippet will fail with this <strong>EBADF Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:32:33:
called `Result::unwrap()` on an `Err` value: EBADF
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</code></pre></div>
<p>There‚Äôs something odd about <strong>Raw File Descriptors</strong> vs <strong>Owned File Descriptors</strong>‚Ä¶ Fetching the raw one too early might cause <strong>EBADF Errors</strong>. Here‚Äôs why‚Ä¶</p>
<p><em>What‚Äôs a Raw File Descriptor?</em></p>
<p>In NuttX and POSIX: <a href="https://github.com/apache/nuttx/blob/master/include/stdio.h#L65-L71"><strong>Raw File Descriptor</strong></a> is a <strong>Plain Integer</strong> that specifies an I/O Stream‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">File Descriptor</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: left">Standard Input</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: left">Standard Output</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left">Standard Error</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">/dev/userleds <br> <em>(assuming we opened it)</em></td></tr>
</tbody></table>
</div>
<p><em>What about Owned File Descriptor?</em></p>
<p>In Rust: <a href="https://doc.rust-lang.org/std/os/fd/struct.OwnedFd.html"><strong>Owned File Descriptor</strong></a> is a <strong>Rust Object</strong>, wrapped around a Raw File Descriptor.</p>
<p>And Rust Objects can be <strong>Automatically Dropped</strong>, when they go out of scope. (Unlike Integers)</p>
<p><em>Which causes the Second Snippet to fail?</em></p>
<p>Exactly! <em>open()</em> returns an <strong>Owned File Descriptor</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Open the LED Device
</span><span class="kw">let </span>raw_fd = open(<span class="string">"/dev/userleds"</span>, OFlag::O_WRONLY, Mode::empty())
  .unwrap()      <span class="comment">// Returns an Owned File Descriptor
  </span>.as_raw_fd();  <span class="comment">// Which becomes a Raw File Descriptor</span></code></pre></div>
<p>But we turned it into <strong>Raw File Descriptor</strong>. (The Plain Integer, not the Rust Object)</p>
<p>Oops! Our Owned File Descriptor goes <strong>out of scope</strong> and gets dropped by Rust.</p>
<p>Which means Rust will helpfully close <em>/dev/userleds</em>. Since it‚Äôs closed, the Raw File Descriptor <strong>becomes invalid</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Set the LEDs via ioctl()
</span>led_set_all(
  raw_fd,    <span class="comment">// Use the earlier Raw File Descriptor
  </span><span class="number">1          </span><span class="comment">// Flip LED 1 to On
</span>).unwrap();  <span class="comment">// Oops will fail with EBADF Error!</span></code></pre></div>
<p>Resulting in the <a href="https://man.freebsd.org/cgi/man.cgi?errno(2)"><strong>EBADF Error</strong></a>. <em>ioctl()</em> failed because <em>/dev/userleds</em> is already closed!</p>
<p><strong>Lesson Learnt:</strong> Be careful with Owned File Descriptors. They are super helpful for auto-closing our files. But might have strange consequences.</p>
<h1 id="nix-vs-rustix"><a class="doc-anchor" href="#nix-vs-rustix">¬ß</a>6 Nix vs Rustix</h1>
<p><em>Is there a safer way to call ioctl()?</em></p>
<p>Calling <em>ioctl()</em> from Rust will surely get messy: It‚Äôs an <strong>Unsafe Call</strong> that might cause bad writes into the NuttX Kernel! (If we‚Äôre not careful)</p>
<p>At the top of the article, we saw <strong><code>nix</code></strong> crate calling <em>ioctl()</em>. Now we look at <a href="TODO"><strong>Rustix</strong></a> calling <em>ioctl()</em>: <a href="https://github.com/bytecodealliance/rustix/blob/main/src/fs/ioctl.rs#L16-L32">rustix/fs/ioctl.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// In Rustix: ioctl() is also unsafe
</span><span class="kw">unsafe </span>{
  <span class="comment">// Create an "Ioctl Getter"
  // That will read data thru ioctl()
  </span><span class="kw">let </span>ctl = ioctl::Getter::&lt;  <span class="comment">// Ioctl Getter has 2 attributes...
    </span>ioctl::BadOpcode&lt;  <span class="comment">// Attribute #1: Ioctl Command Code
      </span>{ c::BLKSSZGET } <span class="comment">// Which is "Fetch the Logical Block Size of a Block Device"
    </span>&gt;,
    c::c_uint  <span class="comment">// Attribute #2: Ioctl Getter will read a uint32_t thru ioctl()
  </span>&gt;::new();    <span class="comment">// Create the Ioctl Getter

  // Now that we have the Ioctl Getter
  // We call ioctl() on the File Descriptor
  // Equivalent to: ioctl(fd, BLKSSZGET, &amp;output) ; return output
  </span>ioctl::ioctl(
    fd,  <span class="comment">// File Descriptor
    </span>ctl  <span class="comment">// Ioctl Getter
  </span>) <span class="comment">// Returns the Value Read (Or Error)
</span>}</code></pre></div>
<p><a href="https://docs.rs/rustix/latest/rustix/ioctl/index.html">(Based on the <strong>Rustix Docs</strong>)</a></p>
<p>TODO: Nix vs Rustix</p>
<p>Updated nix</p>
<div class="example-wrap"><pre class="language-text"><code>Implement I/O Safety #1750
https://github.com/nix-rust/nix/issues/1750

Feature Name: io_safety
https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md</code></pre></div><h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>7 What‚Äôs Next</h1>
<p><em>Which platforms are supported for NuttX + Rust Standard Library?</em></p>
<p>Arm and RISC-V (32-bit and 64-bit). <a href="https://nuttx.apache.org/docs/latest/guides/rust.html"><strong>Check this article</strong></a> for updates.</p>
<p><em>Will it run on a RISC-V SBC?</em></p>
<p>Sorry 64-bit <strong>RISC-V Kernel Mode</strong> is <a href="https://github.com/apache/nuttx-apps/pull/2487#issuecomment-2601488835"><strong>not supported yet</strong></a>.</p>
<p><em>How to test?</em></p>
<p>TODO: Build Farm? Docker? How to bisect</p>
<p>Next Article: Why <strong>Sync-Build-Ingest</strong> is super important for NuttX Continuous Integration. And how we monitor it with our <strong>Magic Disco Light</strong>.</p>
<p>After That: Since we can <strong>Rewind NuttX Builds</strong> and automatically <strong>Git Bisect</strong>‚Ä¶ Can we create a Bot that will fetch the <strong>Failed Builds from NuttX Dashboard</strong>, identify the Breaking PR, and escalate to the right folks?</p>
<p>Many Thanks to the awesome <strong>NuttX Admins</strong> and <strong>NuttX Devs</strong>! And <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a>, for sticking with me all these years.</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/rust7.md"><strong>lupyuen.org/src/rust7.md</strong></a></p>
<h1 id="appendix-build-nuttx-for-rust-standard-library"><a class="doc-anchor" href="#appendix-build-nuttx-for-rust-standard-library">¬ß</a>8 Appendix: Build NuttX for Rust Standard Library</h1>
<p>TODO: Prerequisite</p>
<div class="example-wrap"><pre class="language-text"><code></code></pre></div><div class="example-wrap"><pre class="language-bash"><code>## Install Rust: https://rustup.rs/
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
## Select Standard Installation 
. &quot;$HOME/.cargo/env&quot;

## error: the `-Z` flag is only accepted on the nightly channel of Cargo, but this is the `stable` channel
rustup update
rustup toolchain install nightly
rustup default nightly
rustc --version

## error: &quot;.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/Cargo.lock&quot; does not exist, unable to build with the standard library, try: rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu

## Download the NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure NuttX for RISC-V 64-bit QEMU with LEDs
## (Alternatively: rv-virt:nsh64 or rv-virt:nsh or rv-virt:leds)
tools/configure.sh rv-virt:leds64

## error: Error loading target specification: Could not find specification for target &quot;riscv64imafdc-unknown-nuttx-elf&quot;. Run `rustc --print target-list` for a list of built-in targets

## Disable Floating Point: CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Enable CONFIG_SYSTEM_TIME64 / CONFIG_FS_LARGEFILE / CONFIG_DEV_URANDOM / CONFIG_TLS_NELEM = 16
kconfig-tweak --enable CONFIG_SYSTEM_TIME64
kconfig-tweak --enable CONFIG_FS_LARGEFILE
kconfig-tweak --enable CONFIG_DEV_URANDOM
kconfig-tweak --set-val CONFIG_TLS_NELEM 16

## Enable the Hello Rust Cargo App
## Increase the App Stack Size from 2 KB to 16 KB (especially for 64-bit platforms)
kconfig-tweak --enable CONFIG_EXAMPLES_HELLO_RUST_CARGO
kconfig-tweak --set-val CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE 16384

## Update the Kconfig Dependencies
make olddefconfig

## Build NuttX
make -j

## If it fails with &quot;Mismatched Types&quot;:
## Patch the file `fs.rs` (see below)

## Start NuttX on QEMU RISC-V 64-bit
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Inside QEMU: Run our Hello Rust App
hello_rust_cargo</code></pre></div>
<p>We‚Äôll see this inside QEMU Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6985933271f140db0dc6172ebba9bff5">(See the <strong>Ubuntu Build Log</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/a2b91b5cc15824a31c287fbb6cda5fa2">(See the <strong>macOS Build Log</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/ccfae733657b864f2f9a24ce41808144">(Also works for <strong>rv-virt:leds</strong>)</a></p>
<hr>
<p><strong>Troubleshooting The Rust Build</strong></p>
<ul>
<li>
<p>If the build fails with <strong>‚ÄúMismatched Types‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  Compiling std v0.0.0 (.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std)
error[E0308]: mismatched types
    --&gt; .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs:1037:33
    |
1037 |         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }
    |                  -------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const u8`, found `*const i8`
    |                  |
    |                  arguments to this function are incorrect
    |
    = note: expected raw pointer `*const u8`
                found raw pointer `*const i8`
note: associated function defined here
    --&gt; .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ffi/c_str.rs:264:25
    |
264  |     pub const unsafe fn from_ptr&lt;&#39;a&gt;(ptr: *const c_char) -&gt; &amp;&#39;a CStr {
    |                         ^^^^^^^^</code></pre></div>
<p>Then edit this file‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu
$HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs

$HOME/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs
## For macOS</code></pre></div>
<p>Change this function (line TODO)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">fn </span>name_cstr(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>CStr {
        <span class="kw">unsafe </span>{ CStr::from_ptr(<span class="self">self</span>.entry.d_name.as_ptr()) }
    }</code></pre></div>
<p>To this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">fn </span>name_cstr(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>CStr {
        <span class="kw">unsafe </span>{ CStr::from_ptr(<span class="self">self</span>.entry.d_name.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span>u8) }
    }</code></pre></div>
<p>And verify the change‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu
head -n 1049 $HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs \
  | tail -n 17

## For macOS
head -n 1049 $HOME/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs \
  | tail -n 17

## We should see
## fn name_cstr(&amp;self) -&gt; &amp;CStr {
##   unsafe { CStr::from_ptr(self.entry.d_name.as_ptr() as *const u8) }</code></pre></div>
<p>Then rebuild with <code>make -j</code></p>
</li>
</ul>
<p>TODO: Stack Overflow</p>
<div class="example-wrap"><pre class="language-text"><code>dump_tasks:    PID GROUP PRI POLICY   TYPE    NPX STATE   EVENT      SIGMASK          STACKBASE  STACKSIZE      USED   FILLED    COMMAND
dump_tasks:   ----   --- --- -------- ------- --- ------- ---------- ---------------- 0x8006bbc0      2048      1016    49.6%    irq
dump_task:       0     0   0 FIFO     Kthread -   Ready              0000000000000000 0x8006e7f0      1904       888    46.6%    Idle_Task
dump_task:       1     1 100 RR       Task    -   Waiting Semaphore  0000000000000000 0x8006fd38      2888      1944    67.3%    nsh_main
dump_task:       3     3 100 RR       Task    -   Running            0000000000000000 0x80071420      1856      1856   100.0%!   hello_rust_cargo
QEMU: Terminated</code></pre></div>
<p><em>What if we‚Äôre using Rust already? And we don‚Äôt wish to change the Default Toolchain?</em></p>
<p>Use <code>rustup override</code> to <strong>Override the Toolchain</strong>. Do it in the <strong>Parent Folder</strong> of <code>nuttx</code> and <code>apps</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set Rust to Nightly Build
## Apply this to the Parent Folder
## So it will work for `nuttx` and `apps`
pushd ..
rustup override list
rustup override set nightly
rustup override list
popd</code></pre></div>
<p><em>Rust Build seems to break sometimes?</em></p>
<p>We might need to clean up the <strong>Rust Compiled Files</strong>, if the Rust Build goes wonky‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Erase the Rust Build
pushd ../apps/examples/rust/hello
cargo clean
popd</code></pre></div><h1 id="appendix-tokio-async-threading"><a class="doc-anchor" href="#appendix-tokio-async-threading">¬ß</a>9 Appendix: Tokio Async Threading</h1>
<p>Earlier we saw Tokio‚Äôs <strong>Single-Threaded Scheduler</strong>, running on the <strong>Current NuttX Thread</strong>‚Ä¶</p>
<ul>
<li>TODO</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Use One Single Thread (Current NuttX Thread)
// To schedule Async Functions
</span>tokio::runtime::Builder
  ::new_current_thread()  <span class="comment">// Current Thread is the Single-Threaded Scheduler
  </span>.enable_all()  <span class="comment">// Enable the I/O and Time Functions
  </span>.build()   <span class="comment">// Create the Single-Threaded Scheduler
  </span>.unwrap()  <span class="comment">// Halt on Error
  </span>.block_on( <span class="comment">// Start the Scheduler
    </span><span class="kw">async </span>{  <span class="comment">// With this Async Function
      </span><span class="macro">println!</span>(<span class="string">"Hello world from tokio!"</span>);
  });

<span class="comment">// Is it really async? Let's block and find out!
</span><span class="macro">println!</span>(<span class="string">"Looping Forever..."</span>);
<span class="kw">loop </span>{}</code></pre></div>
<p>Which isn‚Äôt terribly exciting‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
Hello world from tokio!
Looping Forever...</code></pre></div>
<p>Now we try Tokio‚Äôs <strong>Multi-Threaded Scheduler</strong>. And we create <strong>One New NuttX Thread</strong> for the Scheduler: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs">wip-nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Run 4 Async Functions in the Background
// By creating One New NuttX Thread
// Based on https://tokio.rs/tokio/topics/bridging
</span><span class="kw">fn </span>test_async() {

  <span class="comment">// Create a Multi-Threaded Scheduler
  // Containing One New NuttX Thread
  </span><span class="kw">let </span>runtime = tokio::runtime::Builder
    ::new_multi_thread() <span class="comment">// Multi-Threaded Scheduler
    </span>.worker_threads(<span class="number">1</span>)   <span class="comment">// With One New NuttX Thread for our Scheduler
    </span>.enable_all() <span class="comment">// Enable the I/O and Time Functions
    </span>.build()      <span class="comment">// Create the Multi-Threaded Scheduler
    </span>.unwrap();    <span class="comment">// Halt on Error

  // Create 4 Async Functions
  // Remember their Async Handles
  </span><span class="kw">let </span><span class="kw-2">mut </span>handles = Vec::with_capacity(<span class="number">4</span>);
  <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">4 </span>{
    handles.push(        <span class="comment">// Remember the Async Handles
      </span>runtime.spawn(     <span class="comment">// Start in the Background
        </span>my_bg_task(i))); <span class="comment">// Our Async Function
  </span>}

  <span class="comment">// Pretend to be busy while Async Functions execute (in the background)
  // We wait 750 milliseconds
  </span>std::thread::sleep(
    tokio::time::Duration::from_millis(<span class="number">750</span>));
  <span class="macro">println!</span>(<span class="string">"Finished time-consuming task."</span>);

  <span class="comment">// Wait for All Async Functions to complete
  </span><span class="kw">for </span>handle <span class="kw">in </span>handles {
    runtime
      .block_on(handle)  <span class="comment">// Wait for One Async Function to complete
      </span>.unwrap();
  }
}

<span class="comment">// Our Async Function that runs in the background...
// If i=0: Sleep for 1000 ms
// If i=1: Sleep for  950 ms
// If i=2: Sleep for  900 ms
// If i=3: Sleep for  850 ms
</span><span class="kw">async fn </span>my_bg_task(i: u64) {
  <span class="kw">let </span>millis = <span class="number">1000 </span>- <span class="number">50 </span>* i;
  <span class="macro">println!</span>(<span class="string">"Task {} sleeping for {} ms."</span>, i, millis);
  tokio::time::sleep(
    tokio::time::Duration::from_millis(millis)
  ).<span class="kw">await</span>;  <span class="comment">// Wait for sleep to complete
  </span><span class="macro">println!</span>(<span class="string">"Task {} stopping."</span>, i);
}

<span class="comment">// Needed by Tokio Multi-Threaded Scheduler
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>pthread_set_name_np() {}</code></pre></div>
<p>Which shows</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create
Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms
Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/46db6d1baee0e589774cc43dd690da07">(See the <strong>Complete Log</strong>)</a></p>
<p>TODO: <a href="https://tokio.rs/tokio/topics/bridging">Bridging with sync code</a></p>
<p><em>What if we increase the Worker Threads? From 1 to 2?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Two Worker Threads instead of One
</span><span class="kw">let </span>runtime = tokio::runtime::Builder
  ::new_multi_thread() <span class="comment">// New Multi-Threaded Scheduler
  </span>.worker_threads(<span class="number">2</span>)   <span class="comment">// With Two New NuttX Threads for our Scheduler</span></code></pre></div>
<p>TODO: Not much difference?</p>
<div class="example-wrap"><pre class="language-text"><code>pthread_create: pthread_entry=0x80048f10, arg=0x800873e8
nx_pthread_create: entry=0x80048f10, arg=0x800873e8
pthread_create: pthread_entry=0x80048f10, arg=0x80287830
nx_pthread_create: entry=0x80048f10, arg=0x80287830
Task 0 sleeping for 1000 ms.
Task 1 sleeping for 950 ms.
Task 2 sleeping for 900 ms.
Task 3 sleeping for 850 ms.
Finished time-consuming task.
Task 3 stopping.
Task 2 stopping.
Task 1 stopping.
Task 0 stopping.
nsh&gt; </code></pre></div>
<p>TODO: pthread_create</p>
<div class="example-wrap"><pre class="language-text"><code>https://github.com/lupyuen2/wip-nuttx/blob/master/fs/vfs/fs_ioctl.c#L263-L264

#include &lt;debug.h&gt;////
int ioctl(int fd, int req, ...)
{
  // _info(&quot;fd=0x%x, req=0x%x&quot;, fd, req);////


https://github.com/lupyuen2/wip-nuttx/blob/master/libs/libc/pthread/pthread_create.c#L93

#include &lt;debug.h&gt;////
int pthread_create(FAR pthread_t *thread, FAR const pthread_attr_t *attr,
                   pthread_startroutine_t pthread_entry, pthread_addr_t arg)
{
  _info(&quot;pthread_entry=%p, arg=%p&quot;, pthread_entry, arg);////

https://github.com/lupyuen2/wip-nuttx/blob/master/sched/pthread/pthread_create.c#L34

#include &lt;debug.h&gt;////
int nx_pthread_create(pthread_trampoline_t trampoline, FAR pthread_t *thread,
                      FAR const pthread_attr_t *attr,
                      pthread_startroutine_t entry, pthread_addr_t arg)
{
  _info(&quot;entry=%p, arg=%p&quot;, entry, arg);////
</code></pre></div><h1 id="appendix-porting-nix-to-nuttx"><a class="doc-anchor" href="#appendix-porting-nix-to-nuttx">¬ß</a>10 Appendix: Porting Nix to NuttX</h1>
<p>TODO: Redox, BSD not Linux, PR</p>
<p><em>What happens when we call nix crate as-is on NuttX?</em></p>
<p>TODO</p>
<div class="example-wrap"><pre class="language-bash"><code>$ pushd ../apps/examples/rust/hello
$ cargo add nix --features fs,ioctl
Adding nix v0.29.0 to dependencies
Features: + fs + ioctl
33 deactivated features

$ popd
$ make -j

error[E0432]: unresolved import `self::const](TODO)

  --&gt;   [errno.rs:19:15
   |
19 | pub use self::consts::*;
   |               ^^^^^^ could not find `consts` in `self`

error[E0432]: unresolved import `self::Errn](TODO)

   --&gt;  [errno.rs:198:15
    |
198 |     use self::Errno::*;
    |               ^^^^^ could not find `Errno` in `self`

error[E0432]: unresolved import `crate::errno::Errn](TODO)

 --&gt;  [fcntl.rs:2:5
  |
2 | use crate::errno::Errno;
  |     ^^^^^^^^^^^^^^-----
  |     |             |
  |     |             help: a similar name exists in the module: `errno`
  |     no `Errno` in `errno`

error[E0432]: unresolved import `crate::errno::Errn](TODO)

 --&gt;  [sys/signal.rs:6:5
  |
6 | use crate::errno::Errno;
  |     ^^^^^^^^^^^^^^-----
  |     |             |
  |     |             help: a similar name exists in the module: `errno`
  |     no `Errno` in `errno`

error[E0432]: unresolved import `crate::errno::Errn](TODO)

 --&gt;  [unistd.rs:3:5
  |
3 | use crate::errno::Errno;
  |     ^^^^^^^^^^^^^^-----
  |     |             |
  |     |             help: a similar name exists in the module: `errno`
  |     no `Errno` in `errno`

error[E0432]: unresolved import `errno::Errn](TODO)

   --&gt;  [lib.rs:194:5
    |
194 | use errno::Errno;
    |     ^^^^^^^-----
    |     |      |
    |     |      help: a similar name exists in the module: `errno`
    |     no `Errno` in `errno`</code></pre></div>
<p>TODO: Fix nix</p>
<ol>
<li>
<p>We modified <a href="TODO">src/errno.rs</a>, copying FreeBSD <code>#[cfg(target_os = "freebsd")]</code> to NuttX <code>#[cfg(target_os = "nuttx")]</code></p>
</li>
<li>
<p>NuttX seems to have a similar POSIX Profile to <strong>Redox OS</strong>? That‚Äôs why a lot of the modded code looks like this: <a href="TODO">src/sys/time.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[cfg(not(any(target_os = <span class="string">"redox"</span>, target_os=<span class="string">"nuttx"</span>)))]
</span><span class="kw">pub const </span>UTIME_OMIT: TimeSpec = ...

<span class="attr">#[cfg(not(any(target_os = <span class="string">"redox"</span>, target_os = <span class="string">"nuttx"</span>)))]
</span><span class="kw">pub const </span>UTIME_NOW: TimeSpec = ...</code></pre></div>
</li>
<li>
<p><strong>For NuttX ioctl():</strong> It works more like BSD (second parameter is <code>int</code>) than Linux (second parameter is <code>long</code>): <a href="TODO">sys/ioctl/mod.rs</a></p>
<p>TODO</p>
</li>
<li>
<p>Here are all the files we modified for NuttX‚Ä¶</p>
<p>(Supporting <code>fs</code> and <code>ioctl</code> features only)</p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files">All Modified Files</a></p>
<p><a href="TODO">errno.rs</a></p>
<p><a href="TODO">sys/time.rs</a></p>
<p><a href="TODO">fcntl.rs</a></p>
<p><a href="TODO">unistd.rs</a></p>
<p><a href="TODO">sys/stat.rs</a></p>
<p><a href="TODO">sys/statvfs.rs</a></p>
<p><a href="TODO">sys/mod.rs</a></p>
<p><a href="TODO">sys/ioctl/mod.rs</a></p>
<p><a href="TODO">sys/ioctl/bsd.rs</a></p>
</li>
</ol>
<hr>
<p><strong>Troubleshooting nix ioctl() on NuttX</strong></p>
<p>To figure out if nix passes ioctl() parameters correctly to NuttX: We insert <strong>ioctl() Debug Code</strong> into NuttX Kernel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>TODO
riscv/nuttx/fs/vfs/fs_ioctl.c
#include &lt;debug.h&gt;
int ioctl(int fd, int req, ...) {
  _info(&quot;fd=0x%x, req=0x%x&quot;, fd, req);////</code></pre></div>
<p>Which <a href="https://docs.rs/nix/latest/nix/sys/ioctl/"><strong>Ioctl Macro</strong></a> shall we use in nix? We tried <strong>ioctl_none!</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;
<span class="macro">ioctl_none!</span>(led_on, ULEDIOC_SETALL, <span class="number">1</span>);
<span class="kw">unsafe </span>{ led_on(fd).unwrap(); }</code></pre></div>
<p>But the <strong>ioctl() Command Code</strong> got mangled up (<code>0x201d0301</code> should be <code>0x1d03</code>)</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
fd=3
ioctl: fd=0x3, req=0x201d0301

thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:31:25:
called `Result::unwrap()` on an `Err` value: ENOTTY
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</code></pre></div>
<p>Then we tried <strong>ioctl_write_int!</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;
<span class="macro">ioctl_write_int!</span>(led_on, ULEDIOC_SETALL, <span class="number">1</span>);
<span class="kw">unsafe </span>{ led_on(fd, <span class="number">1</span>).unwrap(); }</code></pre></div>
<p>Nope the <strong>ioctl() Command Code</strong> is still mangled (<code>0x801d0301</code> should be <code>0x1d03</code>)</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
ioctl: fd=0x3, req=0x801d0301
thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:30:28:
called `Result::unwrap()` on an `Err` value: ENOTTY</code></pre></div>
<p>Finally this works: <strong>ioctl_write_int_bad!</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;
<span class="macro">ioctl_write_int_bad!</span>(led_set_all, ULEDIOC_SETALL);

<span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 1)
</span><span class="kw">unsafe </span>{ led_set_all(fd, <span class="number">1</span>).unwrap(); }

<span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 0)
</span><span class="kw">unsafe </span>{ led_set_all(fd, <span class="number">0</span>).unwrap(); }</code></pre></div>
<p><strong>ioctl() Command Code</strong> <code>0x1d03</code> is hunky dory yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
fd=3
ioctl: fd=0x3, req=0x1d03
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
ioctl: fd=0x3, req=0x1d03
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0</code></pre></div><h1 id="appendix-snooping-tokio-on-nuttx"><a class="doc-anchor" href="#appendix-snooping-tokio-on-nuttx">¬ß</a>11 Appendix: Snooping Tokio on NuttX</h1>
<p>In this section, we discover how <strong>Tokio works under the hood</strong>. Does it really call <strong>POSIX Functions in NuttX</strong>?</p>
<p>First we obtain the <strong>RISC-V Disassembly</strong> of our NuttX Image, bundled with the Hello Rust App. We trace the NuttX Build: Run <code>make V=1</code> on <code>rv-virt:leds64</code></p>
<div class="example-wrap"><pre class="language-bash"><code>make distclean
tools/configure.sh rv-virt:leds64
## Disable CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU
## Enable CONFIG_SYSTEM_TIME64 / CONFIG_FS_LARGEFILE / CONFIG_DEV_URANDOM / CONFIG_TLS_NELEM = 16
kconfig-tweak --enable CONFIG_SYSTEM_TIME64
kconfig-tweak --enable CONFIG_FS_LARGEFILE
kconfig-tweak --enable CONFIG_DEV_URANDOM
kconfig-tweak --set-val CONFIG_TLS_NELEM 16
## Enable Hello Rust Cargo App
kconfig-tweak --enable CONFIG_EXAMPLES_HELLO_RUST_CARGO
## For knsh64
kconfig-tweak --set-val CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE 16384
## Update the Kconfig Dependencies
make olddefconfig
## Build NuttX
make V=1</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b8f051c25e872fb8a444559c3dbf6374">(See the <strong>Build Log</strong>)</a></p>
<p>According to the <code>make V=1</code> trace: <strong>NuttX Build</strong> does this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Discard the Rust Debug Symbols
cd apps/examples/rust/hello
cargo build \
  --release \
  -Zbuild-std=std,panic_abort \
  --manifest-path apps/examples/rust/hello/Cargo.toml \
  --target riscv64imac-unknown-nuttx-elf

## Generate the Linker Script
riscv-none-elf-gcc \
  -E \
  -P \
  -x c \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script \
  -o  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp

## Link Rust App into NuttX
riscv-none-elf-ld \
  --entry=__start \
  -melf64lriscv \
  --gc-sections \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx.map \
  --print-memory-usage \
  -Tnuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp  \
  -L nuttx/staging \
  -L nuttx/arch/risc-v/src/board  \
  -o nuttx/nuttx   \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lm \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard xpack-riscv-none-elf-gcc-13.2.0-2/lib/gcc/riscv-none-elf/13.2.0/rv64imac/lp64/libgcc.a apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/release/libhello.a \
  --end-group</code></pre></div>
<p>Ah NuttX Build calls <code>cargo build --release</code>, which will strip the Debug Symbols. We change it to <code>cargo build</code> and dump the RISC-V Disassembly‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Preserve the Rust Debug Symbols
pushd ../apps/examples/rust/hello
cargo build \
  -Zbuild-std=std,panic_abort \
  --manifest-path apps/examples/rust/hello/Cargo.toml \
  --target riscv64imac-unknown-nuttx-elf
popd

## Generate the Linker Script
riscv-none-elf-gcc \
  -E \
  -P \
  -x c \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script \
  -o  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp

## Link Rust App into NuttX
riscv-none-elf-ld \
  --entry=__start \
  -melf64lriscv \
  --gc-sections \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx.map \
  --print-memory-usage \
  -Tnuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp  \
  -L nuttx/staging \
  -L nuttx/arch/risc-v/src/board  \
  -o nuttx/nuttx   \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lm \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard xpack-riscv-none-elf-gcc-13.2.0-2/lib/gcc/riscv-none-elf/13.2.0/rv64imac/lp64/libgcc.a apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/debug/libhello.a \
  --end-group

## Dump the disassembly to nuttx.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;leds64-debug-nuttx.S \
  2&gt;&amp;1</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/7b52d54725aaa831cb3dddc0b68bb41f">(See the <strong>Build Log</strong>)</a></p>
<p>Which produces the Complete NuttX Disassembly: <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/leds64-debug-nuttx.S"><strong>leds64-debug-nuttx.S</strong></a></p>
<p>Whoa the Complete NuttX Disassembly is too huge to inspect!</p>
<p>We dump the RISC-V Disassembly of the <strong>Rust Part</strong> only: <strong>libhello.a</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the libhello.a disassembly to libhello.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/debug/libhello.a \
  &gt;libhello.S \
  2&gt;&amp;1</code></pre></div>
<p>Which produces the Rust Disassembly: <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/libhello.S"><strong>libhello.S</strong></a></p>
<p>Is Tokio calling NuttX to create POSIX Threads? We search <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/libhello.S"><strong>libhello.S</strong></a> for <strong>pthread_create</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/thread.rs:85
            assert_eq!(libc::pthread_attr_setstacksize(&amp;mut attr, stack_size), 0);
        }
    };
}

let ret = libc::pthread_create(&amp;mut native, &amp;attr, thread_start, p as *mut _);

 122: 00000517           auipc a0,0x0 122: R_RISCV_PCREL_HI20 std::sys::pal::unix::thread::Thread::new::thread_start
 126: 00050613           mv a2,a0 126: R_RISCV_PCREL_LO12_I .Lpcrel_hi254
 12a: 0148                 add a0,sp,132
 12c: 012c                 add a1,sp,136
 12e: f82e                 sd a1,48(sp)
 130: 00000097           auipc ra,0x0 130: R_RISCV_CALL_PLT pthread_create
 134: 000080e7           jalr ra # 130 &lt;.Lpcrel_hi254+0xe&gt;
 138: 85aa                 mv a1,a0
 13a: 7542                 ld a0,48(sp)
 13c: 862e                 mv a2,a1
 13e: fc32                 sd a2,56(sp)
 140: 1eb12e23           sw a1,508(sp)</code></pre></div>
<p>OK that‚Äôs the <a href="https://doc.rust-lang.org/src/std/sys/pal/unix/thread.rs.html#84"><strong>Rust Standard Library</strong></a> calling <strong>pthread_create</strong> to create a new Rust Thread.</p>
<p>How are Rust Threads created in Rust Standard Library? Like this: <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/thread/mod.rs#L502">std/thread/mod.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// spawn_unchecked_ creates a new Rust Thread
</span><span class="kw">unsafe fn </span>spawn_unchecked_&lt;<span class="lifetime">'scope</span>, F, T&gt;(
    <span class="kw">let </span>my_thread = Thread::new(id, name);</code></pre></div>
<p>And <strong>spawn_unchecked</strong> is called by Tokio, according to our Rust Disassembly‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Disassembly of section .text._ZN4core3ptr164drop_in_place$LT$std..thread..Builder..spawn_unchecked_..MaybeDangling$LT$tokio..runtime..blocking..pool..Spawner..spawn_thread..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$17hdb2d2ae6bc31ecdfE:

0000000000000000 &lt;core::ptr::drop_in_place&lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}&gt;&gt;&gt;:
core::ptr::drop_in_place&lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}&gt;&gt;:
.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:523
   0: 1141                 add sp,sp,-16
   2: e406                 sd ra,8(sp)
   4: e02a                 sd a0,0(sp)
   6: 00000097           auipc ra,0x0 6: R_RISCV_CALL_PLT &lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;T&gt; as core::ops::drop::Drop&gt;::drop
   a: 000080e7           jalr ra # 6 &lt;core::ptr::drop_in_place&lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}&gt;&gt;+0x6&gt;
   e: 60a2                 ld ra,8(sp)
  10: 0141                 add sp,sp,16
  12: 8082                 ret</code></pre></div>
<p>Yep it checks out: Tokio calls Rust Standard Library, which calls NuttX to create POSIX Threads!</p>
<p><em>Are we sure that Tokio creates a POSIX Thread? Not a NuttX Task?</em></p>
<p>We run <code>hello_rust_cargo &amp;</code> to put in the background‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo &amp;
Hello world from tokio!

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK            STACK    USED FILLED COMMAND
    0     0   0 FIFO     Kthread   - Ready              0000000000000000 0001904 0000712  37.3%  Idle_Task
    2     2 100 RR       Task      - Running            0000000000000000 0002888 0002472  85.5%! nsh_main
    4     4 100 RR       Task      - Ready              0000000000000000 0007992 0006904  86.3%! hello_rust_cargo</code></pre></div>
<p><code>ps</code> says that there‚Äôs only One Single NuttX Task <code>hello_rust_cargo</code>. And no other NuttX Tasks.</p>
<p><a href="https://gist.github.com/lupyuen/0377d9e015fee1d6a833c22e1b118961">(See the <strong>Complete Log</strong>)</a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>