<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust Standard Library on Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust Standard Library on Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content="Rust Standard Library is now available on Apache NuttX RTOS, thanks to awesome work by Huang Qi! In this article we explain (1) How to build NuttX + Rust Standard Library (2) Handling JSON with the Serde Crate (3) Async Functions with the Tokio Crate (4) Blinking LEDs with the Nix Crate"
    data-rh="true">
<meta name="description" 
    content="Rust Standard Library is now available on Apache NuttX RTOS, thanks to awesome work by Huang Qi! In this article we explain (1) How to build NuttX + Rust Standard Library (2) Handling JSON with the Serde Crate (3) Async Functions with the Tokio Crate (4) Blinking LEDs with the Nix Crate">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust7-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/rust7.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust Standard Library on Apache NuttX RTOS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#compile-our-rust-hello-app" title="Compile our Rust Hello App">1 Compile our Rust Hello App</a><ul></ul></li>
<li><a href="#json-with-serde" title="JSON with Serde">2 JSON with Serde</a><ul></ul></li>
<li><a href="#async-functions-with-tokio" title="Async Functions with Tokio">3 Async Functions with Tokio</a><ul></ul></li>
<li><a href="#led-blinky-with-nix" title="LED Blinky with Nix">4 LED Blinky with Nix</a><ul></ul></li>
<li><a href="#owned-file-descriptors" title="Owned File Descriptors">5 Owned File Descriptors</a><ul></ul></li>
<li><a href="#nix-vs-rustix" title="Nix vs Rustix">6 Nix vs Rustix</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-rust-standard-library" title="Appendix: Build NuttX for Rust Standard Library">8 Appendix: Build NuttX for Rust Standard Library</a><ul></ul></li>
<li><a href="#appendix-tokio-async-threading" title="Appendix: Tokio Async Threading">9 Appendix: Tokio Async Threading</a><ul></ul></li>
<li><a href="#appendix-porting-nix-to-nuttx" title="Appendix: Porting Nix to NuttX">10 Appendix: Porting Nix to NuttX</a><ul></ul></li>
<li><a href="#appendix-snooping-tokio-on-nuttx" title="Appendix: Snooping Tokio on NuttX">11 Appendix: Snooping Tokio on NuttX</a><ul></ul></li></ul></nav><p>üìù <em>26 Jan 2025</em></p>
<p><img src="https://lupyuen.github.io/images/rust7-title.png" alt="LED Blinky with Rust Standard Library on Apache NuttX RTOS (RustRover IDE)" /></p>
<p><strong>Freshly Baked:</strong> Here‚Äôs how we <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>Blink the LED</strong></a> with <strong>Rust Standard Library</strong> on <a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Open the LED Device for NuttX
</span><span class="kw">let </span>fd = open(      <span class="comment">// Equivalent to NuttX open()
  </span><span class="string">"/dev/userleds"</span>,  <span class="comment">// LED Device
  </span>OFlag::O_WRONLY,  <span class="comment">// Write Only
  </span>Mode::empty()     <span class="comment">// No Modes
</span>).unwrap();         <span class="comment">// Halt on Error

// Define the ioctl() function for Flipping LEDs
</span><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;  <span class="comment">// ioctl() Command
</span><span class="macro">ioctl_write_int_bad!</span>(  <span class="comment">// ioctl() will write One Int Value (LED Bit State)
  </span>led_set_all,         <span class="comment">// Name of our New Function
  </span>ULEDIOC_SETALL       <span class="comment">// ioctl() Command to send
</span>);

<span class="comment">// Flip LED 1 to On
</span><span class="kw">unsafe </span>{             <span class="comment">// Be careful of ioctl()
  </span>led_set_all(       <span class="comment">// Set the LEDs for...
    </span>fd.as_raw_fd(),  <span class="comment">// LED Device
    </span><span class="number">1                </span><span class="comment">// LED 1 (Bit 0) turns On
  </span>).unwrap();        <span class="comment">// Halt on Error
</span>}  <span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 1)

// Flip LED 1 to Off: ioctl(fd, ULEDIOC_SETALL, 0)
</span><span class="kw">unsafe </span>{ led_set_all(fd.as_raw_fd(), <span class="number">0</span>).unwrap(); }</code></pre></div>
<p>Which requires the <strong><code>nix</code> Rust Crate</strong> / Library‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Add the `nix` Rust Crate
## To our NuttX Rust App
$ cd apps/examples/rust/hello
$ cargo add nix --features fs,ioctl

Updating crates.io index
Adding nix v0.29.0 to dependencies
Features: + fs + ioctl</code></pre></div>
<p><em>(OK it‚Äôs more complicated. Stay tuned)</em></p>
<p>All this is now possible, thanks to the awesome work by <a href="https://github.com/apache/nuttx-apps/pull/2487"><strong>Huang Qi</strong></a>! üéâ</p>
<p>In today‚Äôs article, we explain‚Ä¶</p>
<ul>
<li>
<p>How to build <strong>NuttX + Rust Standard Library</strong></p>
</li>
<li>
<p><strong>Handling JSON</strong> with the Serde Crate</p>
</li>
<li>
<p><strong>Async Functions</strong> with the Tokio Crate</p>
</li>
<li>
<p><strong>Blinking LEDs</strong> with the Nix Crate</p>
</li>
<li>
<p>How we ported <strong>Nix to NuttX</strong></p>
</li>
<li>
<p>Why Nix? <strong>Rustix</strong> might be better</p>
</li>
<li>
<p>Why <strong>File Descriptors are ‚ÄúOwned‚Äù</strong> in Rust</p>
</li>
</ul>
<h1 id="compile-our-rust-hello-app"><a class="doc-anchor" href="#compile-our-rust-hello-app">¬ß</a>1 Compile our Rust Hello App</h1>
<p><em>How to build NuttX + Rust Standard Library?</em></p>
<p>Follow the instructions here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust7#appendix-build-nuttx-for-rust-standard-library"><strong>‚ÄúBuild NuttX for Rust Standard Library‚Äù</strong></a></li>
</ul>
<p>Then run the (thoroughly revamped) <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs"><strong>Rust Hello App</strong></a> with <strong>QEMU RISC-V Emulator</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start NuttX on QEMU RISC-V 64-bit
$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run the Rust Hello App
NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo

{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30}
{&quot;name&quot;:&quot;Jane&quot;,&quot;age&quot;:25}
Deserialized: Alice is 28 years old
Pretty JSON:
{
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;age&quot;: 28
}
Hello world from tokio!</code></pre></div>
<p>Some bits are <a href="https://lupyuen.github.io/articles/rust7#appendix-build-nuttx-for-rust-standard-library"><strong>a little wonky</strong></a> (but will get better)</p>
<ul>
<li>
<p>Supports <a href="https://nuttx.apache.org/docs/latest/guides/rust.html"><strong>Arm and RISC-V</strong></a> architectures <em>(32-bit and 64-bit)</em></p>
</li>
<li>
<p>Works on <strong>Rust Nightly Toolchain</strong> <em>(not Rust Stable)</em></p>
</li>
<li>
<p>Needs a tiny patch to <strong>Local Toolchain</strong> <em>(pal/unix/fs.rs)</em></p>
</li>
<li>
<p>Sorry no <strong>RISC-V Floating Point</strong> and no <strong>Kernel Build</strong></p>
</li>
</ul>
<p>What‚Äôs inside the brand new Rust Hello App? We dive in‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust7-json2.png" alt="JSON with Serde on Apache NuttX RTOS (Neovim IDE)" /></p>
<h1 id="json-with-serde"><a class="doc-anchor" href="#json-with-serde">¬ß</a>2 JSON with Serde</h1>
<p><em>What‚Äôs this Serde?</em></p>
<p>Think <em>‚ÄúSerialize-Deserialize‚Äù</em>. <a href="https://crates.io/crates/serde"><strong>Serde</strong></a> is a Rust Crate / Library for Serializing and Deserializing our Data Structures. Works with <a href="https://serde.rs/#data-formats"><strong>JSON, CBOR, MessagePack, ‚Ä¶</strong></a></p>
<p>This is how we <strong>Serialize to JSON</strong> in our Hello Rust App: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L1-L32">nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Allow Serde to Serialize and Deserialize a Person Struct
</span><span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Person {
  name: String,  <span class="comment">// Containing a Name (string)
  </span>age:  u8,      <span class="comment">// And Age (uint8_t)
</span>}  <span class="comment">// Note: Rust Strings live in Heap Memory!

// Main Function of our Hello Rust App
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>hello_rust_cargo_main() {

  <span class="comment">// Create a Person Struct
  </span><span class="kw">let </span>john = Person {
    name: <span class="string">"John"</span>.to_string(),
    age:  <span class="number">30</span>,
  };

  <span class="comment">// Serialize our Person Struct
  </span><span class="kw">let </span>json_str = serde_json <span class="comment">// Person Struct
    </span>::to_string(<span class="kw-2">&amp;</span>john)  <span class="comment">// Becomes a String
    </span>.unwrap();          <span class="comment">// Halt on Error
  </span><span class="macro">println!</span>(<span class="string">"{}"</span>, json_str);</code></pre></div>
<p>Which will print‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30}</code></pre></div>
<p>Now we <strong>Deserialize from JSON</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L32-L41">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Declare a String with JSON inside
</span><span class="kw">let </span>json_data = <span class="string">r#"
  {
    "name": "Alice",
    "age": 28
  }"#</span>;

<span class="comment">// Deserialize our JSON String
// Into a Person Struct
</span><span class="kw">let </span>alice: Person = serde_json <span class="comment">// Get Person Struct
  </span>::from_str(json_data)  <span class="comment">// From JSON String
  </span>.unwrap();             <span class="comment">// Halt on Error
</span><span class="macro">println!</span>(<span class="string">"Deserialized: {} is {} years old"</span>,
  alice.name, alice.age);</code></pre></div>
<p>And we‚Äôll see‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>Deserialized: Alice is 28 years old</code></pre></div>
<p>Serde will also do <strong>JSON Formatting</strong>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L41-L44">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Serialize our Person Struct
// But neatly please
</span><span class="kw">let </span>pretty_json_str = serde_json <span class="comment">// Person Struct
  </span>::to_string_pretty(<span class="kw-2">&amp;</span>alice)     <span class="comment">// Becomes a Formatted String
  </span>.unwrap();                     <span class="comment">// Halt on Error
</span><span class="macro">println!</span>(<span class="string">"Pretty JSON:\n{}"</span>, pretty_json_str);</code></pre></div>
<p>Looks much neater!</p>
<div class="example-wrap"><pre class="language-bash"><code>Pretty JSON:
{
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;age&quot;: 28
}</code></pre></div>
<p><a href="https://bitboom.github.io/2020-10-22/serde-no-std">(Serde also runs on <strong>Rust Core Library</strong>, though super messy)</a></p>
<p><img src="https://lupyuen.github.io/images/rust7-tokio.png" alt="Async Functions with Tokio (Helix Editor + Zellij Workspace)" /></p>
<h1 id="async-functions-with-tokio"><a class="doc-anchor" href="#async-functions-with-tokio">¬ß</a>3 Async Functions with Tokio</h1>
<p><em>What‚Äôs this Tokio? Sounds like a city?</em></p>
<p>Indeed! ‚ÄúTokio‚Äù is inspired by Tokyo (and <a href="https://crates.io/crates/mio"><strong>Metal I/O</strong></a>)</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Tokio_(software)"><strong>Tokio</strong></a> ‚Ä¶ provides a runtime and functions that enable the use of Asynchronous I/O, allowing for Concurrency in regards to Task Completion</p>
</blockquote>
<p>Inside our <strong>Rust Hello App</strong>, here‚Äôs how we we run <strong>Async Functions</strong> with Tokio: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/rust/hello/src/lib.rs#L44-L56">nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Use One Single Thread (Current NuttX Thread)
// To schedule Async Functions
</span>tokio::runtime::Builder
  ::new_current_thread()  <span class="comment">// Current Thread is the Single-Threaded Scheduler
  </span>.enable_all()  <span class="comment">// Enable the I/O and Time Functions
  </span>.build()   <span class="comment">// Create the Single-Threaded Scheduler
  </span>.unwrap()  <span class="comment">// Halt on Error
  </span>.block_on( <span class="comment">// Start the Scheduler
    </span><span class="kw">async </span>{  <span class="comment">// With this Async Code
      </span><span class="macro">println!</span>(<span class="string">"Hello world from tokio!"</span>);
  });

<span class="comment">// Is it really async? Let's block and find out!
</span><span class="macro">println!</span>(<span class="string">"Looping Forever..."</span>);
<span class="kw">loop </span>{}</code></pre></div>
<p>We‚Äôll see‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
Hello world from tokio!
Looping Forever...</code></pre></div>
<p><a href="https://tokio.rs/tokio/topics/bridging">(Derived from <strong>tokio::main</strong>)</a></p>
<p><em>Yawn. Tokio looks underwhelming?</em></p>
<p>Ah we haven‚Äôt seen the full power of <strong>Tokio Multi-Threaded Async Functions</strong> on NuttX!</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create
Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms
Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p>Check this link for the <strong>Tokio Async Demo</strong>. And it works beautifully on NuttX! (Pic below)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust7#appendix-tokio-async-threading"><strong>‚ÄúTokio Async Threading‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust7-vscode2.png" alt="Tokio Async Demo" /></p>
<p><em>NuttX has POSIX Threads. Why use Async Functions?</em></p>
<p>Think <a href="https://en.wikipedia.org/wiki/Node.js#Threading"><strong>Node.js</strong></a> and its <em>Single-Thread Event Loop</em>, making <em>Non-Blocking I/O Calls</em>. Supporting tens of thousands of concurrent connections. <em>(Without costly Thread Context Switching)</em></p>
<p>Today we can (probably) do the same with <strong>NuttX and Async Rust</strong>. Assuming <a href="https://nuttx.apache.org/docs/12.5.0/components/filesystem/aio.html"><strong>POSIX Async I/O</strong></a> works OK with <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/io/bsd/poll_aio.rs"><strong>Tokio</strong></a>.</p>
<p>(Tokio calls them <em>‚ÄúAsync Tasks‚Äù</em>, sorry we won‚Äôt. Because a Task in NuttX is more like a NuttX Process)</p>
<p><em>How will we use Tokio?</em></p>
<blockquote>
<p><a href="https://tokio.rs/tokio/tutorial"><strong>Tokio</strong></a> is designed for <strong>I/O-Bound Applications</strong> where each individual task spends most of its time waiting for I/O.</p>
</blockquote>
<p>Which means it‚Äôs great for <a href="https://tokio.rs/tokio/tutorial/io"><strong>Network Servers</strong></a>. Instead of spawning many many <strong>NuttX Threads</strong>, we spawn a few threads and call <strong>Async Functions</strong>.</p>
<p>(Check out <a href="https://tokio.rs/tokio/tutorial/select"><strong>Tokio Select</strong></a> and <a href="https://tokio.rs/tokio/tutorial/streams"><strong>Tokio Streams</strong></a>)</p>
<p><img src="https://lupyuen.github.io/images/rust7-title.png" alt="LED Blinky with Rust Standard Library on Apache NuttX RTOS (RustRover IDE)" /></p>
<h1 id="led-blinky-with-nix"><a class="doc-anchor" href="#led-blinky-with-nix">¬ß</a>4 LED Blinky with Nix</h1>
<p><em>We‚Äôre running nix on NuttX?</em></p>
<p>Oh that‚Äôs <a href="https://crates.io/crates/nix"><strong><code>nix</code> Crate</strong></a> that provides <strong>Safer Rust Bindings</strong> for POSIX / Unix / Linux. (Nope, not NixOS)</p>
<p>This is how we add the library to our <strong>Rust Hello App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cd ../apps/examples/rust/hello
$ cargo add nix \
  --features fs,ioctl \
  --git https://github.com/lupyuen/nix.git \
  --branch nuttx

Updating git repository `https://github.com/lupyuen/nix.git`
Adding nix (git) to dependencies
Features: + fs + ioctl
34 deactivated features</code></pre></div>
<p><em>The URL looks a little sus?</em></p>
<p>Yep it‚Äôs our Bespoke <strong><code>nix</code></strong> Crate. That‚Äôs because the Official <strong><code>nix</code></strong> Crate doesn‚Äôt support NuttX yet. We made <a href="https://github.com/lupyuen/nix/pull/1/files"><strong>a few tweaks</strong></a> to compile on NuttX. <a href="https://lupyuen.github.io/articles/rust7#appendix-porting-nix-to-nuttx">(Explained in the <strong>Appendix</strong>)</a></p>
<p><em>Why are we calling nix?</em></p>
<p>We‚Äôre <strong>Blinking the LED</strong> on NuttX. We could call the <a href="https://crates.io/crates/libc"><strong>POSIX API</strong></a> direcly from Rust‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fd = <span class="kw">unsafe </span>{ libc::open(<span class="string">"/dev/userleds"</span>, ...) };
<span class="kw">unsafe </span>{ libc::ioctl(fd, ULEDIOC_SETALL, <span class="number">1</span>); }
<span class="kw">unsafe </span>{ libc::close(fd); }</code></pre></div>
<p>Erm it doesn‚Äôt look very‚Ä¶ Safe. That‚Äôs why we call the <strong>Safer POSIX Bindings</strong> provided by <strong><code>nix</code></strong>. Like so: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L6-L39">wip-nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Open the LED Device for NuttX
</span><span class="kw">let </span>fd = open(      <span class="comment">// Equivalent to NuttX open()
  </span><span class="string">"/dev/userleds"</span>,  <span class="comment">// LED Device
  </span>OFlag::O_WRONLY,  <span class="comment">// Write Only
  </span>Mode::empty()     <span class="comment">// No Modes
</span>).unwrap();         <span class="comment">// Halt on Error

// Define the ioctl() function for Flipping LEDs
</span><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;  <span class="comment">// ioctl() Command
</span><span class="macro">ioctl_write_int_bad!</span>(  <span class="comment">// ioctl() will write One Int Value (LED Bit State)
  </span>led_set_all,         <span class="comment">// Name of our New Function
  </span>ULEDIOC_SETALL       <span class="comment">// ioctl() Command to send
</span>);</code></pre></div>
<p>The code above opens the <strong>LED Device</strong>, returning an <strong>Owned File Descriptor</strong> (explained below). It defines a function <strong>led_set_all</strong>, that will call <em>ioctl()</em> to flip the LED.</p>
<p>Here‚Äôs how we call <strong>led_set_all</strong> to flip the LED: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L39-L47">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Flip LED 1 to On
</span><span class="kw">unsafe </span>{             <span class="comment">// Be careful of ioctl()
  </span>led_set_all(       <span class="comment">// Set the LEDs for...
    </span>fd.as_raw_fd(),  <span class="comment">// LED Device
    </span><span class="number">1                </span><span class="comment">// LED 1 (Bit 0) turns On
  </span>).unwrap();        <span class="comment">// Halt on Error
</span>}  <span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 1)</span></code></pre></div>
<p>We wait Two Seconds, then flip the <strong>LED to Off</strong>: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L47-L53">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Wait 2 seconds
</span>sleep(<span class="number">2</span>);

<span class="comment">// Flip LED 1 to Off: ioctl(fd, ULEDIOC_SETALL, 0)
</span><span class="kw">unsafe </span>{ led_set_all(fd.as_raw_fd(), <span class="number">0</span>).unwrap(); }</code></pre></div>
<p><em>ULEDIOC_SETALL looks familiar?</em></p>
<p>We spoke about <em>ULEDIOC_SETALL</em> in <a href="https://lupyuen.github.io/articles/rust6#blink-the-led"><strong>an earlier article</strong></a>. And the Rust Code above mirrors the <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85"><strong>C Version</strong></a> of our Blinky App.</p>
<p><em>How to run the Rust Blinky App?</em></p>
<ol>
<li>
<p>Copy the <strong>Rust Blinky Files</strong> from here‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx-apps/tree/rust-std/examples/rust/hello"><em>lupyuen2/wip-nuttx-apps/examples/rust/hello</em></a></p>
<p>Specifically: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/Cargo.toml"><strong>Cargo.toml</strong></a> and <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>src/lib.rs</strong></a></p>
</li>
<li>
<p>Overwrite our <strong>Rust Hello App</strong>‚Ä¶</p>
<p><em>apps/examples/rust/hello</em></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rust7#appendix-build-nuttx-for-rust-standard-library">Rebuild our <strong>NuttX Project</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>make -j</code></pre></div></li>
<li>
<p>Then run it with <strong>QEMU RISC-V Emulator</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo

board_userled: LED 1 set to 1
board_userled: LED 1 set to 0</code></pre></div>
<p>NuttX blinks the <strong>Emulated LED</strong> on QEMU Emulator!</p>
<p><a href="https://gist.github.com/lupyuen/4321601a962589b531bf83b0032a94af#file-hello_rust_cargo-log-L496-L533">(See the <strong>Complete Log</strong>)</a></p>
</li>
</ol>
<p><em>How to code Rust Apps for NuttX?</em></p>
<p>We could open the <code>apps</code> folder in VSCode, but <strong>Rust Analyzer</strong> won‚Äôt work.</p>
<p>Do this instead: Open the folder <em>apps/examples/rust/hello</em> in VSCode. Then Rust Analyzer <a href="https://lupyuen.github.io/images/rust7-vscode2.png"><strong>will work perfectly</strong></a>!</p>
<p>Remember to run <a href="https://doc.rust-lang.org/clippy/index.html"><strong>cargo clippy</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo clippy
Checking hello v0.1.0 (apps/examples/rust/hello)
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s</code></pre></div>
<p>Let‚Äôs talk about Owned File Descriptors vs Raw File Descriptors‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust7-fd2.jpg" alt="Owned File Descriptors vs Raw File Descriptors" /></p>
<h1 id="owned-file-descriptors"><a class="doc-anchor" href="#owned-file-descriptors">¬ß</a>5 Owned File Descriptors</h1>
<p><strong>Safety Quiz:</strong> Why will this run OK‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Copied from above: Open the LED Device
</span><span class="kw">let </span>owned_fd =
  open(<span class="string">"/dev/userleds"</span>, ...)
  .unwrap();  <span class="comment">// Returns an Owned File Descriptor

// Copied from above: Set the LEDs via ioctl()
</span>led_set_all(
  owned_fd.as_raw_fd(),  <span class="comment">// Extract the Raw File Descriptor
  </span><span class="number">1                      </span><span class="comment">// Flip LED 1 to On
</span>).unwrap();              <span class="comment">// Yep runs OK</span></code></pre></div>
<p>But <strong>Not This</strong>? (Pic above)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Extract earlier the Raw File Descriptor (from the LED Device)
</span><span class="kw">let </span>raw_fd =
  open(<span class="string">"/dev/userleds"</span>, ...)  <span class="comment">// Open the LED Device
  </span>.unwrap()      <span class="comment">// Get the Owned File Descriptor
  </span>.as_raw_fd();  <span class="comment">// Which becomes a Raw File Descriptor

// Set the LEDs via ioctl()
</span>led_set_all(
  raw_fd,    <span class="comment">// Use the earlier Raw File Descriptor
  </span><span class="number">1          </span><span class="comment">// Flip LED 1 to On
</span>).unwrap();  <span class="comment">// Oops will fail!</span></code></pre></div>
<p>The Second Snippet will fail with <strong>EBADF Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:32:33:
called `Result::unwrap()` on an `Err` value: EBADF
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</code></pre></div>
<p>There‚Äôs something odd about <strong>Raw File Descriptors</strong> vs <strong>Owned File Descriptors</strong>‚Ä¶ Fetching the Raw One too early might cause <strong>EBADF Errors</strong>. Here‚Äôs why‚Ä¶</p>
<p><em>What‚Äôs a Raw File Descriptor?</em></p>
<p>In NuttX and POSIX: <a href="https://github.com/apache/nuttx/blob/master/include/stdio.h#L65-L71"><strong>Raw File Descriptor</strong></a> is a <strong>Plain Integer</strong> that specifies an I/O Stream‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">File Descriptor</th><th style="text-align: left">I/O Stream</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: left">Standard Input</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: left">Standard Output</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left">Standard Error</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">/dev/userleds <br> <em>(assuming we opened it)</em></td></tr>
</tbody></table>
</div>
<p><em>What about Owned File Descriptor?</em></p>
<p>In Rust: <a href="https://doc.rust-lang.org/std/os/fd/struct.OwnedFd.html"><strong>Owned File Descriptor</strong></a> is a <strong>Rust Object</strong>, wrapped around a Raw File Descriptor.</p>
<p>And Rust Objects shall be <strong>Automatically Dropped</strong>, when they go out of scope. (Unlike Integers)</p>
<p><em>Causing the Second Snippet to fail?</em></p>
<p>Exactly! <em>open()</em> returns an <strong>Owned File Descriptor</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Owned File Descriptor becomes Raw File Descriptor
</span><span class="kw">let </span>raw_fd =
  open(<span class="string">"/dev/userleds"</span>, ...)  <span class="comment">// Open the LED Device
  </span>.unwrap()      <span class="comment">// Get the Owned File Descriptor
  </span>.as_raw_fd();  <span class="comment">// Which becomes a Raw File Descriptor</span></code></pre></div>
<p>And we turned it into <strong>Raw File Descriptor</strong>. (The Plain Integer, not the Rust Object)</p>
<p>Oops! Our Owned File Descriptor goes <strong>Out Of Scope</strong> and gets dropped by Rust‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust7-fd.jpg" alt="Our Owned File Descriptor goes Out Of Scope and gets dropped by Rust" /></p>
<p>Thus Rust will helpfully close <em>/dev/userleds</em>. Since it‚Äôs closed, the Raw File Descriptor <strong>becomes invalid</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Set the LEDs via ioctl()
</span>led_set_all(
  raw_fd,    <span class="comment">// Use the (closed) Raw File Descriptor
  </span><span class="number">1          </span><span class="comment">// Flip LED 1 to On
</span>).unwrap();  <span class="comment">// Oops will fail with EBADF Error!</span></code></pre></div>
<p>Resulting in the <a href="https://man.freebsd.org/cgi/man.cgi?errno(2)"><strong>EBADF Error</strong></a>. <em>ioctl()</em> failed because <em>/dev/userleds</em> is already closed!</p>
<p><strong>Lesson Learnt:</strong> Be careful with Owned File Descriptors. They‚Äôre super helpful for Auto-Closing our files. But might have strange consequences.</p>
<p>Rustix is another popular POSIX Wrapper. We take a peek‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust7-compare.png" alt="Nix vs Rustix" /></p>
<h1 id="nix-vs-rustix"><a class="doc-anchor" href="#nix-vs-rustix">¬ß</a>6 Nix vs Rustix</h1>
<p><em>Is there a Safer Way to call ioctl()?</em></p>
<p>Calling <em>ioctl()</em> from Rust will surely get messy: It‚Äôs an <strong>Unsafe Call</strong> that might cause bad writes into the NuttX Kernel! <em>(If we‚Äôre not careful)</em></p>
<p>At the top of the article, we saw <strong><code>nix</code></strong> crate calling <em>ioctl()</em>. Now we look at <a href="https://crates.io/crates/rustix"><strong>Rustix</strong></a> calling <em>ioctl()</em>: <a href="https://github.com/bytecodealliance/rustix/blob/main/src/fs/ioctl.rs#L16-L32">rustix/fs/ioctl.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Let's implement ioctl(fd, BLKSSZGET, &amp;output)
// In Rustix: ioctl() is also unsafe
</span><span class="kw">unsafe </span>{
  <span class="comment">// Create an "Ioctl Getter"
  // That will read data thru ioctl()
  </span><span class="kw">let </span>ctl = ioctl::Getter::&lt;  <span class="comment">// Ioctl Getter has 2 attributes...
    </span>ioctl::BadOpcode&lt;  <span class="comment">// Attribute #1: Ioctl Command Code
      </span>{ c::BLKSSZGET } <span class="comment">// Which is "Fetch the Logical Block Size of a Block Device"
    </span>&gt;,
    c::c_uint  <span class="comment">// Attribute #2: Ioctl Getter will read a uint32_t thru ioctl()
  </span>&gt;::new();    <span class="comment">// Create the Ioctl Getter

  // Now that we have the Ioctl Getter
  // We call ioctl() on the File Descriptor
  // Equivalent to: ioctl(fd, BLKSSZGET, &amp;output) ; return output
  </span>ioctl::ioctl(
    fd,  <span class="comment">// Borrowed File Descriptor (safer than Raw)
    </span>ctl  <span class="comment">// Ioctl Getter
  </span>) <span class="comment">// Returns the Value Read (Or Error)
</span>}</code></pre></div>
<p><a href="https://docs.rs/rustix/latest/rustix/ioctl/index.html">(Based on <strong>Rustix Docs</strong>)</a></p>
<p><a href="https://docs.rs/rustix/latest/rustix/ioctl/fn.ioctl.html">(Rustix Ioctl passes a <strong>Borrowed File Descriptor</strong>, safer than Raw)</a></p>
<p><em>Nix vs Rustix: They feel quite similar?</em></p>
<p>Actually Nix was previously a lot simpler, supporting only <strong>Raw File Descriptors</strong>. <em>(Instead of Owned File Descriptors)</em></p>
<p>Today, Nix is moving to <strong>Owned File Descriptors</strong> due to <strong>I/O Safety</strong>. Bummer it means Nix is becoming more <a href="https://crates.io/crates/rustix"><strong>Rustix-like</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/nix-rust/nix/issues/1750"><strong>Nix: Implement I/O Safety</strong></a></p>
</li>
<li>
<p><a href="https://rust-lang.github.io/rfcs/3128-io-safety.html"><strong>Rust: I/O Safety</strong></a> <em>(used in Rustix and New Nix)</em></p>
</li>
</ul>
<p><em>What‚Äôs our preference: Nix or Rustix?</em></p>
<p>Hmmm we‚Äôre still pondering. <strong>Rustix is newer</strong> (pic above), but it‚Äôs also <strong>more complex</strong> (based on Lines of Code). It might hinder our porting to NuttX‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust7-loc.png" alt="Nix vs Rustix: Lines of Code" /></p>
<p><a href="https://lupyuen.github.io/articles/rust6#appendix-nuttx-vs-rust-embedded-hal">(<strong>Rust Embedded HAL</strong> might be a bad fit)</a></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>7 What‚Äôs Next</h1>
<p><img src="https://lupyuen.github.io/images/rust7-slint.jpg" alt="Upcoming: Slint Rust GUI for NuttX üéâ" /></p>
<p><a href="https://github.com/apache/nuttx-apps/pull/2967"><strong>Upcoming:</strong> Slint Rust GUI for NuttX üéâ</a></p>
<p><em>What platforms are supported for NuttX + Rust Standard Library? How about SBCs?</em></p>
<p>Arm and RISC-V (32-bit and 64-bit). <a href="https://nuttx.apache.org/docs/latest/guides/rust.html"><strong>Check this doc</strong></a> for updates.</p>
<p>Sorry 64-bit <strong>RISC-V Kernel Build</strong> is <a href="https://github.com/apache/nuttx-apps/pull/2487#issuecomment-2601488835"><strong>not supported yet</strong></a>. So it <strong>won‚Äôt run on RISC-V SBCs</strong> like Ox64 BL808 and Oz64 SG2000.</p>
<p><em>Sounds like we need plenty of Rust Testing? For every NuttX Platform?</em></p>
<p>Yeah maybe we need <a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>Daily Automated Testing</strong></a> of NuttX + Rust Standard Library on <a href="https://lupyuen.github.io/articles/ci4"><strong>NuttX Build Farm</strong></a>?</p>
<p>With <a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>QEMU Emulator</strong></a> or a <a href="https://lupyuen.github.io/articles/sg2000a"><strong>Real Device</strong></a>?</p>
<p>And when the Daily Test fails: How to <a href="https://lupyuen.github.io/articles/ci6"><strong>Auto-Rewind the Build</strong></a> and discover the Breaking Commit? Hmmm‚Ä¶</p>
<hr>
<p>Many Thanks to the awesome <strong>NuttX Admins</strong> and <strong>NuttX Devs</strong>! And <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a>, for sticking with me all these years.</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/rust7.md"><strong>lupyuen.org/src/rust7.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/rust7-vscode.png" alt="NuttX with Rust Standard Library" /></p>
<h1 id="appendix-build-nuttx-for-rust-standard-library"><a class="doc-anchor" href="#appendix-build-nuttx-for-rust-standard-library">¬ß</a>8 Appendix: Build NuttX for Rust Standard Library</h1>
<p>Follow these steps to build <strong>NuttX bundled with Rust Standard Library</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/qemu-rv/boards/rv-virt/index.html">(Remember to install <strong>RISC-V Toolchain</strong> and <strong>RISC-V QEMU</strong>)</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Install Rust: https://rustup.rs/
## Select &quot;Standard Installation&quot;
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh
. &quot;$HOME/.cargo/env&quot;

## Switch to the Nightly Toolchain
rustup update
rustup toolchain install nightly
rustup default nightly

## Should show `rustc 1.86.0-nightly` or later
rustc --version

## Install the Nightly Toolchain
rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
## For macOS: rustup component add rust-src --toolchain nightly-aarch64-apple-darwin

## Download the NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure NuttX for RISC-V 64-bit QEMU with LEDs
## (Alternatively: rv-virt:nsh64 or rv-virt:nsh or rv-virt:leds)
tools/configure.sh rv-virt:leds64

## Disable Floating Point: CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Enable CONFIG_SYSTEM_TIME64 / CONFIG_FS_LARGEFILE / CONFIG_DEV_URANDOM / CONFIG_TLS_NELEM = 16
kconfig-tweak --enable CONFIG_SYSTEM_TIME64
kconfig-tweak --enable CONFIG_FS_LARGEFILE
kconfig-tweak --enable CONFIG_DEV_URANDOM
kconfig-tweak --set-val CONFIG_TLS_NELEM 16

## Enable the Hello Rust Cargo App
## Increase the App Stack Size from 2 KB to 16 KB (especially for 64-bit platforms)
kconfig-tweak --enable CONFIG_EXAMPLES_HELLO_RUST_CARGO
kconfig-tweak --set-val CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE 16384

## Update the Kconfig Dependencies
make olddefconfig

## Build NuttX
make -j

## If it fails with &quot;Mismatched Types&quot;:
## Patch the file `fs.rs` (see below)

## Start NuttX on QEMU RISC-V 64-bit
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Inside QEMU: Run our Hello Rust App
hello_rust_cargo</code></pre></div>
<p>We‚Äôll see this in <strong>QEMU RISC-V Emulator</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.8.0
nsh&gt; hello_rust_cargo

{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30}
{&quot;name&quot;:&quot;Jane&quot;,&quot;age&quot;:25}
Deserialized: Alice is 28 years old
Pretty JSON:
{
  &quot;name&quot;: &quot;Alice&quot;,
  &quot;age&quot;: 28
}
Hello world from tokio!</code></pre></div>
<p><strong>To Quit QEMU:</strong> Press <strong><code>Ctrl-a</code></strong> then <strong><code>x</code></strong></p>
<p><a href="https://gist.github.com/lupyuen/6985933271f140db0dc6172ebba9bff5">(See the <strong>Ubuntu Build Log</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/a2b91b5cc15824a31c287fbb6cda5fa2">(See the <strong>macOS Build Log</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/ccfae733657b864f2f9a24ce41808144">(Also works for 32-bit <strong>rv-virt:leds</strong>)</a></p>
<hr>
<p><strong>Troubleshooting The Rust Build</strong></p>
<ul>
<li>
<p>If NuttX Build fails with <strong>‚ÄúMismatched Types‚Äù</strong>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>Compiling std v0.0.0 (.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std)
error[E0308]: mismatched types
    --&gt; .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs:1037:33
1037 |         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }
     |                  -------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const u8`, found `*const i8`
     |                  |
     |                  arguments to this function are incorrect
     = note: expected raw pointer `*const u8`
                found raw pointer `*const i8`
note: associated function defined here
    --&gt; .rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ffi/c_str.rs:264:25
264  |     pub const unsafe fn from_ptr&lt;&#39;a&gt;(ptr: *const c_char) -&gt; &amp;&#39;a CStr {
     |                         ^^^^^^^^</code></pre></div></span>
<p>Then edit this file‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu
$HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs

## For macOS
$HOME/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs</code></pre></div></span>
<p>Change the <strong>name_cstr</strong> function at <strong>Line 1036</strong>‚Ä¶</p>
<span style="font-size:80%">

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">fn </span>name_cstr(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>CStr {
        <span class="kw">unsafe </span>{ CStr::from_ptr(<span class="self">self</span>.entry.d_name.as_ptr()) }
    }</code></pre></div>
</span>
<p>To this‚Ä¶</p>
<span style="font-size:80%">

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">fn </span>name_cstr(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>CStr {
        <span class="kw">unsafe </span>{ CStr::from_ptr(<span class="self">self</span>.entry.d_name.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span>u8) }
    }</code></pre></div>
</span>
<p>And verify the change‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>## For Ubuntu
head -n 1049 $HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs \
  | tail -n 17

## For macOS
head -n 1049 $HOME/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/std/src/sys/pal/unix/fs.rs \
  | tail -n 17

## We should see
## fn name_cstr(&amp;self) -&gt; &amp;CStr {
##   unsafe { CStr::from_ptr(self.entry.d_name.as_ptr() as *const u8) }</code></pre></div></span>
<p>Finally rebuild with <code>make -j</code></p>
<p><a href="https://github.com/rust-lang/libc/pull/4222">(Will be fixed in <strong>Rust Toolchain</strong>)</a></p>
</li>
<li>
<p>If the build fails with <strong>‚Äú-Z‚Äù Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>error: the `-Z` flag is only accepted on the nightly channel of Cargo
but this is the `stable` channel</code></pre></div>
<p>Then switch to the Nightly Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Switch to the Nightly Toolchain
rustup update
rustup toolchain install nightly
rustup default nightly

## Should show `rustc 1.86.0-nightly` or later
rustc --version</code></pre></div></li>
<li>
<p>If the build fails with <strong>‚ÄúCargo.lock does not exist‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>error: &quot;.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/Cargo.lock&quot; does not exist, unable to build with the standard library
try: rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu</code></pre></div>
<p>Then install the Nightly Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install the Nightly Toolchain
rustup component add rust-src --toolchain nightly-x86_64-unknown-linux-gnu
## For macOS: rustup component add rust-src --toolchain nightly-aarch64-apple-darwin</code></pre></div></li>
<li>
<p>If the build fails with <strong>‚ÄúError Loading Target‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>error: Error loading target specification:
Could not find specification for target &quot;riscv64imafdc-unknown-nuttx-elf&quot;</code></pre></div>
<p>Then disable Floating Point‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Disable Floating Point: CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Update the Kconfig Dependencies
make olddefconfig
make -j</code></pre></div></li>
<li>
<p><em>What if we‚Äôre using Rust already? And we don‚Äôt wish to change the Default Toolchain?</em></p>
<p>Use <code>rustup override</code> to <strong>Override the Folder Toolchain</strong>. Do it in the <strong>Parent Folder</strong> of <code>nuttx</code> and <code>apps</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set Rust to Nightly Build
## Apply this to the Parent Folder
## So it will work for `nuttx` and `apps`
pushd ..
rustup override list
rustup override set nightly
rustup override list
popd</code></pre></div></li>
<li>
<p><em>Rust App crashes in QEMU?</em></p>
<p>We might see a Stack Dump that <strong>Loops Forever</strong>. Or we might see <strong>100% Full</strong> for the App Stack‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>dump_tasks:    PID GROUP PRI POLICY   TYPE    NPX STATE   EVENT      SIGMASK          STACKBASE  STACKSIZE      USED   FILLED    COMMAND
dump_task:       3     3 100 RR       Task    -   Running            0000000000000000 0x80071420      1856      1856   100.0%!   hello_rust_cargo</code></pre></div></span>
<p>Then increase the App Stack Size‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Increase the App Stack Size to 64 KB
kconfig-tweak --set-val \
  CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE \
  65536

## Update the Kconfig Dependencies and rebuild
make olddefconfig
make -j</code></pre></div></li>
<li>
<p><em>Rust Build seems to break sometimes?</em></p>
<p>We might need to clean up the <strong>Rust Compiled Files</strong>, if the Rust Build goes wonky‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Erase the Rust Build and rebuild
pushd ../apps/examples/rust/hello
cargo clean
popd
make -j</code></pre></div></li>
<li>
<p><em>How to code Rust Apps for NuttX?</em></p>
<p>We could open the <code>apps</code> folder in VSCode, but <strong>Rust Analyzer</strong> won‚Äôt work.</p>
<p>Do this instead: Open the folder <em>apps/examples/rust/hello</em> in VSCode. Then Rust Analyzer will work perfectly! (Pic below)</p>
<p>Remember to run <a href="https://doc.rust-lang.org/clippy/index.html"><strong>cargo clippy</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cargo clippy
Checking hello v0.1.0 (apps/examples/rust/hello)
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s</code></pre></div></li>
</ul>
<p>How did we port Rust Standard Library to NuttX? Details here‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx-apps/pull/2487"><strong>examples: New app to build Rust with Cargo</strong></a></p>
</li>
<li>
<p><a href="https://github.com/rust-lang/rust/pull/127755"><strong>Rust: Add NuttX based targets for RISC-V and ARM</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust7-vscode2.png" alt="Tokio Async Threading" /></p>
<h1 id="appendix-tokio-async-threading"><a class="doc-anchor" href="#appendix-tokio-async-threading">¬ß</a>9 Appendix: Tokio Async Threading</h1>
<p>Earlier we saw Tokio‚Äôs <strong>Single-Threaded Scheduler</strong>, running on the <strong>Current NuttX Thread</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust7#async-functions-with-tokio"><strong>‚ÄúAsync Functions with Tokio‚Äù</strong></a></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Use One Single Thread (Current NuttX Thread)
// To schedule Async Functions
</span>tokio::runtime::Builder
  ::new_current_thread()  <span class="comment">// Current Thread is the Single-Threaded Scheduler
  </span>.enable_all()  <span class="comment">// Enable the I/O and Time Functions
  </span>.build()   <span class="comment">// Create the Single-Threaded Scheduler
  </span>.unwrap()  <span class="comment">// Halt on Error
  </span>.block_on( <span class="comment">// Start the Scheduler
    </span><span class="kw">async </span>{  <span class="comment">// With this Async Code
      </span><span class="macro">println!</span>(<span class="string">"Hello world from tokio!"</span>);
  });

<span class="comment">// Is it really async? Let's block and find out!
</span><span class="macro">println!</span>(<span class="string">"Looping Forever..."</span>);
<span class="kw">loop </span>{}</code></pre></div>
<p>And it ain‚Äôt terribly exciting‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
Hello world from tokio!
Looping Forever...</code></pre></div>
<p>Now we try Tokio‚Äôs <strong>Multi-Threaded Scheduler</strong> (pic above). And we create <strong>One New NuttX Thread</strong> for the Scheduler: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs#L86-L140">wip-nuttx-apps/lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Run 4 Async Functions in the Background
// By creating One New NuttX Thread
// Based on https://tokio.rs/tokio/topics/bridging
</span><span class="kw">fn </span>test_async() {

  <span class="comment">// Create a Multi-Threaded Scheduler
  // Containing One New NuttX Thread
  </span><span class="kw">let </span>runtime = tokio::runtime::Builder
    ::new_multi_thread() <span class="comment">// Multi-Threaded Scheduler
    </span>.worker_threads(<span class="number">1</span>)   <span class="comment">// With One New NuttX Thread for our Scheduler
    </span>.enable_all() <span class="comment">// Enable the I/O and Time Functions
    </span>.build()      <span class="comment">// Create the Multi-Threaded Scheduler
    </span>.unwrap();    <span class="comment">// Halt on Error

  // Create 4 Async Functions
  // Remember their Async Handles
  </span><span class="kw">let </span><span class="kw-2">mut </span>handles = Vec::with_capacity(<span class="number">4</span>);
  <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">4 </span>{
    handles.push(        <span class="comment">// Remember the Async Handles
      </span>runtime.spawn(     <span class="comment">// Start in the Background
        </span>my_bg_task(i))); <span class="comment">// Our Async Function
  </span>}

  <span class="comment">// Pretend to be busy while Async Functions execute (in the background)
  // We wait 750 milliseconds
  </span>std::thread::sleep(
    tokio::time::Duration::from_millis(<span class="number">750</span>));
  <span class="macro">println!</span>(<span class="string">"Finished time-consuming task."</span>);

  <span class="comment">// Wait for All Async Functions to complete
  </span><span class="kw">for </span>handle <span class="kw">in </span>handles {
    runtime
      .block_on(handle)  <span class="comment">// Wait for One Async Function to complete
      </span>.unwrap();
  }
}

<span class="comment">// Our Async Function that runs in the background...
// If i=0: Sleep for 1000 ms
// If i=1: Sleep for  950 ms
// If i=2: Sleep for  900 ms
// If i=3: Sleep for  850 ms
</span><span class="kw">async fn </span>my_bg_task(i: u64) {
  <span class="kw">let </span>millis = <span class="number">1000 </span>- <span class="number">50 </span>* i;
  <span class="macro">println!</span>(<span class="string">"Task {} sleeping for {} ms."</span>, i, millis);
  tokio::time::sleep(
    tokio::time::Duration::from_millis(millis)
  ).<span class="kw">await</span>;  <span class="comment">// Wait for sleep to complete
  </span><span class="macro">println!</span>(<span class="string">"Task {} stopping."</span>, i);
}

<span class="comment">// Needed by Tokio Multi-Threaded Scheduler
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>pthread_set_name_np() {}</code></pre></div>
<p><em>How to run the Tokio Demo?</em></p>
<ol>
<li>
<p>Copy the <strong>Tokio Demo Files</strong> from here‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx-apps/tree/rust-std/examples/rust/hello"><em>lupyuen2/wip-nuttx-apps/examples/rust/hello</em></a></p>
<p>Specifically: <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/Cargo.toml"><strong>Cargo.toml</strong></a> and <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/rust-std/examples/rust/hello/src/lib.rs"><strong>src/lib.rs</strong></a></p>
</li>
<li>
<p>Overwrite our <strong>Rust Hello App</strong>‚Ä¶</p>
<p><em>apps/examples/rust/hello</em></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rust7#appendix-build-nuttx-for-rust-standard-library">Rebuild our <strong>NuttX Project</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>make -j</code></pre></div></li>
<li>
<p>Then run it with <strong>QEMU RISC-V Emulator</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
</code></pre></div></li>
<li>
<p>We‚Äôll see <strong>Four Async Functions</strong>, running on <strong>One New POSIX Thread</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create
Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms
Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/46db6d1baee0e589774cc43dd690da07#file-gistfile1-txt-L497-L535">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://tokio.rs/tokio/topics/bridging">(Explained in <strong>Tokio Docs</strong>)</a></p>
</li>
<li>
<p>Aha! See the call to <a href="https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88"><strong>pthread_create</strong></a>, which calls <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179"><strong>nx_pthread_create</strong></a>? It means that Tokio is actually calling NuttX to create One POSIX Thread! (For the Multi-Threaded Scheduler)</p>
</li>
<li>
<p>Yep it‚Äôs consistent with our <strong>Reverse Engineering of Tokio</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/rust7#appendix-snooping-tokio-on-nuttx"><strong>‚ÄúSnooping Tokio on NuttX‚Äù</strong></a></p>
</li>
</ol>
<p><em>What if we increase the Worker Threads? From 1 to 2?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Two Worker Threads instead of One
</span><span class="kw">let </span>runtime = tokio::runtime::Builder
  ::new_multi_thread() <span class="comment">// New Multi-Threaded Scheduler
  </span>.worker_threads(<span class="number">2</span>)   <span class="comment">// With Two New NuttX Threads for our Scheduler</span></code></pre></div>
<p>The output looks exactly the same‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
pthread_create
nx_pthread_create
pthread_create
nx_pthread_create
Task 0 sleeping for 1000 ms
Task 1 sleeping for  950 ms
Task 2 sleeping for  900 ms
Task 3 sleeping for  850 ms
Finished time-consuming task
Task 3 stopping
Task 2 stopping
Task 1 stopping
Task 0 stopping</code></pre></div>
<p>Except that we see <strong>Two Calls</strong> to <a href="https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88"><strong>pthread_create</strong></a> and <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179"><strong>nx_pthread_create</strong></a>. Tokio called NuttX to create Two POSIX Threads. (For the Multi-Threaded Scheduler)</p>
<p><em>How did we log pthread_create?</em></p>
<p>Inside NuttX Kernel: We added Debug Code to
<a href="https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88"><strong>pthread_create</strong></a> and <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179"><strong>nx_pthread_create</strong></a></p>
<span style="font-size:90%">
<div class="example-wrap"><pre class="language-text"><code>// At https://github.com/apache/nuttx/blob/master/libs/libc/pthread/pthread_create.c#L88
#include &lt;debug.h&gt;
int pthread_create(...) {
  _info(&quot;pthread_entry=%p, arg=%p&quot;, pthread_entry, arg);

// At https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179
#include &lt;debug.h&gt;
int nx_pthread_create(...) {
  _info(&quot;entry=%p, arg=%p&quot;, entry, arg);</code></pre></div></span>
<p><img src="https://lupyuen.github.io/images/rust7-title.png" alt="LED Blinky with Rust Standard Library on Apache NuttX RTOS (RustRover IDE)" /></p>
<h1 id="appendix-porting-nix-to-nuttx"><a class="doc-anchor" href="#appendix-porting-nix-to-nuttx">¬ß</a>10 Appendix: Porting Nix to NuttX</h1>
<p><em>What happens when we call nix crate as-is on NuttX?</em></p>
<p>Earlier we said that we <a href="https://lupyuen.github.io/articles/rust7#led-blinky-with-nix"><strong>Customised the <code>nix</code> Crate</strong></a> to run on NuttX. (Pic above)</p>
<p>Why? Let‚Äôs build our Rust Blinky App with the Original <strong><code>nix</code></strong> Crate‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>$ pushd ../apps/examples/rust/hello
$ cargo add nix --features fs,ioctl
Adding nix v0.29.0 to dependencies
Features: + fs + ioctl
33 deactivated features

$ popd
$ make -j

error[E0432]: unresolved import `self::const`
  --&gt;   errno.rs:19:15
19 | pub use self::consts::*;
   |               ^^^^^^ could not find `consts` in `self`

error[E0432]: unresolved import `self::Errno`
   --&gt;  errno.rs:198:15
198 |     use self::Errno::*;
    |               ^^^^^ could not find `Errno` in `self`

error[E0432]: unresolved import `crate::errno::Errno`
 --&gt;  fcntl.rs:2:5
2 | use crate::errno::Errno;
  |     ^^^^^^^^^^^^^^-----
  |     no `Errno` in `errno`</code></pre></div></span>
<p>Plus many many errors. That‚Äôs why we <a href="https://github.com/lupyuen/nix/tree/nuttx"><strong>Customised the <code>nix</code> Crate</strong></a> for NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ cd ../apps/examples/rust/hello
$ cargo add nix \
  --features fs,ioctl \
  --git https://github.com/lupyuen/nix.git \
  --branch nuttx

Updating git repository `https://github.com/lupyuen/nix.git`
Adding nix (git) to dependencies
Features: + fs + ioctl
34 deactivated features</code></pre></div>
<p>Here‚Äôs how‚Ä¶</p>
<ol>
<li>
<p>We modified <a href="https://github.com/lupyuen/nix/pull/1/files#diff-c64965cf18ab089e705398a750edb9b349ff3e0509454d801d6a150db7ff9b5e">errno.rs</a>, copying FreeBSD <code>#[cfg(target_os = "freebsd")]</code> to NuttX <code>#[cfg(target_os = "nuttx")]</code></p>
</li>
<li>
<p>NuttX seems to have a similar POSIX Profile to <strong>Redox OS</strong>? We changed plenty of code to look like this: <a href="https://github.com/lupyuen/nix/pull/1/files#diff-7f322738311de78991dc089e6bcd3a89bcebc6d39b1a17508cf6c94bb170c9b0">sys/time.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// NuttX works like Redox OS
</span><span class="attr">#[cfg(not(any(target_os = <span class="string">"redox"</span>,
              target_os = <span class="string">"nuttx"</span>)))]
</span><span class="kw">pub const </span>UTIME_OMIT: TimeSpec = ...</code></pre></div>
</li>
<li>
<p><strong>For NuttX ioctl():</strong> It works more like BSD (second parameter is <code>int</code>) than Linux (second parameter is <code>long</code>): <a href="https://github.com/lupyuen/nix/pull/1/files#diff-96785c020c81b7d3962a7ea3c4ec2f2b1388617a412c92b4d1f0437447f42af4">sys/ioctl/mod.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// NuttX ioctl() works like BSD
</span><span class="attr">#[cfg(any(bsd, solarish, target_os = <span class="string">"haiku"</span>, 
          target_os = <span class="string">"nuttx"</span>))]
#[macro_use]
</span><span class="kw">mod </span>bsd;

<span class="comment">// Nope, NuttX ioctl() does NOT work like Linux
</span><span class="attr">#[cfg(any(linux_android, target_os = <span class="string">"fuchsia"</span>, target_os = <span class="string">"redox"</span>))]
#[macro_use]
</span><span class="kw">mod </span>linux;</code></pre></div>
</li>
<li>
<p>Here are all the files we modified for NuttX‚Ä¶</p>
<p>(Supporting <code>fs</code> and <code>ioctl</code> features only)</p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files">All Modified Files</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-c64965cf18ab089e705398a750edb9b349ff3e0509454d801d6a150db7ff9b5e">errno.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-234e7e6580542ac96403821955043ffefa4cef1e0659216a9ee170cad6315c7d">fcntl.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-0223913fb22a7da0dcb64a51b192e5c049b4b276351c83bbaeb0cee0dbbd8a04">unistd.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-5c119a000c85b1959421747235c671cc2f43b4f5fd2628daf1276f684a100ad8">sys/stat.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-ed80a57034c9c336fb4516644f86cbd9ef75296fa76bdf9c7ca9adf251be0421">sys/statvfs.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-db4000d9e8bf29c6719984245eeefdf7e0a9b4e525f37ac8c5d6a918d4dc3005">sys/mod.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-7f322738311de78991dc089e6bcd3a89bcebc6d39b1a17508cf6c94bb170c9b0">sys/time.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-48ef2619f99fe3916c145e82b718b5f2975d58992113203c51fb4315d8e3155b">sys/ioctl/bsd.rs</a></p>
<p><a href="https://github.com/lupyuen/nix/pull/1/files#diff-96785c020c81b7d3962a7ea3c4ec2f2b1388617a412c92b4d1f0437447f42af4">sys/ioctl/mod.rs</a></p>
</li>
</ol>
<hr>
<p><strong>Troubleshooting nix ioctl() on NuttX</strong></p>
<p>To figure out if <strong><code>nix</code></strong> passes ioctl parameters correctly to NuttX: We insert <strong>ioctl Debug Code</strong> into NuttX Kernel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// At https://github.com/apache/nuttx/blob/master/fs/vfs/fs_ioctl.c#L261
#include &lt;debug.h&gt;
int ioctl(int fd, int req, ...) {
  _info(&quot;fd=0x%x, req=0x%x&quot;, fd, req);</code></pre></div>
<p>Which <a href="https://docs.rs/nix/latest/nix/sys/ioctl/"><strong>Ioctl Macro</strong></a> shall we call in <strong><code>nix</code></strong>? We tried <strong>ioctl_none</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;
<span class="macro">ioctl_none!</span>(led_on, ULEDIOC_SETALL, <span class="number">1</span>);
<span class="kw">unsafe </span>{ led_on(fd).unwrap(); }</code></pre></div>
<p>But the <strong>ioctl Command Code</strong> got mangled up (<code>0x201d0301</code> should be <code>0x1d03</code>)</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
fd=3
ioctl: fd=0x3, req=0x201d0301

thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:31:25:
called `Result::unwrap()` on an `Err` value: ENOTTY
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</code></pre></div>
<p>Then we tried <strong>ioctl_write_int</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;
<span class="macro">ioctl_write_int!</span>(led_on, ULEDIOC_SETALL, <span class="number">1</span>);
<span class="kw">unsafe </span>{ led_on(fd, <span class="number">1</span>).unwrap(); }</code></pre></div>
<p>Nope the <strong>ioctl Command Code</strong> is still mangled (<code>0x801d0301</code> should be <code>0x1d03</code>)</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo
ioctl: fd=0x3, req=0x801d0301
thread &#39;&lt;unnamed&gt;&#39; panicked at src/lib.rs:30:28:
called `Result::unwrap()` on an `Err` value: ENOTTY</code></pre></div>
<p>Finally this works: <strong>ioctl_write_int_bad</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">const </span>ULEDIOC_SETALL: i32 = <span class="number">0x1d03</span>;
<span class="macro">ioctl_write_int_bad!</span>(led_set_all, ULEDIOC_SETALL);

<span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 1)
</span><span class="kw">unsafe </span>{ led_set_all(fd, <span class="number">1</span>).unwrap(); }

<span class="comment">// Equivalent to ioctl(fd, ULEDIOC_SETALL, 0)
</span><span class="kw">unsafe </span>{ led_set_all(fd, <span class="number">0</span>).unwrap(); }</code></pre></div>
<p><strong>ioctl Command Code</strong> <code>0x1d03</code> is hunky dory yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.7.0
nsh&gt; hello_rust_cargo
fd=3
ioctl: fd=0x3, req=0x1d03
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
ioctl: fd=0x3, req=0x1d03
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rust7-tokio.png" alt="Async Functions with Tokio (Helix Editor + Zellij Workspace)" /></p>
<h1 id="appendix-snooping-tokio-on-nuttx"><a class="doc-anchor" href="#appendix-snooping-tokio-on-nuttx">¬ß</a>11 Appendix: Snooping Tokio on NuttX</h1>
<p>In this section, we discover how <strong>Tokio works under the hood</strong>. Does it really call <strong>POSIX Functions in NuttX</strong>?</p>
<p>First we obtain the <strong>RISC-V Disassembly</strong> of our NuttX Image, bundled with the Hello Rust App. We trace the NuttX Build: Run <strong><code>make V=1</code></strong> on <strong><code>rv-virt:leds64</code></strong></p>
<div class="example-wrap"><pre class="language-bash"><code>make distclean
tools/configure.sh rv-virt:leds64

## Disable CONFIG_ARCH_FPU
kconfig-tweak --disable CONFIG_ARCH_FPU

## Enable CONFIG_SYSTEM_TIME64 / CONFIG_FS_LARGEFILE / CONFIG_DEV_URANDOM / CONFIG_TLS_NELEM = 16
kconfig-tweak --enable CONFIG_SYSTEM_TIME64
kconfig-tweak --enable CONFIG_FS_LARGEFILE
kconfig-tweak --enable CONFIG_DEV_URANDOM
kconfig-tweak --set-val CONFIG_TLS_NELEM 16

## Enable Hello Rust Cargo App, increase the Stack Size
kconfig-tweak --enable CONFIG_EXAMPLES_HELLO_RUST_CARGO
kconfig-tweak --set-val CONFIG_EXAMPLES_HELLO_RUST_CARGO_STACKSIZE 16384

## Update the Kconfig Dependencies
make olddefconfig

## Build NuttX with Tracing Enabled
make V=1</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b8f051c25e872fb8a444559c3dbf6374">(See the <strong>Build Log</strong>)</a></p>
<p>According to the <strong><code>make V=1</code></strong> trace: <strong>NuttX Build</strong> does this‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>## Discard the Rust Debug Symbols
cd apps/examples/rust/hello
cargo build \
  --release \
  -Zbuild-std=std,panic_abort \
  --manifest-path apps/examples/rust/hello/Cargo.toml \
  --target riscv64imac-unknown-nuttx-elf

## Generate the Linker Script
riscv-none-elf-gcc \
  -E \
  -P \
  -x c \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script \
  -o  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp

## Link Rust App into NuttX
riscv-none-elf-ld \
  --entry=__start \
  -melf64lriscv \
  --gc-sections \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx.map \
  --print-memory-usage \
  -Tnuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp  \
  -L nuttx/staging \
  -L nuttx/arch/risc-v/src/board  \
  -o nuttx/nuttx   \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lm \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard xpack-riscv-none-elf-gcc-13.2.0-2/lib/gcc/riscv-none-elf/13.2.0/rv64imac/lp64/libgcc.a apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/release/libhello.a \
  --end-group</code></pre></div></span>
<p>Ah NuttX Build calls <strong>cargo build ‚Äìrelease</strong>, stripping the Debug Symbols. We change it to <strong>cargo build</strong> and dump the RISC-V Disassembly‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>## Preserve the Rust Debug Symbols
pushd ../apps/examples/rust/hello
cargo build \
  -Zbuild-std=std,panic_abort \
  --manifest-path apps/examples/rust/hello/Cargo.toml \
  --target riscv64imac-unknown-nuttx-elf
popd

## Generate the Linker Script
riscv-none-elf-gcc \
  -E \
  -P \
  -x c \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script \
  -o  nuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp

## Link Rust App into NuttX
riscv-none-elf-ld \
  --entry=__start \
  -melf64lriscv \
  --gc-sections \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx.map \
  --print-memory-usage \
  -Tnuttx/boards/risc-v/qemu-rv/rv-virt/scripts/ld.script.tmp  \
  -L nuttx/staging \
  -L nuttx/arch/risc-v/src/board  \
  -o nuttx/nuttx   \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lm \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard xpack-riscv-none-elf-gcc-13.2.0-2/lib/gcc/riscv-none-elf/13.2.0/rv64imac/lp64/libgcc.a apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/debug/libhello.a \
  --end-group

## Dump the disassembly to nuttx.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;leds64-debug-nuttx.S \
  2&gt;&amp;1</code></pre></div></span>
<p><a href="https://gist.github.com/lupyuen/7b52d54725aaa831cb3dddc0b68bb41f">(See the <strong>Build Log</strong>)</a></p>
<p>Which produces the <strong>Complete NuttX Disassembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/leds64-debug-nuttx.S"><strong>leds64-debug-nuttx.S</strong></a></p>
<p>Whoa the Complete NuttX Disassembly is too huge to inspect!</p>
<p>Let‚Äôs dump the RISC-V Disassembly of the <strong>Rust Part</strong> only: <strong>libhello.a</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the libhello.a disassembly to libhello.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  apps/examples/rust/hello/target/riscv64imac-unknown-nuttx-elf/debug/libhello.a \
  &gt;libhello.S \
  2&gt;&amp;1</code></pre></div>
<p>Which produces the (much smaller) <strong>Rust Disassembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/libhello.S"><strong>libhello.S</strong></a></p>
<p>Is Tokio calling NuttX to create POSIX Threads? We search <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/rust-std-1/libhello.S"><strong>libhello.S</strong></a> for <strong>pthread_create</strong>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/thread.rs:85

let ret = libc::pthread_create(&amp;mut native, &amp;attr, thread_start, p as *mut _);

auipc a0, 0x0 122: R_RISCV_PCREL_HI20 std::sys::pal::unix::thread::Thread::new::thread_start
mv    a2, a0 126: R_RISCV_PCREL_LO12_I .Lpcrel_hi254
add   a0, sp, 132
add   a1, sp, 136
sd    a1, 48(sp)
auipc ra, 0x0 130: R_RISCV_CALL_PLT pthread_create</code></pre></div></span>
<p>OK that‚Äôs the <a href="https://doc.rust-lang.org/src/std/sys/pal/unix/thread.rs.html#84"><strong>Rust Standard Library</strong></a> calling <strong>pthread_create</strong> to create a new Rust Thread.</p>
<p>How are <strong>Rust Threads</strong> created in Rust Standard Library? Like this: <a href="https://github.com/rust-lang/rust/blob/master/library/std/src/thread/mod.rs#L502">std/thread/mod.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// spawn_unchecked_ creates a new Rust Thread
</span><span class="kw">unsafe fn </span>spawn_unchecked_&lt;<span class="lifetime">'scope</span>, F, T&gt;(
  <span class="kw">let </span>my_thread = Thread::new(id, name);</code></pre></div>
<p>And <strong>spawn_unchecked</strong> is called by Tokio, according to our Rust Disassembly‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>&lt;core::ptr::drop_in_place&lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;tokio::runtime::blocking::pool::Spawner::spawn_thread::{{closure}}&gt;&gt;&gt;:

.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:523

add   sp, sp, -16
sd    ra, 8(sp)
sd    a0, 0(sp)
auipc ra, 0x0 6: R_RISCV_CALL_PLT &lt;std::thread::Builder::spawn_unchecked_::MaybeDangling&lt;T&gt; as core::ops::drop::Drop&gt;::drop</code></pre></div></span>
<p>Yep it checks out: Tokio calls Rust Standard Library, which calls NuttX to create POSIX Threads!</p>
<p><em>Are we sure that Tokio creates a POSIX Thread? Not a NuttX Task?</em></p>
<p>We run <strong><code>hello_rust_cargo &amp;</code></strong> to put it in the background‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; hello_rust_cargo &amp;
Hello world from tokio!

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK            STACK    USED FILLED COMMAND
    0     0   0 FIFO     Kthread   - Ready              0000000000000000 0001904 0000712  37.3%  Idle_Task
    2     2 100 RR       Task      - Running            0000000000000000 0002888 0002472  85.5%! nsh_main
    4     4 100 RR       Task      - Ready              0000000000000000 0007992 0006904  86.3%! hello_rust_cargo</code></pre></div></span>
<p><strong><code>ps</code></strong> says that there‚Äôs only One Single NuttX Task <strong><code>hello_rust_cargo</code></strong>. And no other NuttX Tasks.</p>
<p><a href="https://gist.github.com/lupyuen/0377d9e015fee1d6a833c22e1b118961">(See the <strong>Complete Log</strong>)</a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>