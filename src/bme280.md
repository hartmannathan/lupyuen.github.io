# Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS to NuttX RTOS

üìù _10 Mar 2022_

![Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/images/bme280-title.jpg)

_"Will [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/nuttx) talk I2C with [__Bosch BME280 Sensor__](https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/)... On the [__BL602 RISC-V SoC__](https://lupyuen.github.io/articles/pinecone)?"_

...A friend and I pondered (8,000 miles apart) while working on the [__Temperature + Humidity + Air Pressure__](https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide) combo sensor.

Sounds like a fun challenge...

-   NuttX __doesn't have a driver__ for the BME280 Sensor

    (Though it supports BMP280)

-   Can we port the BME280 Driver from [__Zephyr OS__](https://docs.zephyrproject.org/latest/) with a few tweaks?

    (Spoiler: Yes we can!)

-   What's inside a __NuttX Sensor Driver__ anyway?

    (How to build our own driver)

-   NuttX on BL602 is __kinda new-ish__

    (Some features might not work the way we expect)

-   BL602's I2C Port has __interesting quirks__. Will it work?

    (Specifically: I2C Sub Address)

Read on to find out how we solved the challenge and created this driver...

-   [__lupyuen/bme280-nuttx__](https://github.com/lupyuen/bme280-nuttx)

(This BME280 Driver should work OK on other NuttX platforms, like ESP32)

__Note:__ The NuttX Sensor API has been updated in Jul / Aug 2022. [(See the changes)](https://lupyuen.github.io/articles/sensor#appendix-updates-to-nuttx-sensor-api)

![Bus Pirate connected to BME280](https://lupyuen.github.io/images/i2c-buspirate.jpg)

# Test and Connect BME280

Before we begin our exploration, verify that our BME280 Sensor works OK.

(Because we'll see some unexpected behaviour in a while)

We used [__Bus Pirate__](http://dangerousprototypes.com/docs/Bus_Pirate) (pic above) for testing our BME280 Sensor.

[(Here's how)](https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate)

Next we connect BME280 to Pine64's [__PineCone BL602 Board__](https://lupyuen.github.io/articles/pinecone)...

| BL602 Pin | BME280 Pin | Wire Colour
|:---:|:---:|:---|
| __`GPIO 1`__ | `SDA` | Green 
| __`GPIO 2`__ | `SCL` | Blue
| __`3V3`__ | `3.3V` | Red
| __`GND`__ | `GND` | Black

![Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor](https://lupyuen.github.io/images/sensor-connect.jpg)

The __I2C Pins__ on BL602 are defined here: [board.h](https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L91-L98)

```c
/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN2)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN1)
```

[(Which pins can be used? See this)](https://lupyuen.github.io/articles/expander#pin-functions)

_What if we're connecting to ESP32?_

__For ESP32:__ The GPIO Pin Numbers for the I2C Port (I2C0) are defined in [Kconfig](https://github.com/lupyuen/nuttx/blob/master/arch/xtensa/src/esp32/Kconfig#L797-L805) and menuconfig...

```text
config ESP32_I2C0_SCLPIN
  int "I2C0 SCL Pin"
  default 22
  range 0 39

config ESP32_I2C0_SDAPIN
  int "I2C0 SDA Pin"
  default 23
  range 0 39
```

_Do we need Pull-Up Resistors?_

We're using the [__SparkFun BME280 Breakout Board__](https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide/all), which has __Pull-Up Resistors__. (So we don't need to add our own)

_What happens now?_

Coming up we have a lengthy exploration of BME280 on BL602.

If we're only interesting in __running the NuttX BME280 Driver__ (on BL602, ESP32 and other platforms), jump to this section for the instructions...

-   [__"Run BME280 Driver"__](https://lupyuen.github.io/articles/bme280#run-bme280-driver)

But if we're keen to go deep inside the BME280 driver... Read on!

# Start with BMP280 Driver

NuttX doesn't have a BME280 Driver, but there's a __NuttX Driver for BMP280__, the downsized (rightsized?) sibling of BME280.

(BMP280 works like BME280 for sensing Air Pressure and Temperature, but __without Humidity__)

Let's test the __BMP280 Driver on BL602__ and fix any I2C quirks.

1.  Follow these steps to __download and configure__ NuttX...

    [__"Download NuttX"__](https://lupyuen.github.io/articles/bme280#download-nuttx)

    [__"Configure NuttX"__](https://lupyuen.github.io/articles/bme280#configure-nuttx)

    ![Enable the I2C Port and I2C Character Driver](https://lupyuen.github.io/images/bme280-config1.jpg)

1.  Enable the __BMP280 Driver__ in menuconfig...

    Check the box for __"Device Drivers"__ ‚Üí __"Sensor Device Support"__

    Select __"Sensor Device Support"__

    Check the box for __"Bosch BMP280 Barometic Pressure Sensor"__

    ![BMP280 Driver](https://lupyuen.github.io/images/bme280-config3.png)

## Change I2C Address and Device ID

_Will NuttX's BMP280 Driver really work with our BME280?_

Yep the BMP280 Driver ought to read the __Air Pressure__ and __Temperature__ from our BME280 Sensor. (But not Humidity)

Just that we need to we change the __I2C Address__ and __Device ID__ in the BMP280 Driver: [bmp280.c](https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57)

```c
//  Previously: I2C Address of BMP280
//  #define BMP280_ADDR     0x76

//  Testing: I2C Address of BME280
#define BMP280_ADDR         0x77

//  Previously: Device ID of BMP280
//  #define DEVID           0x58

//  Testing: Device ID of BME280
#define DEVID               0x60
```

[(FYI: Zephyr uses the same driver for BMP280 and BME280)](https://github.com/zephyrproject-rtos/zephyr/issues/1709)

![Change I2C Address and Device ID](https://lupyuen.github.io/images/bme280-code1.png)

[(Source)](https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57)

## Register BMP280 Driver

Next we __load the BMP280 Driver__ at startup: [bl602_bringup.c](https://github.com/lupyuen/nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640)

```c
#ifdef CONFIG_SENSORS_BMP280
#include <nuttx/sensors/bmp280.h>
#endif  //  CONFIG_SENSORS_BMP280
...
int bl602_bringup(void) {
...
#ifdef CONFIG_SENSORS_BMP280
  //  Init I2C bus for BMP280
  struct i2c_master_s *bmp280_i2c_bus = 
    bl602_i2cbus_initialize(0);
  if (!bmp280_i2c_bus) {
    _err("ERROR: Failed to get I2C%d interface\n", 0);
  }

  //  Register the BMP280 driver
  ret = bmp280_register(0, bmp280_i2c_bus);
  if (ret < 0) {
    _err("ERROR: Failed to register BMP280\n");
  }
#endif  //  CONFIG_SENSORS_BMP280
```

[(__bmp280_register__ is defined here)](https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760)

__For ESP32:__ Edit the function [esp32_bringup](https://github.com/lupyuen/nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497) in [esp32_bringup.c](https://github.com/lupyuen/nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497) so that it calls [bmp280_register](https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760)

![Register BMP280 Driver](https://lupyuen.github.io/images/bme280-code2a.png)

[(Source)](https://github.com/lupyuen/nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640)

## Invalid Device ID

We're ready to test the BMP280 Driver! __Build, flash and run__ NuttX with these steps...

1.  [__"Build NuttX"__](https://lupyuen.github.io/articles/bme280#build-nuttx)

1.  [__"Flash NuttX"__](https://lupyuen.github.io/articles/bme280#flash-nuttx)

1.  [__"Run NuttX"__](https://lupyuen.github.io/articles/bme280#run-nuttx)

Something unexpected happens when we boot NuttX on BL602...

```text
bl602_i2c_transfer: i2c transfer success
bmp280_checkid:  devid: 0x00
bmp280_checkid:  Wrong Device ID! 00
bmp280_register: Failed to register driver: -19
bl602_bringup:   ERROR: Failed to register BMP280
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#invalid-device-id)

This says that the BMP280 Driver was expecting __Device ID `0x60`__... But it got __`0x00`__ instead!

Let's find out why ü§î

![Invalid Device ID](https://lupyuen.github.io/images/bme280-run1.png)

[(Source)](https://github.com/lupyuen/bme280-nuttx#invalid-device-id)

## Incorrect Register ID

To track down why we're not reading the right Device ID, let's connect a __Logic Analyser__ and inspect the bits on the I2C Bus...

![Logic Analyser connected between BL602 and BME280](https://lupyuen.github.io/images/bme280-logic2.jpg)

The I2C Data captured by our Logic Analyser looks surprising...

![I2C Data captured by Logic Analyser](https://lupyuen.github.io/images/bme280-logic1.jpg)

The pic above shows that BL602 sent the __wrong Register ID__ to BME280...

```text
Write  [0xEE]
0x00 + ACK (Register ID is 0x00, which is incorrect!)
Read   [0xEF]
0x00 + NAK (Invalid result, because Register ID is incorrect!)
```

To read the Device ID, the Register ID should be __`0xD0`__, not __`0x00`__!

Let's fix this ü§î

[(Here's why Register ID should be `0xD0`)](https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate)

## Set I2C Sub Address

_Is there something special about BL602's I2C Port?_

BL602 has a peculiar I2C Port...

We need to send the __I2C Sub Address__ (Register ID) separately from the I2C Data! 

(Which might have caused the BMP280 Driver to fail)

![I2C Sub Address](https://lupyuen.github.io/images/bme280-subaddress2.png)

[(From BL602 Reference Manual)](https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en)

When we browse the NuttX code for BL602's I2C Driver, we realise that it __supports I2C Sub Addresses__: [bl602_i2c.c](https://github.com/lupyuen/nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L719-L738)

```c
static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  //  if msgs[i].flag I2C_M_NOSTOP,means start i2c with subddr
  if (msgs[i].flags & I2C_M_NOSTOP) {
    priv->subflag = 1;
    priv->subaddr = 0;
    for (j = 0; j < msgs[i].length; j++) {
      priv->subaddr += msgs[i].buffer[j] << (j * 8);
    }
    priv->sublen = msgs[i].length;
    i++;
```

But it needs the flag __I2C_M_NOSTOP__ to be set!

Let's patch the NuttX BMP280 Driver to send the __Register ID as I2C Sub Address__ (instead of I2C Data) when we're reading a BMP280 Register: [bmp280.c](https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L209-L219)

```c
//  Read a single BME280 Register
static uint8_t bmp280_getreg8(FAR struct bmp280_dev_s *priv, uint8_t regaddr) {
  ...
  msg[0].frequency = priv->freq;
  msg[0].addr      = priv->addr;

#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0

  msg[0].buffer    = &regaddr;
  msg[0].length    = 1;
```

[(We patch __bmp280_getregs__ and __bmp280_putreg8__ too)](https://github.com/lupyuen/nuttx/blob/bmp280/drivers/sensors/bmp280.c#L238-L327)

_What about writing to BMP280 Registers? Do we need to set the I2C Sub Address?_

Yes we need to send the __Register ID and Register Value__ as I2C Sub Address, followed by an __I2C Read__.

[(More about BL602 I2C Quirks)](https://lupyuen.github.io/articles/bme280#appendix-quirks-in-bl602-nuttx-i2c-driver)

![Send the Register ID as I2C Sub Address (instead of I2C Data) when we're reading a BMP280 Register](https://lupyuen.github.io/images/bme280-code5a.png)

## BMP280 Driver Loads OK

We've patched the BMP280 Driver to send the Register ID as I2C Sub Address. Let's run it!

```text
sensor_custom_register: Registering /dev/uorb/sensor_baro0
bmp280_register: BMP280 driver loaded successfully!
NuttShell (NSH) NuttX-10.2.0-RC0
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#bmp280-driver-loads-ok)

Yep our patched BMP280 Driver __loads successfully__!

(Because it receives the correct Device ID from BMP280)

BMP280 appears on NuttX as __/dev/uorb/sensor_baro0__...

```bash
nsh> ls /dev/uorb
/dev/uorb:
 sensor_baro0
```

Let's read the __baro0__ device.

[(How we enable logging for BL602 I2C Driver)](https://lupyuen.github.io/articles/bme280#appendix-log-i2c-transfers)

![Our patched BMP280 Driver loads successfully](https://lupyuen.github.io/images/bme280-run2a.jpg)

## Run Sensor Test App

NuttX provides a __Sensor Test App__ that will read our BMP280 Device at __/dev/uorb/sensor_baro0__...

-   [__testing/sensortest/sensortest.c__](https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c)

(We'll study the code later)

We configure NuttX to enable the __Sensor Test App__...

-   "Application Configuration" ‚Üí "Testing" ‚Üí "Sensor Driver Test"

[(Details here)](https://lupyuen.github.io/articles/bme280#configure-nuttx)

![Enable the Sensor Test App](https://lupyuen.github.io/images/bme280-config4a.png)

Build, flash and run NuttX. To read 10 sensor values from __/dev/uorb/sensor_baro0__, enter this at the NuttX Shell...

```text
nsh> sensortest -n 10 baro0
SensorTest: Test /dev/uorb/sensor_baro0 with interval(1000000us), latency(0us)
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:1006.21 value2:30.78
baro0: timestamp:30690000 value1:1006.21 value2:30.78
SensorTest: Received message: baro0, number:10/10
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#run-sensor-test-app)

We see the Air Pressure and Temperature: __1,006.21 millibars__ at __30.78 ¬∞C__.

(Air Pressure at Sea Level is 1,013.25 millibars)

Yep this looks reasonable for Sunny Singapore by the Seaside!

![Read sensor values from BMP280](https://lupyuen.github.io/images/bme280-run5a.png)

Now let's port the BME280 Driver from Zephyr OS to NuttX, so we can get the Humidity.

![NuttX BMP280 Driver vs Zephyr BME280 Driver](https://lupyuen.github.io/images/bme280-code6a.jpg)

_[NuttX BMP280 Driver](https://github.com/apache/nuttx/blob/master/drivers/sensors/bmp280.c) vs [Zephyr BME280 Driver](https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c)_

# Port BME280 Driver from Zephyr OS

NuttX's BMP280 Driver works OK with our BME280 Sensor. But we're missing one thing: __Humidity__.

Let's port the BME280 Driver from __Zephyr OS__ to NuttX...

-   [__Zephyr BME280 Driver__](https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c)

_Why not code the BME280 Driver based on the datasheet?_

Well yes we could... But then the rest of this article would become an academic exercise üòâ

_Why port from Zephyr OS?_

Zephyr has an [__extensive collection__](https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers) of drivers. 

The NuttX porting steps that we establish today might work for other Zephyr drivers, with minimal changes!

_Porting a driver from Zephyr to NuttX sounds hard!_

Zephyr's BME280 Driver looks __highly similar__ to NuttX's BMP280 Driver. (Pic above)

Thus porting Zephyr's BME280 Driver to NuttX might not be so hard!

## Zephyr to NuttX

__Zephyr's BME280 Driver__ exposes these functions: [bme280-nuttx/bme280.c](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c)

![Zephyr BME280 Driver](https://lupyuen.github.io/images/bme280-port2.jpg)

-   [__bme280_chip_init__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L348-L417): Initialise the BME280 Sensor

-   [__bme280_pm_action__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L419-L446): Suspend the BME280 Sensor (Low Power Mode) or resume to Normal Power Mode

-   [__bme280_sample_fetch__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245): Fetch a sample from the BME280 Sensor

-   [__bme280_channel_get__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286): Get the Temperature / Humidity / Pressure from the fetched sample

[(__bme280_sample_fetch__ and __bme280_channel_get__ are explained in the Zephyr Sensor Docs)](https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html)

But NuttX expects a different interface for __Sensor Drivers__: [bme280-nuttx/driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c)

![NuttX Driver](https://lupyuen.github.io/images/bme280-port3.jpg)

-   [__bme280_register__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773): Register the sensor at startup and suspend the sensor

-   [__bme280_activate__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431): Suspend the sensor (Low Power Mode) or resume to Normal Power Mode

-   [__bme280_fetch__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572): Fetch the sensor values (Temperature / Humidity / Pressure)

-   [__bme280_set_interval__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341): Set the Standby Interval for the sensor

Our job is to __map the Zephyr BME280 Driver__ to the Sensor Driver Interface expected by NuttX...

![Zephyr BME280 Driver mapped to NuttX Driver](https://lupyuen.github.io/images/bme280-port4.jpg)


| Zephyr Driver | NuttX Driver |
| ------------- | -------------|
| bme280_chip_init,<br>bme280_pm_action | [__bme280_register__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773)
| bme280_pm_action | [__bme280_activate__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431)
| bme280_sample_fetch,<br>bme280_channel_get | [__bme280_fetch__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572) 
| _(Static Interval)_ | [__bme280_set_interval__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341)

We'll cover the details in the next section.

_What about bme280_set_interval?_

Zephyr assumes that the __Standby Interval is Static__. (Defined at compile time)

Whereas NuttX expects the Standby Interval to be __set at runtime__.

To handle this, we code the __bme280_set_interval__ function ourselves in NuttX.

## Read Sensor Data from Zephyr Driver

Our NuttX BME280 Driver reads the __Sensor Data__ from the Zephyr Driver in two steps...

1.  __Fetch a sample__ from the BME280 Sensor

    [(__bme280_sample_fetch__)](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245)

1.  Get the __Temperature, Humidity and Pressure__ from the fetched sample

    [(__bme280_channel_get__)](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286)

This is how we do it: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572)

```c
//  Fetch pressure, temperature and humidity from sensor
static int bme280_fetch(
  FAR struct device *priv,  //  NuttX Device Struct
  FAR struct sensor_baro *baro_data,  //  Returns pressure and temperature (if non-null)
  FAR struct sensor_humi *humi_data   //  Returns humidity (if non-null)
) {

  //  Zephyr BME280 Driver assumes that sensor is not in sleep mode
  if (!priv->activated) {
    snerr("Device must be active before fetch\n");
    return -EIO;
  }
```

We begin by verifying that the sensor is in __Normal Power Mode__.

[(__activated__ is set by __bme280_activate__)](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431)

Next we call the Zephyr Driver to __fetch a sample__ from BME280...

```c
  //  Fetch the sensor sample (from Zephyr BME280 Driver)
  int ret = bme280_sample_fetch(
    priv,            //  NuttX Device Struct
    SENSOR_CHAN_ALL  //  Fetch Temperature, Humidity and Pressure
  );
  if (ret < 0) { return ret; }
```

[(__bme280_sample_fetch__ is defined here)](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245)


The fetched sample contains __Temperature, Humidity and Pressure__.

To get the Pressure we call the Zephyr Driver...

```c
  //  Get the pressure (from Zephyr BME280 Driver)
  struct sensor_value val;
  ret = bme280_channel_get(
    priv,               //  NuttX Device Struct
    SENSOR_CHAN_PRESS,  //  Get Pressure from fetched sample
    &val                //  Pressure in Fixed Point format
  );
  if (ret < 0) { return ret; }
```

[(__bme280_channel_get__ is defined here)](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286)

This returns a Zephyr [__sensor_value__](https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_value) struct that stores the Pressure as a [__Fixed-Point Number__](https://en.wikipedia.org/wiki/Fixed-point_arithmetic).

We convert the [__Pressure__ (kilopascal)](https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_channel.SENSOR_CHAN_PRESS) from __Fixed Point to Float__ (in millibars)...

```c
  //  Convert pressure to float, scale up by 10 to convert kilopascal to millibars
  float pressure = get_sensor_value(&val) * 10;
```

[(__get_sensor_value__ is defined here)](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L93-L107)

We do the same to get the [__Temperature__ (¬∞C)](https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_channel.SENSOR_CHAN_AMBIENT_TEMP) from the fetched sample...

```c
  //  Get the temperature (from Zephyr BME280 Driver)
  ret = bme280_channel_get(
    priv,                      //  NuttX Device Struct
    SENSOR_CHAN_AMBIENT_TEMP,  //  Get Temperature from fetched sample
    &val                       //  Temperature in Fixed Point format
  );
  if (ret < 0) { return ret; }
  float temperature = get_sensor_value(&val);
```

And the [__Humidity__ (relative %)](https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_channel.SENSOR_CHAN_HUMIDITY)...

```c
  //  Get the humidity (from Zephyr BME280 Driver)
  ret = bme280_channel_get(
    priv,                  //  NuttX Device Struct
    SENSOR_CHAN_HUMIDITY,  //  Get Humidity from fetched sample
    &val                   //  Humidity in Fixed Point format
  );
  if (ret < 0) { return ret; }
  float humidity = get_sensor_value(&val);
```

Sensor Values in NuttX are __timestamped__. We get the timestamp like so...

```c
  //  Get the timestamp  
  struct timespec ts;
  clock_systime_timespec(&ts);
  uint64_t timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;
```

Finally we return the __Pressure and Temperature__ data...

```c
  //  Return the pressure and temperature data
  if (baro_data != NULL) {
    baro_data->pressure    = pressure;
    baro_data->temperature = temperature;
    baro_data->timestamp   = timestamp;
  }
```

And the __Humidity__...

```c
  //  Return the humidity data
  if (humi_data != NULL) {
    humi_data->humidity    = humidity;
    humi_data->timestamp   = timestamp;
  }
  return 0;
}
```

That's how we call the Zephyr Driver to fetch the BME280 Sensor Data!

_Why did we return the Sensor Data as two structs: baro_data and humi_data?_

That's because our NuttX BME280 Driver is implemented as a __Composite Sensor__: Barometer Sensor + Humidity Sensor.

More about this in the next chapter.

![Read Sensor Data from Zephyr Driver](https://lupyuen.github.io/images/bme280-code8a.png)

## Power Management

Mapping the __Power Management__ functions (Low Power Mode) from Zephyr to NuttX is straightforward: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431)

```c
//  If enable is true, set Power Mode to normal. Else set to sleep mode.
static int bme280_activate(
    FAR struct device *priv,  //  NuttX Device Struct
    bool enable               //  True for Normal Mode, False for Sleep Mode
) {
  int ret = 0;
  if (enable) {
    //  Set power mode to normal (from Zephyr BME280 Driver)
    ret = bme280_pm_action(
      priv,                     //  NuttX Device Struct
      PM_DEVICE_ACTION_RESUME   //  Resume from Sleep Mode
    );
  } else {
    //  Set to sleep mode (from Zephyr BME280 Driver)
    ret = bme280_pm_action(
      priv,                     //  NuttX Device Struct
      PM_DEVICE_ACTION_SUSPEND  //  Suspend to Sleep Mode
    );
  }
  //  Remember the power mode
  if (ret >= 0) { priv->activated = enable; }
  return ret;
}
```
![BME280 Standby Interval](https://lupyuen.github.io/images/bme280-standby.png)

[(From BME280 Datasheet)](https://cdn.sparkfun.com/assets/learn_tutorials/4/1/9/BST-BME280_DS001-10.pdf)

## Standby Interval

_What's the Standby Interval?_

BME280 automatically measures the Temperature, Humidity and Pressure at periodic intervals. (Without any intervention from our microcontroller)

The time interval between measurements is the __Standby Interval__. 

(_t_standby_ in the pic above)

_Standby Intervals work differently in Zephyr vs NuttX?_

Zephyr defines the Standby Interval at __Compile Time__, it can't be changed at runtime. [(See this)](https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/Kconfig#L81-L103)

But NuttX configures the Standby Interval __at runtime__. That's why we coded this function to set the Standby Interval: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341)

```c
//  Set Standby Interval for the sensor
static int bme280_set_interval(
  FAR struct device *priv,     //  NuttX Device Struct
  FAR unsigned int *period_us  //  Standby Interval in microseconds
) {
  //  Convert the Standby Interval to BME280 constant
  int ret = 0;
  uint8_t regval;
  switch (*period_us) {
    case 500: 
      regval = BME280_STANDBY_05_MS; break;
    ...
    case 4000000:
      regval = BME280_STANDBY_4000_MS; break;
    default:
      ret = -EINVAL; break;
  }

  //  Set the Standby Interval
  if (ret == 0) {
    ret = bme280_set_standby(priv, regval);
  }
  return ret;
}
```

__bme280_set_standby__ is defined below: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L237-L285)

```c
//  Set Standby Duration. Zephyr assumes that Standby Duration is static, so we set it in NuttX.
static int bme280_set_standby(
  FAR struct device *priv,  //  NuttX Device Struct
  uint8_t value             //  BME280 constant for Standby Duration
) {
  //  Set the standby duration value by writing to BME280 Register
  int ret = bme280_reg_read(priv, BME280_REG_CONFIG, &v_data_u8, 1);
  uint8_t v_data_u8 = (v_data_u8 & ~(0x07 << 5)) | (value << 5);
  ret = bme280_reg_write(priv, BME280_REG_CONFIG, v_data_u8);
  ...
  //  Check the standby duration value by reading from BME280 Register
  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &v_data_u8, 1);
  uint8_t v_sb_u8 = (v_data_u8 >> 5) & 0x07;
  //  Omitted: Return error if v_sb_u8 != value
```

[(__bme280_reg_read__ and __bme280_reg_write__ are defined here)](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L147-L235)

[(__bme280_set_interval__ and __bme280_set_standby__ were cloned from the NuttX BMP280 Driver)](https://github.com/lupyuen/nuttx/blob/master/drivers/sensors/bmp280.c#L330-L565)

We'll cover __bme280_register__ in the next chapter.

![Combined Barometer and Humidity Sensor](https://lupyuen.github.io/images/bme280-combine1.png)

# Combined Barometer and Humidity Sensor

_What kinds of Sensors are supported by NuttX?_

Temperature, Humidity, Pressure, GPS, ECG, PM 2.5 and many more. [(Here's the list)](https://github.com/apache/nuttx/blob/master/include/nuttx/sensors/sensor.h)

NuttX's BMP280 Driver implements a [__Barometer Sensor__](https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L326-L331) that provides Pressure and Temperature values.

_What about BME280? Is there a NuttX Sensor that supports Pressure + Temperature + Humidity?_

Sadly no. Thus our BME280 Driver shall implement a __Composite Sensor__ that behaves like two NuttX Sensors combined...

-   [__Barometer Sensor: /dev/uorb/sensor_baro0__](https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L326-L331)

    (For Pressure and Temperature)

-   [__Humidity Sensor: /dev/uorb/sensor_humi0__](https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/sensor.h#L345-L349)

    (For Humidity)

We mash together the two sensors like so: [device.h](https://github.com/lupyuen/bme280-nuttx/blob/main/device.h#L36-L49)

```c
//  NuttX Device for BME280
struct device {
  //  Barometer Sensor (Pressure + Temperature)
  FAR struct sensor_lowerhalf_s sensor_baro;  
  //  Humidity Sensor
  FAR struct sensor_lowerhalf_s sensor_humi;  

  FAR struct i2c_master_s *i2c;  //  NuttX I2C interface
  uint8_t addr;                  //  BME280 I2C address
  int     freq;                  //  BME280 Frequency <= 3.4MHz
  bool    activated;             //  True if device is not in sleep mode
  char    *name;                 //  Name of the device (BME280)
  struct  bme280_data *data;     //  Compensation parameters (bme280.c)
};
```

Let's dive into the implementation of the two NuttX Sensors.

## Sensor Operations

Earlier we talked about the functions exposed by our NuttX Sensor Driver...

![Zephyr BME280 Driver mapped to NuttX Driver](https://lupyuen.github.io/images/bme280-port4.jpg)

Now we expose the functions twice (double exposure?) as the __Sensor Operations__ for our Barometer and Humidity Sensors: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L71-L87)

```c
//  Operations for Barometer Sensor
static const struct sensor_ops_s g_baro_ops = {
  .activate      = bme280_activate_baro,
  .fetch         = bme280_fetch_baro,
  .set_interval  = bme280_set_interval_baro,
};

//  Operations for Humidity Sensor
static const struct sensor_ops_s g_humi_ops = {
  .activate      = bme280_activate_humi,
  .fetch         = bme280_fetch_humi,
  .set_interval  = bme280_set_interval_humi,
};
```

_Barometer Sensor vs Humidity Sensor... How different are the Sensor Operations?_

The Sensor Operations look highly similar. This is how we fetch the __Barometer Sensor Data__: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L574-L617)

```c
//  Called by NuttX to fetch pressure and temperature from sensor
static int bme280_fetch_baro(
  FAR struct sensor_lowerhalf_s *lower,  //  Barometer Sensor
  FAR struct file *filep,  // NuttX File
  FAR char *buffer,  //  Buffer to return Sensor Data
  size_t buflen      //  Size of Buffer
) {
  //  Get NuttX Device Struct
  FAR struct device *priv = container_of(
    lower,              //  Barometer Sensor
    FAR struct device,  //  NuttX Device Struct
    sensor_baro         //  Barometer Sensor Struct
  );

  //  Validate buffer size
  struct sensor_baro baro_data;
  if (buflen != sizeof(baro_data)) { return -EINVAL; }

  //  Fetch the sensor data
  int ret = bme280_fetch(priv, &baro_data, NULL);
  if (ret < 0) { return ret; }

  //  Return the sensor data
  memcpy(buffer, &baro_data, sizeof(baro_data));
  return buflen;
}
```

And this is how we fetch the __Humidity Sensor Data__: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L619-L662)

```c
//  Called by NuttX to fetch humidity from sensor
static int bme280_fetch_humi(
  FAR struct sensor_lowerhalf_s *lower,  //  Humidity Sensor
  FAR struct file *filep,  // NuttX File
  FAR char *buffer,  //  Buffer to return Sensor Data
  size_t buflen      //  Size of Buffer
) {
  //  Get NuttX Device Struct
  FAR struct device *priv = container_of(
    lower,              //  Humidity Sensor
    FAR struct device,  //  NuttX Device Struct
    sensor_humi         //  Humidity Sensor Struct
  );

  //  Validate buffer size
  struct sensor_humi humi_data;
  if (buflen != sizeof(humi_data)) { return -EINVAL; }

  //  Fetch the sensor data
  int ret = bme280_fetch(priv, NULL, &humi_data);
  if (ret < 0) { return ret; }

  //  Return the sensor data
  memcpy(buffer, &humi_data, sizeof(humi_data));
  return buflen;
}
```

[(We've seen __bme280_fetch__ earlier)](https://lupyuen.github.io/articles/bme280#read-sensor-data-from-zephyr-driver)

The other Sensor Operations look similar too...

-   [__bme280_activate_baro__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L433-L458) vs [__bme280_activate_humi__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L460-L485)

    (Both functions call [__bme280_activate__](https://lupyuen.github.io/articles/bme280#power-management))

-   [__bme280_set_interval_baro__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L343-L368) vs [__bme280_set_interval_humi__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L370-L395)

    (Both functions call [__bme280_set_interval__](https://lupyuen.github.io/articles/bme280#standby-interval))

![Register Sensors](https://lupyuen.github.io/images/bme280-combine3a.png)

## Register Sensors

At NuttX Startup we __register the Barometer and Humidity Sensors__: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773)

```c
//  Register the BME280 device at startup
int bme280_register(
  int devno,  //  Instance number for driver
  FAR struct i2c_master_s *i2c  //  I2C Interface
) {
  //  Initialize the NuttX Device Struct
  FAR struct device *priv = (FAR struct device *)kmm_zalloc(sizeof(struct device));
  ...
  //  Allocate the Compensation Parameters
  struct bme280_data *data = (FAR struct bme280_data *)kmm_zalloc(sizeof(struct bme280_data));
  priv->data = data;
  ...
  //  Initialize the Barometer Sensor
  priv->sensor_baro.ops  = &g_baro_ops;
  priv->sensor_baro.type = SENSOR_TYPE_BAROMETER;

  //  Initialize the Humidity Sensor
  priv->sensor_humi.ops  = &g_humi_ops;
  priv->sensor_humi.type = SENSOR_TYPE_RELATIVE_HUMIDITY;

  //  Initialize the Sensor Hardware (Zephyr BME280 Driver)
  int ret = bme280_chip_init(priv);
  ...
  //  Set Power Mode to sleep (Zephyr BME280 Driver)
  ret = bme280_pm_action(priv, PM_DEVICE_ACTION_SUSPEND);
  ...
  //  Register the Barometer Sensor
  ret = sensor_register(&priv->sensor_baro, devno);
  ...
  //  Register the Humidity Sensor
  ret = sensor_register(&priv->sensor_humi, devno);
```

The function above is called at startup by __bl602_bringup__: [bl602_bringup.c](https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640)    

```c
#ifdef CONFIG_SENSORS_BME280
#include <nuttx/sensors/bme280.h>
#endif /* CONFIG_SENSORS_BME280 */
...
int bl602_bringup(void) {
  ...
#ifdef CONFIG_SENSORS_BME280
  //  Init I2C bus for BME280
  struct i2c_master_s *bme280_i2c_bus = bl602_i2cbus_initialize(0);
  if (!bme280_i2c_bus) { _err("ERROR: Failed to get I2C%d interface\n", 0); }

  //  Register the BME280 driver
  ret = bme280_register(0, bme280_i2c_bus);
  if (ret < 0) { _err("ERROR: Failed to register BME280\n"); }
#endif  //  CONFIG_SENSORS_BME280
```

__For ESP32:__ Edit the function [esp32_bringup](https://github.com/lupyuen/nuttx/blob/master/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497) in [esp32_bringup.c](https://github.com/lupyuen/nuttx/blob/master/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497) so that it calls [bme280_register](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773)

One last thing before running the BME280 Driver: We need to bundle together the NuttX and Zephyr Drivers.

![Zephyr BME280 Driver mapped to NuttX Driver](https://lupyuen.github.io/images/bme280-port4.jpg)

# Bundle NuttX and Zephyr Drivers

_Our BME280 Driver consists of two source files: bme280.c and driver.c. Will this work with NuttX?_

Nope this won't compile with NuttX, because it assumes that every Sensor Driver __lives in its own file__. [(Like bmp280.c)](https://github.com/lupyuen/nuttx/blob/master/drivers/sensors/bmp280.c)

To work around this, we bundle together the Zephyr Driver (bme280.c) and NuttX Driver (driver.c) into a __single source file__...

-   [__bme280-nuttx/bundle.c__](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c)

And we create a __Symbolic Link__ at [__drivers/sensors/bme280.c__](https://github.com/lupyuen/nuttx/blob/master/drivers/sensors/bme280.c)...

```bash
## Go to the NuttX Sensors Source directory
pushd nuttx/nuttx/drivers/sensors

## Add the BME280 Driver as a submodule
git submodule add \
  https://github.com/lupyuen/bme280-nuttx \
  bme280

## Create the Symbolic Link to the bundled source file
ln -s \
  bme280/bundle.c \
  bme280.c

## Return to the top directory
popd
```

We do the same for the bundled include file [__bme280-nuttx/bundle.h__](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.h)...

```bash
## Go to the NuttX Sensors Include directory
pushd nuttx/nuttx/include/nuttx/sensors

## Create the Symbolic Link to the bundled include file
ln -s \
  ../../../drivers/sensors/bme280/bundle.h \
  bme280.h

## Return to the top directory
popd
```

Which is Sym-Linked at [__include/nuttx/sensors/bme280.h__](https://github.com/lupyuen/nuttx/blob/master/include/nuttx/sensors/bme280.h)

_This bundling looks complicated. Why not merge the Zephyr and NuttX Drivers into a single source file?_

We wanted to reuse the Zephyr Driver with __minimal changes__ so that...

-   We can __track changes__ to the Zephyr source code...

-   By __isolating the parts__ that were modified for NuttX

And hopefully we can apply the same steps to port other Zephyr Drivers to NuttX.

Let's look inside the bundle.

![Inside the bundle](https://lupyuen.github.io/images/bme280-code7a.png)

[(Source)](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c)

## Inside the Bundle

_What's inside the bundled source file [__bundle.c__](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c)?_

We define the __Constants and Macros__ needed by the Zephyr Driver: [bundle.c](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c#L12-L29)

```c
//  Zephyr BME280 Options from
//  https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/Kconfig
#define CONFIG_BME280_MODE_NORMAL        //  Normal Sampling Mode (continuous measurements)
#define CONFIG_BME280_TEMP_OVER_2X       //  Temperature Oversamling 2x
#define CONFIG_BME280_PRESS_OVER_16X     //  Pressure Oversampling 16x
#define CONFIG_BME280_HUMIDITY_OVER_16X  //  Humidity Oversampling 16x
#define CONFIG_BME280_STANDBY_1000MS     //  Standby Time 1000ms. Note: Will be overwritten in bme280_set_standby
#define CONFIG_BME280_FILTER_4           //  Filter Coefficient 4
#define CONFIG_PM_DEVICE                 //  Enable Power Management

//  Other Zephyr Defines
#define BME280_BUS_I2C  0  //  I2C Bus
#define BME280_BUS_SPI  0  //  SPI Bus
#define __ASSERT_NO_MSG DEBUGASSERT  //  Assertion check
#define LOG_DBG         sninfo       //  Log info message
#define K_MSEC(ms)      (ms * 1000)  //  Convert milliseconds to microseconds
#define k_sleep(us)     usleep(us)   //  Sleep for microseconds
#define sys_le16_to_cpu(x) (x)       //  Convert from little endian to host endian. TODO: Handle big endian
```

Followed by the __Zephyr Types__: [bundle.c](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c#L31-L55)

```c
//  Zephyr Sensor Channel to be fetched from the sensor
enum sensor_channel {
  SENSOR_CHAN_ALL,           //  All Channels
  SENSOR_CHAN_AMBIENT_TEMP,  //  Ambient Temperature
  SENSOR_CHAN_PRESS,         //  Pressure
  SENSOR_CHAN_HUMIDITY,      //  Humidity
};

//  Zephyr Power Management Action
enum pm_device_action {
  PM_DEVICE_ACTION_SUSPEND,  //  Suspend the sensor
  PM_DEVICE_ACTION_RESUME,   //  Resume the sensor
};

//  Zephyr Power Management State
enum pm_device_state {
  PM_DEVICE_STATE_ACTIVE,     //  Sensor is active
  PM_DEVICE_STATE_SUSPENDED,  //  Sensor is suspended
};
 
//  Zephyr Sensor Value
struct sensor_value {
  int32_t val1;  //  Integer part of the value
  int32_t val2;  //  Fractional part of the value (in one-millionth parts)
};
```

And finally we __embed the source code__ of the Zephyr and NuttX Drivers: [bundle.c](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c#L74-L78)

```c
//  Embed Zephyr BME280 Driver
#include "bme280/bme280.c"

//  Embed NuttX Driver Wrapper
#include "bme280/driver.c"
```

Yes this looks peculiar...

## Zephyr Driver Modified For NuttX

_Sacrilege! We're #include-ing C source files?!_

Yeah this is probably the only way to port the Zephyr Driver to NuttX with the __fewest changes__.

Check out the __minor modifications__ we made to the Zephyr BME280 Driver while porting to NuttX...

-   [__Changes to bme280.c__](https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65)

-   [__Changes to bme280.h__](https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-e13ff0ab44de7ead31a3dd6cbbbbf2a6fbfb2f04889300993b87ff5a31ffc233)

In future we might merge the source files to clean this up. Not that hard!

![Changes to Zephyr BME280 Driver](https://lupyuen.github.io/images/bme280-code12.png)

[(Source)](https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65)

# Run BME280 Driver

We're finally ready to run our BME280 Driver!

1.  Follow these steps to __build, flash and run__ NuttX (with our driver inside)...

    [__"Build, Flash and Run NuttX"__](https://lupyuen.github.io/articles/bme280#appendix-build-flash-and-run-nuttx)

1.  At the NuttX Shell, enter this command to list the __NuttX Sensors__...

    ```bash
    ls /dev/uorb
    ```

1.  We should see our BME280 __Barometer and Humidity Sensors__...

    ```text
    /dev/uorb:
     baro0
     humi0
    ```

1.  To read the BME280 __Barometer Sensor__ once, enter this command...

    ```bash
    sensortest -n 1 baro0
    ```

1.  We should see the __Air Pressure__ and __Temperature__ readings...

    ```text
    SensorTest: Test /dev/uorb/sensor_baro0 with interval(1000000us), latency(0us)
    baro0: 
      timestamp: 43760000 
      value1:     1011.29 
      value2:       29.09
    SensorTest: Received message: baro0, number:1/1
    ```

    This says that the Air Pressure is __1,011.29 millibars__ and the Temperature is __29.09 ¬∞C__.

1.  Now enter this command to read the BME280 __Humidity Sensor__ once...

    ```bash
    sensortest -n 1 humi0
    ```

1.  We should see the __Relative Humidity__...

    ```text
    SensorTest: Test /dev/uorb/sensor_humi0 with interval(1000000us), latency(0us)
    humi0: 
      timestamp: 60120000 
      value:     90.58
    SensorTest: Received message: humi0, number:1/1
    ```

    This says that the Relative Humidity is __90.58 %__.

    [(See the complete log)](https://github.com/lupyuen/bme280-nuttx#combined-barometer-and-humidity-sensor)

Yep our BME280 Driver runs successfully on NuttX!

![Running our NuttX BME280 Driver](https://lupyuen.github.io/images/bme280-run8a.png)

# Sensor Test App

Just now we ran the __Sensor Test App__ to read BME280's Barometer and Humidity Sensors (pic above)...

```bash
nsh> sensortest -n 1 baro0
baro0: 
  timestamp: 43760000 
  value1:     1011.29 
  value2:       29.09

nsh> sensortest -n 1 humi0
humi0: 
  timestamp: 60120000 
  value:     90.58
```

(That's 1,011.29 millibars, 29.09 ¬∞C, 90.58 % Humidity)

Let's take a quick look inside the Sensor Test App, so that we can code our own Sensor Apps: [sensortest.c](https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L233-L401)

```c
//  Sensor Test App
int main(int argc, FAR char *argv[]) {
  ...
  //  Allocate buffer for Sensor Data.
  //  len is Sensor Data size: sizeof(struct sensor_baro)
  FAR char *buffer = calloc(1, len);
```

The app begins by allocating a buffer for the Sensor Data Struct: __sensor_baro__ (Barometer) or __sensor_humi__ (Humidity).

Next we open the Sensor Device: __/dev/uorb/sensor_baro0__ (Barometer) or __/dev/uorb/sensor_humi0__ (Humidity)...

```c
  //  Open the Sensor Device.
  //  devname looks like "/dev/uorb/sensor_baro0"
  int fd = open(devname, O_RDONLY | O_NONBLOCK);
  if (fd < 0) { /* Handle error */ ... }
```

We set the [__Standby Interval__](https://lupyuen.github.io/articles/bme280#standby-interval) and __Batch Latency__...

```c
  //  Set Standby Interval
  int ret = ioctl(fd, SNIOC_SET_INTERVAL, interval);
  if (ret < 0) { /* Handle error */ ... }

  //  Set Batch Latency
  ret = ioctl(fd, SNIOC_BATCH, latency);
  if (ret < 0) { /* Handle error */ ... }
```

We prepare to __poll our sensor__...

```c
  //  Prepare to poll the Sensor
  struct pollfd fds;
  fds.fd     = fd;
  fds.events = POLLIN;
```

Then we __poll, read and print the Sensor Data__...

```c
  //  Repeat until all samples have been read
  while ((!count || received < count) && !g_should_exit) {

    //  If Sensor Data is available...
    if (poll(&fds, 1, -1) > 0) {

      //  Read the Sensor Data
      if (read(fd, buffer, len) >= len) {

        //  Print the Sensor Data
        received++;
        g_sensor_info[idx]
          .print(buffer, name);
      }
    }
  }
```

(We'll see __g_sensor_info__ and __print__ in a while)

Finally we __close the sensor__...

```c
  //  Close the Sensor Device and free the buffer
  close(fd);
  free(buffer);
```

Let's talk about the printing of Sensor Data.

## Print Sensor Data

Earlier we saw this code for __printing Sensor Data__...

```c
//  Print the Sensor Data
g_sensor_info[idx]
  .print(buffer, name);
```

_What's g_sensor_info?_

[__g_sensor_info__](https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L77-L110) is a Lookup Table that defines the __Print Function__ for every Sensor Type.

(Remember that the Sensor Test App needs to handle all Sensor Types)

Here's the Print Function for our __Barometer Sensor__: [sensortest.c](https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L146-L151)

```c
//  Print Barometer Sensor Data: Pressure and Temperature
static void print_valf2(const char *buffer, const char *name) {

  //  Cast buffer as Barometer Sensor Data
  struct sensor_baro *event = 
    (struct sensor_baro *) buffer;

  //  Print Pressure and Temperature
  printf(
    "%s: timestamp:%" PRIu64 " value1:%.2f value2:%.2f\n",
    name, 
    event->timestamp, 
    event->pressure, 
    event->temperature
  );
}
```

And here's the Print Function for our __Humidity Sensor__: [sensortest.c](https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L139-L144)

```c
//  Print Humidity or Proximity Sensor Data
static void print_valf(const char *buffer, const char *name) {

  //  Cast buffer as Proximity Sensor Data,
  //  which has same size as Humidity Sensor Data
  struct sensor_prox *event = 
    (struct sensor_prox *) buffer;

  //  Print Humidity or Proximity
  printf(
    "%s: timestamp:%" PRIu64 " value:%.2f\n",
    name, 
    event->timestamp, 
    event->proximity
  );
}
```

_But we're printing Humidity, not Proximity... Why cast to sensor_prox?_

Yep we should cast to __sensor_humi__ instead...

```c
//  Cast buffer as Humidity Sensor Data
struct sensor_humi *event = 
  (struct sensor_humi *) buffer;
```

The Sensor Test App reuses the same function __print_valf__ for printing both Humidity and Proximity Sensor Data. Which is OK because both structs contain the same field types.

_How is the Print Function defined for each Sensor Type?_

The Print Functions are defined in the Lookup Table __g_sensor_info__: [sensortest.c](https://github.com/lupyuen/nuttx-apps/blob/master/testing/sensortest/sensortest.c#L77-L110)

```c
//  Lookup Table of all Sensor Types
static const struct sensor_info g_sensor_info[] = {
  ...
  //  Print Barometer Sensor Data with print_valf2
  { print_valf2, 
    sizeof(struct sensor_baro), 
    "baro" },

  //  Print Humidity Sensor Data with print_valf
  { print_valf,  
    sizeof(struct sensor_humi), 
    "humi" },
```

For our own Sensor App we probably won't need this Lookup Table, since we know which Sensor Type we're using.

(And we don't need to cast our Sensor Data Structs too)

![Connect BME280 to #RISCV PineCone #BL602 @PINE64 ... Preferably not on a cooking pot üòÇ](https://lupyuen.github.io/images/bme280-pot.jpg)

# What's Next

Today we described the steps for porting the BME280 Driver from Zephyr OS to NuttX.

[(And we fixed an I2C quirk on BL602)](https://lupyuen.github.io/articles/bme280#set-i2c-sub-address)

I hope you'll be inspired to port [__other Zephyr drivers__](https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers) to NuttX!

_Besides Zephyr OS, where else can we find drivers for NuttX?_

[__Embedded Rust__](https://lupyuen.github.io/articles/rust2) might be a terrific source of drivers for NuttX.

[(Check out the Embedded Rust drivers)](https://github.com/rust-embedded/awesome-embedded-rust#driver-crates)

But first we need to wrap up the [__NuttX I2C ioctl Interface__](https://github.com/lupyuen/nuttx-apps/tree/master/system/i2c) as a [__Rust Embedded HAL__](https://docs.rs/embedded-hal/0.2.6/embedded_hal/blocking/i2c/index.html).

We'll cover this in the next article...

-   [__"Rust talks I2C on Apache NuttX RTOS"__](https://lupyuen.github.io/articles/rusti2c)

The BME280 Driver can also be called from Zig...

-   [__"Read NuttX Sensor Data with Zig"__](https://lupyuen.github.io/articles/sensor)

-   [__"Zig Visual Programming with Blockly"__](https://lupyuen.github.io/articles/blockly)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [Sponsor me a coffee](https://github.com/sponsors/lupyuen)

-   [Discuss this article on Reddit](https://www.reddit.com/r/RISCV/comments/t9x9yk/apache_nuttx_driver_for_bme280_sensor_ported_from/)

-   [Read "The RISC-V BL602 / BL604 Book"](https://lupyuen.github.io/articles/book)

-   [Check out my articles](https://lupyuen.github.io)

-   [RSS Feed](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[`lupyuen.github.io/src/bme280.md`](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/bme280.md)

# Notes

1.  This article is the expanded version of [this Twitter Thread](https://twitter.com/MisterTechBlog/status/1494301654186823683)

1.  The design of the __NuttX Sensor API__ is discussed here...

    [__"Unified Management for Sensor"__](https://github.com/apache/nuttx/pull/2039)

1.  How to access the I2C Port in a __NuttX App__ via ioctl? See this...

    [__"Read I2C Register in C (NuttX App)"__](https://lupyuen.github.io/articles/rusti2c#appendix-read-i2c-register-in-c)

![Log I2C Transfers](https://lupyuen.github.io/images/bme280-code3a.png)

# Appendix: Quirks in BL602 NuttX I2C Driver

The BL602 NuttX I2C Driver works in mysterious ways (because of the I2C Sub Address). In this section we'll explain how to make the driver work correctly, and attempt to decipher the original intentions of the driver's creator.

BL602 has a peculiar I2C Port that requires us to send the Register ID as __I2C Sub Address__ (I2C_SUB_ADDR), separately from the I2C Data...

![I2C Sub Address](https://lupyuen.github.io/images/bme280-subaddress2.png)

[(From BL602 Reference Manual)](https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en)

_Will BL602 I2C work if we disable I2C Sub Address?_

Nope. If we disable I2C Sub Address, the Register ID sent will be `0x00`. [(See this)](https://lupyuen.github.io/articles/bme280#incorrect-register-id)

Thus we must set the Register ID as I2C Sub Address when reading and writing I2C Registers. Here's how we do this by passing the __I2C_M_NOSTOP__ flag...

## Read I2C Register

When __reading an I2C Register__, we set the flag __I2C_M_NOSTOP__ like so: [bme280-nuttx/driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L147-L198)

```c
//  Read from 8-bit BME280 registers
static int bme280_reg_read(const struct device *priv,
  uint8_t start, uint8_t *buf, int size) {
  struct i2c_msg_s msg[2];
  int ret;

  //  Send Register ID
  msg[0].frequency = priv->freq;
  msg[0].addr      = priv->addr;
#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0
  msg[0].buffer    = &start;
  msg[0].length    = 1;

  //  Receive Register Value
  msg[1].frequency = priv->freq;
  msg[1].addr      = priv->addr;
  msg[1].flags     = I2C_M_READ;
  msg[1].buffer    = buf;
  msg[1].length    = size;

  //  Execute I2C transfers
  ret = I2C_TRANSFER(priv->i2c, msg, 2);
```

This transmits the Register ID as I2C Sub Address, then receives the Register Value.

## Write I2C Register

When __writing an I2C Register__, we need two steps...

1.  Send the __Register ID and Register Value__ (in a single chunk) as I2C Sub Address

1.  Followed by __I2C Read__

Here's how: [bme280-nuttx/driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L200-L247)

```c
//  Write to an 8-bit BME280 register
static int bme280_reg_write(const struct device *priv, uint8_t reg,
  uint8_t val) {
  struct i2c_msg_s msg[2];
  uint8_t txbuffer[2];
  uint8_t rxbuffer[1];
  int ret;

  //  Transmit buffer contains Register ID and value
  txbuffer[0] = reg;
  txbuffer[1] = val;

  //  Send Register ID and value
  msg[0].frequency = priv->freq;
  msg[0].addr      = priv->addr;
#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID and value must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID and value as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0
  msg[0].buffer    = txbuffer;
  msg[0].length    = 2;

  //  For BL602: We read I2C Data because this 
  //  forces BL602 to send the first message correctly
  msg[1].frequency = priv->freq;
  msg[1].addr      = priv->addr;
  msg[1].flags     = I2C_M_READ;
  msg[1].buffer    = rxbuffer;
  msg[1].length    = sizeof(rxbuffer);

  //  Execute I2C transfers
  ret = I2C_TRANSFER(priv->i2c, msg, 2);
```

## Must Read After Write

_Why must we do I2C Read after sending the Register ID and value?_

We're not sure why this happens with the BL602 I2C Driver. But it works correctly when we checked with a Logic Analyser.

Here's what happens when we run the code above to write `0xA0` to Register ID `0xF5` at I2C Address `0x77`...

```text
Setup Write to [0xEE] + ACK
0xF5 + ACK
0xA0 + ACK
Setup Read to [0xEF] + ACK
0xA0 + NAK
```

![Write 0xA0 to Register 0xF4](https://lupyuen.github.io/images/rusti2c-logic3a.png)

Which looks correct. There's an extra I2C Read at the end, but it's harmless.

_What if we write to the I2C Register without reading?_

The I2C Address is sent incorrectly (`0x02`) and the I2C Write gets truncated...

```text
Setup Write to [0x02] + NAK
```

![Write to I2C Register without reading](https://lupyuen.github.io/images/rusti2c-noread.png)

_What if we send the Register ID and Register Value as I2C Data (flags = 0) instead of I2C Sub Address?_

The Register ID and value are sent incorrectly as `0x00 0x00`...

```text
Setup Write to [0xEE] + ACK
0x00 + ACK
0x00 + ACK
(...600 microseconds later...)
Setup Read to [0xEF] + ACK
0x00 + NAK
```

![Send the Register ID and Register Value as I2C Data instead of I2C Sub Address](https://lupyuen.github.io/images/rusti2c-nosubaddr.png)

Let's try to make sense of this mysterious behaviour...

## I2C Sub Address

_How is I2C Sub Address supposed to work on BL602 anyway?_

Let's compare with the I2C Driver from Bouffalo Lab's official __BL602 IoT SDK__...

-   [__"Set I2C Device Address and Register Address"__](https://lupyuen.github.io/articles/i2c#set-i2c-device-address-and-register-address)

-   [__"Create I2C Message"__](https://lupyuen.github.io/articles/i2c#create-i2c-message)

Here's the code that reads Register ID `0xD0` from I2C Address `0x77`...

```c
//  Define I2C message and buffer
static i2c_msg_t read_msg;    //  Message for reading I2C Data
static uint8_t read_buf[32];  //  Buffer for reading I2C Data

static void test_i2c_start_read(char *buf, int len, int argc, char **argv) {
  //  Start reading data from I2C device
  //  Expect result 0x60 for BME280, 0x58 for BMP280
  int data_len = 1;  //  Bytes to be read
  memset(read_buf, 0, sizeof(read_buf));

  //  Set the I2C operation    
  read_msg.i2cx    = 0;            //  I2C Port
  read_msg.direct  = I2C_M_READ;   //  Read I2C data
  read_msg.block   = I2C_M_BLOCK;  //  Wait until data has been read

  //  Set the I2C buffer
  read_msg.buf     = read_buf;     //  Read buffer
  read_msg.len     = data_len;     //  Number of bytes to be read
  read_msg.idex    = 0;            //  Index of next byte to be read into buf

  //  Set device address and register address
  read_msg.addr    = 0x77;   //  BME280 I2C Secondary Address (Primary Address is 0x76)
  read_msg.subflag = 1;      //  Enable Register Address
  read_msg.subaddr = 0xd0;   //  Register Address (BME280 Chip ID)
  read_msg.sublen  = 1;      //  Length of Register Address (bytes)

  //  Start the I2C transfer and enable I2C interrupts
  gpstmsg = &read_msg;
  i2c_transfer_start(&read_msg);
```

Note that this code executes __only one I2C Transfer__.

(BL602 NuttX requires __two I2C Transfers__: One for Register ID, another for Register Value)

From BL602 IoT SDK we see that each I2C Transfer is allowed to specify an __I2C Sub Address on top of each I2C Read / Write Transfer__.

## BL602 I2C Driver

But on NuttX it seems that this overlay of I2C Sub Address on I2C Read / Write Transfers is __not supported__.

The creator of the BL602 NuttX I2C Driver has decided to split the I2C Sub Address and I2C Read / Write as __two separate I2C Transfers__.

We see this in the BL602 NuttX I2C Driver: [bl602_i2c.c](https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L710-L742)

```c
//  Execute the I2C transfers
static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  priv->msgv = msgs;

  //  Execute each I2C Transfer...
  for (i = 0; i < count; i++)
    {
      priv->bytes    = 0;
      priv->i2cstate = EV_I2C_END_INT;

      bl602_i2c_set_freq(msgs[i].frequency);

      //  If I2C_M_NOSTOP is specified, 
      //  send entire message as I2C Sub Address
      if (msgs[i].flags & I2C_M_NOSTOP)
        {
          priv->subflag = 1;
          priv->subaddr = 0;
          for (j = 0; j < msgs[i].length; j++)
            {
              priv->subaddr += msgs[i].buffer[j] << (j * 8);
            }

          //  Note: Entire message is the I2C Sub Address!
          priv->sublen = msgs[i].length;
          i++;
        }
      //  Else send message as I2C Data
      //  (Read / Write Transfer)
      else
        {
          priv->subflag = 0;
          priv->subaddr = 0;
          priv->sublen  = 0;
        }

      priv->msgid = i;
      bl602_i2c_start_transfer(priv);
```

This driver code shows that each I2C Transfer is either...

1.  __I2C Sub Address__

1.  Or __I2C Data__ (Read / Write Transfer)

No mixing of the two is allowed.

I haven't deciphered the rest of the I2C Driver, but I think this separation of I2C Sub Address causes problems for I2C Write. Hence the need to do I2C Read after I2C Write.

In summary: The creator of the BL602 NuttX I2C Driver might have __force-fitted I2C Sub Address__ into the NuttX I2C Interface, causing problems for I2C Write.

The solution? We might need to __extend the NuttX I2C Interface__ to support I2C Sub Addresses. (Instead of I2C_M_NOSTOP)

[(Besides BL602, NXP Microcontrollers are probably the only ones that support I2C Sub Addresses)](https://mcuxpresso.nxp.com/api_doc/dev/116/group__i2c.html)

## Configure I2C Transfer

_How is the I2C Sub Address configured on NuttX?_

Below is the code from the BL602 I2C Driver that configures the I2C Sub Address for each I2C Transfer: [bl602_i2c.c](https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L275-L319)

```c
//  Configure the parameters for an I2C Transfer
static void bl602_i2c_config_para(struct bl602_i2c_priv_s *priv) {
  struct i2c_msg_s *msg = &priv->msgv[priv->msgid];

  //  Set the I2C Direction: Read or write
  if (msg->flags & I2C_M_READ)
    {
      modifyreg32(BL602_I2C_CONFIG, 0, I2C_CONFIG_CR_I2C_PKT_DIR);
    }
  else
    {
      modifyreg32(BL602_I2C_CONFIG, I2C_CONFIG_CR_I2C_PKT_DIR, 0);
    }

  //  Set the I2C Address
  modifyreg32(BL602_I2C_CONFIG,
              I2C_CONFIG_CR_I2C_SLV_ADDR_MASK,
              msg->addr << I2C_CONFIG_CR_I2C_SLV_ADDR_SHIFT);

  //  If this I2C Transfer is for I2C Sub Address...
  if (priv->subflag > 0)
    {
      //  Enable I2C Sub Address
      modifyreg32(BL602_I2C_CONFIG, 0, I2C_CONFIG_CR_I2C_SUB_ADDR_EN);
      //  Set the I2C Sub Address length
      modifyreg32(BL602_I2C_CONFIG,
                  I2C_CONFIG_CR_I2C_SUB_ADDR_BC_MASK,
                  (priv->sublen - 1) << I2C_CONFIG_CR_I2C_SUB_ADDR_BC_SHIFT);
    }
  else
    {
      //  Else disable I2C Sub Address
      modifyreg32(BL602_I2C_CONFIG, I2C_CONFIG_CR_I2C_SUB_ADDR_EN, 0);
    }

  //  Set the I2C Message Length
  modifyreg32(BL602_I2C_CONFIG,
              I2C_CONFIG_CR_I2C_PKT_LEN_MASK,
              (msg->length - 1) << I2C_CONFIG_CR_I2C_PKT_LEN_SHIFT);

  //  If this I2C Transfer is for I2C Sub Address...
  if (priv->subflag > 0)
    {
      //  Set the I2C Sub Address
      putreg32(priv->subaddr, BL602_I2C_SUB_ADDR);
    }
}
```

# Appendix: Log I2C Transfers

Here's how we modded the BL602 I2C Driver on NuttX to __log the I2C transfers__...

For sending I2C data: [bl602_i2c.c](https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L194-L197)

```c
static void bl602_i2c_send_data(struct bl602_i2c_priv_s *priv)
{
  ...
  putreg32(temp, BL602_I2C_FIFO_WDATA);
  priv->bytes += count;
  //  Insert this
  i2cinfo("count=%d, temp=0x%x\n", count, temp);
}
```

For receiving I2C data: [bl602_i2c.c](https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L207-L216)

```c
static void bl602_i2c_recvdata(struct bl602_i2c_priv_s *priv)
{
  ...
  count = msg->length - priv->bytes;
  temp  = getreg32(BL602_I2C_FIFO_RDATA);
  //  Insert this
  i2cinfo("count=%d, temp=0x%x\n", count, temp);
```

For I2C transfers: [bl602_i2c.c](https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_i2c.c#L740-L742)

```c
static int bl602_i2c_transfer(struct i2c_master_s *dev,
                              struct i2c_msg_s *   msgs,
                              int                      count)
{
  ...
  for (i = 0; i < count; i++)
    {
      ...
      priv->msgid = i;
      //  Insert this before bl602_i2c_start_transfer
      i2cinfo("subflag=%d, subaddr=0x%x, sublen=%d\n", priv->subflag, priv->subaddr, priv->sublen);
```

# Appendix: Build, Flash and Run NuttX

_(For BL602, BL604 and ESP32)_

Below are the steps to build, flash and run NuttX on BL602, BL604 and ESP32.

The instructions below will work on __Linux (Ubuntu)__, __WSL (Ubuntu)__ and __macOS__.

[(Instructions for other platforms)](https://nuttx.apache.org/docs/latest/quickstart/install.html)

[(See this for Arch Linux)](https://popolon.org/gblog3/?p=1977&lang=en)

## Download NuttX

To use the NuttX BME280 Driver, download the modified source code for __NuttX OS and NuttX Apps__...

```bash
mkdir nuttx
cd nuttx
git clone --recursive https://github.com/lupyuen/nuttx nuttx
git clone --recursive https://github.com/lupyuen/nuttx-apps apps
```

Or if we prefer to __add the BME280 Driver__ to our NuttX Project, follow these instructions...

-   [__"Install BME280 Driver"__](https://github.com/lupyuen/bme280-nuttx#install-driver)

[(__For PineDio Stack BL604:__ The BME280 Driver is already preinstalled)](https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features)

## Configure NuttX

Now we configure our NuttX project...

1.  Install the build prerequisites...

    [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

1.  Configure the build...

    ```bash
    cd nuttx

    ## For BL602: Configure the build for BL602
    ./tools/configure.sh bl602evb:nsh

    ## For PineDio Stack BL604: Configure the build for BL604
    ./tools/configure.sh bl602evb:pinedio

    ## For ESP32: Configure the build for ESP32.
    ## TODO: Change "esp32-devkitc" to our ESP32 board.
    ./tools/configure.sh esp32-devkitc:nsh

    ## Edit the Build Config
    make menuconfig 
    ```

1.  Enable __I2C0 Port__...

    __For BL602 / BL604:__ Check the box for __"System Type"__ ‚Üí __"BL602 Peripheral Support"__ ‚Üí __"I2C0"__

    __For ESP32:__ Check the box for __"System Type"__ ‚Üí __"ESP32 Peripheral Select"__ ‚Üí __"I2C 0"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable the I2C Port and I2C Character Driver](https://lupyuen.github.io/images/bme280-config1.jpg)

1.  Enable __I2C Character Driver__...

    Check the box for __"Device Drivers"__ ‚Üí __"I2C Driver Support"__ ‚Üí __"I2C Character Driver"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Enable __BME280 Driver__...

    Check the box for __"Device Drivers"__ ‚Üí __"Sensor Device Support"__

    Select __"Sensor Device Support"__

    Check the box for __"Bosch BME280 Sensor"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    The BME280 Driver will appear in NuttX at __/dev/uorb/sensor_baro0__ and __/dev/uorb/sensor_humi0__

1.  Enable __Sensor Driver Test App__...

    Check the box for __"Application Configuration"__ ‚Üí __"Testing"__ ‚Üí __"Sensor Driver Test"__

    Set __"Sensor Driver Test Stack Size"__ to __4096__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable the Sensor Test App](https://lupyuen.github.io/images/bme280-config4a.png)

1.  Enable __ls__ command...

    Select __"Application Configuration"__ ‚Üí __"NSH Library"__ ‚Üí __"Disable Individual commands"__
    
    Uncheck __"Disable ls"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Enable __Logging and Assertion Checks__...

    Select __"Build Setup"__ ‚Üí __"Debug Options"__

    Check the boxes for the following...

    ```text
    Enable Debug Features
    Enable Error Output
    Enable Warnings Output
    Enable Informational Debug Output
    Enable Debug Assertions
    I2C Debug Features
    I2C Error Output
    I2C Warnings Output
    I2C Informational Output  
    Sensor Debug Features
    Sensor Error Output
    Sensor Warnings Output  
    Sensor Informational Output 
    ```

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Save the configuration and exit menuconfig

    [(See the .config for BL602)](https://gist.github.com/lupyuen/9d84889f5e2415ecb0f28cea2c2a657f)

## Build NuttX

Follow these steps to build NuttX for BL602, BL604 or ESP32...

1.  To build NuttX, enter this command...

    ```bash
    make
    ```

1.  We should see...

    ```text
    LD: nuttx
    CP: nuttx.hex
    CP: nuttx.bin
    ```

    [(See the complete log for BL602 / BL604)](https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746)

1.  __For WSL:__ Copy the __NuttX Firmware__ to the __c:\blflash__ directory in the Windows File System...

    ```bash
    ##  /mnt/c/blflash refers to c:\blflash in Windows
    mkdir /mnt/c/blflash
    cp nuttx.bin /mnt/c/blflash
    ```

    For WSL we need to run __blflash__ under plain old Windows CMD (not WSL) because it needs to access the COM port.

1.  In case of problems, refer to the __NuttX Docs__...

    [__"BL602 / BL604 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html)

    [__"ESP32 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html)

    [__"Installing NuttX"__](https://nuttx.apache.org/docs/latest/quickstart/install.html)

> ![Building NuttX](https://lupyuen.github.io/images/nuttx-build2.png)

## Flash NuttX

__For ESP32:__ [__See instructions here__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing) [(Also check out this article)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602 / BL604:__ Follow these steps to install __blflash__...

1.  [__"Install rustup"__](https://lupyuen.github.io/articles/flash#install-rustup)

1.  [__"Download and build blflash"__](https://lupyuen.github.io/articles/flash#download-and-build-blflash)

We assume that our Firmware Binary File __nuttx.bin__ has been copied to the __blflash__ folder.

Set BL602 / BL604 to __Flashing Mode__ and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __High__ [(Like this)](https://lupyuen.github.io/images/pinedio-high.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`H` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperh.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Connect BL10 to the USB port

1.  Press and hold the __D8 Button (GPIO 8)__

1.  Press and release the __EN Button (Reset)__

1.  Release the D8 Button

__For [Ai-Thinker Ai-WB2](https://docs.ai-thinker.com/en/wb2), Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __3.3V__

1.  Reconnect the board to the USB port

Enter these commands to flash __nuttx.bin__ to BL602 / BL604 over UART...

```bash
## For Linux: Change "/dev/ttyUSB0" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change "/dev/tty.usbserial-1410" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change "COM5" to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
```

[(See the Output Log)](https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f)

For WSL: Do this under plain old Windows CMD (not WSL) because __blflash__ needs to access the COM port.

[(Flashing WiFi apps to BL602 / BL604? Remember to use __bl_rfbin__)](https://github.com/apache/nuttx/issues/4336)

[(More details on flashing firmware)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

![Flashing NuttX](https://lupyuen.github.io/images/nuttx-flash2.png)

## Run NuttX

__For ESP32:__ Use Picocom to connect to ESP32 over UART...

```bash
picocom -b 115200 /dev/ttyUSB0
```

[(More about this)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602 / BL604:__ Set BL602 / BL604 to __Normal Mode__ (Non-Flashing) and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __Low__ [(Like this)](https://lupyuen.github.io/images/pinedio-low.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`L` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperl.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Press and release the __EN Button (Reset)__

__For [Ai-Thinker Ai-WB2](https://docs.ai-thinker.com/en/wb2), Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __GND__

1.  Reconnect the board to the USB port

After restarting, connect to BL602 / BL604's UART Port at 2 Mbps like so...

__For Linux:__

```bash
screen /dev/ttyUSB0 2000000
```

__For macOS:__ Use CoolTerm ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__For Windows:__ Use `putty` ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__Alternatively:__ Use the Web Serial Terminal ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

Press Enter to reveal the __NuttX Shell__...

```text
NuttShell (NSH) NuttX-10.2.0-RC0
nsh>
```

Congratulations NuttX is now running on BL602 / BL604!

[(More details on connecting to BL602 / BL604)](https://lupyuen.github.io/articles/flash#watch-the-firmware-run)

![Running NuttX](https://lupyuen.github.io/images/nuttx-boot2.png)

__macOS Tip:__ Here's the script I use to build, flash and run NuttX on macOS, all in a single step: [run.sh](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

![Script to build, flash and run NuttX on macOS](https://lupyuen.github.io/images/spi2-script.png)

[(Source)](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)
