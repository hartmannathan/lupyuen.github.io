# Rendering PinePhone's Display (DE and TCON0)

📝 _2 Nov 2022_

![PinePhone rendering Mandelbrot Set on Apache NuttX RTOS](https://lupyuen.github.io/images/de-title.jpg)

_PinePhone rendering Mandelbrot Set on Apache NuttX RTOS_

In the last 2 articles we talked about [__Pine64 PinePhone__](https://wiki.pine64.org/index.php/PinePhone) (pic above) and how we built a __Display Driver__ for PinePhone's MIPI Display Serial Interface...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

But our PinePhone Display Driver __isn't complete__... It won't render any graphics!

Today we'll learn about the missing bits in our Display Driver...

-   What's the __Display Engine (DE)__ inside PinePhone

-   How the __Timing Controller (TCON0)__ controls PinePhone's LCD Display

-   How we call DE and TCON0 to __render graphics__

-   How our new __PinePhone Display Driver__ will support DE and TCON0

_Why are we doing this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone and we have created a (barebones) [__Display Driver in Zig__](https://lupyuen.github.io/articles/dsi2) that initialises the LCD Display.

To finish the driver, we need to understand what's inside PinePhone's Display Engine and Timing Controller.

Let's dive in and continue the journey from our (super long) __NuttX Porting Journal__...

-   [__lupyuen/pinephone-nuttx__](https://github.com/lupyuen/pinephone-nuttx)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Display Rendering on PinePhone

_Suppose we're building our own Operating System for PinePhone..._

_How do we render graphics on the LCD Display?_

Rendering graphics directly to PinePhone Hardware ("Bare Metal") is more complicated than we expect!

Let's walk through the steps (pic above)...

1.  Inside PinePhone's [__Allwinner A64 SoC__](https://linux-sunxi.org/A64) is a __Display Engine__ that combines and transforms Pixel Data for display

1.  The Display Engine reads the Pixel Data from __Framebuffers in RAM__ via __Direct Memory Access (DMA)__

    (Up to 3 Framebuffers)

1.  Inside the Display Engine is a __Real-Time Mixer__ (RT Mixer Core 0) that handles real-time __DMA, Overlay, Scaling and Blending__ of the Pixel Data (from the Framebuffers)

    (We won't need RT Mixer Core 1 today, it's a smaller version of Core 0)

1.  The Real-Time Mixer supports __3 UI Channels__ (for graphics), all mixed together into a __Single Image Frame__ in real time

    (The Mixer supports Video, but we won't use it today)

1.  The successive Image Frames (generated by the Display Engine) are pumped in real time to the __Timing Controller (TCON0)__

1.  The Timing Controller pushes the Image Frames to __PinePhone's LCD Controller__ as a stream of pixels (over MIPI Display Serial Interface)

All this happens in __Real Time__... Any updates to the Framebuffers in RAM are __pushed out instantly__ to the LCD Display.

(Super efficient thanks to DMA!)

_Why so complicated?_

PinePhone's ST7703 LCD Controller __doesn't have any RAM__ inside...

-   [__"Sitronix ST7703 LCD Controller"__](https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller)

That's why we need to __pump a constant stream of pixels__ to the LCD Display via DMA, Display Engine and Timing Controller... Otherwise the display stays blank!

[(Sounds a bit like the Amiga Video Toaster)](https://en.wikipedia.org/wiki/Video_Toaster)

Let's look inside the Display Engine...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

# Display Engine in Allwinner A64

Recall that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the __Timing Controller (TCON0)__ for display on PinePhone's LCD Display.

The pic above shows how the Display Engine mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3.

(Plus a Video Channel on DMA0, but we won't use it today)

_Is the Display Engine documented?_

The official doc for the A64 Display Engine is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

Though it doesn't describe the actual steps for programming the Display Engine.

In a while we'll boot [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) on PinePhone and experiment with the Display Engine, to understand it better.

[(Overview of A64 Display Engine)](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But the Display Engine doc doesn't mention A64?_

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with 64-bit Cores...

> "The A64 is basically an Allwinner H3 with the Cortex-A7 cores replaced with Cortex-A53 cores (ARM64 architecture). They share most of the memory map, clocks, interrupts and also uses the same IP blocks."

> [(Source)](https://linux-sunxi.org/A64)

_Why are there 2 Mixers in the A64 Display Engine?_

Maybe because A64 (or H3) was designed for [__OTT Set-Top Boxes__](https://linux-sunxi.org/H3) with Picture-In-Picture Overlay Videos?

The 3 UI Overlay Channels would be super helpful for overlaying an OTT Graphical UI on top of a Video Channel.

[(Wait... Wasn't Pine64 created thanks to OTT Boxes? 🤔)](https://en.wikipedia.org/wiki/Pine64#History)

![Rendering simple Colour Blocks on the PinePhone Display](https://lupyuen.github.io/images/de-code1a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

# Render Colours

_How do we program the A64 Display Engine to render graphics?_

Let's begin by rendering simple __Colour Blocks__ on the PinePhone Display...

![Blue, Green, Red Blocks on PinePhone](https://lupyuen.github.io/images/de-rgb.jpg)

First we __allocate the Framebuffer__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

[(PinePhone's display resolution is 720 x 1440)](https://en.wikipedia.org/wiki/PinePhone)

Each Pixel occupies __4 bytes__. (ARGB 8888 Format)

Then we __fill the Framebuffer__ with Blue, Green and Red: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

```c
// Fill with Blue, Green and Red
for (int i = 0; i < fb0_len; i++) {
  // Colours are in ARGB format
  if (i < fb0_len / 4) {
    // Blue for top quarter
    fb0[i] = 0x80000080;
  } else if (i < fb0_len / 2) {
    // Green for next quarter
    fb0[i] = 0x80008000;
  } else {
    // Red for lower half
    fb0[i] = 0x80800000;
  }
}
```

Each Pixel in the Framebuffer is stored as __32-bit ARGB 8888__.

Thus __`0x8000` `8000`__ means Semi-Transparent Green...

| Channel | Value |
|:--------|-------|
| Alpha | `0x80` |
| Red   | `0x00` |
| Green | `0x80` |
| Blue  | `0x00` |

A64 Display Engine lets us render of 3 Framebuffers as __3 UI Channels__.

This is how we allocate the 3 UI Channels: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L262)

```c
// Allocate 3 UI Channels
static struct display disp;
memset(&disp, 0, sizeof(disp));
struct display *d = &disp;
```

[(__`display`__ struct is defined here)](https://megous.com/git/p-boot/tree/src/display.h#n28)

We point the __First UI Channel__ to our Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L262-L271)

```c
// Init UI Channel 1: (Base Channel)
// Fullscreen 720 x 1440
d->planes[0].fb_start = (uintptr_t) fb0;  // Framebuffer Address
d->planes[0].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[0].src_w    = 720;   // Source Width
d->planes[0].src_h    = 1440;  // Source Height
d->planes[0].dst_w    = 720;   // Dest Width
d->planes[0].dst_h    = 1440;  // Dest Height
```

(__`fb_pitch`__ is the number of bytes per row of pixels)

We disable the __Second and Third UI Channels__ for now: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L299)

```c
// Init UI Channel 2: (First Overlay)
// Disable Channel for now
d->planes[1].fb_start = 0;

// Init UI Channel 3: (Second Overlay)
// Disable Channel for now
d->planes[2].fb_start = 0;

// Render the UI Channels over DMA
display_commit(d);
```

And we __render the 3 UI Channels__.

([__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) is defined in the p-boot Display Code, we'll come back to this)

That's all! We should see the [__Blue, Green and Red Blocks__](https://lupyuen.github.io/images/de-rgb.jpg) like in the pic above.

(Not sure why there are black lines, needs investigation)

_Didn't we set the Alpha Channel to `0x80`?_

__UI Channel 1__ is the Base UI Channel, so the Alpha Channel has no effect.

(Actually UI Channel 1 is configured as __XRGB 8888__)

In a while we'll set the Alpha Channels for UI Channels 2 and 3. And the UI Channels will appear as semi-transparent overlays.

![Rendering Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-code3a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

# Render Mandelbrot Set

_Rendering colour blocks is so blah. Are we sure we can render every single pixel correctly?_

Let's render something infinitely more detailed and sophisticated... [__Mandelbrot Set__](https://en.wikipedia.org/wiki/Mandelbrot_set)!

![Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-title.jpg)

Earlier we created a __Fullscreen Framebuffer__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

Now we fill the Framebuffer with the __Mandelbrot Set__, pixel by pixel: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

```c
// Fill with Mandelbrot Set.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Convert Pixel Coordinates to a Complex Number
    float cx = x_start + (y / 1440.0) * (x_end - x_start);
    float cy = y_start + (x / 720.0)  * (y_end - y_start);

    // Compute Manelbrot Set
    int m = mandelbrot(cx, cy);

    // Color depends on the number of iterations
    uint8_t hue = 255.0 * m / MAX_ITER;
    uint8_t saturation = 255;
    uint8_t value = (m < MAX_ITER) ? 255 : 0;

    // Convert Hue / Saturation / Value to RGB
    uint32_t rgb = hsvToRgb(hue, saturation, value);

    // Set the Pixel Colour (ARGB Format)
    int p = (y * 720) + x;
    assert(p < fb0_len);
    fb0[p] = 0x80000000 | rgb;
  }
}
```

[(__`mandelbrot`__ and __`hsvToRgb`__ are defined here)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L335-L432)

Then we initialise the __3 UI Channels__ and render them. [(Like this)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L299)

The [__Mandelbrot Set__](https://lupyuen.github.io/images/de-title.jpg) appears on PinePhone, like in the pic above.

Yep we can render every single pixel precisely on PinePhone!

![Animating the Madelbrot Set](https://lupyuen.github.io/images/de-code4a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L299-L334)

# Animate Madelbrot Set

_Earlier we said that updates to the Framebuffer are instantly pushed to PinePhone's Display via DMA..._

_Can we prove it?_

Yep let's __animate the Mandelbrot Set__ in our Framebuffer. And watch the updates appear instantly on PinePhone's Display, thanks to __Direct Memory Access (DMA)__!

This is how we animate the Mandelbrot Set: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L334)

```c
// Omitted: Init UI Channels 1, 2 and 3
d->planes[0].fb_start = ...
d->planes[1].fb_start = ...
d->planes[2].fb_start = ...
...

// Render the UI Channels over DMA
display_commit(d);

// Animate the Mandelbrot Set forever.
// For every frame of animation...
for (;;) {

  // Fill with Mandelbrot Set.
  // For every pixel row...
  for (int y = 0; y < 1440; y++) {

    // For every pixel column...
    for (int x = 0; x < 720; x++) {
```

In the code above, we __repeatly render__ the Mandelbrot Set for every frame of animation.

We __render each frame__ the exact same way as before...

```c
      // Convert Pixel Coordinates to a Complex Number
      float cx = x_start + (y / 1440.0) * (x_end - x_start);
      float cy = y_start + (x / 720.0)  * (y_end - y_start);

      // Compute Manelbrot Set
      int m = mandelbrot(cx, cy);

      // Color depends on the number of iterations
      uint8_t hue = 255.0 * m / MAX_ITER;
      uint8_t saturation = 255;
      uint8_t value = (m < MAX_ITER) ? 255 : 0;

      // Convert Hue / Saturation / Value to RGB
      uint32_t rgb = hsvToRgb(hue, saturation, value);

      // Set the Pixel Colour (ARGB Format)
      int p = (y * 720) + x;
      assert(p < fb0_len);
      fb0[p] = 0x80000000 | rgb;
    }
  }
```

But now we __tweak slightly the position__ of the Mandelbrot Set...

```c
  // Zoom in to (-1.4, 0)
  float x_dest = -1.4;
  float y_dest = 0;
  x_start += (x_dest - x_start) * 0.05;
  x_end   -= (x_end  - x_dest)  * 0.05;
  y_start += (y_dest - y_start) * 0.05;
  y_end   -= (y_end  - y_dest)  * 0.05;
}
```

Before looping back to render the next frame.

We should see this Animated Mandelbrot Set...

-   [__Demo Video on YouTube__](https://youtu.be/toC9iiPRwRI)

Thus DMA works correctly for rendering our Framebuffers on the fly!

_We don't call `display_commit` after every frame?_

[__`display_commit`__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L296-L299) only needs to be called once. It configures the Display Engine to read our Framebuffer directly via DMA.

Subsequent updates to the Framebuffer will be automatically pushed to the display via DMA.

![Rendering a Square Overlay on PinePhone](https://lupyuen.github.io/images/de-code5b.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

# Render Square Overlay

_Earlier we said that A64 Display Engine can render Framebuffers as Overlays. How can we do it?_

The pic below shows that A64 Display Engine can render __3 Framebuffers (UI Channels)__ as overlays, via DMA1, 2 and 3...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

(Skipping DMA0 because it's for Video only)

The UI Channels are rendered as overlays in a specific sequence (pic above)...

-   __UI Channel 3__ (DMA3) is rendered on top of __UI Channel 2__ (DMA2)

-   __UI Channel 2__ (DMA2) is rendered on top of __UI Channel 1__ (DMA1)

Our Mandelbrot Set is rendered on __UI Channel 1__ (DMA1), which is the Base Channel.

Let's overlay a __Blue Square__ on __UI Channel 2__ (DMA2).

First we prepare a __600 x 600 Framebuffer__ that contains a Semi-Transparent Blue Square: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

```c
// Init Framebuffer 1:
// Square 600 x 600 (4 bytes per ARGB pixel)
// fb1_len is 600 * 600
static uint32_t fb1[600 * 600];
int fb1_len = sizeof(fb1) / sizeof(fb1[0]);

// Fill with Semi-Transparent Blue
for (int i = 0; i < fb1_len; i++) {
  // Colours are in ARGB format
  fb1[i] = 0x80000080;
}
```

The new Framebuffer is a little __smaller than the Screen Width__. (600 pixels vs 720 pixels)

Thanks to __Framebuffer Blending__ in A64 Display Engine, it's perfectly OK to render the new Framebuffer at 600 x 600 (as a partial screen region).

This is how we set __UI Channel 2__ to the 600 x 600 Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L283)

```c
// Init UI Channel 2: (First Overlay)
// Square 600 x 600
d->planes[1].fb_start = (uintptr_t) fb1;  // Framebuffer Address
d->planes[1].fb_pitch = 600 * 4;  // Framebuffer Pitch
d->planes[1].src_w    = 600;  // Source Width
d->planes[1].src_h    = 600;  // Source Height
d->planes[1].dst_w    = 600;  // Dest Width
d->planes[1].dst_h    = 600;  // Dest Height
d->planes[1].dst_x    = 52;   // Dest X
d->planes[1].dst_y    = 52;   // Dest Y
```

(We specify the X and Y Offset in __`dst_x`__ and __`dst_y`__)

_Can the Dest Width / Height be different from the Source Width / Height?_

Yes, because the Display Engine supports Scaling. But we won't do that today, to simplify our discussion.

Before we watch the outcome, let's render another overlay...

![Rendering a Circle Overlay on PinePhone](https://lupyuen.github.io/images/de-code5c.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

# Render Circle Overlay

Our PinePhone UI Overlay Sandwich has these goodies inside...

-   __UI Channel 1__: Mandelbrot Set (Base Channel)

-   __UI Channel 2__: Semi-Transparent Blue Square

Let's top off our Cucumber Sandwich...

-   __UI Channel 3__: Semi-Transparent Green Circle

First we fill a Fullscreen Framebuffer with a __Semi-Transparent Green Circle__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

```c
// Init Framebuffer 2:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb2_len is 720 * 1440
static uint32_t fb2[720 * 1440];
int fb2_len = sizeof(fb2) / sizeof(fb2[0]);

// Fill with Semi-Transparent Green Circle.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Get pixel index
    int p = (y * 720) + x;
    assert(p < fb2_len);

    // Shift coordinates so that centre of screen is (0,0)
    int x_shift = x - 360;
    int y_shift = y - 720;

    // If pixel is inside circle (x^2 + y^2 < radius^2)...
    // Set the pixel to Semi-Transparent Green
    if (x_shift*x_shift + y_shift*y_shift < 360*360) {
      fb2[p] = 0x80008000;  // Semi-Transparent Green in ARGB Format
    } else {  // Otherwise set to Transparent Black
      fb2[p] = 0x00000000;  // Transparent Black in ARGB Format
    }
  }
}
```

Note that pixels outside the circle are set to __Transparent Black__.

(Which makes them invisible)

Next we point __UI Channel 3__ to the Fullscreen Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L283-L296)

```c
// Init UI Channel 3: (Second Overlay)
// Fullscreen 720 x 1440 with Alpha Blending
d->planes[2].fb_start = (uintptr_t) fb2;  // Framebuffer Address
d->planes[2].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[2].src_w    = 720;   // Source Width
d->planes[2].src_h    = 1440;  // Source Height
d->planes[2].dst_w    = 720;   // Dest Width
d->planes[2].dst_h    = 1440;  // Dest Height
d->planes[2].dst_x    = 0;     // Dest X
d->planes[2].dst_y    = 0;     // Dest Y
d->planes[2].alpha    = 128;   // Dest Alpha
```

Note that we set the __Destination Alpha__. So our Green Circle will appear super transparent.

Finally we render the 3 UI Channels...

```c
// Render the UI Channels over DMA
display_commit(d);
```

We should see the Animated Mandelbrot Set, with Blue Square and (very faint) Green Circle as Overlays. (Pic below)

That's how we render 3 UI Channels (with overlay blending) on PinePhone's Display Engine!

(Why the missing horizontal lines in the Blue Square and Green Circle?)

![Mandelbrot Set with Blue Square and Green Circle on PinePhone](https://lupyuen.github.io/images/de-overlay.jpg)

# Test PinePhone Display Engine

_We've seen the Test Code for Display Engine... How do we run the code?_

To test the A64 Display Engine, we'll boot __Apache NuttX RTOS__ on PinePhone and run our Test App...

-   [__test_display.c__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c)

Follow these steps to build NuttX RTOS and our Test App...

-   [__"Test PinePhone Display Engine"__](https://github.com/lupyuen/pinephone-nuttx#test-pinephone-display-engine)

Boot PinePhone with NuttX RTOS in the microSD Card.

At the NuttX Shell, enter this command to __test our Zig Display Driver__...

```bash
hello
```

We should see our Test App controlling the Hardware Registers on A64 Display Engine...

```text
HELLO NUTTX ON PINEPHONE!
...
Shell (NSH) NuttX-11.0.0-RC2
nsh> hello
...
TODO
...
```

[(TODO: See the Complete Log)]()

_Hmmm building the Test Code looks complicated..._

Yeah we need a few steps to build the Test Code because we patched together a few programs to make it work...

-   __Apache NuttX RTOS for PinePhone__

-   __Zig Driver for MIPI Display Serial Interface__

    [(More about this)](https://lupyuen.github.io/articles/dsi2)

-   __p-boot Display Code__

    [(See the next chapter)](https://lupyuen.github.io/articles/de#p-boot-display-code)

The steps will be a lot simpler when we have completed the  Display Engine Driver for NuttX.

# p-boot Display Code

TODO

_About the code that talks to A64 Display Engine... Where is `display_commit` defined?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) comes from the super-helpful [__p-boot PinePhone Bootloader__](https://xnux.eu/p-boot/).

To test the A64 Display Engine on Apache NuttX RTOS, we borrowed these [__Source Files__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L135-L142) (relevant to the Display Engine) from p-boot...

-   [__display.c__](https://megous.com/git/p-boot/tree/src/display.c)
-   [__pmic.c__](https://megous.com/git/p-boot/tree/src/pmic.c)
-   [__clock_sun6i.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c)
-   [__sunxi_gpio.c__](https://megous.com/git/p-boot/tree/src/uboot/drivers/gpio/sunxi_gpio.c)
-   [__pinmux.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/pinmux.c)

[(Plus a whole bunch of Header Files)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L115-L135)

Which we have modified to compile on NuttX:

`p-boot.6.zip`

[pinephone-nuttx/releases/tag/pboot6](https://github.com/lupyuen/pinephone-nuttx/releases/tag/pboot6)

TODO

_How does `display_commit` talk to the A64 Display Engine?_

TODO

# Other Display Engine Features

TODO

We won't use these Display Engine Features today...

__DE RT-WB:__ (Page 116)
> The Real-time write-back controller (RT-WB) provides data capture function for display engine. It captures data from RT-mixer module, performs the image resizing function, and then write-back to SDRAM.

(For screen capture?)

__DE VSU:__ (Page 128)
> The Video Scaler (VS) provides YUV format image resizing function for display engine. It receives data from overlay module, performs the image resizing function, and outputs to video post-processing modules. 

__DE Rotation:__ (Page 137)
> There are several types of rotation: clockwise 0/90/180/270 degree Rotation and H-Flip/V-Flip. Operation of Copy is the same as a 0 degree rotation.

# What's Next

TODO

Check out the other articles on __NuttX RTOS for PinePhone__...

-   [__"Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone"__](https://lupyuen.github.io/articles/arm)

-   [__"PinePhone boots Apache NuttX RTOS"__](https://lupyuen.github.io/articles/uboot)

-   [__"NuttX RTOS for PinePhone: Fixing the Interrupts"__](https://lupyuen.github.io/articles/interrupt)

-   [__"NuttX RTOS for PinePhone: UART Driver"__](https://lupyuen.github.io/articles/serial)

-   [__"NuttX RTOS for PinePhone: Blinking the LEDs"__](https://lupyuen.github.io/articles/pio)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__My Current Project: "The RISC-V BL602 Book"__](https://lupyuen.github.io/articles/book)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/de.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/de.md)

# Appendix: Overview of Allwinner A64 Display Engine

TODO

[DE2_Register_Guide](https://linux-sunxi.org/DE2_Register_Guide)

According to the doc, DE Base Address is 0x0100 0000 (Page 24)

_What's a Display Engine Mixer?_

__DE RT-MIXER:__ (Page 87)
> The RT-mixer Core consist of dma, overlay, scaler and blender block. It supports 4 layers overlay in one pipe, and its result can scaler up or down to blender in the next processing.

The Display Engine has 2 Mixers: RT-MIXER0 and RT-MIXER1...

__DE RT-MIXER0__ has 4 Channels (DE Offset 0x10 0000, Page 87)
-   Channel 0 for Video: DMA0, Video Overlay, Video Scaler
-   Channels 1, 2, 3 for UI: DMA1 / 2 / 3, UI Overlays, UI Scalers, UI Blenders
-   4 Overlay Layers per Channel
-   Layer priority is Layer 3 > Layer2 > Layer 1 > Layer 0 (Page 89)
-   Channel 0 is unused (we don't use video right now)
-   Channel 1 has format XRGB 8888
-   Channels 2 and 3 have format ARGB 8888
-   MIXER0 Registers:
    -   GLB at MIXER0 Offset 0x00000 (de_glb_regs)
    -   BLD (Blender) at MIXER0 Offset 0x01000 (de_bld_regs)
    -   OVL_V(CH0) (Video Overlay / Channel 0) at MIXER0 Offset 0x2000 (Unused)
    -   OVL_UI(CH1) (UI Overlay / Channel 1) at MIXER0 Offset 0x3000
    -   OVL_UI(CH2) (UI Overlay / Channel 2) at MIXER0 Offset 0x4000
    -   OVL_UI(CH3) (UI Overlay / Channel 3) at MIXER0 Offset 0x5000
    -   POST_PROC2 at MIXER0 Offset 0xB0000 (de_csc_regs)

__DE RT-MIXER1__ has 2 Channels (DE Offset 0x20 0000, Page 23)
-   Channel 0 for Video: DMA0, Video Overlay, Video Scaler
-   Channel 1 for UI: DMA1, UI Overlay, UI Scaler, UI Blender
-   We don't use MIXER1 right now

RT-MIXER0 and RT-MIXER1 are multiplexed to Timing Controller TCON0.

(TCON0 is connected to ST7703 over MIPI DSI)

So MIXER0 mixes 1 Video Channel with 3 UI Channels over DMA ... And pumps the pixels continuously to ST7703 LCD Controller (via the Timing Controller)

Let's use the 3 UI Channels to render: 1️⃣ Mandelbrot Set 2️⃣ Blue Square 3️⃣ Green Circle

![Mandelbrot Set with UI Overlays on PinePhone](https://lupyuen.github.io/images/de-overlay.jpg)

# Appendix: Programming the A64 Display Engine

TODO

Based on the log captured from our instrumented [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c), we have identified the steps to render 3 UI Channels (1 to 3) with the Display Engine [(`display_commit`)](https://megous.com/git/p-boot/tree/src/display.c#n2017)

This is how we'll create a NuttX Driver for PinePhone's A64 Display Engine that implements Display Rendering...

1.  Configure Blender...
    -   BLD BkColor (BLD_BK_COLOR Offset 0x88): BLD background color register
    -   BLD Premultiply (BLD_PREMUL_CTL Offset 0x84): BLD pre-multiply control register

    ```text
    Configure Blender
    BLD BkColor:     0x110 1088 = 0xff000000
    BLD Premultiply: 0x110 1084 = 0x0
    ```

1.  For Channels 1 to 3...

    1.  If Channel is unused, disable Overlay, Pipe and Scaler. Skip to next Channel

        -   UI Config Attr (OVL_UI_ATTCTL @ OVL_UI Offset 0x00): OVL_UI attribute control register
        -   Mixer (??? @ 0x113 0000 + 0x10000 * Channel)

        ```text
        Channel 2: Disable Overlay and Pipe
        UI Config Attr: 0x110 4000 = 0x0

        Channel 3: Disable Overlay and Pipe
        UI Config Attr: 0x110 5000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

    1.  Channel 1 has format XRGB 8888, Channel 2 and 3 have format ARGB 8888

    1.  Set Overlay (Assume Layer = 0)
        -   UI Config Attr (OVL_UI_ATTCTL @ OVL_UI Offset 0x00): OVL_UI attribute control register
        -   UI Config Top LAddr (OVL_UI_TOP_LADD @ OVL_UI Offset 0x10): OVL_UI top field memory block low address register
        -   UI Config Pitch (OVL_UI_PITCH @ OVL_UI Offset 0x0C): OVL_UI memory pitch register
        -   UI Config Size (OVL_UI_MBSIZE @ OVL_UI Offset 0x04): OVL_UI memory block size register
        -   UI Overlay Size (OVL_UI_SIZE @ OVL_UI Offset 0x88): OVL_UI overlay window size register
        -   IO Config Coord (OVL_UI_COOR @ OVL_UI Offset 0x08): OVL_UI memory block coordinate register

        ```text
        Channel 1: Set Overlay (fb0 is 720 x 1440)
        UI Config Attr:      0x110 3000 = 0xff00 0405
        UI Config Top LAddr: 0x110 3010 = 0x4064 a6ac (Address of fb0)
        UI Config Pitch:     0x110 300c = 0xb40 (720 * 4)
        UI Config Size:      0x110 3004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 3088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 3008 = 0x0

        Channel 2: Set Overlay (fb1 is 600 x 600)
        UI Config Attr:      0x110 4000 = 0xff00 0005
        UI Config Top LAddr: 0x110 4010 = 0x404e adac (Address of fb1)
        UI Config Pitch:     0x110 400c = 0x960 (600 * 4)
        UI Config Size:      0x110 4004 = 0x257 0257 (599 << 16 + 599)
        UI Overlay Size:     0x110 4088 = 0x257 0257 (599 << 16 + 599)
        IO Config Coord:     0x110 4008 = 0x0

        Channel 3: Set Overlay (fb2 is 720 x 1440)
        UI Config Attr:      0x110 5000 = 0x7f00 0005
        UI Config Top LAddr: 0x110 5010 = 0x400f 65ac (Address of fb2)
        UI Config Pitch:     0x110 500c = 0xb40 (720 * 4)
        UI Config Size:      0x110 5004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 5088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 5008 = 0x0
        ```

        Note that UI Config Size and UI Overlay Size are `(height-1) << 16 + (width-1)`

    1.  For Channel 1: Set Blender Output
        -   BLD Output Size (BLD_SIZE @ BLD Offset 0x08C): BLD output size setting register
        -   GLB Size (GLB_SIZE @ GLB Offset 0x00C): Global size register

        ```text
        Channel 1: Set Blender Output
        BLD Output Size: 0x110 108c = 0x59f 02cf (1439 * 16 + 719)
        GLB Size:        0x110 000c = 0x59f 02cf (1439 * 16 + 719)
        ```

    1.  Set Blender Input Pipe (N = Pipe Number, from 0 to 2 for Channels 1 to 3)
        -   BLD Pipe InSize (BLD_CH_ISIZE @ BLD Offset 0x008 + N*0x14): BLD input memory size register(N=0,1,2,3,4)
        -   BLD Pipe FColor (BLD_FILL_COLOR @ BLD Offset 0x004 + N*0x14): BLD fill color register(N=0,1,2,3,4)
        -   BLD Pipe Offset (BLD_CH_OFFSET @ BLD Offset 0x00C + N*0x14): BLD input memory offset register(N=0,1,2,3,4)
        -   BLD Pipe Mode (BLD_CTL @ BLD Offset 0x090 – 0x09C): BLD control register

        (Should `N*0x14` be `N*0x10` instead?)

        ```text
        Channel 1: Set Blender Input Pipe 0 (fb0 is 720 x 1440)
        BLD Pipe InSize: 0x110 1008 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1004 = 0xff00 0000
        BLD Pipe Offset: 0x110 100c = 0x0
        BLD Pipe Mode:   0x110 1090 = 0x301 0301

        Channel 2: Set Blender Input Pipe 1 (fb1 is 600 x 600)
        BLD Pipe InSize: 0x110 1018 = 0x257 0257 (599 << 16 + 599)
        BLD Pipe FColor: 0x110 1014 = 0xff00 0000
        BLD Pipe Offset: 0x110 101c = 0x34 0034
        BLD Pipe Mode:   0x110 1094 = 0x301 0301

        Channel 3: Set Blender Input Pipe 2 (fb2 is 720 x 1440)
        BLD Pipe InSize: 0x110 1028 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1024 = 0xff00 0000
        BLD Pipe Offset: 0x110 102c = 0x0
        BLD Pipe Mode:   0x110 1098 = 0x301 0301
        ```

        Note that BLD Pipe InSize is `(height-1) << 16 + (width-1)`

    1.  Disable Scaler (assuming we're not using Scaler)

        ```text
        Channel 1: Disable Scaler
        Mixer: 0x114 0000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

1.  Set BLD Route and BLD FColor Control
    -   BLD Route (BLD_CH_RTCTL @ BLD Offset 0x080): BLD routing control register
    -   BLD FColor Control (BLD_FILLCOLOR_CTL @ BLD Offset 0x000): BLD fill color control register

    ```text
    Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x321
    BLD FColor Control: 0x110 1000 = 0x701
    ```

1.  Apply Settings: GLB DBuff
    -   GLB DBuff (GLB_DBUFFER @ GLB Offset 0x008): Global double buffer control register

    ```text
    Apply Settings
    GLB DBuff: 0x110 0008 = 0x1
    ```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

(See Memory Mapping List and Register List at Page 90)
