# ST7789 Display with LVGL Graphics on Apache NuttX RTOS

üìù _2 Apr 2022_

![ST7789 SPI Display connected to Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/images/st7789-title.jpg)

_ST7789 SPI Display connected to [Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/articles/pinecone)_

__Sitronix ST7789__ is an SPI Display Controller that's found in many gadgets. (Like [__PineTime Smartwatch__](https://lupyuen.github.io/articles/sneak-peek-of-pinetime-smart-watch-and-why-its-perfect-for-teaching-iot))

[__LVGL__](https://docs.lvgl.io/master/index.html) is a popular Open-Source Library that renders text and graphics on Embedded Devices.

Today we shall run ST7789 Display and LVGL Library on [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/nuttx) (Real-Time Operating System).

NuttX supports ST7789 and LVGL right __out of the box__. (Batteries all included!) So this tutorial should be breezy squeezy peasy.

We'll run this tutorial on the [__BL602 RISC-V SoC__](https://lupyuen.github.io/articles/pinecone) and fix some issues specific to BL602...

-   __SPI Send__ didn't work correctly on BL602

-   ST7789 __Data / Command Pin__ wasn't implemented on BL602

-   BL602 only talks __SPI Mode 3__ to ST7789

The same steps should work on __ESP32 and other NuttX Platforms__. (Without the BL602 quirks)

![Connect BL602 to ST7789](https://lupyuen.github.io/images/st7789-connect.jpg)

# Connect ST7789 Display

We connect the ST7789 SPI Display to BL602 as follows (pic above)...

| BL602 Pin     | ST7789 SPI          | Wire Colour 
|:--------------|:--------------------|:-------------------
| __`GPIO 0`__  | `DC`  _(MISO)_      | Blue
| __`GPIO 2`__  | Unused _(CS)_
| __`GPIO 1`__  | `SDA` _(MOSI)_      | Yellow
| __`GPIO 3`__  | `SCL` _(SCK)_       | Green
| __`GPIO 4`__  | `RST` _(Reset)_     | Black
| __`GPIO 5`__  | `BLK` _(Backlight)_ | Orange
| __`3V3`__     | `3.3V`              | Red
| __`GND`__     | `GND`               | Grey

The BL602 pins for ST7789 are defined in [board.h](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/bl602/bl602evb/include/board.h#L92-L104)

```c
/* SPI Configuration: For PineCone BL602 */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN2)
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN1)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN3)

#ifdef CONFIG_LCD_ST7789
/* ST7789 Configuration: Reset and Backlight Pins */

#define BOARD_LCD_RST (GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO | GPIO_PIN4)
#define BOARD_LCD_BL  (GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO | GPIO_PIN5)
#endif  /* CONFIG_LCD_ST7789 */
```

[(Which pins can be used? See this)](https://lupyuen.github.io/articles/expander#pin-functions)

_What if we're connecting to ESP32-C3?_

__For ESP32-C3:__ The SPI Pins are defined in [Kconfig](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/esp32c3/Kconfig#L467-L485) and menuconfig...

```text
config ESP32C3_SPI2_CSPIN
	default 10

config ESP32C3_SPI2_CLKPIN
	default 6

config ESP32C3_SPI2_MOSIPIN
	default 7

config ESP32C3_SPI2_MISOPIN
	default 2
```

The Reset and Backlight Pins are also defined in [Kconfig](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/esp32c3/esp32c3-devkit/Kconfig#L119-L129) and menuconfig...

```text
config ESP32C3_LCD_RSTPIN
	int "LCD reset pin"
	default 9

config ESP32C3_LCD_BLPIN
	int "LCD backlight pin"
	default 18
```

[(ESP32-C3 pins are referenced here)](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/esp32c3/esp32c3-devkit/src/esp32c3_st7789.c#L45-L48)

# Download Source Code

To run ST7789 Display and LVGL Library on NuttX, download the modified source code for __NuttX OS and NuttX Apps__...

```bash
mkdir nuttx
cd nuttx
git clone --recursive --branch st7789 https://github.com/lupyuen/nuttx nuttx
git clone --recursive --branch st7789 https://github.com/lupyuen/nuttx-apps apps
```

(We'll cover the modifications in the following sections)

Or if we have an __existing NuttX Project,__ apply the following patches for ST7789 Display...

[(__For PineDio Stack BL604:__ The patches are already preinstalled)](https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features)

-   [__"Fix SPI Poll Send"__ (BL602)](https://github.com/apache/nuttx/pull/5869)

-   [__"Remove Check for LCD Driver"__ (BL602)](https://github.com/apache/nuttx/pull/5907)

-   [__"Implement SPI Cmd/Data"__ (BL602)](https://github.com/apache/nuttx/pull/5898)

-   Edit [boards/risc-v/bl602/bl602evb/include/board.h](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/bl602/bl602evb/include/board.h#L92-L104) and define the ST7789 pins...

    [__"Connect ST7789 Display"__](https://lupyuen.github.io/articles/st7789#connect-st7789-display)

-   Edit [boards/risc-v/bl602/bl602evb/src/bl602_bringup.c](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L676-L696) and load the LCD Driver and the ST7789 Driver...

    [__"Load ST7789 Driver"__](https://lupyuen.github.io/articles/st7789#load-st7789-driver)

-   Edit [drivers/lcd/st7789.c](https://github.com/lupyuen/nuttx/blob/st7789/drivers/lcd/st7789.c#L50-L57) and configure ST7789 for SPI Mode 3...

    [__"SPI Mode 3"__](https://lupyuen.github.io/articles/st7789#spi-mode-3)

(We'll cover the patches in the following sections)

# ST7789 Data / Command Pin

_What's the DC Pin on ST7789?_

That's the __Data / Command Pin__ that tells ST7789 whether we're sending data or commands to the display.

The Data / Command Pin __goes Low__ when we're sending __ST7789 Commands__...

![MISO goes Low when transmitting ST7789 Commands](https://lupyuen.github.io/images/st7789-logic1.png)

And __goes High__ when we're sending __ST7789 Data__...

![MISO goes High when transmitting ST7789 Data](https://lupyuen.github.io/images/st7789-logic2a.png)

_So MISO talks to the Data / Command Pin?_

Yep NuttX uses the __SPI MISO Pin__ to control the ST7789 Data / Command Pin, as seen in the __SPI Driver__ for ESP32-C3...

![SPI Driver for ESP32-C3 uses the SPI MISO Pin to control the ST7789 Data / Command Pin](https://lupyuen.github.io/images/st7789-dc3a.png)

[(Source)](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/esp32c3/esp32c3-devkit/src/esp32c3_board_spi.c#L58-L86)

It flips the MISO Pin __as though it was a GPIO Pin!__

_Can we do the same on BL602?_

Yes but we need to __reconfigure the SPI MISO Pin__ as a GPIO Pin, on the fly, before flipping it as a GPIO Pin...

![Reconfigure the SPI MISO Pin as a GPIO Pin](https://lupyuen.github.io/images/st7789-dc4a.png)

[(Source)](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L679-L748)

After sending ST7789 Command or Data, we __revert the pin back from GPIO Pin__ to SPI MISO Pin...

![Revert the pin back from GPIO Pin to SPI MISO Pin](https://lupyuen.github.io/images/st7789-dc2a.png)

[(Source)](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L415-L453)

_Why must we revert the pin from GPIO back to SPI?_

We must revert because the SPI Bus may be __shared by other SPI Drivers__ that expect a functioning SPI MISO Pin.

[(Like the Semtech SX1262 Driver on PineDio Stack BL604)](https://lupyuen.github.io/articles/st7789#shared-spi-bus)

This nifty implementation of the Data / Command Pin has been __merged into NuttX Mainline__. [(See this)](https://github.com/apache/nuttx/pull/5898)

[(For implementation details, see the Appendix)](https://lupyuen.github.io/articles/st7789#appendix-spi-cmddata-on-bl602)

# Fix SPI Send

While testing the ST7789 Driver, we hit a strange problem...

Our BL602 device would __hang when sending anything__ over SPI to ST7789!

Can you spot the bug in __bl602_spi_poll_send__?

![BL602 hangs when sending anything over SPI to ST7789](https://lupyuen.github.io/images/st7789-spi1.png)

[(Source)](https://github.com/apache/nuttx/blob/54e630e14d7e32d6f81ae79d4e5df3d2fa787ef0/arch/risc-v/src/bl602/bl602_spi.c#L779-L803)

__Answer:__ If we call __SPI Poll Send__ _(bl602_spi_poll_send)_ directly instead of __SPI Poll Exchange__ _(bl602_spi_poll_exchange)_...

The SPI Port __won't get configured correctly__!

("SPI Enable Master" and "SPI FIFO Clear" are skipped)

And __it hangs__!

(Looping forever waiting for SPI FIFO)

![SPI Port won't get configured correctly if we call SPI Poll Send](https://lupyuen.github.io/images/st7789-spi2a.png)

[(Source)](https://github.com/apache/nuttx/blob/54e630e14d7e32d6f81ae79d4e5df3d2fa787ef0/arch/risc-v/src/bl602/bl602_spi.c#L779-L803)

We fix this problem by __moving the code that configures the SPI Port__ from SPI Poll Exchange to SPI Poll Send...

(Note that SPI Poll Exchange calls SPI Poll Send)

```c
//  SPI Poll Send: Send the byte or word to the SPI Port
static uint32_t bl602_spi_poll_send(struct bl602_spi_priv_s *priv, uint32_t wd) {

  //  Enable SPI Master (moved from SPI Poll Exchange)
  modifyreg32(BL602_SPI_CFG, SPI_CFG_CR_S_EN, SPI_CFG_CR_M_EN);

  //  Clear SPI FIFO (moved from SPI Poll Exchange)
  modifyreg32(BL602_SPI_FIFO_CFG_0, SPI_FIFO_CFG_0_RX_CLR | SPI_FIFO_CFG_0_TX_CLR, 0);

  //  Rest of the function is the same...
  //  Write data to Transmit FIFO
  putreg32(wd, BL602_SPI_FIFO_WDATA);

  //  Wait for Receive FIFO and receive data
  while (0 == tmp_val) { ... }
```

[(Source)](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L806-L839)

After fixing, we verify with a [__Logic Analyser__](https://lupyuen.github.io/images/st7789-probe.jpg) that SPI Poll Send transmits data correctly to ST7789...

![SPI Poll Send transmits SPI Data correctly](https://lupyuen.github.io/images/st7789-logic3.png)

SPI Poll Send has been __fixed in NuttX Mainline__. [(See this)](https://github.com/apache/nuttx/pull/5869)

[(For details of the fix, see the Appendix)](https://lupyuen.github.io/articles/st7789#appendix-fix-spi-send-on-bl602)

# SPI Mode 3

For some unknown reason, BL602 talks to ST7789 __only in SPI Mode 3__.

We hardcode SPI Mode 3 in the __ST7789 Driver__: [st7789.c](https://github.com/lupyuen/nuttx/blob/st7789/drivers/lcd/st7789.c#L50-L57)

```c
//  If this is BL602...
#ifdef CONFIG_BL602_SPI0
  //  Use SPI Mode 3 as workaround for BL602
  #warning Using SPI Mode 3 for ST7789 on BL602
  #define CONFIG_LCD_ST7789_SPIMODE SPIDEV_MODE3

//  If not BL602...
#else
  //  Use SPI Mode 0 or from menuconfig
  #ifndef CONFIG_LCD_ST7789_SPIMODE
  #define CONFIG_LCD_ST7789_SPIMODE SPIDEV_MODE0
  #endif  //  CONFIG_LCD_ST7789_SPIMODE
#endif    //  CONFIG_BL602_SPI0
```

We've seen this behaviour with ST7789 and BL602 IoT SDK, so it's probably a __quirk in BL602's SPI Port__, not in the ST7789 Driver.

__UPDATE:__ BL602 talks to ST7789 in SPI Mode 1 or Mode 3, depending on whether the MISO / MOSI Pins are swapped. [(See this)](https://lupyuen.github.io/articles/pinedio2#st7789-spi-mode)

![BL602 talks to ST7789 only in SPI Mode 3](https://lupyuen.github.io/images/st7789-code4.png)

# Load ST7789 Driver

We fixed the SPI issues on BL602... Now we can __load the ST7789 Driver__ at startup!

We do this in 2 steps...

-   We load the __LCD Driver "/dev/lcd0"__

-   Then we load the __ST7789 Driver__

    (Which will be exposed to apps through the LCD Driver)

## LCD Driver

This is how we load the __LCD Driver__ at startup: [bl602_bringup.c](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L676-L696)

```c
#ifdef CONFIG_LCD_DEV
#include <nuttx/board.h>
#include <nuttx/lcd/lcd_dev.h>
#endif  //  CONFIG_LCD_DEV

#ifdef CONFIG_LCD_ST7789
#include <nuttx/lcd/st7789.h>
#include "../boards/risc-v/bl602/bl602evb/include/board.h"
#include "riscv_internal.h"
#endif  //  CONFIG_LCD_ST7789
...
//  Called during NuttX startup to load drivers
int bl602_bringup(void) {
  ...
#ifdef CONFIG_LCD_DEV
  //  Initialize the LCD driver
  ret = board_lcd_initialize();
  if (ret < 0) {
    _err("ERROR: board_lcd_initialize() failed: %d\n", ret);
  }

  //  Register the LCD driver
  ret = lcddev_register(0);
  if (ret < 0) {
    _err("ERROR: lcddev_register() failed: %d\n", ret);
  }
#endif  //  CONFIG_LCD_DEV
  return ret;
}
```

__bl602_bringup__ is called by NuttX during startup to load NuttX Drivers...

-   We call __board_lcd_initialize__ to initialise the LCD Driver

    (We'll see this in a while)

-   Then we call __lcddev_register__ to register the LCD Driver as "__/dev/lcd0__"

    [(__lcddev_register__ is defined here)](https://github.com/lupyuen/nuttx/blob/st7789/drivers/lcd/lcd_dev.c#L305-L353)

-   Which calls __board_lcd_getdev__ to load the ST7789 Driver

Let's study __board_lcd_initialize__ and __board_lcd_getdev__

## ST7789 Driver

__board_lcd_initialize__ initialises the LCD Driver at startup:  [bl602_bringup.c](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L698-L742)

```c
#ifdef CONFIG_LCD_ST7789

//  SPI Port Number for LCD
#define LCD_SPI_PORTNO 0

//  SPI Bus for LCD
static struct spi_dev_s *st7789_spi_bus;

//  LCD Device
static struct lcd_dev_s *g_lcd = NULL;

//  Called by bl602_bringup during NuttX startup 
//  to init the LCD Driver
int board_lcd_initialize(void) {
  //  Fetch the SPI Bus for the LCD Driver
  st7789_spi_bus = bl602_spibus_initialize(LCD_SPI_PORTNO);
  if (!st7789_spi_bus) {
    lcderr("ERROR: Failed to initialize SPI port %d for LCD\n", LCD_SPI_PORTNO);
    return -ENODEV;
  }

  //  Pull Reset Pin high to reset ST7789
  bl602_configgpio(BOARD_LCD_RST);        //  Configure Reset as GPIO Pin
  bl602_gpiowrite(BOARD_LCD_RST, false);  //  Set to Low
  up_mdelay(1);                           //  Wait 1 millisecond
  bl602_gpiowrite(BOARD_LCD_RST, true);   //  Set to High
  up_mdelay(10);                          //  Wait 10 milliseconds

  //  Set Backlight to full brightness
  bl602_configgpio(BOARD_LCD_BL);       //  Configure Backlight as GPIO Pin
  bl602_gpiowrite(BOARD_LCD_BL, true);  //  Set to High
  return OK;
}
```

Inside this function we...

-   __Fetch the SPI Bus__ from NuttX

    (Will be used by ST7789 Driver)

-   __Flip the Reset Pin__ to Low then High

    (To reset the ST7789 Display)

-   Switch on the __Backlight__

    (So we can see things on the screen)

Finally we __load the ST7789 Driver__: [bl602_bringup.c](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L744-L769)

```c
//  Called by lcddev_register during NuttX startup
//  to load the ST7789 Driver
FAR struct lcd_dev_s *board_lcd_getdev(int devno) {
  //  Init the ST7789 driver
  g_lcd = st7789_lcdinitialize(st7789_spi_bus);

  //  Return the ST7789 driver
  if (!g_lcd) {
    lcderr("ERROR: Failed to bind SPI port %d to LCD %d\n", LCD_SPI_PORTNO,
      devno);
  } else {
    lcdinfo("SPI port %d bound to LCD %d\n", LCD_SPI_PORTNO, devno);
    return g_lcd;
  }
  return NULL;
}
#endif  //  CONFIG_LCD_ST7789
```

(We'll see __st7789_lcdinitialize__ later)

We __initialise the ST7789 Driver__ and return it to [__lcddev_register__](https://github.com/lupyuen/nuttx/blob/st7789/drivers/lcd/lcd_dev.c#L305-L353)...

Which will __wrap the ST7789 Driver__ inside our LCD Driver "__/dev/lcd0__".

That's how we load the LCD Driver and ST7789 Driver on NuttX!

_What about ESP32-C3?_

__For ESP32-C3:__ This is how we load the LCD Driver and ST7789 Driver at startup...

-   [__Load LCD Driver__ (ESP32-C3)](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/esp32c3/esp32c3-devkit/src/esp32c3_bringup.c#L196-L210)

-   [__Load ST7789 Driver__ (ESP32-C3)](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/esp32c3/esp32c3-devkit/src/esp32c3_st7789.c)

![Render Pink Screen at startup](https://lupyuen.github.io/images/st7789-code3.png)

[(Source)](https://github.com/lupyuen/nuttx/blob/st7789/drivers/lcd/st7789.c#L752-L777)

# Render Pink Screen

In a while we'll boot NuttX to load the ST7789 Driver but...

_How will we know if the ST7789 Driver is really working?_

Here's an idea... Let's __render a Pink Screen__ at startup! 

This is how we do it: [st7789.c](https://github.com/lupyuen/nuttx/blob/st7789/drivers/lcd/st7789.c#L752-L777)

```c
//  Called by board_lcd_getdev during NuttX startup
//  to init the ST7789 driver
FAR struct lcd_dev_s *st7789_lcdinitialize(FAR struct spi_dev_s *spi) {
  ...
  //  Disable sleep mode
  st7789_sleep(priv, false);

  //  Set to 16-bit colour
  st7789_bpp(priv, ST7789_BPP);

  //  Set display orientation
  st7789_setorientation(priv);

  //  Enable display
  st7789_display(priv, true);
  
  //  Fill the screen with pink
  st7789_fill(priv, 0xAAAA);

  //  Previously: Fill the screen with white
  //  st7789_fill(priv, 0xFFFF);
```

Recalls that __st7789_lcdinitialize__ is called by [__board_lcd_getdev__](https://lupyuen.github.io/articles/st7789#st7789-driver) during NuttX startup.

This function initialises the ST7789 Display. We changed the last line so that it __fills the screen with pink__. (Colour value AAAA)

Let's talk about AAAA...

![AAAA in RGB565 is pink](https://lupyuen.github.io/images/st7789-rgb565.jpg)

## RGB565 Colour Encoding

_Why is AAAA pink?_

That's because ST7789 encodes colours in __16 bits as RGB565__...

-   5 bits for __Red__

-   6 bits for __Green__

-   5 bits for __Blue__

The pic above shows that AAAA broken down into __RGB565__ is...

-   __66%__ Red

-   __33%__ Green

-   __32%__ Blue

Which is a reddish hue of white: __pink!__

# Run ST7789 Driver

We're ready to boot NuttX and test the ST7789 Driver!

1.  Follow these steps to __build, flash and run__ NuttX (configured for ST7789 Driver)...

    [__"Build, Flash and Run NuttX"__](https://lupyuen.github.io/articles/st7789#appendix-build-flash-and-run-nuttx)

1.  At the NuttX Shell, enter this command to list the __NuttX Devices__...

    ```bash
    ls /dev
    ```

1.  We should see our __LCD Device "/dev/lcd0"__...

    ```text
    /dev:
     lcd0
     ...
    ```

    [(See the complete log)](https://github.com/lupyuen/st7789-nuttx#boot-nuttx)

1.  And our ST7789 Display should show a __Pink Screen__.

    (Pic below)

    [(Watch the demo on YouTube)](https://youtu.be/iaDYjO1rCmY)

Yep the ST7789 Driver works on NuttX!

The screen update looks laggy, hopefully we'll fix this in 2 ways...

-   Increase the __SPI Frequency__ from 1 MHz to 40 MHz, the maximum frequency supported by BL602

    (In menuconfig: Device Drivers ‚Üí LCD Driver Support ‚Üí Graphic LCD Driver Support ‚Üí LCD Driver Selection ‚Üí Sitronix ST7789 ‚Üí SPI Frequency)

    [(UPDATE: We have successfully tested ST7789 at 4 MHz)](https://lupyuen.github.io/articles/pinedio2#st7789-spi-frequency)

-   Implement __SPI Direct Memory Access__ (DMA) for faster transfers

    [(More about this)](https://lupyuen.github.io/articles/spi#spi-with-direct-memory-access)

__UPDATE:__ SPI DMA is now supported on BL602 NuttX...

-   [__"SPI DMA on BL602 NuttX"__](https://lupyuen.github.io/articles/spi2#appendix-spi-dma-on-bl602-nuttx)

![When NuttX boots, we should see a pink screen](https://lupyuen.github.io/images/st7789-boot.jpg)

# LVGL Demo App

The ST7789 Driver works great on NuttX... Let's render some graphics!

We'll use the [__LVGL Graphics Library__](https://docs.lvgl.io/master/index.html) and __LVGL Demo App__ bundled with NuttX.

Let's look inside the __LVGL Demo App__: [lvgldemo.c](https://github.com/lupyuen/nuttx-apps/blob/st7789/examples/lvgldemo/lvgldemo.c#L109-L238)

```c
//  LVGL Demo App
int main(int argc, FAR char *argv[]) {
  lv_disp_drv_t disp_drv;
  lv_disp_buf_t disp_buf;
  ...
  //  LVGL initialization
  lv_init();

  //  Basic LVGL display driver initialization
  lv_disp_buf_init(&disp_buf, buffer1, buffer2, DISPLAY_BUFFER_SIZE);
  lv_disp_drv_init(&disp_drv);
  disp_drv.buffer     = &disp_buf;
  disp_drv.monitor_cb = monitor_cb;
```

The app begins by [__initialising the LVGL Library__](https://docs.lvgl.io/7.11/get-started/quick-overview.html#add-lvgl-into-your-project).

NuttX supports 2 ways to access the display...

-   Frame Buffer Driver: "__/dev/fb0__"

-   LCD Driver: "__/dev/lcd0__"

```c
  //  Display interface initialization
  if (fbdev_init(&disp_drv) != EXIT_SUCCESS) {      
    //  Failed to use Frame Buffer, falling back to LCD Driver
    if (lcddev_init(&disp_drv) != EXIT_SUCCESS) {
      //  No possible drivers left, fail
      return EXIT_FAILURE;
    }
  }

  //  Register the display driver
  lv_disp_drv_register(&disp_drv);
```

For ST7789 we'll use the __LCD Driver__.

Then we render some [__LVGL Widgets__](https://docs.lvgl.io/7.11/get-started/quick-overview.html#widgets) (UI controls)...

```c
  //  Render the widgets
  lv_demo_widgets();
```

(We'll see __lv_demo_widgets__ later)

And we loop forever handling [__LVGL Events__](https://docs.lvgl.io/7.11/get-started/quick-overview.html#events) (like for display updates)...

```c
  //  Loop forever handling LVGL tasks
  while (1) {
    lv_task_handler();  //  Handle LVGL tasks
    usleep(10000);      //  Sleep 10 milliseconds
  }
```

Let's run this!

![LVGL Demo App](https://lupyuen.github.io/images/st7789-code5a.png)

# Run LVGL Demo

For our final demo today, we'll run the __LVGL Demo App__ that's bundled with NuttX...

1.  Follow these steps to __build, flash and run__ NuttX (configured for LVGL Library and LVGL Demo)...

    [__"Build, Flash and Run NuttX"__](https://lupyuen.github.io/articles/st7789#appendix-build-flash-and-run-nuttx)

1.  At the NuttX Shell, enter this command to run the __LVGL Demo App__...

    ```bash
    lvgldemo
    ```

1.  We see that the app __initialises the ST7789 Display__...

    ```text
    fbdev_init: Failed to open /dev/fb0: 2
    st7789_getvideoinfo: fmt: 11 xres: 240 yres: 240 nplanes: 1
    lcddev_init: VideoInfo:
      fmt: 11
      xres: 240
      yres: 240
      nplanes: 1
    lcddev_init: PlaneInfo (plane 0):
      bpp: 16
    ```

    The app says it can't open the Frame Buffer Driver "/dev/fb0". But that's OK because it uses the LCD Driver "/dev/lcd0".

1.  Then the app __paints the ST7789 Display__ in batches of 20 Pixel Rows (240 horizontal pixels each)...

    ```text
    st7789_putarea: row_start:  0 row_end: 19 col_start: 0 col_end: 239
    st7789_putarea: row_start: 20 row_end: 39 col_start: 0 col_end: 239
    ...
    st7789_putarea: row_start: 220 row_end: 239 col_start: 0 col_end: 239
    monitor_cb: 57600 px refreshed in 1100 ms
    ```

    [(See the complete log)](https://github.com/lupyuen/st7789-nuttx#run-lvgl-demo)

    [(__UPDATE:__ We now call __putrun__ instead of __putarea__)](https://github.com/apache/nuttx/pull/6657#issuecomment-1200094716)

The LVGL Demo Screen appears on ST7789 yay! (Colours in the display below are inverted, should be red instead of blue)

![LVGL Demo Screen appears on ST7789](https://lupyuen.github.io/images/st7789-lvgl.jpg)

# LVGL Widgets

_How do we render UI controls with the LVGL Library?_

We render UI controls by creating __LVGL Widgets__.

Here's how the LVGL Demo App renders the screen above: [lv_demo_widgets.c](https://github.com/lvgl/lv_demos/blob/v7.3.0/src/lv_demo_widgets/lv_demo_widgets.c#L63-L101)

```c
//  Create Demo Widgets
void lv_demo_widgets(void) {
  //  Create a Tab View Widget
  tv = lv_tabview_create(lv_scr_act(), NULL);
  ...
  //  Create 3 tabs: Controls, Visuals, Selectors
  t1 = lv_tabview_add_tab(tv, "Controls");
  t2 = lv_tabview_add_tab(tv, "Visuals");
  t3 = lv_tabview_add_tab(tv, "Selectors");
  ...
  //  Create the widgets for the Controls, Visuals and Selectors Tabs
  controls_create(t1);
  visuals_create(t2);
  selectors_create(t3);
}
```

The Demo Screen looks overcrowded for a tiny display, but we can make out 3 tabs: __"Controls", "Visuals" and "Selectors"__.

The app renders the 3 tabs by creating a [__Tab View Widget__](https://docs.lvgl.io/7.11/widgets/tabview.html).

__controls_create__ populates the Controls Tab with a [__Message Box Widget__](https://docs.lvgl.io/7.11/widgets/msgbox.html) (and other widgets) like so: [lv_demo_widgets.c](https://github.com/lvgl/lv_demos/blob/v7.3.0/src/lv_demo_widgets/lv_demo_widgets.c#L108-L203)

```c
//  Create widgets for the Controls Tab
static void controls_create(lv_obj_t * parent) {
  ...
  //  Create a Message Box Widget
  lv_obj_t * m = lv_msgbox_create(lv_scr_act(), NULL);

  //  Define the Message Box Buttons
  static const char * btns[] = {"Cancel", "Ok", ""};

  //  Add the buttons to the Message Box
  lv_msgbox_add_btns(m, btns);
```

Check out the __LVGL Docs__ to get started on writing our own LVGL App...

-   [__"LVGL Quick Overview"__](https://docs.lvgl.io/7.11/get-started/quick-overview.html)

# LVGL Version

_LVGL gets updated frequently (every few months). Can we set the LVGL Version in NuttX?_

Yes we can specify the __LVGL Version__ in menuconfig...

- Application Configuration ‚Üí Graphics Support ‚Üí Light and Versatile Graphic Library (LVGL) ‚Üí LVGL Version  

After setting the LVGL Version, be sure to __delete all downloaded versions__ of LVGL before building NuttX...

```bash
## TODO: Change this to the path of our "nuttx" folder
cd nuttx/nuttx

## Preserve the Build Config
cp .config ../config

## Erase the build files
make clean

## Erase the Build Config and Kconfig files
make distclean

## For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

## For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

## For ESP32: Configure the build for ESP32.
## TODO: Change "esp32-devkitc" to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

## Restore the Build Config
cp ../config .config

## Erase all downloaded versions of LVGL
rm ../apps/graphics/lvgl/v7*.zip
rm ../apps/graphics/lvgl/v8*.zip

## Build NuttX
make
```

NuttX is currently bundled with __LVGL Version 7.3.0__.

But the latest version of LVGL is __8.2.0__.

And LVGL 8 is __not backward compatible__ with LVGL 7. These are the breaking changes...

-   [__LVGL 8.0.0 Release Notes__](https://github.com/lvgl/lvgl/blob/master/docs/CHANGELOG.md#v800-01062021)

_What happens if we switch to LVGL 8.2.0?_

NuttX Build fails when downloading the Demo Code for __LVGL 8.2.0__...

```text
make[3]: Entering directory '/home/user/nuttx/apps/examples/lvgldemo'
Downloading: v8.2.0.zip
Unpacking: v8.2.0.zip -> lv_demos
Archive:  v8.2.0.zip
  End-of-central-directory signature not found.  Either this file is not
  a zipfile, or it constitutes one disk of a multi-part archive.  In the
  latter case the central directory and zipfile comment will be found on
  the last disk(s) of this archive.
unzip:  cannot find zipfile directory in one of v8.2.0.zip or
        v8.2.0.zip.zip, and cannot find v8.2.0.zip.ZIP, period.
```

It seems the NuttX Build needs to be fixed to support LVGL 8. 

_LVGL 7.11.0 is the last version of LVGL 7. What happens if we switch to LVGL 7.11.0?_

NuttX Build fails when we switch to __LVGL 7.11.0__...

```text
nuttx/apps/graphics/lvgl/lv_conf.h:86:50: error: incompatible types when initializing type 'short unsigned int' using type 'lv_color_t' {aka 'union <anonymous>'}
 #define LV_COLOR_TRANSP    ((lv_color_t){.full = (CONFIG_LV_COLOR_TRANSP)})
                                                  ^
nuttx/apps/graphics/lvgl/lvgl/src/lv_core/../lv_draw/lv_img_buf.h:351:25: note: in expansion of macro 'LV_COLOR_TRANSP'
         lv_color_t ct = LV_COLOR_TRANSP;
```

We might need to identify the latest version of LVGL 7 that works with NuttX.

![Shared SPI Bus on PineDio Stack BL604](https://lupyuen.github.io/images/pinedio-spi2.jpg)

[(Source)](https://lupyuen.github.io/articles/pinedio#bl604-spi)

# Shared SPI Bus

_Do we expect any problems with ST7789 in complex IoT Gadgets?_

Possibly. The pic above shows that [__PineDio Stack BL604__](https://lupyuen.github.io/articles/pinedio#bl604-spi) connects ST7789 to the __same SPI Bus__ as SPI Flash and Semtech SX1262 LoRa Transceiver.

To prevent crosstalk on the SPI Bus, we need to flip the __Chip Select Pin__ (CS) for each SPI Device.

_Will the ST7789 Driver play nice with multiple SPI Devices sharing the same SPI Bus?_

Not yet. The BL602 SPI Driver in NuttX assumes that the Chip Select Pin is __controlled by BL602's SPI Port__ (in hardware): [bl602_spi.c](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L438-L453)

```c
//  Select the SPI Device by flipping the 
//  Chip Select Pin from High to Low
static void bl602_spi_select(struct spi_dev_s *dev, uint32_t devid, bool selected) {
  //  Nothing here, we use BL602's 
  //  Hardware Chip Select
```

We might change this to flip the Chip Select Pin ourselves.

(__devid__ will identify the SPI Device)

__UPDATE:__ We have implemented the Shared SPI Bus for PineDio Stack. [(See this)](https://lupyuen.github.io/articles/pinedio2#appendix-shared-spi-bus)

_Can't we flip the Chip Select Pin inside the ST7789 Driver? (Instead of SPI Driver)_

Nope we can't flip the Chip Select Pin inside the ST7789 Driver. That's because the ST7789 Driver / SPI Flash Driver / SX1262 Driver will call this to __lock the SPI Bus__: [bl602_spi.c](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L398-L413)

```c
//  Lock the BL602 SPI Bus
static int bl602_spi_lock(struct spi_dev_s *dev, bool lock) {
  ...
  //  Lock with a NuttX Semaphore
  if (lock) {
    ret = nxsem_wait_uninterruptible(&priv->exclsem);
  } else {
    ret = nxsem_post(&priv->exclsem); 
  }
```

...Before calling __bl602_spi_select__ to select the SPI Device.

So we need to flip the Chip Select Pin inside __bl602_spi_select__.

_ST7789 receives plenty of data on the SPI Bus (for screen updates). Will there be contention?_

Most definitely. That's why we need to implement [__SPI DMA on BL602__](https://lupyuen.github.io/articles/spi#spi-with-direct-memory-access) so that our gadget can do other tasks while painting the ST7789 Display.

[(Right now the BL602 SPI Driver polls the SPI Port when transferring SPI data)](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L805-L855)

__UPDATE:__ SPI DMA is now supported on BL602 NuttX...

-   [__"SPI DMA on BL602 NuttX"__](https://lupyuen.github.io/articles/spi2#appendix-spi-dma-on-bl602-nuttx)

![Pine64 PineDio Stack BL604](https://lupyuen.github.io/images/spi2-pinedio2a.jpg)

_Pine64 PineDio Stack BL604_

# What's Next

In the next article we'll run NuttX with ST7789 Driver and LVGL Library on a real IoT gadget: __Pine64's PineDio Stack BL604__!

-   [__"PineDio Stack BL604 runs Apache NuttX RTOS"__](https://lupyuen.github.io/articles/pinedio2)

Many Thanks to my [__GitHub Sponsors__](https://lupyuen.github.io/articles/sponsor) for supporting my work! This article wouldn't have been possible without your support.

-   [Sponsor me a coffee](https://lupyuen.github.io/articles/sponsor)

-   [Discuss this article on Reddit](https://www.reddit.com/r/RISCV/comments/tth4zi/st7789_display_with_lvgl_graphics_on_apache_nuttx/)

-   [Read "The RISC-V BL602 / BL604 Book"](https://lupyuen.github.io/articles/book)

-   [Check out my articles](https://lupyuen.github.io)

-   [RSS Feed](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[`lupyuen.github.io/src/st7789.md`](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/st7789.md)

# Notes

1.  This article is the expanded version of [this Twitter Thread](https://twitter.com/MisterTechBlog/status/1507854679241199616)

1.  There are recent changes to the ST7789 Driver that may affect __SPI DMA performance__...

    [__"ST7789: Update putarea() method"__](https://github.com/apache/nuttx/pull/6657#issuecomment-1200094716)

![SPI Cmd/Data on BL602](https://lupyuen.github.io/images/st7789-dc4a.png)

# Appendix: SPI Cmd/Data on BL602

This section explains how we implemented the __ST7789 Data / Command Pin__ on BL602 NuttX...

To control the Data / Command Pin on ST7789 SPI Display, the SPI Driver flips the MISO Pin as though it was a GPIO. Here's the existing implementation for ESP32-C3: [esp32c3_board_spi.c](https://github.com/lupyuen/nuttx/blob/st7789/boards/risc-v/esp32c3/esp32c3-devkit/src/esp32c3_board_spi.c#L58-L86)

```c
#if defined(CONFIG_ESP32C3_SPI2) && defined(CONFIG_SPI_CMDDATA)

int esp32c3_spi2_cmddata(FAR struct spi_dev_s *dev, uint32_t devid, bool cmd)
{
#if defined(CONFIG_LCD_ST7735) || defined(CONFIG_LCD_ST7789) || \
    defined(CONFIG_LCD_GC9A01)
  if (devid == SPIDEV_DISPLAY(0))
    {
      /*  This is the Data/Command control pad which determines whether the
       *  data bits are data or a command.
       */

      esp32c3_gpiowrite(CONFIG_ESP32C3_SPI2_MISOPIN, !cmd);

      return OK;
    }

#endif
  spiinfo("devid: %" PRIu32 " CMD: %s\n", devid, cmd ? "command" :
          "data");

  return -ENODEV;
}

#endif
```

To implement this on BL602, we reconfigure MISO from SPI Pin to GPIO Pin on the fly: [bl602_spi.c](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L679-L748)

```c
#ifdef CONFIG_SPI_CMDDATA
static int bl602_spi_cmddata(struct spi_dev_s *dev,
                              uint32_t devid, bool cmd)
{
  spiinfo("devid: %" PRIu32 " CMD: %s\n", devid, cmd ? "command" :
          "data");

#if defined(CONFIG_LCD_ST7735) || defined(CONFIG_LCD_ST7789) || \
    defined(CONFIG_LCD_GC9A01)
  if (devid == SPIDEV_DISPLAY(0))
    {
      gpio_pinset_t gpio;
      int ret;

      /* reconfigure MISO from SPI Pin to GPIO Pin */

      gpio = (BOARD_SPI_MISO & GPIO_PIN_MASK)
            | GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO;
      ret = bl602_configgpio(gpio);
      if (ret < 0)
        {
          spierr("Failed to configure MISO as GPIO\n");
          DEBUGPANIC();

          return ret;
        }

      /* set MISO to high (data) or low (command) */

      bl602_gpiowrite(gpio, !cmd);

      return OK;
    }
#endif

  spierr("SPI cmddata not supported\n");
  DEBUGPANIC();

  return -ENODEV;
}
#endif
```

Note that `BOARD_SPI_MISO & GPIO_PIN_MASK` preserves the MISO GPIO Number when reconfiguring from SPI Pin to GPIO Pin.

When the SPI Port is deselected (after the SPI operation), we revert MISO back from GPIO Pin to SPI Pin: [bl602_spi.c](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L415-L453)

```c
static void bl602_spi_select(struct spi_dev_s *dev, uint32_t devid, bool selected) {
  ...
#ifdef CONFIG_SPI_CMDDATA
  /* revert MISO from GPIO Pin to SPI Pin */

  if (!selected)
    {
      bl602_configgpio(BOARD_SPI_MISO);
    }
#endif
}
```

We must revert because the SPI Bus may be shared by other SPI Drivers. (Like the Semtech SX1262 Driver on PineDio Stack BL604)

We tested this implementation of SPI Cmd/Data with NuttX ST7789 Driver and a [__Logic Analyser__](https://lupyuen.github.io/images/st7789-probe.jpg) on PineCone BL602. Logic Analyser shows that MISO goes Low when transmitting ST7789 Commands...

![MISO goes Low when transmitting ST7789 Commands](https://lupyuen.github.io/images/st7789-logic1.png)

And MISO goes High when transmitting ST7789 Data...

![MISO goes High when transmitting ST7789 Data](https://lupyuen.github.io/images/st7789-logic2a.png)

We also tested LVGL with ST7789 on PineCone BL602:

-   [Testing with LVGL](https://github.com/lupyuen/st7789-nuttx#run-lvgl-demo)

As for regular SPI Devices that don't require SPI Cmd/Data, we tested `CONFIG_SPI_CMDDATA=y` with Semtech SX1262 SPI Transceiver on PineCone BL602:

-   [Testing Cmd/Data](https://github.com/lupyuen/nuttx/releases/tag/release-2022-03-29)

[(Our implementation of SPI Cmd/Data has been merged into NuttX)](https://github.com/apache/nuttx/pull/5898)

![Fix SPI Send on BL602](https://lupyuen.github.io/images/st7789-spi2a.png)

# Appendix: Fix SPI Send on BL602

This section explains how we __fixed SPI Send__ on BL602 NuttX...

On BL602, SPI Poll Send `bl602_spi_poll_send()` doesn't send any data because it doesn't enable SPI Master and it doesn't clear the SPI FIFO.

SPI Poll Send also hangs because it loops forever waiting for the SPI FIFO: [bl602_spi.c](https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c#L779-L803)

```c
static uint32_t bl602_spi_poll_send(struct bl602_spi_priv_s *priv, uint32_t wd)
{
  uint32_t val;
  uint32_t tmp_val = 0;

  /* write data to tx fifo */

  putreg32(wd, BL602_SPI_FIFO_WDATA);
  
  /* This loop hangs because SPI Master is not enabled and SPI FIFO is not cleared */
  
  while (0 == tmp_val)
    {
      /* get data from rx fifo */

      tmp_val = getreg32(BL602_SPI_FIFO_CFG_1);
      tmp_val = (tmp_val & SPI_FIFO_CFG_1_RX_CNT_MASK)
                >> SPI_FIFO_CFG_1_RX_CNT_SHIFT;
    }
```

This problem affects the NuttX ST7789 Driver because the ST7789 Driver calls SPI Poll Send via `SPI_SEND()` and `bl602_spi_send()`.

We fix this problem by moving the code that enables SPI Master and clears the FIFO, from SPI Poll Exchange `bl602_spi_poll_exchange()` to SPI Poll Send. (Note that SPI Poll Exchange calls SPI Poll Send)

Before fixing, SPI Poll Send looks like this: [bl602_spi.c](https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c#L779-L803)

```c
static uint32_t bl602_spi_poll_send(struct bl602_spi_priv_s *priv, uint32_t wd)
{
  uint32_t val;
  uint32_t tmp_val = 0;

  /* write data to tx fifo */

  putreg32(wd, BL602_SPI_FIFO_WDATA);

  while (0 == tmp_val)
    {
      /* get data from rx fifo */
      ...
```

After fixing, SPI Poll Send enables SPI Master and clears SPI FIFO: [bl602_spi.c](https://github.com/lupyuen/nuttx/blob/st7789/arch/risc-v/src/bl602/bl602_spi.c#L806-L839)

```c
static uint32_t bl602_spi_poll_send(struct bl602_spi_priv_s *priv, uint32_t wd)
{
  uint32_t val;
  uint32_t tmp_val = 0;

  /* spi enable master */

  modifyreg32(BL602_SPI_CFG, SPI_CFG_CR_S_EN, SPI_CFG_CR_M_EN);

  /* spi fifo clear  */

  modifyreg32(BL602_SPI_FIFO_CFG_0, SPI_FIFO_CFG_0_RX_CLR
              | SPI_FIFO_CFG_0_TX_CLR, 0);

  /* write data to tx fifo */

  putreg32(wd, BL602_SPI_FIFO_WDATA);

  while (0 == tmp_val)
    {
      /* get data from rx fifo */
      ...
```

[__Logic Analyser__](https://lupyuen.github.io/images/st7789-probe.jpg) shows that SPI Poll Send now transmits SPI Data correctly:

![SPI Poll Send transmits SPI Data correctly](https://lupyuen.github.io/images/st7789-logic3.png)

Note that the MOSI Pin shows the correct data. Before fixing, the data was missing.

As for the modified SPI Poll Exchange, we tested it with Semtech SX1262 SPI Transceiver on PineCone BL602: [release-2022-03-28](https://github.com/lupyuen/nuttx/releases/tag/release-2022-03-28)

[(Our fix for SPI Poll Send has been merged into NuttX)](https://github.com/apache/nuttx/pull/5869)

# Appendix: Build, Flash and Run NuttX

_(For BL602, BL604 and ESP32)_

Below are the steps to build, flash and run NuttX on BL602, BL604 and ESP32.

The instructions below will work on __Linux (Ubuntu)__, __WSL (Ubuntu)__ and __macOS__.

[(Instructions for other platforms)](https://nuttx.apache.org/docs/latest/quickstart/install.html)

[(See this for Arch Linux)](https://popolon.org/gblog3/?p=1977&lang=en)

## Configure NuttX

Now we configure our NuttX project...

1.  Install the build prerequisites...

    [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

1.  Assume that we have downloaded the __NuttX Source Code__ (or patched an existing NuttX Project)...

    [__"Download Source Code"__](https://lupyuen.github.io/articles/st7789#download-source-code)

1.  Configure the build...

    ```bash
    cd nuttx

    ## For BL602: Configure the build for BL602
    ./tools/configure.sh bl602evb:nsh

    ## For PineDio Stack BL604: Configure the build for BL604
    ./tools/configure.sh bl602evb:pinedio

    ## For ESP32: Configure the build for ESP32.
    ## TODO: Change "esp32-devkitc" to our ESP32 board.
    ./tools/configure.sh esp32-devkitc:nsh

    ## Edit the Build Config
    make menuconfig 
    ```

1.  Enable __SPI Port__...

    In __menuconfig__, select __"System Type"__

    __For BL602:__ Check the box for __"BL602 Peripheral Support"__ ‚Üí __"SPI0"__

    __For ESP32:__ Check the box for __"ESP32 Peripheral Select"__ ‚Üí __"SPI 2"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Enable __SPI Cmd/Data__...

    Select __"Device Drivers"__ ‚Üí __"SPI Driver"__

    Check the boxes for the following...

    ```text
    SPI Exchange
    SPI CMD/DATA
    SPI Character Driver
    ```

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable SPI Cmd/Data](https://lupyuen.github.io/images/st7789-config1.png)

1.  Enable __ST7789 Driver__...

    Select __"Device Drivers"__ ‚Üí __"LCD Driver Support"__ ‚Üí __"Graphic LCD Driver Support"__ ‚Üí __"LCD Driver Selection"__
    
    Check the box for __"Sitronix ST7789 TFT Controller"__

    Assuming our ST7789 Display has 240 x 240 resolution...

    For __"X Resolution"__: Set to 240

    For __"Y Resolution"__: Set to 240

    For __"SPI Mode"__: Check your ST7789 Display

    [(For BL602: We hardcode to SPI Mode 3)](https://lupyuen.github.io/articles/st7789#spi-mode-3)

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable ST7789 Driver](https://lupyuen.github.io/images/st7789-config2a.png)

1.  Enable __LCD Character Device__...

    Select __"Device Drivers"__ ‚Üí __"LCD Driver Support"__ ‚Üí __"Graphic LCD Driver Support LCD"__ ‚Üí __"Character Device"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    The ST7789 Display will be connected to NuttX at "__/dev/lcd0__"

    ![Enable LCD Character Device](https://lupyuen.github.io/images/st7789-config3a.png)

1.  Enable __LVGL Library__...

    Select __"Application Configuration"__ ‚Üí __"Graphics Support"__
    
    Check the box for __"Light and Versatile Graphic Library (LVGL)"__

    ![Enable LVGL Library](https://lupyuen.github.io/images/st7789-config4a.png)

1.  Select __"Light and Versatile Graphic Library (LVGL)"__ ‚Üí __"Graphics Settings"__

    Assuming our ST7789 Display has 240 x 240 resolution...

    For __"Horizontal Resolution"__: Set to 240

    For __"Vertical Resolution"__: Set to 240

    Hit __"Exit"__

    Select __"Color settings"__

    Check the box for __"Swap the 2 bytes of RGB565 color"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Set LVGL Resolution](https://lupyuen.github.io/images/st7789-config6.png)

1.  Enable __LVGL Demo App__...

    Select __"Application Configuration"__ ‚Üí __"Examples"__ ‚Üí __"LVGL Demo"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable LVGL Demo App](https://lupyuen.github.io/images/st7789-config7a.png)

1.  Enable __ls__ command...

    Select __"Application Configuration"__ ‚Üí __"NSH Library"__ ‚Üí __"Disable Individual commands"__
    
    Uncheck __"Disable ls"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Enable __Logging and Assertion Checks__...

    Select __"Build Setup"__ ‚Üí __"Debug Options"__

    Check the boxes for the following...

    ```text
    Enable Debug Features
    Enable Error Output
    Enable Warnings Output
    Enable Informational Debug Output
    Enable Debug Assertions
    GPIO Debug Features
    GPIO Error Output
    GPIO Warnings Output
    GPIO Informational Output
    SPI Debug Features
    SPI Error Output
    SPI Warnings Output
    Graphics Debug Features
    Graphics Error Output
    Graphics Warnings Output
    Graphics Informational Output  
    Low-level LCD Debug Features
    LCD Driver Error Output
    LCD Driver Warnings Output
    LCD Driver Informational Output
    ```

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Save the configuration and exit menuconfig

    [(See the .config for BL602 and BL604)](https://gist.github.com/lupyuen/a7fc921531c1d14e8d336fba0cdb1c83)

## Build NuttX

Follow these steps to build NuttX for BL602, BL604 or ESP32...

1.  To build NuttX, enter this command...

    ```bash
    make
    ```

1.  We should see...

    ```text
    LD: nuttx
    CP: nuttx.hex
    CP: nuttx.bin
    ```

    [(See the complete log for BL602 / BL604)](https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746)

1.  __For WSL:__ Copy the __NuttX Firmware__ to the __c:\blflash__ directory in the Windows File System...

    ```bash
    ##  /mnt/c/blflash refers to c:\blflash in Windows
    mkdir /mnt/c/blflash
    cp nuttx.bin /mnt/c/blflash
    ```

    For WSL we need to run __blflash__ under plain old Windows CMD (not WSL) because it needs to access the COM port.

1.  In case of problems, refer to the __NuttX Docs__...

    [__"BL602 / BL604 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html)

    [__"ESP32 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html)

    [__"Installing NuttX"__](https://nuttx.apache.org/docs/latest/quickstart/install.html)

> ![Building NuttX](https://lupyuen.github.io/images/nuttx-build2.png)

## Flash NuttX

__For ESP32:__ [__See instructions here__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing) [(Also check out this article)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602 / BL604:__ Follow these steps to install __blflash__...

1.  [__"Install rustup"__](https://lupyuen.github.io/articles/flash#install-rustup)

1.  [__"Download and build blflash"__](https://lupyuen.github.io/articles/flash#download-and-build-blflash)

We assume that our Firmware Binary File __nuttx.bin__ has been copied to the __blflash__ folder.

Set BL602 / BL604 to __Flashing Mode__ and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __High__ [(Like this)](https://lupyuen.github.io/images/pinedio-high.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`H` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperh.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Connect BL10 to the USB port

1.  Press and hold the __D8 Button (GPIO 8)__

1.  Press and release the __EN Button (Reset)__

1.  Release the D8 Button

__For [Ai-Thinker Ai-WB2](https://docs.ai-thinker.com/en/wb2), Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __3.3V__

1.  Reconnect the board to the USB port

Enter these commands to flash __nuttx.bin__ to BL602 / BL604 over UART...

```bash
## For Linux: Change "/dev/ttyUSB0" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change "/dev/tty.usbserial-1410" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change "COM5" to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
```

[(See the Output Log)](https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f)

For WSL: Do this under plain old Windows CMD (not WSL) because __blflash__ needs to access the COM port.

[(Flashing WiFi apps to BL602 / BL604? Remember to use __bl_rfbin__)](https://github.com/apache/nuttx/issues/4336)

[(More details on flashing firmware)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

![Flashing NuttX](https://lupyuen.github.io/images/nuttx-flash2.png)

## Run NuttX

__For ESP32:__ Use Picocom to connect to ESP32 over UART...

```bash
picocom -b 115200 /dev/ttyUSB0
```

[(More about this)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602 / BL604:__ Set BL602 / BL604 to __Normal Mode__ (Non-Flashing) and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __Low__ [(Like this)](https://lupyuen.github.io/images/pinedio-low.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`L` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperl.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Press and release the __EN Button (Reset)__

__For [Ai-Thinker Ai-WB2](https://docs.ai-thinker.com/en/wb2), Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __GND__

1.  Reconnect the board to the USB port

After restarting, connect to BL602 / BL604's UART Port at 2 Mbps like so...

__For Linux:__

```bash
screen /dev/ttyUSB0 2000000
```

__For macOS:__ Use CoolTerm ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__For Windows:__ Use `putty` ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__Alternatively:__ Use the Web Serial Terminal ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

Press Enter to reveal the __NuttX Shell__...

```text
NuttShell (NSH) NuttX-10.2.0-RC0
nsh>
```

Congratulations NuttX is now running on BL602 / BL604!

[(More details on connecting to BL602 / BL604)](https://lupyuen.github.io/articles/flash#watch-the-firmware-run)

![Running NuttX](https://lupyuen.github.io/images/nuttx-boot2.png)

__macOS Tip:__ Here's the script I use to build, flash and run NuttX on macOS, all in a single step: [run.sh](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

![Script to build, flash and run NuttX on macOS](https://lupyuen.github.io/images/spi2-script.png)

[(Source)](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

![ST7789 SPI Display connected to Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/images/st7789-title2.jpg)

_ST7789 SPI Display connected to [Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/articles/pinecone)_
