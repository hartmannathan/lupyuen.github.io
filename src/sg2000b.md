# RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)

üìù _15 Jul 2024_

![TODO](https://lupyuen.github.io/images/sg2000b-title.jpg)

TODO: Read the article

TODO: Watch the presentation

[sg2000-emulator](https://github.com/lupyuen2/sg2000-emulator)

Let's create a Software Emulator for Sophgo SG2000 SoC and Milk-V Duo S SBC! It runs every day for our [Daily Automated Testing](https://github.com/lupyuen/nuttx-sg2000#nuttx-automated-daily-build-for-sg2000) of Apache NuttX RTOS for SG2000.

# Update the Memory Map

We begin with the [__TinyEMU RISC-V Emulator__](https://lupyuen.github.io/articles/tinyemu3) for Ox64 BL808 SBC. And we tweak it for SG2000.

This is how we update the __RISC-V Memory Map__ for SG2000: [riscv_machine.c](https://github.com/lupyuen2/sg2000-emulator/commit/d36190c63c1db116a206a26f3bc27dfacf5c8298)

```c
// Base Addresss of System RAM, Core Local Interrupt Controller (unused)
// And Platform-Level Interrupt Controller
#define RAM_BASE_ADDR   0x80200000ul
#define CLINT_BASE_ADDR 0x74000000ul
#define PLIC_BASE_ADDR  0x70000000ul
```

Then build and run TinyEMU...

```bash
## Build TinyEMU for macOS
## For Linux: See https://github.com/lupyuen/nuttx-sg2000/blob/main/.github/workflows/sg2000-test.yml#L29-L45
cd $HOME/sg2000-emulator/
make clean
make \
  CFLAGS="-I$(brew --prefix)/opt/openssl/include -I$(brew --prefix)/opt/sdl2/include" \
  LDFLAGS="-L$(brew --prefix)/opt/openssl/lib -L$(brew --prefix)/opt/sdl2/lib" \
  CONFIG_MACOS=y

## Build NuttX for SG2000
## https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000
cd $HOME/nuttx
tools/configure.sh milkv_duos:nsh
make
## Omitted: Create the `Image` file for SG2000 NuttX

## Boot TinyEMU with NuttX for SG2000
cd $HOME/nuttx
wget https://raw.githubusercontent.com/lupyuen/nuttx-sg2000/main/nuttx.cfg
sg2000-emulator/temu nuttx.cfg
```

Our Emulator crashes at a strange address...

# `auipc` Overflow in Boot Code

When we __Boot our Emulator__ with SG2000 NuttX, it crashes...

```bash
$ sg2000-emulator/temu nuttx.cfg

TinyEMU Emulator for Sophgo SG2000 SoC
raise_exception2:
  cause=1
  tval= 0xffffffff_80200000
  pc=   0xffffffff_80200000

tinyemu:
  Illegal instruction, quitting
```

_What just happened?_

Our Emulator tried to execute the code at MTVAL _0xffffffff_80200000_. And crashed because it's __not a valid address!__

_0xffffffff_80200000_ looks sus, it seems related to __RAM Base Address__ _0x80200000_.

_Our Emulator is booting the wrong address?_

We check the __Original TinyEMU__ Boot Code: [riscv_machine.c](https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L857-L861)

```c
// Init the TinyEMU Boot Code
static void copy_bios(...) {
  ...
  // `q` points to the Boot Code
  q = (uint32_t *)(ram_ptr + 0x1000);

  // Load `RAM_BASE_ADDR` into Register T0:
  // `auipc t0, RAM_BASE_ADDR`
  // `RAM_BASE_ADDR` is 0x80000000
  q[0] = 0x297 + RAM_BASE_ADDR - 0x1000;

  // Later: Jump to Register T0
```

To load the __RAM Base Address__ into Register T0: TinyEMU tries to assemble this RISC-V Instruction (into our Boot Code)...

```bash
auipc t0, 0x80200000
```

_Maybe auipc has a problem?_

We verify with the [__RISC-V Online Assembler__](https://riscvasm.lucasteske.dev/#).

When we assemble the __`auipc`__ instruction above, the Online Assembler fails with an error...

```yaml
Error: lui expression not in range 0..1048575
Error: value of 0000080200000000 too large
  for field of 4 bytes at 0000000000000000
```

Aha _0x80200000_ is too big to assemble as an __`auipc` Address!__

_But 0x80200000 is a perfectly valid address?_

Remember that RISC-V is a __RISC Platform__ after all. Some operations won't fit into 4 bytes of Machine Code.

We upsize to 8 bytes of Machine Code...

# Change `auipc` to `li` in Boot Code

We load _0x80200000_ into Register t0 in another way, with the __`li` Instruction__...

```bash
li  t0, 0x80200000
```

When we feed this above into [__RISC-V Online Assembler__](https://riscvasm.lucasteske.dev/#), we see the resulting (8-byte) __Machine Code__...

```bash
4010029b  addiw  t0, zero, 1025
01529293  slli   t0, t0,   0x15
```

That's because __`li`__ is a Pseudo-Instruction that expands into two RISC-V Instructions...

- __`addiw`__: Add zero to `1025` and store into T0

- __`slli`__: Shift-Left T0 by `0x15` bits

- Producing: `1025` << `0x15` = `0x8020_0000`

Thus we copy the above Machine Code into our TinyEMU Boot Code: [riscv_machine.c](https://github.com/lupyuen2/sg2000-emulator/commit/b2d5cf63c5d6d1d0d4eafa5d400216d1f76a6e21)

```c
// Init the TinyEMU Boot Code
static void copy_bios(...) {
  ...
  // Load `RAM_BASE_ADDR` into Register T0:
  // `li  t0, 0x80200000`
  // Which is assembled as...
  q[pc++] = 0x4010029b;  // addiw t0, zero, 1025
  q[pc++] = 0x01529293;  // slli  t0, t0,   0x15

  // TODO: Remove the hardcoding of 0x80200000
```

Our Emulator now boots NuttX correctly at _0x80200000_!

# Emulate the 16550 UART Controller

_Nothing appears when we boot NuttX?_

```bash
$ sg2000-emulator/temu nuttx.cfg

TinyEMU Emulator for Sophgo SG2000 SoC
(...crickets...)
```

That's because we haven't emulated the __16550 UART Controller__ in TinyEMU!

To figure out what's needed, we refer to the __16550 UART Driver__ in NuttX: [uart_16550.c](https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1602-L1671)

```c
// To send one byte to UART Output...
void u16550_send(struct uart_dev_s *dev, int ch) {
  ...
  // We write the byte to the 16550 UART Register...
  u16550_serialout(
    priv,             // UART Device
    UART_THR_OFFSET,  // UART Register: Transmit Holding Register (THR)
    ch                // Byte to be sent
  );
}

// To check if the UART Transmit FIFO is ready...
bool u16550_txready(struct uart_dev_s *dev) {
  ...
  // We read the 16550 UART Register...
  return ((
    u16550_serialin(
      priv,            // UART Device
      UART_LSR_OFFSET  // UART Register: Line Status Register (LSR)
    ) & UART_LSR_THRE  // And check the THRE Bit (Transmit Holding Register Empty)
  ) != 0);
}
```

Which says that...

- __UART_THR__: Transmit Holding Register

  Will receive the byte that NuttX is transmitting

- __UART_LSR__: Line Status Register

  Will be read by NuttX to check if the Transmit FIFO is Empty

- __UART_LSR_THRE__: Transmit Holding Register Empty

  This is the bit in __UART_LSR__ that will indicate whether Transmit FIFO is Empty

Let's emulate the above in TinyEMU...

# Emulate the UART Output Registers

_How will we emulate the 16550 UART Registers in TinyEMU?_

When TinyEMU needs to Read or Write a Memory Address, it will call the functions below.

This is how we __Intercept the Memory Writes__ to emulate the __UART Output Register__ (Transmit Holding): [riscv_cpu.c](https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L536-L550)

```c
// TinyEMU calls this function to execute Memory Writes
int target_write_slow(...) {
  ...
  // If TinyEMU is writing to this address...
  switch(paddr) {

    // Address is UART Transmit Holding Register
    case UART0_BASE_ADDR + UART_THR_OFFSET:

      // Print the character that's written by NuttX
      char buf[1] = { val };
      print_console(NULL, buf, 1);
```

[(__UART Addresses__ are here)](https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L395-L411)

And this is how we __Intercept the Memory Reads__ to emulate the __UART Status Register__ (Line Status): [riscv_cpu.c](https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L390-L420)

```c
// TinyEMU calls this function to execute Memory Reads
int target_read_slow(...) {
  ...
  // If TinyEMU is reading from this address...
  switch(paddr) {

    // Address is UART Line Status Register
    case UART0_BASE_ADDR + UART_LSR_OFFSET:

      // Always tell NuttX that
      // Transmit Holding Register is Empty
      ret = UART_LSR_THRE;

      // If UART Input is available:
      // Tell NuttX that Receive Data is Available
      if (read_input() != 0) {
        ret |= UART_LSR_DR;
      }
```

[(__UART Addresses__ are here)](https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L395-L411)

(More about UART Input in a while)

_What happens when we run this?_

Now we see the NuttX Shell yay!

```bash
$ sg2000-emulator/temu nuttx.cfg 

TinyEMU Emulator for Sophgo SG2000 SoC
NuttShell (NSH) NuttX-12.5.1
nsh>
```

Next we fix the UART Input...

# Fix the UART Input

TODO

_How does the NuttX 16550 UART Driver use UART_IIR_OFFSET and UART_MSR_OFFSET?_

The NuttX 16550 UART Driver reads UART_IIR_OFFSET and UART_MSR_OFFSET to handle UART Interrupts: 

[uart_16550.c](https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L979-L1282)

```c
// NuttX Interrupt Handler for 16550 UART
int u16550_interrupt(int irq, FAR void *context, FAR void *arg) {
  ...
  // Loop until no characters to be transferred
  for (passes = 0; passes < 256; passes++) {

    // Get the current UART Status
    status = u16550_serialin(priv, UART_IIR_OFFSET);

    // If no Pending Interrupts, exit
    if ((status & UART_IIR_INTSTATUS) != 0) { break; }

    // Handle the UART Interrupt
    switch (status & UART_IIR_INTID_MASK) {

      // If UART Input is available,
      // receive the Input Data
      case UART_IIR_INTID_RDA:
        uart_recvchars(dev);
        break;
  ...
}

// Receive one character from UART.
// Called by the above Interrupt Handler.
int u16550_receive(struct uart_dev_s *dev, unsigned int *status) {
  ...
  // Return the Line Status and Receive Buffer
  *status = u16550_serialin(priv, UART_LSR_OFFSET);
  rbr     = u16550_serialin(priv, UART_RBR_OFFSET);
  return rbr;
}
```

Which says that...

- __UART_IIR__: Interrupt ID Register

  Should return __INTID_RDA__ (data available)

  Followed by __IIR_INTSTATUS__ (no more data)

- __UART_LSR__: Line Status Register

  Should return __LSR_DR__ (data available)

  Followed by 0 (no more data)

- __UART_RBR__: Receiver Buffer Register

  Should return the UART Input Data

TODO

# Emulate the UART Input Registers

TODO

We emulate the UART Interrupt like this: [Emulate UART Interrupt: UART_LSR, UART_IIR, UART_RBR](https://github.com/lupyuen2/sg2000-emulator/commit/ce3562e4d7efe53b52a1b945850f08d93630d4d2)

Now we see...

```bash
plic_set_irq: irq_num=44, state=1
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c

read UART_IIR_OFFSET
read UART_RBR_OFFSET
read UART_IIR_OFFSET

plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c

read UART_IIR_OFFSET
plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
read UART_IIR_OFFSET
```

# Fix the UART Interrupt

TODO

When we press a key, NuttX triggers an expected interrupt...

```bash
$ sg2000-emulator/temu nuttx.cfg 
...
NuttShell (NSH) NuttX-12.5.1
nsh> irq_unexpected_isr: ERROR irq: 45
_assert: Current Version: NuttX  12.5.1 218ccd843a Jun 18 2024 22:14:46 risc-v
_assert: Assertion failed panic: at file: irq/irq_unexpectedisr.c:54 task: Idle_Task process: Kernel 0x8020110c
up_dump_register: EPC: 000000008021432a
```

Now we fix the UART Input and UART Interrupt. Based on the NuttX Config...

```bash
CONFIG_16550_UART0_IRQ=69
```

Since NuttX IRQ Offset is 25, so Actual RISC-V IRQ is 69 - 25 = 44 (as confirmed by the SG2000 Reference Manual)...

[Set VIRTIO_IRQ to 44](https://github.com/lupyuen2/sg2000-emulator/commit/643c25cada46289539e31579616e7afbf108c3ae)

```c
#define VIRTIO_IRQ       44  // UART0 IRQ
```

But when we press a key: TinyEMU crashes with a Segmentation Fault...

```bash
$ sg2000-emulator/temu nuttx.cfg    
...
NuttShell (NSH) NuttX-12.5.1
nsh> [1]    94499 segmentation fault  sg2000-emulator/temu nuttx.cfg
```

# UART Input causes Segmentation Fault

TODO

We debug with `lldb` (because `gdb` is not available for macOS Arm64)...

```bash
$ lldb sg2000-emulator/temu nuttx.cfg 
(lldb) target create "/Users/luppy/sg2000/sg2000-emulator/temu"
Current executable set to '/Users/luppy/sg2000/sg2000-emulator/temu' (arm64).
(lldb) settings set -- target.run-args  "nuttx.cfg"
(lldb) r
Process 90245 launched: '/Users/luppy/sg2000/sg2000-emulator/temu' (arm64)
...
NuttShell (NSH) NuttX-12.5.1
Process 90245 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000000000000
error: memory read failed for 0x0
Target 0: (temu) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
  * frame #0: 0x0000000000000000
    frame #1: 0x000000010000b978 temu`virt_machine_run(m=0x000000013461b2a0) at temu.c:598:17 [opt]
    frame #2: 0x000000010000be6c temu`main(argc=<unavailable>, argv=<unavailable>) at temu.c:845:9 [opt]
    frame #3: 0x0000000197a4e0e0 dyld`start + 2360
(lldb) 
```

Which is at...

```c
void virt_machine_run(VirtMachine *m) {
  ...    
  virtio_console_write_data(m->console_dev, buf, ret);
```

Why did TinyEMU crash? This doesn't make sense, `m` is non-null!

Maybe it's already optimised? Let's disable GCC Optimisation...

- [Disable GCC Optimisation](https://github.com/lupyuen2/sg2000-emulator/commit/af768df81fc349562565d638e359aca6127c9267)

Now it makes more sense!

```bash
$ lldb sg2000-emulator/temu nuttx.cfg 
...
NuttShell (NSH) NuttX-12.5.1
Process 1595 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
    frame #0: 0x0000000000000000
error: memory read failed for 0x0
Target 0: (temu) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
  * frame #0: 0x0000000000000000
    frame #1: 0x0000000100002604 temu`set_irq(irq=0x000000013a607b08, level=1) at iomem.h:145:5
    frame #2: 0x00000001000025a4 temu`virtio_console_write_data(s=0x000000013d604080, buf="a", buf_len=1) at virtio.c:1346:5
    frame #3: 0x000000010000fd2c temu`virt_machine_run(m=0x000000013a607680) at temu.c:598:17
    frame #4: 0x00000001000105cc temu`main(argc=2, argv=0x000000016fdff080) at temu.c:845:9
    frame #5: 0x0000000197a4e0e0 dyld`start + 2360
```

Which crashes here...

```c
static inline void set_irq(IRQSignal *irq, int level) {
  irq->set_irq(irq->opaque, irq->irq_num, level);
}
```

Which means `irq->set_irq` is null! (Rightfully it should be set to `plic_set_irq`)

# IRQ Isn't Initialised

TODO

_Why is `irq->set_irq` set to null?_

We verify with an Assertion Check: [irq->set_irq is null!](https://github.com/lupyuen2/sg2000-emulator/commit/4a8652a70ff16b85ab16108686916a75505e4ef6)

```bash
NuttShell (NSH) NuttX-12.5.1
nsh> Assertion failed: (irq->set_irq != NULL), function set_irq, file iomem.h, line 145.
Process 15262 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert
    frame #4: 0x000000010000249c temu`set_irq(irq=0x000000014271a478, level=1) at iomem.h:145:5
   142 
   143  static inline void set_irq(IRQSignal *irq, int level)
   144  {
-> 145      assert(irq->set_irq != NULL); //// TODO
   146      irq->set_irq(irq->opaque, irq->irq_num, level);
   147  }
   148 
Target 0: (temu) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert
    frame #0: 0x0000000197d9ea60 libsystem_kernel.dylib`__pthread_kill + 8
    frame #1: 0x0000000197dd6c20 libsystem_pthread.dylib`pthread_kill + 288
    frame #2: 0x0000000197ce3a30 libsystem_c.dylib`abort + 180
    frame #3: 0x0000000197ce2d20 libsystem_c.dylib`__assert_rtn + 284
  * frame #4: 0x000000010000249c temu`set_irq(irq=0x000000014271a478, level=1) at iomem.h:145:5
    frame #5: 0x0000000100002418 temu`virtio_console_write_data(s=0x0000000142719980, buf="a\xc0\xedE", buf_len=1) at virtio.c:1346:5
    frame #6: 0x000000010000fc30 temu`virt_machine_run(m=0x0000000142719ff0) at temu.c:598:17
    frame #7: 0x00000001000104d0 temu`main(argc=2, argv=0x000000016fdff080) at temu.c:845:9
    frame #8: 0x0000000197a4e0e0 dyld`start + 2360
```

We [inspect the variables](https://lldb.llvm.org/use/map.html) in LLDB...

```bash
frame #4: 0x000000010000249c temu`set_irq(irq=0x000000014271a478, level=1) at iomem.h:145:5
   142 
   143  static inline void set_irq(IRQSignal *irq, int level)
   144  {
-> 145      assert(irq->set_irq != NULL); //// TODO
   146      irq->set_irq(irq->opaque, irq->irq_num, level);
   147  }
   148 
(lldb) frame variable
(IRQSignal *) irq = 0x000000014271a478
(int) level = 1
(lldb) p *irq
(IRQSignal) {
  set_irq = 0x0000000000000000
  opaque = 0x0000000000000000
  irq_num = 0
}
```

`irq` is all empty! Where does `irq` come from? We step up the Call Stack...

```bash
(lldb) up
frame #5: 0x0000000100002418 temu`virtio_console_write_data(s=0x0000000142719980, buf="a\xc0\xedE", buf_len=1) at virtio.c:1346:5
   1343     _info("[%c]\n", buf[0]); ////
   1344     set_input(buf[0]);
   1345     s->int_status |= 1;
-> 1346     set_irq(s->irq, 1);
   1347
   1348 #ifdef NOTUSED
   1349     int queue_idx = 0;
(lldb) frame variable
(VIRTIODevice *) s = 0x0000000142719980
(const uint8_t *) buf = 0x000000016fdfeae8 "a\xc0\xedE"
(int) buf_len = 1

(lldb) p *s
(VIRTIODevice) {
  mem_map = 0x000000014380fc00
  mem_range = 0x000000014380fe60
  pci_dev = NULL
  irq = 0x000000014271a478
  get_ram_ptr = 0x00000001000065dc (temu`virtio_mmio_get_ram_ptr at virtio.c:193)
  debug = 0
  int_status = 1
  status = 0
  device_features_sel = 0
  queue_sel = 0
  queue = {
    [0] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = YES
    }
    [1] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [2] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [3] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [4] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [5] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [6] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
    [7] = {
      ready = 0
      num = 16
      last_avail_idx = 0
      desc_addr = 0
      avail_addr = 0
      used_addr = 0
      manual_recv = NO
    }
  }
  device_id = 3
  vendor_id = 65535
  device_features = 1
  device_recv = 0x00000001000025cc (temu`virtio_console_recv_request at virtio.c:1278)
  config_write = 0x0000000000000000
  config_space_size = 4
  config_space = "P\0\U00000019"
}
```

This says that `s` is a `virtio_console`.

# TinyEMU Supports only 32 IRQs

TODO

Why is `s->irq` empty? We step up the Call Stack...

```bash
(lldb) up
frame #6: 0x000000010000fc30 temu`virt_machine_run(m=0x0000000142719ff0) at temu.c:598:17
   595              len = min_int(len, sizeof(buf));
   596              ret = m->console->read_data(m->console->opaque, buf, len);
   597              if (ret > 0) {
-> 598                  virtio_console_write_data(m->console_dev, buf, ret);
   599              }
   600          }
   601  #endif
(lldb) p *m
(VirtMachine) {
  vmc = 0x0000000100080620
  net = NULL
  console_dev = 0x0000000142719980
  console = 0x0000000142719510
  fb_dev = NULL
}
```

`s->irq` comes from `m->console_dev`.

_Why is `console_dev` not properly inited?_

From earlier: UART0 is at RISC-V IRQ 44. But we discover that TinyEMU supports only 32 IRQs!

```c
static VirtMachine *riscv_machine_init(const VirtMachineParams *p) {
  for(i = 1; i < 32; i++) {
    irq_init(&s->plic_irq[i], plic_set_irq, s, i);
  }
```

# Increase TinyEMU IRQs from 32 to 64

TODO

So we increase the IRQs from 32 to 256: [Increase the IRQs from 32 to 256](https://github.com/lupyuen2/sg2000-emulator/commit/c6ce6bdbbdaf7585ce18f77b2b2f25a2317914be)

(256 IRQs is too many, as we shall soon see)

Now we see something different when we press a key!

```bash
NuttShell (NSH) NuttX-12.5.1
nsh> irq_unexpected_isr: ERROR irq: 37
_assert: Current Version: NuttX  12.5.1 218ccd843a Jun 18 2024 22:14:46 risc-v
_assert: Assertion failed panic: at file: irq/irq_unexpectedisr.c:54 task: Idle_Task process: Kernel 0x8020110c
up_dump_register: EPC: 000000008021432a
```

_What is NuttX IRQ 37? (RISC-V IRQ 12) Shouldn't it be RISC-V IRQ 44 for UART Input?_

Seems the RISC-V IRQs wrap around at 32? So RISC-V IRQ 44 becomes IRQ 12?

```bash
NuttShell (NSH) NuttX-12.5.1
nsh> plic_set_irq: irq_num=44, state=1
plic_pending_irq=0x800, plic_served_irq=0x0, mask=0x800
plic_update_mip: set_mip, pending=0x800, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x800, served=0x800
plic_read: pending irq=0xc
plic_pending_irq=0x800, plic_served_irq=0x800, mask=0x800
irq_unexpected_isr: ERROR irq: 37
```

So we fix the IRQ Size: [Increase the Pending IRQ Size and Served IRQ Size from 32-bit to 64-bit](https://github.com/lupyuen2/sg2000-emulator/commit/78ac3ad75f1ec0b54f5bee10488731c7a21fb9ea)

Now we see the correct Pending IRQ!

```bash
NuttShell (NSH) NuttX-12.5.1
nsh> plic_set_irq: irq_num=44, state=1
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
plic_write: offset=0x201004, val=0x2c
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
plic_write: offset=0x201004, val=0x2c
```

# Pending IRQ Loops Forever

TODO

_Why does Pending IRQ loop forever? Maybe because we haven't cleared the UART Interrupt?_

To find out why, we trace the reads and writes to UART Registers: [Log the invalid memory accesses](https://github.com/lupyuen2/sg2000-emulator/commit/1f4b79bc9d276e1ca6371e60d0c9d25a53f7fa80)

```bash
NuttShell (NSH) NuttX-12.5.1
target_write_slow: invalid physical address 0x0000000004140004
User ECALL: pc=0xc0001998
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
nsh> target_write_slow: invalid physical address 0x0000000004140004
User ECALL: pc=0xc0001998
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
User ECALL: pc=0xc000aa0e
target_write_slow: invalid physical address 0x0000000004140004
target_write_slow: invalid physical address 0x0000000004140004
plic_set_irq: irq_num=44, state=1
plic_update_mip: set_mip, pending=0x80000000000, served=0x0
plic_read: offset=0x201004
plic_update_mip: reset_mip, pending=0x80000000000, served=0x80000000000
plic_read: pending irq=0x2c
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140018
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140018
target_read_slow: invalid physical address 0x0000000004140008
target_read_slow: invalid physical address 0x0000000004140018
```

_What are UART Registers 0x4140008 and 0x4140018? Why are they read when we press a key?_

We look up the UART Registers...

```c
// UART Registers from https://github.com/apache/nuttx/blob/master/include/nuttx/serial/uart_16550.h
#define UART0_BASE_ADDR 0x04140000
#define CONFIG_16550_REGINCR 4
#define UART_IIR_INCR          2  /* Interrupt ID Register */
#define UART_FCR_INCR          2  /* FIFO Control Register */
#define UART_MSR_INCR          6  /* Modem Status Register */

// So 0x4140008 is one of these...
#define UART_IIR_OFFSET        (CONFIG_16550_REGINCR*UART_IIR_INCR)
#define UART_FCR_OFFSET        (CONFIG_16550_REGINCR*UART_FCR_INCR)

// And 0x4140018 is...
#define UART_MSR_OFFSET        (CONFIG_16550_REGINCR*UART_MSR_INCR)
```

We check the NuttX 16550 UART Driver for UART_IIR_OFFSET, UART_FCR_OFFSET and UART_MSR_OFFSET. (See the next section)

_What is UART Register 0x4140004? Why is it read when we print to UART?_

We look up the UART Register...

```c
// UART Registers from https://github.com/apache/nuttx/blob/master/include/nuttx/serial/uart_16550.h
#define UART0_BASE_ADDR 0x04140000
#define CONFIG_16550_REGINCR 4
#define UART_DLM_INCR          1  /* (DLAB =1) Divisor Latch MSB */
#define UART_IER_INCR          1  /* (DLAB =0) Interrupt Enable Register */

// So 0x4140004 is one of these...
#define UART_DLM_OFFSET        (CONFIG_16550_REGINCR*UART_DLM_INCR)
#define UART_DLM_OFFSET        (CONFIG_16550_REGINCR*UART_IER_INCR)
```

TODO: Check the NuttX 16550 UART Driver for UART_DLM_OFFSET and UART_DLM_OFFSET


# Clear the UART Interrupt

TODO

_Why is pending IRQ looping forever?_

That's because we forgot to clear the UART Interrupt duh!

- [Clear the UART Interrupt](https://github.com/lupyuen2/sg2000-emulator/commit/2d10b7699378525a3cf4282d2eaf9da051726638)

Finally it works OK yay! [(We disabled logging)](https://github.com/lupyuen2/sg2000-emulator/commit/ba2e9e09df18e7feed38e67a1ca678348f0c2d2a)

```bash
$ sg2000-emulator/temu nuttx.cfg
TinyEMU Emulator for Sophgo SG2000 SoC
virtio_console_init
Patched DCACHE.IALL (Invalidate all Page Table Entries in the D-Cache) at 0x80200a28
Patched SYNC.S (Ensure that all Cache Operations are completed) at 0x80200a2c
Found ECALL (Start System Timer) at 0x8020b2c6
Patched RDTIME (Read System Time) at 0x8020b2cc
elf_len=0
virtio_console_resize_event
ABC
NuttShell (NSH) NuttX-12.5.1
nsh> uname -a
NuttX 12.5.1 50fadb93f2 Jun 18 2024 09:20:31 risc-v milkv_duos
nsh> 
```

[OSTest works OK too!](https://gist.github.com/lupyuen/ac80b426f67ad38f6a59ae563b0ecb9f)

_SG2000 Emulator seems slower than Ox64 BL808 Emulator?_

Yeah probably because SG2000 runs on [MTIMER_FREQ of 25000000](https://github.com/lupyuen2/wip-nuttx/commit/bb4906c976e44a05237f91944844cd1c68ef5d5b).

When we execute `sleep 10`, it completes in 25 seconds. We might need to adjust the TinyEMU System Timer.

(CPU-bound operations like `getprime` won't have this timing delay)

# What's Next

TODO

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) (and the awesome NuttX Community) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__My Current Project: "Apache NuttX RTOS for Sophgo SG2000"__](https://github.com/lupyuen/nuttx-sg2000)

-   [__My Other Project: "NuttX for Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64)

-   [__Older Project: "NuttX for Star64 JH7110"__](https://github.com/lupyuen/nuttx-star64)

-   [__Olderer Project: "NuttX for PinePhone"__](https://github.com/lupyuen/pinephone-nuttx)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/sg2000b.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000b.md)
