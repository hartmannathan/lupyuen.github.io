# Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S SBC)

üìù _22 May 2024_

![TODO](https://lupyuen.github.io/images/sg2000-title.jpg)

TODO

64-bit RISC-V Sophgo SG2000 SoC ... Will it boot Apache NuttX RTOS? ü§î (T-Head C906 / Milk-V Duo S)

- [SG2000 Overview](https://www.cnx-software.com/2024/02/07/sophgo-sg2000-sg2002-ai-soc-features-risc-v-arm-8051-cores-android-linux-freertos/)

- [SG2000 Reference Manual](https://github.com/sophgo/sophgo-doc/releases)

Let's find out!

Something strangely satisfying about NuttX on RISC-V... We finished the port in only 10 days! üéâ

_Is this a sponsored review?_

I was given a Milk-V Duo S, and I bought another. So it cancels out, I guess?

_Why are we doing all this?_

1.  We hear that there will be plenty of interesting new SBCs based on Sophgo SG2000 and SG2002. Perfect for NuttX!

1.  NuttX has been ported from QEMU RISC-V to Star64 JH7110 to Ox64 BL808 and now Sophgo SG2000. Let's find the most efficient way to port NuttX to new RISC-V Devices!

TODO: [(Watch the Demo on YouTube)](https://www.youtube.com/watch?v=pPNDiC5NLqM)

![Sophgo SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-soc.jpg)

# Sophgo SG2000 RISC-V SoC

__Sophgo SG2000 SoC__ has a fascinating mix of 64-bit RISC-V Cores (Arm too)...

- __Main Processor:__ 64-bit RISC-V Core

  __T-Head C906__ _(1.0 GHz)_

  (For NuttX and Linux)

- __Co-Processor:__ 64-bit RISC-V Core

  __T-Head C906__ _(700 MHz)_

  (No Cache)

- __Alt-Main Processor:__ 64-bit Arm Core

  __Cortex-A53__ _(1.0 GHz)_

Plus a __Low-Power 8051 MCU__ (for wakeup duties) and a __Tensor Processing Unit__ (for image recognition, not LLM)...

![Sophgo SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-arch.jpg)

_Whoa RISC-V AND Arm CPUs in a single SoC?_

Actually there's a __Hardware Switch__ that selects the Main CPU: __RISC-V OR Arm__.

(Don't let yer pet hamster flip it... It will get super frustrating!)

![Milk-V Duo S](https://lupyuen.github.io/images/sg2000-board.jpg)

# Boot Without MicroSD

_What happens if we boot Milk-V Duo S? Fresh from the box?_

Connect our __USB UART Dongle__ according to [__the instructions__](https://milkv.io/docs/duo/getting-started/duos#uart-serial-console) (pic above)...

| Milk-V Duo S | USB UART |
|:------------:|:--------:|
| __GND__ (Pin 6)	| __GND__ |
| __TX__ (Pin 8) |	__RX__ |
| __RX__ (Pin 10)	| __TX__ |

USB UART Dongle must be [__CP2102__](http://sun-light.com.sg/index.php?route=product/product&product_id=2367), it doesn't like [__CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) üò¨

![Switch to "RV" (RISC-V) instead of "Arm"](https://lupyuen.github.io/images/sg2000-switch.jpg)

Flip the Switch so it's set to "__`RV`__" (RISC-V) instead of "__`Arm`__". (Pic above)

Power up the board via the __USB-C Port__. Connect to the USB UART at __115.2 kbps__.

Milk-V Duo S [__won't boot__](https://gist.github.com/lupyuen/a7c3af98be36dcd5cc5b45f5aadc5d16) because it doesn't ship with __U-Boot Bootloader__ in Flash Memory...

```bash
C.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000. 
E:eMMC initializing failed
E:Boot failed
```

We'll need U-Boot on MicroSD. (Next section)

If we see ["__`B.SCS`__"](https://gist.github.com/lupyuen/d55b77a51ee8b258d6d1c0799770742a) instead of "__`C.SCS`__"...

```bash
B.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000.
```
Nope we're in Arm Mode... Flip the switch back to RISC-V!

[__If we use CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) (instead of CP2102): UART Output will be [__gloriously garbled__](https://gist.github.com/lupyuen/1d5ba1b2a47c110ee7ff265102b1aae5).

# Download the Linux MicroSD

_Milk-V Duo S won't boot without MicroSD. How now?_

Let's boot __Linux on MicroSD__, thanks to the awesome work by [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Images for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

```bash
## For Linux
$ sudo apt install lz4

## For macOS
$ brew install lz4

## Uncompress the download to get `duos_sd.img`
$ lz4 duos_sd.img.lz4

## TODO: Write `duos_sd.img` to MicroSD with Balena Etcher

## Here are the MicroSD Files
$ ls -l /Volumes/boot
-rwxrwxrwx  3494900 System.map-5.10.4-20240329-1+
-rwxrwxrwx   125534 config-5.10.4-20240329-1+
drwxrwxrwx     2048 extlinux
drwxrwxrwx     2048 fdt
-rwxrwxrwx   388608 fip.bin
-rwxrwxrwx  4937389 vmlinuz-5.10.4-20240329-1+

## U-Boot Bootloader Config
$ ls -l /Volumes/boot/extlinux
-rwxrwxrwx  749 extlinux.conf

## Linux Device Tree for SG2000
$ ls -l /Volumes/boot/fdt/linux-image-duos-5.10.4-20240329-1+
-rwxrwxrwx  21575 cv181x_milkv_duos_sd.dtb
```

We peek at the __U-Boot Bootloader Config__...

```bash
$ cat /Volumes/boot/extlinux/extlinux.conf
...
label l0
  menu label Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
  linux /vmlinuz-5.10.4-20240329-1+
  fdtdir /fdt/linux-image-duos-5.10.4-20240329-1+/
  append root=/dev/root console=ttyS0,115200 earlycon=sbi root=/dev/mmcblk0p2 rootwait rw
```

(With a tiny tweak, we can boot NuttX RTOS!)

TODO: Pic of OpenSBI

# Boot the Linux MicroSD

_Linux on MicroSD: Does it boot on Milk-V Duo S?_

Yep Linux boots OK on Milk-V Duo S!

First we see [__OpenSBI (Supervisor Binary Interface)__](TODO)...

```bash
OpenSBI v0.9
Platform Name       : Milk-V DuoS
Platform Features   : mfdeleg
Platform HART Count : 1
Platform Console Device : uart8250
Firmware Base       : 0x8000_0000
Firmware Size       : 132 KB
Runtime SBI Version : 0.3

Domain0 Region00 : 0x7400_0000-0x7400_ffff (I)
Domain0 Region01 : 0x8000_0000-0x8003_ffff ()
Domain0 Region02 : 0x0-0xffff_ffff_ffff_ffff (R,W,X)
Boot HART ISA      : rv64imafdcvsux
Boot HART Features : scounteren,mcounteren,time
Boot HART MIDELEG  : 0x0000000000000222
Boot HART MEDELEG  : 0x000000000000b109

## OpenSBI boots at 0x8000_0000.
## 0x7400_0000 looks interesting! We'll come back to this
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/01d409b7bde9607a96cd4d460e53330a)

Followed by the __U-Boot Bootloader__...

```bash
## U-Boot Boots
U-Boot 2021.10-ga57aa1f2-dirty (Apr 24 2024 - 11:24:46 +0000) cvitek_cv181x
Hit any key to stop autoboot:  0 
Scanning mmc 0:1...
Found /extlinux/extlinux.conf

## U-Boot Menu
1:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
2:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+ (rescue target)
Enter choice: 1

## U-Boot boots Debian Linux
Retrieving file: /vmlinuz-5.10.4-20240329-1+
Retrieving file: /fdt/linux-image-duos-5.10.4-20240329-1+/cv181x_milkv_duos_sd.dtb
Booting using the fdt blob at 0x81200000
```

Finally we see __Debian Linux__...

```bash
Starting kernel ...
Linux version 5.10.4-20240329-1+ (root@3abcc283c6ba) (riscv64-unknown-linux-musl-gcc (Xuantie-900 linux-5.10.4 musl gcc Toolchain V2.6.1 B-20220906) 10.2.0, GNU ld (GNU Binutils) 2.35)
...
Debian GNU/Linux trixie/sid duos ttyS0
duos login: 
```

TODO

# Settings for U-Boot Bootloader

TODO

Let's dump the U-Boot Config...

As we power on Milk-V Duo S, hit Enter a few times to see the __U-Boot Command Prompt__...

```bash
U-Boot 2021.10-ga57aa1f2-dirty (May 07 2024 - 08:13:12 +0000) cvitek_cv181x
Loading Environment from FAT... mmc1 : finished tuning, code:53
Hit any key to stop autoboot:  0
cv181x_c906# 
```

Enter __`printenv`__ to dump the U-Boot Settings...

```bash
$ printenv
fdt_addr_r=0x81200000
fdtoverlay_addr_r=0x81300000
kernel_addr_r=0x80200000
kernel_comp_addr_r=0x81800000
kernel_comp_size=0x1000000
ramdisk_addr_r=0x84000000
uImage_addr=0x81800000
update_addr=0x9fe00000
```

[(See the __U-Boot Settings__)](https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L189-L246)

__`kernel_addr_r`__ says that U-Boot will load Linux Kernel into RAM at Address __`0x8020_0000`__. (We'll set this in NuttX)

And the __Ethernet Driver__ is fully operational in U-Boot. Which means we can boot __NuttX over the Network__ yay! (TFTP)

```bash
$ net list
eth0: ethernet@4070000
00:00:00:00:00:00
active
```

[(See the __U-Boot Commands__)](https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L99-L188)

TODO: Pic of TFTP

# Boot NuttX over TFTP 

_What's the quickest way to port NuttX?_

Like Linux, we could __copy NuttX to MicroSD__, insert into Milk-V Duo S and power up. Again and again and again...

But there's a quicker way: Boot __NuttX over the Network__, thanks to U-Boot Bootloader and TFTP! (Trivial File Transfer Protocol)

- [__"Configure U-Boot for TFTP"__](https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp)

At the __U-Boot Command Prompt__: We configure our __TFTP Server__...

```bash
## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## If Initial RAM Disk is needed (like for Linux, not for NuttX)...
## Set the RAM Disk Size (assume the max)
## setenv ramdisk_size 0x1000000

## Save the U-Boot Config for future reboots
saveenv
```

Then we load the __NuttX Image__ into RAM over TFTP...

```bash
## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x80200000
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Load the Device Tree from TFTP Server
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
fdt addr ${fdt_addr_r}

## If Initial RAM Disk is needed...
## Load the Intial RAM Disk from TFTP Server
## ramdisk_addr_r=0x81600000
## tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd
```

And we boot __NuttX from RAM__...

```bash
## Boot the NuttX Image with the Device Tree
## kernel_addr_r=0x80200000
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}

## For Linux: We need the RAM Disk Address
## ramdisk_addr_r=0x81600000
## ramdisk_size=0x1000000
## booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
```

Or mashed up in a single line...

```bash
## Boot NuttX Image over TFTP
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}
```

_What happens when we boot NuttX?_

Absolutely nothing!

```bash
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9e27f000, end 9f27f000 ... OK
Loading Device Tree to 000000009e26f000, end 000000009e27e43a ... OK
Starting kernel ...
```

But that's OK, we haven't modified NuttX Kernel for SG2000. Let's print something in the next section.

_We type these commands EVERY TIME we boot?_

We can automate this! Just do this once, and __NuttX will Auto-Boot__ whenever we power up...

```bash
## Add the Boot Command for TFTP
setenv bootcmd_tftp 'dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}'

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Targets
setenv orig_boot_targets "$boot_targets"

## Prepend TFTP to the Boot Targets
setenv boot_targets "tftp $boot_targets"

## Save it for future reboots
saveenv
```

# UART Controller for SG2000

_How will NuttX print to the Serial Console?_

First we track down the __UART Controller__ for SG2000.

From [__SG2000 Reference Manual__](https://github.com/sophgo/sophgo-doc/releases) (Page TODO): The UART Controller is at these Base Addresses...

| UART Module | Base Address |
|:-----------:|:------------:|
| UART0 | `0x0414_0000` |
| UART1 | `0x0415_0000` |
| UART2 | `0x0416_0000` |
| UART3 | `0x0417_0000` |
| UART4 | `0x041C_0000` |
| RTCSYS_UART | `0x0502_2000` |

We'll print to UART0 in NuttX: `0x0414_0000`

_What UART Controller is inside SG2000?_

According to [__OpenSBI Log__](TODO): The UART Controller is __`uart8250`__.

Which is supported by NuttX yay! We mod the NuttX Boot Code to print something...

# Print to UART in RISC-V Assembly

_We're printing in RISC-V Assembly? Why not C?_

That's because the very first thing that boots is the NuttX Boot Code in __RISC-V Assembly__. Which we'll modify like this...

- [__"Print to QEMU Console"__](https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console)

SG2000 UART0 Controller is at __`0x0414_0000`__ (previous section). To print something, we write to the __UART Output Register__ at that address: [bl808_head.S](https://github.com/lupyuen2/wip-nuttx/blob/sg2000/arch/risc-v/src/bl808/bl808_head.S#L70-L89)

```c
/* RISC-V Boot Code for Apache NuttX RTOS */
real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x04140000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)
```

Our code will print "__`123`__" when NuttX boots. We test this...

# NuttX Boots A Tiny Bit

TODO

Follow these steps to build (work-in-progress) Apache NuttX RTOS for SG2000 and Milk-V Duo S...

TODO

This produces the NuttX Image file: __`Image`__. Which we copy to our __TFTP Server__...

```bash
## Copy NuttX Image to TFTP Server
## TODO: Change `tftpserver` and `tftpboot` to our TFTP Server and Path
scp Image tftpserver:/tftpboot/Image-sg2000
```

To boot NuttX: We run these commands at the __U-Boot Command Prompt__...

```bash
## Load NuttX Image into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
123
```

NuttX boots a tiny bit, and prints "__`123`__" yay!

Our NuttX Boot Code is actually running on SG2000 and Milk-V Duo S!

[(See the __Complete Log__)](https://gist.github.com/lupyuen/78b54326daf0894a2c23ab6d2c03456d)

TODO: Pic of NuttX Kernel

# NuttX Kernel Boots OK

_NuttX Kernel prints "123". What about the rest?_

More mods for __NuttX Kernel__!

1.  We set the [__NuttX Memory Map__](TODO) for SG2000: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    ## Kernel RAM
    CONFIG_RAM_START=0x80200000
    CONFIG_RAM_SIZE=1048576
    ```

    [(Explained here)](TODO)

1.  Also the [__NuttX Linker Script__](TODO): [ld.script](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37)

    ```c
    MEMORY {
      kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
      ...
    SECTIONS {
      . = 0x80200000;
    ```

    [(Explained here)](TODO)

1.  We select the [__NuttX Driver for 16550 UART__](TODO): [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    CONFIG_16550_REGINCR=4
    CONFIG_16550_UART0=y
    CONFIG_16550_UART0_BASE=0x04140000
    CONFIG_16550_UART0_SERIAL_CONSOLE=y
    CONFIG_16550_UART=y
    CONFIG_16550_WAIT_LCR=y
    CONFIG_SERIAL_UART_ARCH_MMIO=y
    ```

    [(Explained here)](TODO)

1.  Enable Logging for [__NuttX Scheduler and Binary Loader__](TODO): [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    CONFIG_DEBUG_BINFMT=y
    CONFIG_DEBUG_BINFMT_ERROR=y
    CONFIG_DEBUG_BINFMT_WARN=y
    CONFIG_DEBUG_SCHED=y
    CONFIG_DEBUG_SCHED_ERROR=y
    CONFIG_DEBUG_SCHED_INFO=y
    CONFIG_DEBUG_SCHED_WARN=y
    ```

    [(Explained here)](TODO)

1.  And disable the [__PLIC Interrupt Controller__](TODO) (until we figure it out)

    [(Explained here)](TODO)

NuttX Kernel boots OK on SG2000 yay!

```bash
## Load NuttX Image into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x80409140
nxtask_exit: AppBringUp pid=2,TCB=0x80408740
```

One last thing and we're done...

[(See the __Complete Log__)](https://gist.github.com/lupyuen/aaa0a6646490d45e5cd99b781cbe59f8)

[(Watch the __Demo on YouTube__)](https://www.youtube.com/watch?v=pPNDiC5NLqM)

TODO: Pic of NuttX Shell

# NuttX Shell Too!

_But where's the NuttX Shell?_

We won't see the NuttX Shell until we fix the __Interrupt Controller__ for SG2000. Which is NOT documented!

That's because NuttX Shell requires [__UART Input Interrupts__](TODO) AND [__UART Output Interrupts__](TODO), to operate properly.

Let's sniff around and find out how the Interrupt Controller works...

1.  We dumped the [__Linux Device Tree__](TODO) for SG2000...

    ```bash
    ## Convert the SG2000 Device Tree
    dtc \
      -o cv181x_milkv_duos_sd.dts \
      -O dts \
      -I dtb \
      cv181x_milkv_duos_sd.dtb
    ```

    [(Explained here)](TODO)

1.  Snooped the [__PLIC Interrupt Controller__](TODO) in the Device Tree: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

    ```c
    interrupt-controller@70000000 {
      riscv,ndev = <0x65>;
      riscv,max-priority = <0x07>;
      reg-names = "control";
      reg = <0x00 0x70000000 0x00 0x4000000>;
      interrupts-extended = <0x16 0xffffffff 0x16 0x09>;
      interrupt-controller;
      compatible = "riscv,plic0";
    ```

    [(Explained here)](TODO)

1.  And fixed the [__NuttX Driver__](TODO) for PLIC Interrupts: [bl808_memorymap.h](https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6#diff-8fffa570a48f8f10004d9da8d4c671d34336f6c4b8dcfc2bd72275d8cda4ac04)

    ```c
    // Base Address of PLIC Interrupt Controller
    #define BL808_PLIC_BASE 0x70000000ul
    ```

    [(Explained here)](TODO)

After fixing the Interrupt Controller and UART Interrupt: NuttX Kernel now boots all the way to __NuttX Shell__ yay!

```bash
## Load NuttX Image into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
NuttShell (NSH) NuttX-12.4.0

nsh> uname -a
NuttX 12.4.0 122c717 May  8 2024 18:13:30 risc-v ox64

nsh> ls
/:
 dev/
 proc/
 system/

nsh> ls /dev
/dev:
 console
 null
 ram0
 ttyS0
 zero
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/b778986ba87c18067cd993b92c673634)

TODO: NuttX OSTest works great too!

[(See the __Complete Log__)](https://gist.github.com/lupyuen/fff5242cf77a3f52d81f3effb9aa402f)

TODO: Pic of Milk-V Duo S Box

# What's Next

TODO

Up Next...

1.  We'll upstream SG2000 to NuttX Mainline

1.  Create an SG2000 Emulator for easier testing

    (Similar to TinyEMU for Ox64)

1.  Someday we might run NuttX on the SG2000 Co-Processor!

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) (and the awesome NuttX Community) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__My Current Project: "Apache NuttX RTOS for Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64)

-   [__My Other Project: "NuttX for Star64 JH7110"__](https://github.com/lupyuen/nuttx-star64)

-   [__Older Project: "NuttX for PinePhone"__](https://github.com/lupyuen/pinephone-nuttx)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/sg2000.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000.md)

# Appendix: Build NuttX for SG2000

In this article we took NuttX for [__Ox64 BL808 RISC-V SBC__](TODO). Then made a few tweaks, and it boots on SG2000 and Milk-V Duo S!

TODO

Follow these steps to build (work-in-progress) Apache NuttX RTOS for __SG2000 and Milk-V Duo S__...

```bash
## TODO: Set PATH
export PATH="$HOME/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-apple-darwin/bin:$PATH"

set -e  #  Exit when any command fails
set -x  #  Echo commands

## Build NuttX
function build_nuttx {

  ## Go to NuttX Folder
  pushd ../nuttx

  ## Build NuttX
  make -j 8

  ## Return to previous folder
  popd
}

## Build Apps Filesystem
function build_apps {

  ## Go to NuttX Folder
  pushd ../nuttx

  ## Build Apps Filesystem
  make -j 8 export
  pushd ../apps
  ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
  make -j 8 import
  popd

  ## Return to previous folder
  popd
}

## Download WIP NuttX for SG2000 (based on Ox64 BL808)
git clone --branch sg2000 \
  https://github.com/lupyuen2/wip-nuttx \
  nuttx
git clone --branch sg2000 \
  https://github.com/lupyuen2/wip-nuttx-apps \
  apps
cd nuttx

## Pull updates
git pull && git status && hash1=`git rev-parse HEAD`
pushd ../apps
git pull && git status && hash2=`git rev-parse HEAD`
popd
echo NuttX Source: https://github.com/apache/nuttx/tree/$hash1 >nuttx.hash
echo NuttX Apps: https://github.com/apache/nuttx-apps/tree/$hash2 >>nuttx.hash

## Show the version of GCC
riscv64-unknown-elf-gcc -v

## Configure build
tools/configure.sh ox64:nsh

## Build NuttX
build_nuttx

## Build Apps Filesystem
build_apps

## Generate Initial RAM Disk
genromfs -f initrd -d ../apps/bin -V "NuttXBootVol"

## Show the size
riscv64-unknown-elf-size nuttx

## Export the Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero >/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  >Image

## Copy the config
cp .config nuttx.config

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  >nuttx.S \
  2>&1

## Dump the init disassembly to init.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/init \
  >init.S \
  2>&1

## Dump the hello disassembly to hello.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello \
  >hello.S \
  2>&1

## Copy NuttX Image to TFTP Server
scp Image tftpserver:/tftpboot/Image-sg2000
ssh tftpserver ls -l /tftpboot/Image-sg2000
```

We have copied the NuttX Image to our TFTP Server. Let's boot this on Milk-V Duo S...

TODO

# Appendix: Port NuttX to SG2000

_How did we port NuttX to SG2000?_

We started with NuttX for [__Ox64 BL808 RISC-V SBC__](TODO). Then made a few tweaks, and it boots on SG2000 and Milk-V Duo S!

This chapter explains the minor tweaks that we made.

_Why did we start with NuttX for Ox64?_

That's because Ox64 BL808 runs on the same RISC-V Core as SG2000: [__T-Head C906__](TODO).

_What about the T-Head Extensions for C906?_

Yep we copied (unchanged) the __T-Head Extensions for C906__ from Ox64 BL808 to SG2000. And they work hunky dory on SG2000...

TODO: Cache, VM

Let's talk about the tweaks...

## NuttX Memory Map

From [__U-Boot Bootloader Settings__](TODO): We see that SG2000 boots at this address...

```bash
kernel_addr_r=0x80200000
```

Thus we define the __NuttX Memory Map__ for SG2000 like so...

- [__Set the NuttX Memory Map for SG2000__](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2)

NuttX Kernel will boot at __`0x8020_0000`__, NuttX Apps will run at Virtual Address __`0xC000_0000`__.

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
## Kernel RAM
CONFIG_RAM_START=0x80200000
CONFIG_RAM_SIZE=1048576

## Kernel Paged Pool (Allocated to NuttX Apps)
CONFIG_ARCH_PGPOOL_PBASE=0x80600000
CONFIG_ARCH_PGPOOL_VBASE=0x80600000
CONFIG_ARCH_PGPOOL_SIZE=4194304

## Virtual Memory for NuttX App Code
CONFIG_ARCH_TEXT_VBASE=0xC0000000
CONFIG_ARCH_TEXT_NPAGES=128

## Virtual Memory for NuttX App Data
CONFIG_ARCH_DATA_VBASE=0xC0100000
CONFIG_ARCH_DATA_NPAGES=128

## Virtual Memory for NuttX App Heap
CONFIG_ARCH_HEAP_VBASE=0xC0200000
CONFIG_ARCH_HEAP_NPAGES=128
```

And here's the __NuttX Linker Script__: [ld.script](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37)

```c
MEMORY {
  kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
  ksram (rwx) : ORIGIN = 0x80400000, LENGTH = 2048K   /* w/ cache */
  pgram (rwx) : ORIGIN = 0x80600000, LENGTH = 4096K   /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x80A00000, LENGTH = 16M   /* w/ cache */
}
...
SECTIONS {
  . = 0x80200000;
```

## Disable Interrupt Controller

Most RISC-V SBCs (Ox64, Star64) will manage Interrupts with a [__Platform-Level Interrupt Controller (PLIC)__](TODO). But PLIC isn't documented for SG2000.

For now, let's disable PLIC in NuttX...

- [__Disable the PLIC Interrupt Controller__](https://github.com/lupyuen2/wip-nuttx/commit/6d66caa1408d7a7d7b21b0e876ce32ceb5b93ec4)

Later we'll dump the SG2000 Linux Device Tree to understand the Interrupt Controller.

## Select the 16550 UART Driver

From [__OpenSBI Log__](TODO): We see that SG2000 operates with a __8250 UART Controller__.

Thus we select the NuttX Driver for __16550 UART__, which is compatible with 8250...

- [__Select the NuttX Driver for 16550 UART__](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec)

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x04140000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y
```

Don't update the NuttX Config File directly! We ran __`make menuconfig`__ to generate the above file...

```bash
## Update NuttX Config
make menuconfig \
  && make savedefconfig \
  && grep -v CONFIG_HOST defconfig \
  >boards/risc-v/bl808/ox64/configs/nsh/defconfig
```

To find the menuconfig settings: Press "__`/`__" and enter the name of the setting, like "16550_ADDRWIDTH". This ensures that the Kconfig Dependencies are correctly updated.

_How did we get IRQ 69 for UART?_

We set IRQ 69 for UART0...

- [__Set UART0 IRQ to 69 (25 + 44)__](https://github.com/lupyuen2/wip-nuttx/commit/122c717447f81c310a4fb082101213ad338dfb0e)

  ```bash
  CONFIG_16550_UART0_IRQ=69
  ```

That's because the [__SG2000 Reference Manual__](https://github.com/sophgo/sophgo-doc/releases) (Page TODO) says...

> 3.1 Interrupt Subsystem

> Table 3.2: Interrupt number and Interrupt source mapping for Master RISCV C906 @ 1.0Ghz

> Int #44: UART0

__Linux Device Tree__ also says UART0 IRQ is 44 (`0x2C`)

```c
serial@04140000 {
  compatible = "snps,dw-apb-uart";
  reg = <0x00 0x4140000 0x00 0x1000>;
  clock-frequency = <0x17d7840>;
  reg-shift = <0x02>;
  reg-io-width = <0x04>;
  status = "okay";
  interrupts = <0x2c 0x04>;
  interrupt-parent = <0x04>;
};
```

Thus we compute [NuttX IRQ](https://lupyuen.github.io/articles/plic2#uart-interrupt) = 25 + RISC-V IRQ = 69

TODO: Fix the UART Clock: __16550_UART0_CLOCK__

## Enable Logging for Scheduler

For easier troubleshooting: We enable Logging for __NuttX Scheduler and Binary Loader__...

- [__Enable Logging for Scheduler and Binary Loader__](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47)

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
CONFIG_DEBUG_BINFMT=y
CONFIG_DEBUG_BINFMT_ERROR=y
CONFIG_DEBUG_BINFMT_WARN=y
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y
```

Remember: Always use __`make menuconfig`__ to update the settings!

## Dump the Linux Device Tree

To understand the Interrupt Controller: Let's dump the __Linux Device Tree__ for SG2000.

From the SG2000 Debian Release, thanks to [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Images for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

We copy out the SG2000 __Device Tree Binary__: [cv181x_milkv_duos_sd.dtb](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dtb)

And convert it to __Device Tree Source__: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

```bash
## Convert the SG2000 Device Tree
dtc \
  -o cv181x_milkv_duos_sd.dts \
  -O dts \
  -I dtb \
  cv181x_milkv_duos_sd.dtb
```

We look inside...

## Interrupt Controller for SG2000

Earlier we dumped the __Linux Device Tree__ for SG2000. Let's snoop the Interrupt Controller to understand it.

Based on the __SG2000 Device Tree__: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

```c
cpus {
  #address-cells = <0x01>;
  #size-cells = <0x00>;
  timebase-frequency = <0x17d7840>;

  cpu-map {
    cluster0 {
      core0 {
        cpu = <0x01>;
      };
    };
  };

  cpu@0 {
    device_type = "cpu";
    reg = <0x00>;
    status = "okay";
    compatible = "riscv";
    riscv,isa = "rv64imafdvcsu";
    mmu-type = "riscv,sv39";
    clock-frequency = <0x17d7840>;

    interrupt-controller {
      #interrupt-cells = <0x01>;
      interrupt-controller;
      compatible = "riscv,cpu-intc";
      phandle = <0x16>;
    };
  };
};

soc {
  #address-cells = <0x02>;
  #size-cells = <0x02>;
  compatible = "simple-bus";
  ranges;

  interrupt-controller@70000000 {
    riscv,ndev = <0x65>;
    riscv,max-priority = <0x07>;
    reg-names = "control";
    reg = <0x00 0x70000000 0x00 0x4000000>;
    interrupts-extended = <0x16 0xffffffff 0x16 0x09>;
    interrupt-controller;
    compatible = "riscv,plic0";
    #interrupt-cells = <0x02>;
    #address-cells = <0x00>;
    phandle = <0x04>;
  };

  clint@74000000 {
    interrupts-extended = <0x16 0x03 0x16 0x07>;
    reg = <0x00 0x74000000 0x00 0x10000>;
    compatible = "riscv,clint0";
    clint,has-no-64bit-mmio;
  };
};
```

We see that PLIC is at __`0x7000_0000`__, CLINT at __`0x7400_0000`__. Let's implement this in NuttX...

## Fix the NuttX Driver for PLIC

Based on the SG2000 PLIC Address from above: We fix the __PLIC Interrupt Controller__ for SG2000...

- [__Fix the PLIC Interrupt Controller for SG2000__](https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6)

Now we see a bit more NuttX...

```text
Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80409130
nxtask_activate: AppBringUp pid=2,TCB=0x80409740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x8040b730
nxtask_exit: AppBringUp pid=2,TCB=0x80409740

Nuttnx_start: CPU0: Beginning Idle Loop
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/922e6379375fbc5d775d1e83cac4deb5)

_Why did it stop?_

Duh we set the wrong UART0 IRQ! Here's the fix...

[Set UART0 IRQ to 69 (25 + 44)](https://github.com/lupyuen2/wip-nuttx/commit/122c717447f81c310a4fb082101213ad338dfb0e)

```bash
CONFIG_16550_UART0_IRQ=69
```

_How did we get IRQ 69 for UART?_

We saw this in the [SG2000 Reference Manual](https://github.com/sophgo/sophgo-doc/releases)...

> 3.1 Interrupt Subsystem

> Table 3.2: Interrupt number and Interrupt source mapping for Master RISCV C906 @ 1.0Ghz

> Int #44: UART0

Linx Device Tree also says UART0 IRQ is 44 (0x2C)...

```c
serial@04140000 {
  compatible = "snps,dw-apb-uart";
  reg = <0x00 0x4140000 0x00 0x1000>;
  clock-frequency = <0x17d7840>;
  reg-shift = <0x02>;
  reg-io-width = <0x04>;
  status = "okay";
  interrupts = <0x2c 0x04>;
  interrupt-parent = <0x04>;
};
```

Thus we compute [NuttX IRQ](https://lupyuen.github.io/articles/plic2#uart-interrupt) = 25 + RISC-V IRQ = 69

## NuttX Crash Dump

TODO

We apply the fixes above. Now NuttX boots some more on RISC-V SG2000 SoC / Milk-V Duo S. And shows our very first NuttX Crash Dump yay!

```bash
Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9fe00000, end 9fe00000 ... OK
Loading Device Tree to 000000009f26f000, end 000000009f27e43a ... OK
Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3

_assert: Current Version: NuttX  12.4.0 f37a380-dirty May  7 2024 10:31:33 risc-v
_assert: Assertion failed 0x17 == (insn & 0x7F): at file: machine/risc-v/arch_elf.c:494 task: AppBringUp process: Kernel 0x80200f34
up_dump_register: EPC: 000000008021087a
up_dump_register: A0: 0000000080401b70 A1: 00000000000001ee A2: 0000000080228ef8 A3: 0000000000000000
up_dump_register: A4: 0000000000000017 A5: 0000000000000002 A6: 000000000000ab9c A7: fffffffffffffff8
up_dump_register: T0: 000000000000002e T1: 0000000000000007 T2: 00000000000001ff T3: 000000008040c3fc
up_dump_register: T4: 000000008040c3f0 T5: 0000000000000009 T6: 000000000000002a
up_dump_register: S0: 0000000000000000 S1: 0000000080408740 S2: 0000000000000017 S3: 0000000000000000
up_dump_register: S4: 0000000080228ef8 S5: 0000000080228de8 S6: 0000000080401e10 S7: 8000000201842022
up_dump_register: S8: 00000000000001ee S9: 000000008040b9a0 S10: 0000000000000070 S11: 000000008040b990
up_dump_register: SP: 000000008040c330 FP: 0000000000000000 TP: 0000000000000000 RA: 000000008021087a
dump_stack: User Stack:
dump_stack:   base: 0x8040c030
dump_stack:   size: 00002000
dump_stack:     sp: 0x8040c330
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/594f0df20d39001bac171412d594d517)

_What's this Assertion Failure?_

```bash
_assert: Assertion failed 0x17 == (insn & 0x7F):
at file: machine/risc-v/arch_elf.c:494
task: AppBringUp process: Kernel 0x80200f34
```

Oops we goofed and used the wrong U-Boot Command...

```bash
## Nope! This won't work for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ;
booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
```

Which overwrites the NuttX Image in RAM. Watch what happens when we use the correct U-Boot Command...

```bash
## This works OK for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; 
booti ${kernel_addr_r} - ${fdt_addr_r}
```

NuttX now boots correctly yay!

TODO
