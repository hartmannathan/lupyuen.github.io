# Ox64 BL808 RISC-V SBC: Booting Linux and (maybe) Apache NuttX RTOS

üìù _5 Nov 2023_

![Booting Linux on Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)](https://lupyuen.github.io/images/ox64-title.jpg)

[(Also on __hackster.io__)](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358)

[(Watch the __Demo on YouTube__)](https://youtu.be/UJ_7DyHnfDA)

_What's this BL808?_ [(Datasheet)](https://github.com/bouffalolab/bl_docs/blob/main/BL808_DS/en/BL808_DS_1.2_en.pdf) [(Reference Manual)](https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf)

[__Bouffalo Lab BL808 SoC__](https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf) is a curiously complex creature with __3 (Asymmetric) RISC-V Cores__ (pic below)...

1.  __D0 Core:__ [__64-bit T-Head C906__](https://www.t-head.cn/product/c906?lang=en) (RV64IMAFCV, 480 MHz)

    __Multimedia Core__ with MIPI CSI / DSI, Neural Processing Unit

    __Memory Management Unit__ is Sv39 with 128 / 256 / 512 TLB table entries. (Like Star64)

1.  __M0 Core:__ [__32-bit T-Head E907__](https://www.t-head.cn/product/e907?lang=en) (RV32IMAFCP, 320 MHz)

    __Wireless + Peripherals Core__ with WiFi, Bluetooth LE, Zigbee, Audio, USB, Ethernet

1.  __Low Power Core:__ [__32-bit T-Head E902__](https://www.t-head.cn/product/e902?lang=en) (RV32E\[M\]C, 150 MHz)

    [(__Upcoming BL606__ is similar, minus the Low Power Core)](https://en.bouffalolab.com/product/?type=detail&id=16)

![Bouffalo Lab BL808 is a complex creature with 3 (Asymmetric) RISC-V Cores](https://lupyuen.github.io/images/ox64-cores.jpg)

[__Pine64 Ox64 (128Mb)__](https://pine64.org/documentation/Ox64/) is the development board for BL808C. (Pic below)

__BL808C__ supports MIPI CSI Cameras but not MIPI DSI Displays.

(Maybe someday we'll see BL808D for MIPI DSI Displays)

_Is Ox64 an SBC? Or an MCU Board?_

Technically Ox64 boots __64-bit RISC-V Linux__ (via microSD). Thus Ox64 feels like a __RISC-V SBC__...

- [__Linux Image + OpenSBI + U-Boot Bootloader__](https://github.com/openbouffalo/buildroot_bouffalo) for BL808

  [(__OpenSBI__ is the "BIOS" for RISC-V SBCs)](https://lupyuen.github.io/articles/sbi)

- With USB-C Port for __Camera Module__ (Dual-Lane MIPI CSI)

  (USB-C is not for Flashing!)

- And USB 2.0 support for __USB OTG__

  (OTG "On-The-Go" means USB Host + USB Device)

- UART Pins need a __USB Serial Adapter__ for Flashing and Console I/O

But Ox64 also feels like an __MCU Board__...

- __Form Factor__ is similar to an MCU Board (pic below)

- __Limited Memory:__ 64 MB of RAM, 16 MB of Flash Memory

- M0 Wireless Core is __32-bit RISC-V MCU__

- Powered by __Micro USB Port__

  (Micro USB is not for Flashing either!)

- __Super Affordable:__ [__Only $8__](https://pine64.com/product/128mb-ox64-sbc-available-on-december-2-2022/) for a 64-bit RISC-V Board!

![Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)](https://lupyuen.github.io/images/ox64-sbc.jpg)

_Ox64 BL808 sounds a little tiny for 64-bit Linux?_

Yeah 64-bit Linux runs with __Limited RAM__ on the D0 Multimedia Core. But most Peripherals are hosted on the M0 Wireless Core: __WiFi, BLE, BT, Zigbee, Ethernet, USB, Audio, ...__

So we flash M0 Wireless Core with a simple 32-bit RISC-V Firmware, to __forward the Peripheral Interrupts__ from M0 to D0 Linux.

Perhaps Ox64 might run more efficiently with a __tiny 64-bit RTOS__?  (Real-Time Operating System)

_Why Apache NuttX RTOS?_

It might be interesting to run the tiny [__Apache NuttX RTOS__](https://nuttx.apache.org/docs/latest/) on both the D0 Multimedia Core and the M0 Wireless Core.

Then D0 and M0 can talk over [__OpenAMP__](https://www.openampproject.org/). (Asymmetric Multi-Processing)

In this article we begin with Linux, then explore NuttX...

__NOTE:__ The steps here will work only with the [__128Mb (64KB) Version of Ox64__](https://pine64.com/product/128mb-ox64-sbc-available-on-december-2-2022/), not the 16Mb Version that doesn't support microSD

![Flashing UART vs Serial Console](https://lupyuen.github.io/images/ox64-pinout.jpg)

# Flashing UART vs Serial Console

_We need to connect TWO UART Ports on Ox64? (Pic above)_

Yeah don't confuse the __2 UART Ports__ that we'll connect on Ox64!

Let's give the 2 UART Ports distinctive names [(like Migi & Dali)](https://en.wikipedia.org/wiki/Migi_%26_Dali)...

1.  __Ox64 Flashing UART__: Used for Flashing Ox64

    | USB Serial | Ox64 Pin |                |
    |:----------:|:--------:|:---------------|
    | __RX__  | __`GPIO 14`__ _(TX)_ | Pin 1 |
    | __TX__  | __`GPIO 15`__ _(RX)_ | Pin 2 |
    | __GND__ | __`GND`__ | Pin 3 |

    __Baud Rates__ are...

    |               |                      |
    |:--------------|:---------------------|
    | __Normal Mode:__   | 2,000,000 (2 Mbps)   |
    | __Flashing Mode:__ | 230,400 (230.4 kbps) <br> |
    | &nbsp;

    __BL808 UART0__ is controlled by the M0 Wireless Core. (OpenBouffalo Firmware)

1.  __Ox64 Serial Console__: Used for Linux Serial Console. (Plus OpenSBI and U-Boot Bootloader)

    | USB Serial | Ox64 Pin |                |
    |:----------:|:--------:|:---------------|
    | __RX__  | __`GPIO 16`__ _(TX)_ | Pin 32 |
    | __TX__  | __`GPIO 17`__ _(RX)_ | Pin 31 |
    | __GND__ | __`GND`__ | Pin 33 |

    __Baud Rate:__ 2,000,000 (2 Mbps)

    __BL808 UART3__ is controlled by the D0 Multimedia Core. (Linux + OpenSBI + U-Boot)

    __Output is totally blank__ if OpenBouffalo Firmware [__wasn't flashed correctly__](https://github.com/openbouffalo/buildroot_bouffalo/issues/60). Or if OpenSBI / U-Boot couldn't boot.

__NEITHER UART Port__ is accessible over USB-C or Micro USB. So yeah it's totally counterintuitive.

(Maybe someone can create a Stackable Shield or Breadboard, that will __expose the 2 UART Ports__ as USB Dongles? Or a UART Switcher?)

[(__For Pre-Production Ox64:__ Physical Pins are different, but GPIOs above are correct)](https://lupyuen.github.io/images/ox64-sd.jpg)

_Why 2 Baud Rates for Flashing UART?_

When we power up Ox64 in __Normal Mode__: (Boot Button NOT pressed)

- The port for Flashing UART will show us the __OpenBouffalo Firmware__ running on M0 Wireless Core

- This M0 Firmware will forward __Peripheral Interrupts__ to D0 Multimedia Core

- M0 Firmware is hardcoded for __2 Mbps__

- Not really fun to watch. But we use this for testing our 2 Mbps USB Serial Adapter.

When we power up Ox64 in __Flashing Mode__: (Boot Button pressed)

- Ox64 is ready for __Firmware Flashing__ by the BL DevCube GUI Tool

- Firmware Flashing supports __various Baud Rates__: 230.4 kbps, 2 Mbps, ...

- But 2 Mbps will [__fail on macOS__](https://gist.github.com/lupyuen/0fde950460cffed37c3c78ce79beca9c#file-ox64-bldevcube-fail-1-8-3-log-L94-L114). That's why we Flash Firmware at __230.4 kbps__.

  [(Same problem when flashing BL602)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

_Serial Console is always 2 Mbps?_

Yeah __2 Mbps is hardcoded__ in Ox64 Linux. Switching to other Baud Rates will show garbled text.

Thus our USB Serial Adapter must __connect reliably to Ox64__ at 2 Mbps. Let's test it...

![Flashing UART](https://lupyuen.github.io/images/ox64-pinout2.jpg)

# Test the USB Serial Adapter

__Warning:__ Some USB Serial Adapters [__WON'T WORK!__](https://pine64.org/documentation/Ox64/Further_information/Compatible_UARTs/)

Ox64 was tested OK with the [__Pine64 Woodpecker CH340G__](https://pine64.com/product/serial-console-woodpecker-edition/) USB Serial Adapter on macOS x64.

Ox64 mandates 2 Mbps, which might be too fast for some USB Serial Adapters. (Like this [__CP2102 Dongle__](https://www.lazada.sg/products/i2037772272-s11135131253.html), which shows garbled text at 2 Mbps)

To test our USB Serial Adapter...

1.  Connect the __USB Serial Adapter__ to the port for __Ox64 Flashing UART__ (pic above)...

    | USB Serial | Ox64 Pin |                |
    |:----------:|:--------:|:---------------|
    | __RX__  | __`GPIO 14`__ _(TX)_ | Pin 1 |
    | __TX__  | __`GPIO 15`__ _(RX)_ | Pin 2 |
    | __GND__ | __`GND`__ | Pin 3 |

1.  Start the __USB Serial Terminal__ for __Flashing UART__. Use "[__putty__](https://www.putty.org/)" (Windows), "[__screen__](https://www.makeuseof.com/connect-to-serial-consoles-on-linux/)" (Linux) or "[__minicom__](https://www.makeuseof.com/connect-to-serial-consoles-on-linux/)" (Linux).

    Connect at __2,000,000 bps__. (2 Mbps)

    ```bash
    sudo screen /dev/ttyUSB0 2000000
    ```

    __For macOS:__ The "[__screen__](https://lupyuen.github.io/articles/led#appendix-fix-bl602-demo-firmware-for-macos)" command might not support 2 Mbps. Use [__CoolTerm__](https://freeware.the-meiers.org/) instead.

1.  Power up Ox64 via the __Micro USB Port__. Ox64 Green LED should light up.

    [(Or connect __USB Serial 3V3__ to __Pin 40 VBUS__)](https://wiki.pine64.org/wiki/File:Ox64_pinout.png)

    This Clickety Micro USB Cable is very handy for rebooting Ox64...

    ![Clickety Micro USB Cable](https://lupyuen.github.io/images/ox64-usb.jpg)

1.  We should see the __Ox64 Factory Test Firmware__...

    ```text
    dynamic memory init success
    sig1:ffff32ff
    sig2:0000ffff
    Pong!
    Ping!
    ```

    [(Source)](https://gist.github.com/lupyuen/7a55d7ad358b9ed01bf1e78c50b3d27c)

    __If the text appears garbled:__ Try a different USB Serial Adapter. [(Like these)](https://pine64.org/documentation/Ox64/Further_information/Compatible_UARTs/)

    [(__Pre-Production Ox64__ looks different)](https://gist.github.com/lupyuen/43676407bbced733e65566879e18732b)

1.  __Pre-Flash Check:__ Set Ox64 to __Flashing Mode__...

    + Remove the microSD Card
    + Press and Hold the Boot Button
    + Unplug and replug the Micro USB Port
    + Release the Boot Button
    + Ox64 Green LED should turn on

    In the USB Serial Terminal, we should see something totally different...

    ```text
    .
    ```

Ox64 is ready for flashing!

[(__Paul S__ explains why some USB Serial Adapters won't work)](https://www.linkedin.com/feed/update/urn:li:activity:7125857280952037376?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A7125857280952037376%2C7125884844219281408%29&dashCommentUrn=urn%3Ali%3Afsd_comment%3A%287125884844219281408%2Curn%3Ali%3Aactivity%3A7125857280952037376%29)

# Flash OpenSBI and U-Boot

_Our USB Serial Adapter works great at 2 Mbps. What next?_

Before booting Linux on Ox64, we flash...

- [__m0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/m0_lowload) for M0 Wireless Core:

  Firmware that forwards __Peripheral Interrupts__ to the D0 Multimedia Core.

  [(Like __SD Card__ and __GPIO Interrupts__)](https://lupyuen.github.io/articles/ox64#appendix-peripheral-interrupts)

- [__d0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/d0_lowload) for D0 Multimedia Core:

  Basic Bootloader that loads __OpenSBI, U-Boot Bootloader__ and Device Tree into RAM.

- [__bl808-firmware__](https://github.com/openbouffalo/buildroot_bouffalo) for D0 Multimedia Core:

  Binary Image for __OpenSBI, U-Boot Bootloader__ and Device Tree.

  [(__OpenSBI__ is the "BIOS" for RISC-V SBCs)](https://lupyuen.github.io/articles/sbi)

![Flashing UART](https://lupyuen.github.io/images/ox64-pinout2.jpg)

Here are the steps, based on the [__Official Flashing Instructions__](https://github.com/openbouffalo/buildroot_bouffalo#flashing-instructions)...

1.  Check that our __USB Serial Adapter__ is connected to the port for __Flashing UART__. (Pic above)

    Close the __USB Serial Terminal__. (To release the Flashing UART)

1.  Set Ox64 to __Flashing Mode__...

    + Remove the microSD Card
    + Press and Hold the Boot Button
    + Unplug and replug the Micro USB Port
    + Release the Boot Button
    + Ox64 Green LED should turn on

1.  Download the __Ox64 Binaries__...

    - [bl808-linux-pine64_ox64_full_defconfig.tar.gz](https://github.com/openbouffalo/buildroot_bouffalo/releases/download/v1.0.1/bl808-linux-pine64_ox64_full_defconfig.tar.gz) 

    From the latest __Ox64 Linux Release__...

    - [openbouffalo/buildroot_bouffalo (Release v1.0.1)](https://github.com/openbouffalo/buildroot_bouffalo/releases/tag/v1.0.1)

    Unzip the download and we should see...

    ```bash
    $ ls -l firmware
       7340032  bl808-firmware.bin
         31360  d0_lowload_bl808_d0.bin
         65760  m0_lowload_bl808_m0.bin
      43859444  sdcard-pine64_ox64_full_defconfig.img.xz    
    ```

1.  We'll run __Bouffalo Lab DevCube__ for Flashing Ox64.

    Which supports __Ubuntu x64, macOS and Windows__ only.

    (How to flash BL808 on Arm64 SBCs and Pinebook Pro? Sigh. See [__bflb-iot-tool__ / __bflb-mcu-tool__](https://pine64.org/documentation/Ox64/Software/Flashing/#download_flashing_tools))

1.  Download __BL DevCube 1.8.3__ from...

    [openbouffalo.org/static-assets/bldevcube/BouffaloLabDevCube-v1.8.3.zip](https://openbouffalo.org/static-assets/bldevcube/BouffaloLabDevCube-v1.8.3.zip)

    (Because [__1.8.4 and later__](https://github.com/openbouffalo/buildroot_bouffalo/issues/60) won't work!)

1.  Start BL DevCube, select "__BL808__"

    ![Select BL808 in BL DevCube](https://lupyuen.github.io/images/ox64-flash1.png)

    We might need to __Grant Execute Permission__...

    ```bash
    cd BouffaloLabDevCube-v1.8.3
    chmod +x BLDevCube-macos-x86_64
    ./BLDevCube-macos-x86_64
    ```

1.  Click the "__MCU__" Tab

    ![Flash MCU in BL DevCube](https://lupyuen.github.io/images/ox64-flash2.jpg)

1.  Set the Firmware for __M0 Wireless Core__...

    |              |          |
    |:-------------|:---------|
    | __M0 Group:__ | __`group0`__ |
    | __Image Addr:__ | __`0x58000000`__ |
    | &nbsp;
    
    Select the download: <br>__`m0_lowload_bl808_m0.bin`__

1.  Set the Firmware for __D0 Multimedia Core__...

    |              |          |
    |:-------------|:---------|
    | __D0 Group:__ | __`group0`__ |
    | __Image Addr:__ | __`0x58100000`__ |
    | &nbsp;
    
    Select the download: <br>__`d0_lowload_bl808_d0.bin`__

1.  Set __UART Rate__ to __`230400`__ (230.4 kbps)

    Don't set to 2,000,000 (2 Mbps), it will [__fail on macOS__](https://gist.github.com/lupyuen/0fde950460cffed37c3c78ce79beca9c#file-ox64-bldevcube-fail-1-8-3-log-L94-L114)!

    [(Same problem when flashing BL602)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

1.  Click "__Create & Download__" and wait for it to complete

    ![Flash MCU Log](https://lupyuen.github.io/images/ox64-flash3.png)

    [(See the __MCU Flash Log__)](https://gist.github.com/lupyuen/125e15be5ed1e034bed33d16ed496d87)

1.  Click the "__IOT__" Tab

    ![Flash IoT in BL DevCube](https://lupyuen.github.io/images/ox64-flash4.jpg)

1.  Set the __Single Download Options__...

    Enable "__Single Download__"

    Set __Address__ to __`0x800000`__
    
    Select the download: <br>__`bl808-firmware.bin`__

1.  Set __UART Rate__ to __`230400`__ (230.4 kbps)

    Don't set to 2,000,000 (2 Mbps), it will fail on macOS!

    [(Same problem when flashing BL602)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

1.  Click "__Create & Download__" and wait for it to complete

    ![IoT Flash Log](https://lupyuen.github.io/images/ox64-flash5.png)

    [(See the __IoT Flash Log__)](https://gist.github.com/lupyuen/e8c0aca0ebd0f1eae034b0996a5b3ec3)

Now we check our work...

# Verify OpenSBI and U-Boot

_Did we flash OpenSBI and U-Boot successfully?_

Let's verify if the flashing was OK...

![Flashing UART](https://lupyuen.github.io/images/ox64-pinout2.jpg)

1.  Check that our __USB Serial Adapter__ is connected to the port for __Flashing UART__. (Pic above)

1.  Start the __USB Serial Terminal__ for __Flashing UART__.  Use "[__putty__](https://www.putty.org/)" (Windows), "[__screen__](https://www.makeuseof.com/connect-to-serial-consoles-on-linux/)" (Linux) or "[__minicom__](https://www.makeuseof.com/connect-to-serial-consoles-on-linux/)" (Linux).

    Connect at __2,000,000 bps__. (2 Mbps)

    ```bash
    sudo screen /dev/ttyUSB0 2000000
    ```

    __For macOS:__ The "[__screen__](https://lupyuen.github.io/articles/led#appendix-fix-bl602-demo-firmware-for-macos)" command might not support 2 Mbps. Use [__CoolTerm__](https://freeware.the-meiers.org/) instead.

1.  Unplug and replug the __Micro USB Port__.

    (Don't press the Boot Button!)

1.  In the USB Serial Terminal (Flashing UART), we should see...

    ```text
    Starting Mailbox Handlers
    Forwarding Interupt SDH (33) to D0 (0x58008bbc)
    Forwarding Interupt GPIO (60) to D0 (0x58008d0e)
    Running...
    Mailbox IRQ Stats:
    .Peripheral SDH (33): 0
    .Peripheral GPIO (60): 0
    Unhandled Interupts: 0 Unhandled Signals 0
    ```

    [(Source)](https://gist.github.com/lupyuen/52ccdf076ae294db26e837e6ffc4bafb)

    Yep we have flashed the OpenBouffalo Firmware successfully!

![Serial Console](https://lupyuen.github.io/images/ox64-pinout3.jpg)

Next we check the __Serial Console__...

1.  Connect our __USB Serial Adapter__ to the port for __Ox64 Serial Console__ (pic above)...

    | USB Serial | Ox64 Pin |                |
    |:----------:|:--------:|:---------------|
    | __RX__  | __`GPIO 16`__ _(TX)_ | Pin 32 |
    | __TX__  | __`GPIO 17`__ _(RX)_ | Pin 31 |
    | __GND__ | __`GND`__ | Pin 33 |

1.  Start the __USB Serial Terminal__ for __Serial Console__.
    
    Connect at __2,000,000 bps__. (2 Mbps)

    ```bash
    sudo screen /dev/ttyUSB0 2000000
    ```

1.  Unplug and replug the __Micro USB Port__.

    (Don't press the Boot Button!)

1.  In the USB Serial Terminal (Serial Console), we should see...

    ```text
    U-Boot 2023.04-rc2 (Mar 06 2023 - 11:48:40 +0000)
    Card did not respond to voltage select! : -110
    BOOTP broadcast
    Retry time exceeded; starting again
    ```

    [(Source)](https://gist.github.com/lupyuen/0b1a98781e86ba11c5538eb1e3058718)

    Which is OK because U-Boot Bootloader is waiting for our microSD Card. 

1.  __If nothing appears:__ Check that we are using [__BL DevCube 1.8.3__](https://openbouffalo.org/static-assets/bldevcube/BouffaloLabDevCube-v1.8.3.zip)

    [(__1.8.4 and later__ won't work!)](https://github.com/openbouffalo/buildroot_bouffalo/issues/60)

    In BL DevCube, __UART Rate__ (for MCU and IoT) should be __230400__. (230.4 kbps)

    Don't set to 2,000,000 (2 Mbps), it will fail on macOS!

    [(Same problem when flashing BL602)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

Let's load Ox64 Linux into a microSD Card...

![Ox64 Linux in a microSD Card](https://lupyuen.github.io/images/ox64-sd.jpg)

# Boot Linux on Ox64

D0 Multimedia Core has been flashed with OpenSBI and U-Boot Bootloader. We're ready to boot __Linux on microSD__!

Based on the [__Official Flashing Instructions__](https://github.com/openbouffalo/buildroot_bouffalo#flashing-instructions)...

1.  Look for the __microSD Image__ that we downloaded earlier...

    ```text
    sdcard-pine64_ox64_full_defconfig.img.xz
    ```

    Uncompress the file to get...

    ```text
    sdcard-pine64_ox64_full_defconfig.img
    ```

1.  Flash the __Uncompressed Image__ to our microSD card.

    Use [__Balena Etcher__](https://etcher.balena.io), [__GNOME Disks__](https://wiki.gnome.org/Apps/Disks) or [__`dd`__](https://gist.github.com/lupyuen/aae995d942d5ec3ffa6629667bcc3ae6).

1.  Insert the __microSD Card__ into Ox64. (Pic above)

    ![Flashing UART](https://lupyuen.github.io/images/ox64-pinout2.jpg)

1.  Connect our __USB Serial Adapter__ to the port for __Ox64 Flashing UART__ (pic above)...

    | USB Serial | Ox64 Pin |                |
    |:----------:|:--------:|:---------------|
    | __RX__  | __`GPIO 14`__ _(TX)_ | Pin 1 |
    | __TX__  | __`GPIO 15`__ _(RX)_ | Pin 2 |
    | __GND__ | __`GND`__ | Pin 3 |

    Start the __USB Serial Terminal__ for __Flashing UART__.
    
    Connect at __2,000,000 bps__. (2 Mbps)

    ```bash
    sudo screen /dev/ttyUSB0 2000000
    ```

    Unplug and replug the __Micro USB Port__.

    (Don't press the Boot Button!)

1.  We should see the same thing as earlier...

    ```text
    Starting Mailbox Handlers
    Forwarding Interupt SDH (33) to D0 (0x58008bbc)
    Forwarding Interupt GPIO (60) to D0 (0x58008d0e)
    Running...
    Mailbox IRQ Stats:
    .Peripheral SDH (33): 0
    .Peripheral GPIO (60): 0
    Unhandled Interupts: 0 Unhandled Signals 0
    ```

    [(Source)](https://gist.github.com/lupyuen/52ccdf076ae294db26e837e6ffc4bafb)

    ![Serial Console](https://lupyuen.github.io/images/ox64-pinout3.jpg)

1.  Connect our __USB Serial Adapter__ to the port for __Ox64 Serial Console__ (pic above)...

    | USB Serial | Ox64 Pin |                |
    |:----------:|:--------:|:---------------|
    | __RX__  | __`GPIO 16`__ _(TX)_ | Pin 32 |
    | __TX__  | __`GPIO 17`__ _(RX)_ | Pin 31 |
    | __GND__ | __`GND`__ | Pin 33 |

    Start the __USB Serial Terminal__ for __Serial Console__.
    
    Connect at __2,000,000 bps__. (2 Mbps)

    ```bash
    sudo screen /dev/ttyUSB0 2000000
    ```

    Unplug and replug the __Micro USB Port__.

    (Don't press the Boot Button!)

1.  We should see [__d0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/d0_lowload) starting on D0 Multimedia Core...

    ```text
    D0 start...
    low_load start... 
    Copying DTB to 0x51ff8000...0x51ffb7ea
    Copying OpenSBI to 0x3ef80000...0x3ef9ad28
    Uncompressing Kernel to 0x50000000...
    Booting OpenSBI at 0x000000003ef80000 with DTB at 0x51ff8000
    ```

    Which loads the [__OpenSBI Supervisor Binary Interface__](https://lupyuen.github.io/articles/sbi)...

    ```text
    OpenSBI v1.2
    Platform Name             : Pine64 Ox64 (D0)
    Platform Features          medeleg
    Platform HART Count       : 1
    Platform IPI Device       : aclint-mswi
    Platform Timer Device     : aclint-mtimer @ 1000000Hz
    Platform Console Device   : bflb_uart
    Firmware Base             : 0x3ef80000
    Firmware Size             : 200 KB
    Runtime SBI Version       : 1.0
    ```

    Which starts the [__U-Boot Bootloader__](https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64)...

    ```text
    U-Boot 2023.04-rc2 (Mar 06 2023 - 11:48:40 +0000)
    DRAM:  64 MiB
    Core:  36 devices, 17 uclasses, devicetree: board
    MMC:   mmc@20060000: 0
    Loading Environment from FAT...
    Unable to read "uboot.env" from mmc0:2... 
    ```

    Which starts [__Buildroot Linux__](https://github.com/bouffalolab/buildroot_bouffalo) (finally!)...

    ```text
    Starting kernel ...
    Linux version 6.2.0
      (runner@fv-az587-938)
      (riscv64-unknown-linux-gnu-gcc
      (Xuantie-900 linux-5.10.4 glibc gcc Toolchain V2.6.1 B-20220906) 10.2.0, GNU ld (GNU Binutils) 2.35) #1 Mon Mar  6 11:17:27 UTC 2023
    ...
    Welcome to Buildroot
    ox64 login: 
    ```

    Yep Linux is running on Ox64 yay! (Pic below)

    [(See the __Complete Log__)](https://gist.github.com/lupyuen/3035a70d52d2d1d529e96f5292f54210)

    [(Watch the __Demo on YouTube__)](https://youtu.be/UJ_7DyHnfDA)

    [(See the __U-Boot Settings__)](https://gist.github.com/lupyuen/30df5a965fabf719cc52bf733e945db7)

1.  __If nothing appears:__ Check that we are using [__BL DevCube 1.8.3__](https://openbouffalo.org/static-assets/bldevcube/BouffaloLabDevCube-v1.8.3.zip)

    [(__1.8.4 and later__ won't work!)](https://github.com/openbouffalo/buildroot_bouffalo/issues/60)

    In BL DevCube, __UART Rate__ (for MCU and IoT) should be __230400__. (230.4 kbps)

    Don't set to 2,000,000 (2 Mbps), it will fail on macOS!

    [(Same problem when flashing BL602)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

1.  __If U-Boot fails to boot Linux__...

    ```text
    U-Boot 2023.04-rc2 (Mar 06 2023 - 11:48:40 +0000)
    Card did not respond to voltage select! : -110
    BOOTP broadcast
    Retry time exceeded; starting again
    ```

    [(Source)](https://gist.github.com/lupyuen/0b1a98781e86ba11c5538eb1e3058718)

    Check that our __microSD Card__ is inserted correctly. (Pic above)

    [(Anyone with __microSD Issues__?)](https://github.com/lupyuen/lupyuen.github.io/issues/20)

![Boot Linux on Ox64 BL808](https://lupyuen.github.io/images/ox64-title.jpg)

_Flashing BL808 sounds a little wonky?_

Yeah. According to [__@gamelaster__](https://web.archive.org/web/20231103055532/https://twitter.com/gamelaster/status/1719073156281798755)...

> "This is not hardware specific, but flasher specific. With blisp, I was able to get faster flashing working, but this is Apple's quirk. Or maybe not? Because FreeBSD need same quirks and exact buffer sizes as Apple."

Hopefully we can use [__blisp__](https://github.com/pine64/blisp) for flashing BL808 more reliably!

# Apache NuttX RTOS for Ox64

Read the article...

-   [__"RISC-V Ox64 BL808 SBC: Starting Apache NuttX RTOS"__](https://lupyuen.github.io/articles/ox2)

_Why Apache NuttX RTOS?_

Ox64 (with 64 MB RAM) seems a little tiny for __64-bit Linux__.

Perhaps Ox64 might run more efficiently with a tiny __64-bit RTOS__ (Real-Time Operating System)? Like __Apache NuttX RTOS__?

Let's explore...

1.  _How to boot Apache NuttX RTOS on Ox64?_

    Ox64 boots Linux like a __typical RISC-V SBC__ with...

    - [__OpenSBI Supervisor Binary Interface__](https://lupyuen.github.io/articles/sbi)

    - [__U-Boot Bootloader__](https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64)

    So let's __pretend to be Linux__ and trick Ox64 into booting NuttX!

    - [__"Linux Image Header for Ox64"__](https://lupyuen.github.io/articles/ox64#appendix-linux-image-header)

    "Linux-To-NuttX Switcheroo" has worked remarkably well for booting NuttX on [__PinePhone__](https://lupyuen.github.io/articles/what), [__PinePhone Pro__](https://github.com/apache/nuttx/pull/10193), [__NanoPi M4 SBC__](https://github.com/apache/nuttx/pull/10645) and [__Star64 RISC-V SBC__](https://lupyuen.github.io/articles/release)...
    
    We'll do it again for Ox64! Starting with the [__NuttX Boot Code__](https://lupyuen.github.io/articles/release#nuttx-startup-explained)...

    - [__"Boot Apache NuttX RTOS on Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64#boot-apache-nuttx-rtos-on-ox64-bl808)

1.  _How will we print to the Serial Console?_

    We'll borrow the [__NuttX UART Driver for BL602__](https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c). (Which will probably work with BL808)

    - [__"Print to Ox64 Serial Console in NuttX Boot Code"__](https://github.com/lupyuen/nuttx-ox64#print-to-ox64-serial-console-in-nuttx-boot-code)

    The __Linux Device Tree__ has helpful hints...

    - [__"Linux Device Tree for Ox64"__](https://lupyuen.github.io/articles/ox64#appendix-linux-device-tree)

    Or we'll call the __OpenSBI Legacy Console__...

    - [__"Call OpenSBI from NuttX"__](https://lupyuen.github.io/articles/sbi#call-opensbi-from-nuttx)

    (Ox64 implements [__SBI Spec v1.0__](https://gist.github.com/lupyuen/3035a70d52d2d1d529e96f5292f54210#file-ox64-linux-boot-log-L54) without [__Debug Console__](https://lupyuen.github.io/articles/sbi#opensbi-debug-console))

1.  _What about the other BL808 Drivers?_

    We'll port the BL808 Drivers from Bouffalo Lab's [__BouffaloSDK__](https://github.com/bouffalolab/bouffalo_sdk) to NuttX.

    [(BouffaloSDK is __Apache 2.0 Licensed__)](https://github.com/bouffalolab/bouffalo_sdk/blob/master/LICENSE)

    ![Bouffalo Lab BL808 is a complex creature with 3 (Asymmetric) RISC-V Cores](https://lupyuen.github.io/images/ox64-cores.jpg)

1.  _Will we boot NuttX on both 32-bit and 64-bit RISC-V Cores? (Pic above)_

    Initially we'll boot NuttX on the 64-bit __D0 Multimedia Core__.
    
    NuttX will talk to the __Existing OpenBouffalo Firmware__ on the 32-bit M0 Wireless Core over Mailbox.

    [(__Linux Device Tree__ tells us how)](https://lupyuen.github.io/articles/ox64#appendix-linux-device-tree)

    Later we might boot NuttX on the 32-bit M0 Wireless Core. And let the 64-bit and 32-bit Cores talk over [__OpenAMP__](https://www.openampproject.org/). (Asymmetric Multi-Processing)

1.  _Will OpenSBI boot NuttX on the 32-bit RISC-V Core?_

    Sadly nope. The 32-bit M0 Wireless Core __isn't controlled by OpenSBI__, according to the [__OpenSBI Log__](https://gist.github.com/lupyuen/3035a70d52d2d1d529e96f5292f54210#file-ox64-linux-boot-log-L44)...

    ```text
    Platform HART Count: 1
    ```    

    (That's for the D0 Multimedia Core)

    So booting 32-bit NuttX with [__OpenSBI HSM__](https://lupyuen.github.io/articles/sbi#query-the-risc-v-cpus) simply won't work.

    We'll have to flash 32-bit NuttX to Ox64 with [__BL DevCube__](https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot). (Ouch!)

1.  _Are you sorry that NuttX Fans had to put up with this entire article?_

    Yes I'm truly sorry! But that's exactly how we'll __boot NuttX on Ox64__...
    
    - __Flash OpenSBI and U-Boot Bootloader__ to Ox64...
    
    - So that it will load our __NuttX Kernel Image__
    
      (That pretends to be Linux)

    Thankfully it's a __One-Time Thing__. To upgrade the NuttX Kernel, we only need to __update the microSD Card__.
    
    (No more flashing yay!)

    [(Ox64 on a Breadboard might block the microSD Card. Can this __microSD Extender__ help?)](https://pine64.com/product/pinephone-microsd-extender/)

    [(__TFTP Booting over Ethernet__ might work on Ox64 U-Boot)](https://wiki.pine64.org/wiki/File:Ox64_ethphy.png)

![Booting Apache NuttX RTOS on Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)](https://lupyuen.github.io/images/ox64-nuttx.png)

# What's Next

Thanks to the excellent work by the [__OpenBouffalo Community__](https://openbouffalo.org/index.php/Main_Page), we have Linux booting smoothly (and swiftly) on __Ox64 BL808 RISC-V SBC__.

And by studying their work, we have booted a tiny bit of __Apache NuttX RTOS__ on Ox64 BL808! (Pic above)

We'll talk more about NuttX on Ox64 in the next article!

-   [__"RISC-V Ox64 BL808 SBC: Starting Apache NuttX RTOS"__](https://lupyuen.github.io/articles/ox2)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) (and the awesome NuttX Community) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__Discuss this article on Hacker News__](https://news.ycombinator.com/item?id=38138566)

-   [__Discuss this article on Pine64 Forum__](https://forum.pine64.org/showthread.php?tid=18838)

-   [__Discuss this article on Bouffalo Lab Forum__](https://bbs.bouffalolab.com/d/256-article-ox64-bl808-risc-v-sbc-booting-linux-and-maybe-apache-nuttx-rtos)

-   [__My Current Project: "Apache NuttX RTOS for Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64)

-   [__My Other Project: "NuttX for Star64 JH7110"__](https://github.com/lupyuen/nuttx-star64)

-   [__Older Project: "NuttX for PinePhone"__](https://github.com/lupyuen/pinephone-nuttx)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/ox64.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/ox64.md)

![My horrigible soldering of Ox64 BL808 üò¨](https://lupyuen.github.io/images/ox64-solder.jpg)

_My horrigible soldering of Ox64 BL808_ üò¨

# Appendix: Linux Image Header

_Will Apache NuttX RTOS boot on Ox64 BL808?_

Let's examine the __Linux Kernel Image for Ox64__, and we replicate the same format for NuttX. (Which is how we ported NuttX to 64-bit RISC-V Star64 JH7110 SBC)

We download the __Ox64 Binaries__...

- [bl808-linux-pine64_ox64_full_defconfig.tar.gz](https://github.com/openbouffalo/buildroot_bouffalo/releases/download/v1.0.1/bl808-linux-pine64_ox64_full_defconfig.tar.gz) 

From the latest __Ox64 Linux Release__...

- [openbouffalo/buildroot_bouffalo (Release v1.0.1)](https://github.com/openbouffalo/buildroot_bouffalo/releases/tag/v1.0.1)

Unzip it and mount the __SD Card Image__...

```bash
$ ls -l sdcard-pine64_ox64_full_defconfig     
-  13,154,816  Image
-       4,012  bl808-pine64-ox64.dtb
-       4,106  bl808-sipeed-m1s.dtb
-         350  boot-m1s.scr
-         352  boot-pine64.scr
-         352  boot.scr
d          96  extlinux
```

Dump the __`Image`__ as hex...

```bash
$ hexdump sdcard-pine64_ox64_full_defconfig/Image
0000000 4d 5a 6f 10 20 08 01 00 00 00 20 00 00 00 00 00
0000010 00 80 cd 00 00 00 00 00 00 00 00 00 00 00 00 00
0000020 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000030 52 49 53 43 56 00 00 00 52 53 43 05 40 00 00 00
```

The Linux Kernel Image begins with this __RISC-V Linux Image Header__...

-   [__"Boot Image Header in RISC-V Linux"__](https://www.kernel.org/doc/html/latest/riscv/boot-image-header.html)

Here are the decoded bytes...

1.  __code0__: Executable code

    (4 bytes, offset `0x00`)

    ```text
    4d 5a 6f 10 
    ```

1.  __code1__: Executable code 

    (4 bytes, offset `0x04`)

    ```text
    20 08 01 00 
    ```

1.  __text_offset__: Image load offset, little endian

    (8 bytes, offset `0x08`)

    ```text
    00 00 20 00 00 00 00 00
    ```

1.  __image_size__: Effective Image size, little endian 

    (8 bytes, offset `0x10`)

    ```text
    00 80 cd 00 00 00 00 00
    ```

1.  __flags__: Kernel flags, little endian 

    (8 bytes, offset `0x18`)

    ```text
    00 00 00 00 00 00 00 00
    ```

1.  __version__: Version of this header (_MinL_ _MinM_ `.` _MajL_ _MajM_)

    (4 bytes, offset `0x20`)

    ```text
    02 00 00 00
    ```

1.  __res1__: Reserved

    (4 bytes, offset `0x24`)

    ```text
    00 00 00 00
    ```

1.  __res2__: Reserved

    (8 bytes, offset `0x28`)

    ```text
    00 00 00 00 00 00 00 00
    ```

1.  __magic__: Magic number, little endian, "RISCV\x00\x00\x00" 
    
    (8 bytes, offset `0x30`)

    ```text
    52 49 53 43 56 00 00 00
    ```

1.  __magic2__: Magic number 2, little endian, "RSC\x05" 

    (4 bytes, offset `0x38`)

    ```text
    52 53 43 05
    ```

1.  __res3__: Reserved for PE COFF offset

    (4 bytes, offset `0x3C`)
    
    ```text
    40 00 00 00
    ```

Our NuttX Kernel shall __recreate this RISC-V Linux Image Header__. (Total `0x40` bytes)

(Or U-Boot Bootloader might refuse to boot NuttX)

The above Header Values are __exactly the same as Star64__. (Except the Image Size and Executable Code, since the Jump Address is different)

Thus we simply [__reuse the code__](https://lupyuen.github.io/articles/nuttx2#risc-v-linux-kernel-header) from NuttX Star64...

- [__"Boot Apache NuttX RTOS on Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64#boot-apache-nuttx-rtos-on-ox64-bl808)

# Appendix: Linux Device Tree

_What's inside the Linux Device Tree for Ox64?_

_Anything that might help NuttX for Ox64?_

Let's dump the __Linux Device Tree for Ox64__, based on the files that we have downloaded earlier...

```text
dtc \
  -o bl808-pine64-ox64.dts \
  -O dts \
  -I dtb \
  bl808-pine64-ox64.dtb
```

Which produces the __Decompiled Device Tree__: [bl808-pine64-ox64.dts](https://github.com/lupyuen/nuttx-ox64/blob/main/bl808-pine64-ox64.dts)

_What's inside the Decompiled Device Tree?_

This says the Ox64 Linux will __transmit to UART3__ at Base Address __`0x3000` `2000`__...

```text
serial@30002000 {
  compatible = "bflb,bl808-uart";
  reg = <0x30002000 0x1000>;
  interrupts = <0x14 0x04>;
  clocks = <0x04>;
  status = "okay";
  phandle = <0x0a>;
};
```

[(Source)](https://github.com/lupyuen/nuttx-ox64/blob/main/bl808-pine64-ox64.dts#L89-L96)

We'll do the same for NuttX and reuse the [__NuttX UART Driver for BL602__](https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_serial.c)...

- [__"Print to Ox64 Serial Console in NuttX Boot Code"__](https://github.com/lupyuen/nuttx-ox64#print-to-ox64-serial-console-in-nuttx-boot-code)

And this specifies the __Mailbox__ that will forward the __Peripheral Interrupts__ from M0 Wireless Core to D0 Multimedia Core...

```text
mailbox@30005000 {
  compatible = "bflb,bl808-ipc";
  reg = <
    0x30005000 0x20 
    0x30005020 0x20 
    0x2000a800 0x20 
    0x2000a820 0x20
  >;
  interrupts = <0x36 0x04>;
  interrupt-controller;
  #interrupt-cells = <0x03>;
  #mbox-cells = <0x02>;
  status = "okay";
  phandle = <0x03>;
};
```

[(Source)](https://github.com/lupyuen/nuttx-ox64/blob/main/bl808-pine64-ox64.dts#L118-L127)

NuttX will receive the __Forwarded Peripheral Interrupts__ the same way, via the Mailbox.

Let's talk about the Forwarding of Peripheral Interrupts...

![Bouffalo Lab BL808 is a complex creature with 3 (Asymmetric) RISC-V Cores](https://lupyuen.github.io/images/ox64-cores.jpg)

# Appendix: Peripheral Interrupts

_What's this forwarding of Peripheral Interrupts? (Pic above)_

From the __M0 Wireless Core__, we see this log by the OpenBouffalo Firmware [__m0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/m0_lowload)...

```text
Starting Mailbox Handlers
Forwarding Interupt SDH (33) to D0 (0x58008bbc)
Forwarding Interupt GPIO (60) to D0 (0x58008d0e)
Running...
Mailbox IRQ Stats:
.Peripheral SDH (33): 0
.Peripheral GPIO (60): 0
Unhandled Interupts: 0 Unhandled Signals 0
```

[(Source)](https://gist.github.com/lupyuen/52ccdf076ae294db26e837e6ffc4bafb)

The log above says that...

- __M0 Wireless Core__ (OpenBouffalo Firmware) will forward the __Peripheral Interrupts__ to D0 Multimedia Core (Linux)

- The Forwarded Peripheral Interrupts are for __SD Card Host Controller__ (SDH) and __GPIO__ 

- Which makes sense because the __U-Boot Bootloader__ (on D0 Multimedia Core) needs to access the __SD Card__ (for booting Linux)

_What are the BL808 Interrupt Numbers?_

- __GPIO Interrupt__ is IRQ 60

  Because __GPIO_INT0__ = IRQ_NUM_BASE + 44
  
  [(__BL808 Reference Manual__, Page 44)](https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf)

  And __IRQ_NUM_BASE__ is 16
  
  [(__BL808 Reference Manual__, Page 45)](https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf)

  [(Defined as __GPIO_INT0_IRQn__)](https://github.com/bouffalolab/bl808_linux/blob/main/bl_mcu_sdk_bl808/drivers/bl808_driver/regs/bl808.h#L123)

- __SD Card Interrupt__ is IRQ 33

  [(__BL808 Reference Manual__, Page 561)](https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf)

  [(Defined as __SDH_IRQn__)](https://github.com/bouffalolab/bl808_linux/blob/main/bl_mcu_sdk_bl808/drivers/bl808_driver/regs/bl808.h#L96)

_How does the OpenBouffalo Firmware forward the Peripheral Interrupts?_

Check out...

- How we [__Setup SD Card Interrupt__](https://github.com/openbouffalo/OBLFR/blob/master/components/mailbox/src/oblfr_mailbox.c#L238C1-L257)

  And [__Forward SD Card Interrupt__](https://github.com/openbouffalo/OBLFR/blob/master/components/mailbox/src/oblfr_mailbox.c#L95-L103)

- How we [__Forward GPIO Interrupt__](https://github.com/openbouffalo/OBLFR/blob/master/components/mailbox/src/oblfr_mailbox.c#L127-L135)

- Refer to [__OpenBouffalo Firmware for m0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/m0_lowload)

  And [__OpenBouffalo Firmware for d0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/d0_lowload)

_What about other Peripheral Interrupts?_

[__OpenBouffalo Firmware for m0_lowload__](https://github.com/openbouffalo/OBLFR/tree/master/apps/m0_lowload) seems to support other Peripheral Interrupts (but disabled for now)...

- [__Forward UART2 Interrupt__](https://github.com/openbouffalo/OBLFR/blob/master/components/mailbox/src/oblfr_mailbox.c#L103-L111)

- [__Forward USB Interrupt__](https://github.com/openbouffalo/OBLFR/blob/master/components/mailbox/src/oblfr_mailbox.c#L111-L119)

- [__Forward Ethernet Interrupt__](https://github.com/openbouffalo/OBLFR/blob/master/components/mailbox/src/oblfr_mailbox.c#L119-L127)

_Are there other ways to boot Linux on Ox64?_

According to [__@madushan1000__](https://web.archive.org/web/20231103055452/https://twitter.com/madushan1000/status/1719069431580524720?s=20)...

> "You can also use u-boot. [openbouffalo/u-boot/bl808-2023-02-19](https://github.com/openbouffalo/u-boot/releases/tag/bl808-2023-02-19). 
You can also get rid of mailbox, but you will have to build the kernel yourself [openbouffalo/linux/bl808](https://github.com/openbouffalo/linux/tree/bl808/all)"
