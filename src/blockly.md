# Zig Visual Programming with Blockly

üìù _7 Aug 2022_

![Zig Visual Programming with Blockly](https://lupyuen.github.io/images/blockly-title.jpg)

_Can we create a Zig program visually... The Drag-and-Drop way?_

Let's find out! Today we shall explore [__Blockly__](https://developers.google.com/blockly), the Scratch-like browser-based coding toolkit...

And how we might customise Blockly to __create Zig programs__ visually. (Pic above)

_Will it work for any Zig program?_

We're not quite done yet. We hit some __interesting challenges__, like Blockly's "Typelessness" and Zig's "Anti-Shadowing".

But it might work for creating __IoT Sensor Apps__ for Embedded Platforms like [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/zig).

(More about this below)

Let's head down into our Zig experiment with Blocky...

-   [__lupyuen3/blockly-zig-nuttx__](https://github.com/lupyuen3/blockly-zig-nuttx)

And learn how how we ended up here...

-   [__Blockly with Zig (Work in Progress)__](https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/)

-   [__Watch the Demo on YouTube__](https://youtu.be/192ZKA-1OqY)

# Visual Program

_What's Visual Programming like with Blockly?_

With Blockly, we create Visual Programs by dragging and dropping __Interlocking Blocks__. (Exactly like Scratch and MakeCode)

This is a Visual Program that loops 10 times, printing the number `123.45`...

![Blockly Visual Program](https://lupyuen.github.io/images/blockly-run1.png)

We can try dragging-n-dropping the Blocks here...

-   [__Blockly with Zig (Work in Progress)__](https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/)

-   [__Watch the Demo on YouTube__](https://youtu.be/192ZKA-1OqY)

To find the above Blocks, click the __Blocks Toolbox__ (at left) and look under __"Loops"__, __"Variables"__, __"Math"__ and __"Text"__.

_But will it produce a Zig program?_

Yep if we click the __Zig Tab__...

![Zig Tab in Blockly](https://lupyuen.github.io/images/blockly-run3a.png)

This __Zig Program__ appears...

```zig
/// Import Standard Library
const std = @import("std");

/// Main Function
pub fn main() !void {
  var count: usize = 0;
  while (count < 10) : (count += 1) {
    const a: f32 = 123.45;
    debug("a={}", .{ a });
  }
}

/// Aliases for Standard Library
const assert = std.debug.assert;
const debug  = std.log.debug;
```

When we copy-n-paste the program and run it with Zig...

```text
$ zig run a.zig
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
debug: a=1.23449996e+02
```

Indeed it produces the right result!

(Not the tidiest output, but we'll come back to this)

_Will this work with all Blocks?_

Not quite. We customised Blockly to support the __bare minimum of Blocks__.

There's plenty more to be customised for Zig. Lemme know if you're keen to help! üôè

![Zig Code generated by Blocky](https://lupyuen.github.io/images/blockly-run2.png)

# Code Generator

_How did Blockly automagically output our Zig Program?_

Blockly comes bundled with __Code Generators__ that will churn out programs in JavaScript, Python, Dart, ...

Sadly it doesn't have one for Zig. So we built our own __Zig Code Generator__ for Blockly...

-   [__"Add a Zig Tab"__](https://lupyuen.github.io/articles/blockly#appendix-add-a-zig-tab)

-   [__"Zig Code Generator"__](https://lupyuen.github.io/articles/blockly#appendix-zig-code-generator)

-   [__"Load Code Generator"__](https://lupyuen.github.io/articles/blockly#appendix-load-code-generator)

_Every Block generates its own Zig Code?_

Our Code Generator needs to output Zig Code for __every kind of Block__.

(Which makes it tiresome to customise Blockly for Zig)

To understand the work involved, we'll look at three Blocks and how our Code Generator handles them...

-   __Set Variable__

-   __Print Expression__

-   __Repeat Loop__

We'll also study the __Main Function__ that's produced by our Code Generator.

![Set Variable](https://lupyuen.github.io/images/blockly-run5.png)

## Set Variable

Blockly will let us assign Values to Variables. (Pic above)

To keep things simple, we'll handle Variables as __Constants__. And they shall be __Floating-Point Numbers__. (We'll explain why)

Thus the Block above will generate this Zig code...

```zig
const a: f32 = 123.45;
```

__UPDATE:__ We have removed `f32` from all `const` declarations, replying on __Type Inference__ instead. This works better for supporting CBOR Messages. [(Like so)](https://twitter.com/MisterTechBlog/status/1557857587667775489)

This is how we generate the code with a template (through __String Interpolation__): [generators/zig/variables.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig/variables.js#L25-L32)

```javascript
Zig['variables_set'] = function(block) {
  // Variable setter.
  ...
  return `const ${varName}: f32 = ${argument0};\n`;
};
```

[(More about String Interpolation)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)

_Isn't this (gasp) JavaScript?_

Blockly is coded in __plain old JavaScript__. Hence we'll write our Zig Code Generator in JavaScript too.

(Maybe someday we'll convert the Zig Code Generator to WebAssembly and build it in Zig)

![Print Expression](https://lupyuen.github.io/images/blockly-run6.png)

## Print Expression

To __print the value__ of an expression (pic above), we generate this Zig code...

```zig
debug("a={}", .{ a });
```

Here's the implementation in our Zig Code Generator: [generators/zig/text.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig/text.js#L268-L272)

```javascript
Zig['text_print'] = function(block) {
  // Print statement.
  ...
  return `debug("${msg}={}", .{ ${msg} });\n`;
};
```

(It won't work with strings, we'll handle that later)

![Repeat Loop](https://lupyuen.github.io/images/blockly-run4.png)

## Repeat Loop

To run a __repeating loop__ (pic above), we generate this Zig code...

```zig
var count: usize = 0;
while (count < 10) : (count += 1) {
  ...
}
```

With this template in our Zig Code Generator: [generators/zig/loops.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig/loops.js#L19-L45)

```javascript
Zig['controls_repeat_ext'] = function(block) {
  // Repeat n times.
  ...
  code += [
    `var ${loopVar}: usize = 0;\n`,
    `while (${loopVar} < ${endVar}) : (${loopVar} += 1) {\n`,
    branch,
    '}\n'
  ].join('');
  return code;
};
```

_What if we have two Repeat Loops? Won't "`count`" clash?_

Blockly will helpfully __generate another counter__ like "`count2`"...

```zig
var count2: usize = 0;
while (count2 < 10) : (count2 += 1) {
  ...
}
```

(Try it out!)

## Main Function

To become a valid Zig program, our generated Zig code needs to be wrapped into a __Main Function__ like this...

```zig
/// Import Standard Library
const std = @import("std");

/// Main Function
pub fn main() !void {
  // TODO: Generated Zig Code here
  ...
}

/// Aliases for Standard Library
const assert = std.debug.assert;
const debug  = std.log.debug;
```

We do this with another template in our Zig Code Generator: [generators/zig.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig.js#L132-L193)

```javascript
Zig.finish = function(code) {
  ...
  // Compose Main Function
  code = [
    '/// Main Function\n',
    'pub fn main() !void {\n',
    code,
    '}',
  ].join('');
```

The code above composes the __Main Function__.

Next we define the __Header and Trailer__...

```javascript
  // Compose Zig Header
  const header = [
    '/// Import Standard Library\n',
    'const std = @import("std");\n',
  ].join('');

  // Compose Zig Trailer
  const trailer = [
    '/// Aliases for Standard Library\n',
    'const assert = std.debug.assert;\n',
    'const debug  = std.log.debug;\n',
  ].join('');
```

Finally we combine them and return the result...

```javascript
  // Combine Header, Code, 
  // Function Definitions and Trailer
  return [
    header,
    '\n',
    code,
    (allDefs == '') ? '' : '\n\n',
    allDefs.replace(/\n\n+/g, '\n\n').replace(/\n*$/, '\n\n'),
    trailer,
  ].join('');
};
```

Let's talk about Function Definitions...

# Define Functions

_Can we define Zig Functions in Blockly?_

Sure can! This __Function Block__...

![Define Blockly Function](https://lupyuen.github.io/images/blockly-run7a.jpg)

[(Parameters are defined in __Function Settings__)](https://lupyuen.github.io/images/blockly-run9.jpg)

[(Watch the Demo on YouTube)](https://youtu.be/192ZKA-1OqY?t=56)

Will generate this perfectly valid __Zig Function__...

```zig
fn do_something(x: f32, y: f32) !f32 {
  const a: f32 = 123.45;
  debug("a={}", .{ a });
  return x + y;
}
```

And calling the above function...

![Call Blockly Function](https://lupyuen.github.io/images/blockly-run7b.jpg)

Works OK with Zig too...

```zig
const a: f32 = 123.45;
const b: f32 = try do_something(a, a);
debug("b={}", .{ b });
```

Thus indeed it's possible to create [__Complex Blockly Apps__](https://lupyuen.github.io/images/blockly-run10.jpg) with Zig. [(Like this)](https://lupyuen.github.io/images/blockly-run10.jpg)

The above templates are defined in our Code Generator at [generators/zig/procedures.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig/procedures.js#L18-L92)

# Blockly is Typeless

_Why are our Constants declared as Floating-Point `f32`?_

Here comes the interesting challenge with Zig on Blockly...

__Blockly is Typeless!__

Blockly doesn't recognise Types, so it will gladly accept this...

![Blocky is Typeless](https://lupyuen.github.io/images/blockly-run8.jpg)

Which works fine with [__Dynamically-Typed Languages__](https://developer.mozilla.org/en-US/docs/Glossary/Dynamic_typing) like JavaScript...

```javascript
// Dynamic Type in JavaScript
var a;
a = 123.45;
a = 'abc';
```

But not for [__Statically-Typed Languages__](https://developer.mozilla.org/en-US/docs/Glossary/Static_typing) like Zig!

That's why we constrain all Types as `f32`, until we figure out how to handle strings and other types...

```zig
// Static Type in Zig
const a: f32 = 123.45;
// Nope we won't accept "abc"
```

_Won't that severely limit our Zig Programs?_

`f32` is probably sufficient for simple __IoT Sensor Apps__.

Such apps work only with numeric __Sensor Data__ (like temperature, humidity). And they don't need to manipulate strings.

(More about this in a while)

# Constants vs Variables

_What other challenges do we have with Zig on Blockly?_

Our Astute Reader would have seen this Oncoming Wreckage (from miles away)...

![Redeclared Constants in Blockly](https://lupyuen.github.io/images/blockly-run12.jpg)

The __Double Assignment__ above will cause Constant Problems...

```zig
// This is OK
const a: f32 = 123.45;

// Oops! `a` is redeclared...
const a: f32 = 234.56;
```

Our Code Generator will have to stop this somehow.

_Why not declare as a Variable? (Instead of a Constant)_

```zig
// This is OK
var a: f32 = undefined;
a = 123.45;
a = 234.56;
```

Call me stupendously stubborn, but I think Constants look neater than Variables?

Also we might have a problem with [__Shadowed Identifiers__](https://ziglang.org/documentation/master/#Shadowing)...

![Shadowing in Blockly](https://lupyuen.github.io/images/blockly-run15.jpg)

This code won't compile with Zig even if we change `const` to `var`...

```zig
// This is OK
const a: f32 = 123.45;
debug("a={}", .{ a });

var count: usize = 0;
while (count < 10) : (count += 1) {

  // Oops! `a` is shadowed...
  const a: f32 = 234.56;
  debug("a={}", .{ a });
}
```

[(More about Shadowing)](https://ziglang.org/documentation/master/#Shadowing)

So yeah, supporting Zig on Blockly can get really challenging.

(Though supporting C on Blockly without Type Inference would be a total nightmare!)

# Desktop and Mobile

_Can we build Blockly apps on Mobile Devices?_

Blockly works OK with Mobile Web Browsers...

![Blocky on Mobile Web Browser](https://lupyuen.github.io/images/blockly-mobile.jpg)

[(Source)](https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/)

_Is Blockly available as an offline, non-web Desktop App?_

Not yet. But we could package Blockly as a __VSCode Extension__ that will turn it into a Desktop App...

-   [__Blockly Extension for VSCode__](https://lupyuen.github.io/articles/advanced-topics-for-visual-embedded-rust-programming)

Or we might package Blockly into a __Standalone App__ with Tauri...

-   [__Tauri Desktop Bundler__](https://tauri.app/)

_Why would we need a Desktop App for Blockly?_

It's easier to __compile the Generated Zig Code__ when we're on a Desktop App.

And a Desktop App is more convenient for __flashing the compiled code__ to Embedded Devices.

# IoT Sensor Apps

_We said earlier that Blockly might be suitable for IoT Sensor Apps. Why?_

Suppose we're building an __IoT Sensor Device__ that will monitor Temperature and Humidity.

The firmware in our device will periodically __read and transmit the Sensor Data__ like this...

![IoT Sensor App](https://lupyuen.github.io/images/blockly-iot.jpg)

Which we might __build with Blockly__ like so...

![Visual Programming for Zig with NuttX Sensors](https://lupyuen.github.io/images/sensor-visual.jpg)

_Whoa that's a lot to digest!_

We'll break down this IoT Sensor App in the next section.

_But why build IoT Sensor Apps with Blockly and Zig?_

-   __Types are simpler:__ Only Floating-Point Numbers will be supported for Sensor Data

    (No strings needed)

-   __Blockly is Typeless:__ With Zig we can use Type Inference to deduce the missing Types

    (Doing this in C would be extremely painful)

-   __Easier to experiment__ with various IoT Sensors: Temperature, Humidity, Air Pressure, ...

    (Or mix and match a bunch of IoT Sensors!)

Let's talk about the reading and sending of Sensor Data...

# Read Sensor Data

Previously we talked about our IoT Sensor App __reading Sensor Data__ (like Temperature) from a real sensor [(like __Bosch BME280__)](https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/).

This is how it might look in Blockly...

> ![Read Sensor Data in Blockly](https://lupyuen.github.io/images/sensor-visual2.jpg)

(We'll populate Blockly with a whole bunch of __Sensor Blocks__ like BME280)

And this is the Zig Code that we might auto-generate: [visual-zig-nuttx/visual/visual.zig](https://github.com/lupyuen/visual-zig-nuttx/blob/visual/visual.zig#L27-L115)

```zig
// Read the Temperature
const temperature: f32 = blk: {

  // Open the Sensor Device
  const fd = c.open(
    "/dev/uorb/sensor_baro0",  // Path of Sensor Device
    c.O_RDONLY | c.O_NONBLOCK    // Open for read-only
  );

  // Close the Sensor Device when this block returns
  defer {
    _ = c.close(fd);
  }

  // If Sensor Data is available...
  var sensor_value: f32 = undefined;
  if (c.poll(&fds, 1, -1) > 0) {

    // Define the Sensor Data Type
    var sensor_data = std.mem.zeroes(c.struct_sensor_event_baro);
    const len = @sizeOf(@TypeOf(sensor_data));

    // Read the Sensor Data
    if (c.read(fd, &sensor_data, len) >= len) {

      // Remember the Sensor Value
      sensor_value = sensor_data.temperature;
            
    } else { std.log.err("Sensor data incorrect size", .{}); }
  } else { std.log.err("Sensor data not available", .{}); }

  // Return the Sensor Value
  break :blk sensor_value;
};

// Print the Temperature
debug("temperature={}", .{
  floatToFixed(temperature)
});
```

When we run this on __Apache NuttX RTOS__, it will actually fetch the Temperature from the Bosch BME280 Sensor!

[(As explained here)](https://lupyuen.github.io/articles/sensor#read-barometer-sensor)

_What a huge chunk of Zig!_

The complete implementation is a huger chunk of Zig, because we need to __handle Errors__. [(See this)](https://github.com/lupyuen/visual-zig-nuttx/blob/visual/sensor.zig#L33-L109)

But it might be hunky dory for Blockly. We just need to define one Block for __every Sensor__ supported by NuttX. (Like BME280)

And every Block will churn out the __Boilerplate Code__ (plus Error Handling) that we see above.

_Surely some of the code can be refactored into reusable Zig Functions?_

Refactoring the code can get tricky because the __Sensor Data Struct and Fields__ are dependent on the Sensor...

```zig
// Define the Sensor Data Type
// Note: `sensor_event_baro` depends on the sensor
var sensor_data = std.mem.zeroes(
  c.struct_sensor_event_baro
);
const len = @sizeOf(@TypeOf(sensor_data));

// Read the Sensor Data
if (c.read(fd, &sensor_data, len) >= len) {

  // Remember the Sensor Value
  // Note: `temperature` depends on the sensor
  sensor_value = sensor_data.temperature;
```

[(__`comptime` Generics__ might help)](https://ziglang.org/documentation/master/#Compile-Time-Parameters)

_What's floatToFixed?_

```zig
// Read the Temperature as a Float
const temperature: f32 = ...

// Print the Temperature as a
// Fixed-Point Number (2 decimal places)
debug("temperature={}", .{
  floatToFixed(temperature)
});
```

That's our tidy way of printing [__Fixed-Point Numbers__](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) (with 2 decimal places)...

```text
temperature=23.45
```

Instead of the awful `2.34500007e+01` we saw earlier.

[(More about this in the Appendix)](https://lupyuen.github.io/articles/blockly#appendix-fixed-point-numbers)

_What's `blk`?_

That's how we return a value from the __Block Expression__...

```zig
// Read the Temperature
const temperature: f32 = blk: {

  // Do something
  var fd = ...

  // Return the Sensor Value
  break :blk 23.45;
};
```

This sets `temperature` to `23.45`.

Block Expressions are a great way to __prevent leakage__ of our Local Variables (like `fd`) into the Outer Scope and [__avoid Shadowing__](https://lupyuen.github.io/articles/blockly#constants-vs-variables).

[(More about Block Expressions)](https://ziglang.org/documentation/master/#blocks)

# Transmit Sensor Data

Two sections ago we talked about our IoT Sensor App __transmitting Sensor Data__ (like Temperature) to a Wireless IoT Network [(like __LoRaWAN__)](https://makezine.com/2021/05/24/go-long-with-lora-radio/).

We'll do this in two steps...

-   __Compose__ the Sensor Data Message

    (Compress our Sensor Data into a tiny Data Packet)

-   __Transmit__ the Sensor Data Message

    (Over LoRaWAN)

Assume we've read Temperature and Humidity from our sensor.

This is how we shall __compose a Sensor Data Message__ with Blockly...

> ![Compose Sensor Data Message in Blockly](https://lupyuen.github.io/images/sensor-visual3.jpg)

The Block above will pack the Temperature and Humidity into this format...

```json
{
  "t": 2345,
  "h": 6789
}
```

(Numbers have been scaled up by 100)

Then compress it with [__Concise Binary Object Representation (CBOR)__](https://lupyuen.github.io/articles/cbor2).

_Why CBOR? Why not JSON?_

The message above compressed with CBOR will require only __11 bytes!__ [(See this)](https://lupyuen.github.io/images/blockly-cbor.jpg)

That's 8 bytes fewer than JSON! Tiny compressed messages will work better with Low-Bandwidth Networks like LoRaWAN.

After composing our Sensor Data Message, we shall __transmit the Sensor Data Message__ with Blockly...

> ![Transmit Sensor Data Message in Blockly](https://lupyuen.github.io/images/sensor-visual4.jpg)

This Block transmits our compressed CBOR Message to the [__LoRaWAN Wireless Network__](https://makezine.com/2021/05/24/go-long-with-lora-radio/).

_Will Zig talk to LoRaWAN?_

Yep we've previously created a Zig app for LoRaWAN and Apache NuttX RTOS...

-   [__"Build an IoT App with Zig and LoRaWAN"__](https://lupyuen.github.io/articles/iot)

We'll reuse the code to transmit our message to LoRaWAN.

_Is it OK to create Custom Blocks in Blockly? Like for "BME280 Sensor", "Compose Message" and "Transmit Message"?_

Yep here are the steps to create a __Custom Block__ in Blockly...

-   [__"Customise Blockly"__](https://lupyuen.github.io/articles/lisp#customise-blockly-for-ulisp)

When our Custom Blocks are done, we're all set to create IoT Sensor Apps with Blockly!

![Visual Programming for Zig with NuttX Sensors](https://lupyuen.github.io/images/sensor-visual.jpg)

# What's Next

This has been a fun experiment with Blockly. I hope we'll extend it to make it more accessible to __Zig Learners__!

I'll continue to customise Blockly for __NuttX Sensors__. Hopefully we'll create __IoT Sensor Apps__ the drag-n-drop way, real soon!

-   [__Follow the updates on Twitter__](https://twitter.com/MisterTechBlog/status/1557857587667775489)

Check out my earlier work on Zig, NuttX, LoRaWAN and LVGL...

-   [__"Zig on RISC-V BL602: Quick Peek with Apache NuttX RTOS"__](https://lupyuen.github.io/articles/zig)

-   [__"Build an IoT App with Zig and LoRaWAN"__](https://lupyuen.github.io/articles/iot)

-   [__"Build an LVGL Touchscreen App with Zig"__](https://lupyuen.github.io/articles/lvgl)

Many Thanks to my [__GitHub Sponsors__](https://lupyuen.github.io/articles/sponsor) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://lupyuen.github.io/articles/sponsor)

-   [__Discuss this article on Reddit__](https://www.reddit.com/r/Zig/comments/wi57d8/zig_visual_programming_with_blockly/)

-   [__Read "The RISC-V BL602 / BL604 Book"__](https://lupyuen.github.io/articles/book)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/blockly.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/blockly.md)

# Notes

1.  This article is the expanded version of [__this Twitter Thread__](https://twitter.com/MisterTechBlog/status/1554650482240397312)

# Appendix: Fixed-Point Numbers

Earlier we talked about reading __Floating-Point Sensor Data__ (like Temperature)...

-   [__"Read Sensor Data"__](https://lupyuen.github.io/articles/blockly#read-sensor-data)

And we wrote this to __print our Sensor Data__: [visual-zig-nuttx/visual/visual.zig](https://github.com/lupyuen/visual-zig-nuttx/blob/visual/visual.zig#L15-L25)

```zig
// Assume we've read the Temperature as a Float
const temperature: f32 = 23.45;

// Print the Temperature as a
// Fixed-Point Number (2 decimal places)
debug("temperature={}", .{
  floatToFixed(temperature)
});
```

This prints the Temperature correctly as...

```text
temperature=23.45
```

Instead of the awful `2.34500007e+01` that we see typically with printed Floating-Point Numbers.

_What's floatToFixed?_

We call __floatToFixed__ to convert a Floating-Point Number to a [__Fixed-Point Number__](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) (2 decimal places) for printing.

(We'll see __floatToFixed__ in a while)

__UPDATE:__ We no longer need to call __floatToFixed__ when printing only one Floating-Point Number. The Debug Logger auto-converts it to Fixed-Point for us. [(See this)](https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensortest.zig#L266-L294)

_How do we represent Fixed-Point Numbers?_

Our Fixed-Point Number has two Integer components...

-   __int__: The Integer part

-   __frac__: The Fraction part, scaled by 100

So to represent `123.456`, we break it down as...

-   __int__ = `123`

-   __frac__ = `45`

We drop the final digit `6` when we convert to Fixed-Point.

In Zig we define Fixed-Point Numbers as a __FixedPoint Struct__...

```zig
/// Fixed Point Number (2 decimal places)
pub const FixedPoint = struct {

  /// Integer Component
  int: i32,

  /// Fraction Component (scaled by 100)
  frac: u8,

  /// Format the output for Fixed Point Number (like 123.45)
  pub fn format(...) !void { ... }
};
```

[(Source)](https://github.com/lupyuen/visual-zig-nuttx/blob/visual/sensor.zig#L54-L75)

(We'll explain __format__ in a while)

_How do we convert Floating-Point to Fixed-Point?_

Below is the implementation of __floatToFixed__, which receives a Floating-Point Number and returns the Fixed-Point Number (as a Struct): [visual-zig-nuttx/visual/sensor.zig](https://github.com/lupyuen/visual-zig-nuttx/blob/visual/sensor.zig#L39-L49)

```zig
/// Convert the float to a fixed-point number (`int`.`frac`) with 2 decimal places.
/// We do this because `debug` has a problem with floats.
pub fn floatToFixed(f: f32) FixedPoint {
  const scaled = @floatToInt(i32, f * 100.0);
  const rem = @rem(scaled, 100);
  const rem_abs = if (rem < 0) -rem else rem;
  return .{
    .int  = @divTrunc(scaled, 100),
    .frac = @intCast(u8, rem_abs),
  };
}
```

(See the docs: [__@floatToInt__](https://ziglang.org/documentation/master/#floatToInt), [__@rem__](https://ziglang.org/documentation/master/#rem), [__@divTrunc__](https://ziglang.org/documentation/master/#divTrunc), [__@intCast__](https://ziglang.org/documentation/master/#intCast))

This code has been tested for positive and negative numbers.

_Why handle Sensor Data as Fixed-Point Numbers? Why not Floating-Point?_

When we tried printing the Sensor Data as Floating-Point Numbers, we hit some __Linking and Runtime Issues__...

-   [__"Fix Floating-Point Values"__](https://github.com/lupyuen/visual-zig-nuttx#fix-floating-point-values)

-   [__"Floating-Point Link Error"__](https://github.com/lupyuen/visual-zig-nuttx#floating-point-link-error)

-   [__"Fixed-Point Printing"__](https://github.com/lupyuen/visual-zig-nuttx#fixed-point-printing)

Computations on Floating-Point Numbers are OK, only printing is affected. So we print the numbers as Fixed-Point instead.

(We observed these issues with Zig Compiler version 0.10.0, they might have been fixed in later versions of the compiler)

_Isn't our Sensor Data less precise in Fixed-Point?_

Yep we lose some precision with Fixed-Point Numbers. (Like the final digit `6` from earlier)

But most IoT Gadgets will __truncate Sensor Data__ before transmission anyway.

And for some data formats (like CBOR), we need __fewer bytes__ to transmit Fixed-Point Numbers instead of Floating-Point...

-   [__"Floating-Point Numbers (CBOR)"__](https://lupyuen.github.io/articles/cbor2#floating-point-numbers)

Thus we'll probably stick to Fixed-Point Numbers for our upcoming IoT projects.

_How do we print Fixed-Point Numbers?_

This works OK for printing Fixed-Point Numbers...

```zig
// Print the Temperature as a
// Fixed-Point Number (2 decimal places)
debug("temperature={}", .{
  floatToFixed(temperature)
});
```

Because our Fixed-Point Struct includes a [__Custom Formatter__](https://ziglearn.org/chapter-2/#formatting)...

```zig
/// Fixed Point Number (2 decimal places)
pub const FixedPoint = struct {

  /// Integer Component
  int: i32,

  /// Fraction Component (scaled by 100)
  frac: u8,

  /// Format the output for Fixed Point Number (like 123.45)
  pub fn format(
    self: FixedPoint,
    comptime fmt: []const u8,
    options: std.fmt.FormatOptions,
    writer: anytype,
  ) !void {
    _ = fmt;
    _ = options;
    try writer.print("{}.{:0>2}", .{
      self.int, 
      self.frac 
    });
  }
};
```

[(Source)](https://github.com/lupyuen/visual-zig-nuttx/blob/visual/sensor.zig#L54-L75)

_Why print the numbers as "`{}.{:0>2}`"?_

Our Format String "`{}.{:0>2}`" says...

|   |   |
|:---:|:---|
| `{}` | Print __int__ as a number
| `.` | Print `.`
| `{:0>2}` | Print __frac__ as a 2-digit number, padded at the left by `0`

Which gives us the printed output `123.45`

# Appendix: Add a Zig Tab

This section explains how we added the Zig Tab to Blockly.

Blockly is bundled with a list of Demos...

[lupyuen3.github.io/blockly-zig-nuttx/demos](https://lupyuen3.github.io/blockly-zig-nuttx/demos/)

There's a __Code Generation Demo__ that shows the code generated by Blockly for JavaScript, Python, Dart, ...

[lupyuen3.github.io/blockly-zig-nuttx/demos/code](https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/)

Let's add a __Zig Tab__ that will show the Zig code generated by Blockly: [demos/code/index.html](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/demos/code/index.html)

```html
<!--  Inserted this to Load Messages: (Not sure why)  -->
<script src="../../msg/messages.js"></script>
...
<tr id="tabRow" height="1em">
  <td id="tab_blocks" class="tabon">...</td>
  <td class="tabmin tab_collapse">&nbsp;</td>
  <!-- Inserted these two lines: -->
  <td id="tab_zig" class="taboff tab_collapse">Zig</td>
  <td class="tabmin tab_collapse">&nbsp;</td>
...
<div id="content_blocks" class="content"></div>
<!-- Inserted this line: -->
<pre id="content_zig" class="content prettyprint lang-zig"></pre>
```

[(See the changes)](https://github.com/lupyuen3/blockly-zig-nuttx/pull/1/files#diff-dcf2ffe98d7d8b4a0dd7b9f769557dbe8c9e0e726236ef229def25c956a43d8f)

We'll see the Zig Tab like this...

[lupyuen3.github.io/blockly-zig-nuttx/demos/code](https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/)

![Zig Tab in Blockly](https://lupyuen.github.io/images/blockly-run3a.png)

Let's generate the Zig code...

# Appendix: Zig Code Generator

Blockly comes bundled with Code Generators for JavaScript, Python, Dart, ...

Let's create a __Code Generator for Zig__, by copying from the Dart Code Generator.

Copy [generators/dart.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/dart.js) to [generators/zig.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig.js)

Copy all files from [generators/dart](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/dart) to [generators/zig](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig)...

```text
all.js
colour.js
lists.js
logic.js
loops.js
math.js
procedures.js
text.js
variables.js  
variables_dynamic.js
```

[(See the copied files)](https://github.com/lupyuen3/blockly-zig-nuttx/commit/ba968942c6ee55937ca554e1d290d8d563fa0b78)

Edit [generators/zig.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/dart.js) and all files in [generators/zig](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/generators/zig).

Change all "`Dart`" to "`Zig`", remember to __preserve case__.

[(See the changes)](https://github.com/lupyuen3/blockly-zig-nuttx/commit/efe185d6cac4306dcdc6b6a5f261b331bb992976)

This is how we load our Code Generator...

# Appendix: Load Code Generator

Let's __load our Zig Code Generator__ in Blockly...

Add the Zig Code Generator to [demos/code/index.html](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/demos/code/index.html)...

```html
<!--  Load Zig Code Generator  -->
<script src="../../zig_compressed.js"></script>
```

[(See the changes)](https://github.com/lupyuen3/blockly-zig-nuttx/pull/1/files#diff-dcf2ffe98d7d8b4a0dd7b9f769557dbe8c9e0e726236ef229def25c956a43d8f)

Enable the Zig Code Generator in [demos/code/code.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/demos/code/code.js)...

```javascript
// Inserted `zig`...
Code.TABS_ = [
  'blocks', 'zig', 'javascript', 'php', 'python', 'dart', 'lua', 'xml', 'json'
];
...
// Inserted `Zig`...
Code.TABS_DISPLAY_ = [
  'Blocks', 'Zig', 'JavaScript', 'PHP', 'Python', 'Dart', 'Lua', 'XML', 'JSON'
];
...
Code.renderContent = function() {
  ...
  } else if (content.id === 'content_json') {
    var jsonTextarea = document.getElementById('content_json');
    jsonTextarea.value = JSON.stringify(
        Blockly.serialization.workspaces.save(Code.workspace), null, 2);
    jsonTextarea.focus();
  // Inserted this...
  } else if (content.id == 'content_zig') {
    Code.attemptCodeGeneration(Blockly.Zig);
```

[(See the changes)](https://github.com/lupyuen3/blockly-zig-nuttx/pull/1/files#diff-d72873b861dee958e5d443c919726dd856de594bd56b1e73d8948a7719163553)

Add our Code Generator to the Build Task: [scripts/gulpfiles/build_tasks.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/scripts/gulpfiles/build_tasks.js#L98-L139)

```javascript
 const chunks = [
   // Added this...
   {
      name: 'zig',
      entry: 'generators/zig/all.js',
      reexport: 'Blockly.Zig',
   }
 ];
```

[(See the changes)](https://github.com/lupyuen3/blockly-zig-nuttx/pull/1/files#diff-a9a5784f43ce15ca76bb3e99eb6625c3ea15381e20eac6f7527ecbcb2945ac14)

Now we compile our Zig Code Generator...

# Appendix: Build Blockly

Blockly builds fine with Linux, macOS and WSL. (But not plain old Windows CMD)

To build Blockly with the Zig Code Generator...

```bash
## Download Blockly and install the dependencies
git clone --recursive https://github.com/lupyuen3/blockly-zig-nuttx
cd blockly-zig-nuttx
npm install

## Build Blockly and the Code Generators.
## Run these steps when we change the Zig Code Generator.
npm run build
npm run publish

## When prompted "Is this the correct branch?",
## press N

## Instead of "npm run publish" (which can be slow), we may do this...
## cp build/*compressed* .

## For WSL: We can copy the generated files to c:\blockly-zig-nuttx for testing on Windows
## cp *compressed*      /mnt/c/blockly-zig-nuttx
## cp demos/code/*.*    /mnt/c/blockly-zig-nuttx/demos/code
## cp generators/zig.js /mnt/c/blockly-zig-nuttx/generators
## cp generators/zig/*  /mnt/c/blockly-zig-nuttx/generators/zig
```

This compiles and updates the Zig Code Generator in [zig_compressed.js](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/zig_compressed.js) and [zig_compressed.js.map](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/zig_compressed.js.map)

If we're using VSCode, here's the Build Task: [.vscode/tasks.json](https://github.com/lupyuen3/blockly-zig-nuttx/blob/master/.vscode/tasks.json)

Finally we test our compiled Code Generator...

# Appendix: Test Blockly

Browse to __blockly-zig-nuttx/demos/code__ with a Local Web Server. [(Like Web Server for Chrome)](https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/)

We should see this...

[lupyuen3.github.io/blockly-zig-nuttx/demos/code](https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/)

![Zig Tab in Blockly](https://lupyuen.github.io/images/blockly-run3a.png)

Blockly will NOT render correctly with __file://...__, it must be __http://localhost:port/...__

Drag-and-drop some Blocks and click the __Zig Tab.__

The Zig Tab now shows the generated code in Zig.

Some of the generated code might appear as Dart (instead of Zig) because we haven't completely converted our Code Generator from Dart to Zig.

In case of problems, check the __JavaScript Console__. (Ignore the __storage.js__ error)

_Can we save the Blocks? So we don't need to drag them again when retesting?_

Click the __JSON Tab__ and copy the Blockly JSON that appears.

Whenever we rebuild Blockly and reload the site, just paste the Blockly JSON back into the JSON Tab. The Blocks will be automagically restored.
